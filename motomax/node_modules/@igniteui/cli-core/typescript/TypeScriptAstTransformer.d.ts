import * as ts from 'typescript';
import { FormattingService, PropertyAssignment, Identifier, ImportDeclarationMeta, FormatSettings, ChangeRequest } from '../types';
/**
 * Applies transformations to a source file using TypeScript compiler API.
 */
export declare class TypeScriptAstTransformer {
    readonly sourceFile: ts.SourceFile;
    protected readonly printerOptions?: ts.PrinterOptions;
    protected readonly customCompilerOptions?: ts.CompilerOptions;
    private readonly formatSettings?;
    private _defaultCompilerOptions;
    private _expressionCollector;
    private _factory;
    private _flatNodeRelations;
    private _printer;
    /**
     * Create a new TypeScriptAstTransformer instance for the given source file.
     * @param sourceFile The source file to update.
     * @param printerOptions Options to use when printing the source file.
     * @param customCompilerOptions Custom compiler options to use when transforming the source file.
     * @param formatSettings Custom formatting settings to apply. If provided, a {@link TypeScriptFormattingService} will be initialized.
     */
    constructor(sourceFile: ts.SourceFile, printerOptions?: ts.PrinterOptions, customCompilerOptions?: ts.CompilerOptions, formatSettings?: FormatSettings);
    /** Map of all transformations to apply to the source file. */
    readonly transformations: Map<string, ChangeRequest<ts.Node>>;
    /** The formatting service to use when printing the source file. */
    formatter: FormattingService;
    /** A map of nodes with their parents. */
    get flatNodeRelations(): Map<ts.Node, ts.Node>;
    /**
     * The printer instance to use to print the source file after modifications.
     */
    get printer(): ts.Printer;
    /**
     * The compiler options to use when transforming the source file.
     */
    get compilerOptions(): ts.CompilerOptions;
    /**
     * Looks up a property assignment in the AST.
     * @param visitCondition The condition by which the property assignment is found.
     * @param lastMatch Whether to return the last match found. If not set, the first match will be returned.
     */
    findPropertyAssignment(visitCondition: (node: ts.PropertyAssignment) => boolean, lastMatch?: boolean): ts.PropertyAssignment | undefined;
    /**
     * Searches the AST for a variable declaration with the given name and type.
     * @param name The name of the variable to look for.
     * @param type The type of the variable to look for.
     * @returns The variable declaration if found, otherwise `undefined`.
     */
    findVariableDeclaration(name: string, type: string): ts.VariableDeclaration | undefined;
    /**
     * Traverses the {@link flatNodeRelations} up to find a node that satisfies the given condition.
     * @param node The starting point of the search.
     * @param condition The condition to satisfy.
     * @returns The node's ancestor that satisfies the condition, `undefined` if none is found.
     */
    findNodeAncestor(node: ts.Node, condition: (node: ts.Node) => boolean): ts.Node | undefined;
    /**
     * Creates a request that will resolve during {@link finalize} for a new property assignment in an object literal expression.
     * @param visitCondition The condition by which the object literal expression is found.
     * @param propertyAssignment The property that will be added.
     */
    requestNewMemberInObjectLiteral(visitCondition: (node: ts.ObjectLiteralExpression) => boolean, propertyAssignment: PropertyAssignment): void;
    /**
     * Creates a request that will resolve during {@link finalize} for a new property assignment in an object literal expression.
     * @param visitCondition The condition by which the object literal expression is found.
     * @param propertyName The name of the property that will be added.
     * @param propertyValue The value of the property that will be added.
     * @param multiline Whether the object literal should be multiline.
     */
    requestNewMemberInObjectLiteral(visitCondition: (node: ts.ObjectLiteralExpression) => boolean, propertyName: string, propertyValue: ts.Expression, multiline?: boolean): void;
    /**
     * Creates a request that will resolve during {@link finalize} for a new property assignment that has a JSX value.
     * The member is added in an object literal expression.
     * @param visitCondition The condition by which the object literal expression is found.
     * @param propertyName The name of the property that will be added.
     * @param propertyValue The value of the property that will be added.
     * @param jsxAttributes The JSX attributes to add to the JSX element.
     *
     * @remarks Creates a property assignment of the form `{ propertyName: <propertyValue /> }` in the object literal.
     */
    requestJsxMemberInObjectLiteral(visitCondition: (node: ts.ObjectLiteralExpression) => boolean, propertyName: string, propertyValue: string, jsxAttributes?: ts.JsxAttributes): void;
    /**
     * Creates a request that will resolve during {@link finalize} for an update to the value of a member in an object literal expression.
     * @param visitCondition The condition by which the object literal expression is found.
     * @param targetMember The member that will be updated. The value should be the new value to set.
     */
    requestUpdateForObjectLiteralMember(visitCondition: (node: ts.ObjectLiteralExpression) => boolean, targetMember: PropertyAssignment): void;
    /**
     * Creates a request that will resolve during {@link finalize} which adds a new element to an array literal expression.
     * @param visitCondition The condition by which the array literal expression is found.
     * @param elements The elements that will be added to the array literal.
     * @param prepend If the elements should be added at the beginning of the array.
     * @param anchorElement The element to anchor the new elements to.
     * @param multiline Whether the array literal should be multiline.
     * @remarks The `anchorElement` must match the type of the elements in the collection.
     */
    requestNewMembersInArrayLiteral(visitCondition: (node: ts.ArrayLiteralExpression) => boolean, elements: ts.Expression[], prepend?: boolean, anchorElement?: ts.Expression | PropertyAssignment, multiline?: boolean): void;
    /**
     * Creates a request that will resolve during {@link finalize} which adds a new element to an array literal expression.
     * @param visitCondition The condition by which the array literal expression is found.
     * @param elements The elements that will be added to the array literal
     * @param prepend If the elements should be added at the beginning of the array.
     * @param anchorElement The element to anchor the new elements to.
     * @param multiline Whether the array literal should be multiline.
     * @remarks The `anchorElement` must match the type of the elements in the collection.
     */
    requestNewMembersInArrayLiteral(visitCondition: (node: ts.ArrayLiteralExpression) => boolean, elements: PropertyAssignment[], prepend?: boolean, anchorElement?: ts.Expression | PropertyAssignment, multiline?: boolean): void;
    /**
     * Creates a request that will resolve during {@link finalize} which adds a new argument to a method call expression.
     * @param visitCondition The condition by which the method call expression is found.
     * @param argument The argument to add to the method call.
     * @param position The position in the argument list to add the new argument.
     * @param override Whether to override the argument at the given position.
     * @remarks If `position` is not provided or is less than zero, the argument will be added at the end of the argument list.
     */
    requestNewArgumentInMethodCallExpression(visitCondition: (node: ts.CallExpression) => boolean, argument: ts.Expression, position?: number, override?: boolean): void;
    /**
     * Checks if an import declaration's identifier or alias would collide with an existing one.
     * @param identifier The identifier to check for collisions.
     * @param moduleName The module that the import is for, used for side effects imports.
     * @param isSideEffects If the import is strictly a side effects import.
     * @param sourceFile The source file to check for collisions.
     */
    importDeclarationCollides(identifier: Identifier, moduleName?: string, isSideEffects?: boolean, sourceFile?: ts.SourceFile): boolean;
    /**
     * Creates a request that will resolve during {@link finalize} which adds an import declaration to the source file.
     * @param importDeclarationMeta Metadata for the new import declaration.
     * @param isDefault Whether the import is a default import.
     * @remarks If `isDefault` is `true`, the first identifier will be used and
     * the import will be a default import of the form `import MyClass from "my-module"`.
     * @remarks If `isSideEffects` is `true`, all other options are ignored
     * and the import will be a side effects import of the form `import "my-module"`.
     * @reference {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#description|MDN}
     */
    requestNewImportDeclaration(importDeclarationMeta: ImportDeclarationMeta, isDefault?: boolean, isSideEffects?: boolean): void;
    /**
     * Applies the requested changes to the source file.
     * @remarks Does not mutate the original `ts.SourceFile`. Instead, it creates a new one with the changes applied.
     */
    applyChanges(): ts.SourceFile;
    /**
     * Applies all transformations, parses the AST and returns the resulting source code.
     * @remarks This method should be called after all modifications are ready to be applied to the AST.
     * If a {@link formatter} is present, it will be used to format the source code and update the file on the FS.
     */
    finalize(): string;
    /**
     * Requests a change to the source file.
     * @param type The type of change to request.
     * @param transformerFactory The transformer to apply to the source file during finalization.
     * @param syntaxKind The syntax kind of the node to change.
     * @param node The affected node.
     * @param relatedChangeId The ID of the change request that should be applied before this one.
     * @remarks All aggregated changes will be applied during {@link finalize}.
     */
    private requestChange;
    /**
     * Creates a flat map of nodes with their parent nodes.
     * @param rootNode The node to create a map for.
     */
    private createNodeRelationsMap;
}
