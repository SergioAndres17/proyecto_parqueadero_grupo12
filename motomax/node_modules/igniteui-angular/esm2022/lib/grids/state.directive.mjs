import { Directive, EventEmitter, Input, Output } from '@angular/core';
import { IgxGridStateBaseDirective } from './state-base.directive';
import * as i0 from "@angular/core";
export class IgxGridStateDirective extends IgxGridStateBaseDirective {
    constructor() {
        super(...arguments);
        /**
         *  Event emitted when set state is called with a string.
         * Returns the parsed state object so that it can be further modified before applying to the grid.
         * ```typescript
         * this.state.stateParsed.subscribe(parsedState => parsedState.sorting.forEach(x => x.strategy = NoopSortingStrategy.instance()});
         * ```
         */
        this.stateParsed = new EventEmitter();
    }
    /**
     *  An object with options determining if a certain feature state should be saved.
     * ```html
     * <igx-grid [igxGridState]="options"></igx-grid>
     * ```
     * ```typescript
     * public options = {selection: false, advancedFiltering: false};
     * ```
     */
    get options() {
        return super.options;
    }
    set options(value) {
        super.options = value;
    }
    /**
     * Gets the state of a feature or states of all grid features, unless a certain feature is disabled through the `options` property.
     *
     * @param `serialize` determines whether the returned object will be serialized to JSON string. Default value is true.
     * @param `feature` string or array of strings determining the features to be added in the state. If skipped, all features are added.
     * @returns Returns the serialized to JSON string IGridState object, or the non-serialized IGridState object.
     * ```html
     * <igx-grid [igxGridState]="options"></igx-grid>
     * ```
     * ```typescript
     * @ViewChild(IgxGridStateDirective, { static: true }) public state;
     * let state = this.state.getState(); // returns string
     * let state = this.state(false) // returns `IGridState` object
     * ```
     */
    getState(serialize = true, features) {
        return super.getStateInternal(serialize, features);
    }
    /* blazorSuppress */
    /**
     * Restores grid features' state based on the IGridState object passed as an argument.
     *
     * @param IGridState object to restore state from.
     * @returns
     * ```html
     * <igx-grid [igxGridState]="options"></igx-grid>
     * ```
     * ```typescript
     * @ViewChild(IgxGridStateDirective, { static: true }) public state;
     * this.state.setState(gridState);
     * ```
     */
    setState(state, features) {
        if (typeof state === 'string') {
            state = JSON.parse(state);
            this.stateParsed.emit(state);
        }
        return super.setStateInternal(state, features);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxGridStateDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.4", type: IgxGridStateDirective, isStandalone: true, selector: "[igxGridState]", inputs: { options: ["igxGridState", "options"] }, outputs: { stateParsed: "stateParsed" }, usesInheritance: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxGridStateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igxGridState]',
                    standalone: true
                }]
        }], propDecorators: { options: [{
                type: Input,
                args: ['igxGridState']
            }], stateParsed: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL2dyaWRzL3N0YXRlLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3ZFLE9BQU8sRUFBK0MseUJBQXlCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQzs7QUFNaEgsTUFBTSxPQUFPLHFCQUFzQixTQUFRLHlCQUF5QjtJQUpwRTs7UUFrRUk7Ozs7OztXQU1HO1FBRUksZ0JBQVcsR0FBRyxJQUFJLFlBQVksRUFBYyxDQUFDO0tBQ3ZEO0lBcEVHOzs7Ozs7OztPQVFHO0lBQ0gsSUFDb0IsT0FBTztRQUN2QixPQUFPLEtBQUssQ0FBQyxPQUFPLENBQUM7SUFDekIsQ0FBQztJQUVELElBQW9CLE9BQU8sQ0FBQyxLQUF3QjtRQUNoRCxLQUFLLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztJQUMxQixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7O09BY0c7SUFDSSxRQUFRLENBQUMsU0FBUyxHQUFHLElBQUksRUFBRSxRQUF3QztRQUN0RSxPQUFPLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUVELG9CQUFvQjtJQUNwQjs7Ozs7Ozs7Ozs7O09BWUc7SUFDSSxRQUFRLENBQUMsS0FBMEIsRUFBRSxRQUF3QztRQUNoRixJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBRSxDQUFDO1lBQzVCLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBZSxDQUFDO1lBQ3hDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFBO1FBQ2hDLENBQUM7UUFDRCxPQUFPLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDbkQsQ0FBQzs4R0E1RFEscUJBQXFCO2tHQUFyQixxQkFBcUI7OzJGQUFyQixxQkFBcUI7a0JBSmpDLFNBQVM7bUJBQUM7b0JBQ1AsUUFBUSxFQUFFLGdCQUFnQjtvQkFDMUIsVUFBVSxFQUFFLElBQUk7aUJBQ25COzhCQWN1QixPQUFPO3NCQUQxQixLQUFLO3VCQUFDLGNBQWM7Z0JBMERkLFdBQVc7c0JBRGpCLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgR3JpZEZlYXR1cmVzLCBJR3JpZFN0YXRlLCBJR3JpZFN0YXRlT3B0aW9ucywgSWd4R3JpZFN0YXRlQmFzZURpcmVjdGl2ZSB9IGZyb20gJy4vc3RhdGUtYmFzZS5kaXJlY3RpdmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tpZ3hHcmlkU3RhdGVdJyxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneEdyaWRTdGF0ZURpcmVjdGl2ZSBleHRlbmRzIElneEdyaWRTdGF0ZUJhc2VEaXJlY3RpdmUge1xuICAgIHByaXZhdGUgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX29wdGlvbnM6IElHcmlkU3RhdGVPcHRpb25zIHwgJyc7XG5cbiAgICAvKipcbiAgICAgKiAgQW4gb2JqZWN0IHdpdGggb3B0aW9ucyBkZXRlcm1pbmluZyBpZiBhIGNlcnRhaW4gZmVhdHVyZSBzdGF0ZSBzaG91bGQgYmUgc2F2ZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCBbaWd4R3JpZFN0YXRlXT1cIm9wdGlvbnNcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgb3B0aW9ucyA9IHtzZWxlY3Rpb246IGZhbHNlLCBhZHZhbmNlZEZpbHRlcmluZzogZmFsc2V9O1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgnaWd4R3JpZFN0YXRlJylcbiAgICBwdWJsaWMgb3ZlcnJpZGUgZ2V0IG9wdGlvbnMoKTogSUdyaWRTdGF0ZU9wdGlvbnMge1xuICAgICAgICByZXR1cm4gc3VwZXIub3B0aW9ucztcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgc2V0IG9wdGlvbnModmFsdWU6IElHcmlkU3RhdGVPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyLm9wdGlvbnMgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGF0ZSBvZiBhIGZlYXR1cmUgb3Igc3RhdGVzIG9mIGFsbCBncmlkIGZlYXR1cmVzLCB1bmxlc3MgYSBjZXJ0YWluIGZlYXR1cmUgaXMgZGlzYWJsZWQgdGhyb3VnaCB0aGUgYG9wdGlvbnNgIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGBzZXJpYWxpemVgIGRldGVybWluZXMgd2hldGhlciB0aGUgcmV0dXJuZWQgb2JqZWN0IHdpbGwgYmUgc2VyaWFsaXplZCB0byBKU09OIHN0cmluZy4gRGVmYXVsdCB2YWx1ZSBpcyB0cnVlLlxuICAgICAqIEBwYXJhbSBgZmVhdHVyZWAgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MgZGV0ZXJtaW5pbmcgdGhlIGZlYXR1cmVzIHRvIGJlIGFkZGVkIGluIHRoZSBzdGF0ZS4gSWYgc2tpcHBlZCwgYWxsIGZlYXR1cmVzIGFyZSBhZGRlZC5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBzZXJpYWxpemVkIHRvIEpTT04gc3RyaW5nIElHcmlkU3RhdGUgb2JqZWN0LCBvciB0aGUgbm9uLXNlcmlhbGl6ZWQgSUdyaWRTdGF0ZSBvYmplY3QuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCBbaWd4R3JpZFN0YXRlXT1cIm9wdGlvbnNcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKElneEdyaWRTdGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IHRydWUgfSkgcHVibGljIHN0YXRlO1xuICAgICAqIGxldCBzdGF0ZSA9IHRoaXMuc3RhdGUuZ2V0U3RhdGUoKTsgLy8gcmV0dXJucyBzdHJpbmdcbiAgICAgKiBsZXQgc3RhdGUgPSB0aGlzLnN0YXRlKGZhbHNlKSAvLyByZXR1cm5zIGBJR3JpZFN0YXRlYCBvYmplY3RcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0U3RhdGUoc2VyaWFsaXplID0gdHJ1ZSwgZmVhdHVyZXM/OiBHcmlkRmVhdHVyZXMgfCBHcmlkRmVhdHVyZXNbXSk6IElHcmlkU3RhdGUgfCBzdHJpbmcgIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldFN0YXRlSW50ZXJuYWwoc2VyaWFsaXplLCBmZWF0dXJlcyk7XG4gICAgfVxuXG4gICAgLyogYmxhem9yU3VwcHJlc3MgKi9cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyBncmlkIGZlYXR1cmVzJyBzdGF0ZSBiYXNlZCBvbiB0aGUgSUdyaWRTdGF0ZSBvYmplY3QgcGFzc2VkIGFzIGFuIGFyZ3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIElHcmlkU3RhdGUgb2JqZWN0IHRvIHJlc3RvcmUgc3RhdGUgZnJvbS5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgW2lneEdyaWRTdGF0ZV09XCJvcHRpb25zXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChJZ3hHcmlkU3RhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiB0cnVlIH0pIHB1YmxpYyBzdGF0ZTtcbiAgICAgKiB0aGlzLnN0YXRlLnNldFN0YXRlKGdyaWRTdGF0ZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHNldFN0YXRlKHN0YXRlOiBJR3JpZFN0YXRlIHwgc3RyaW5nLCBmZWF0dXJlcz86IEdyaWRGZWF0dXJlcyB8IEdyaWRGZWF0dXJlc1tdKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEpTT04ucGFyc2Uoc3RhdGUpIGFzIElHcmlkU3RhdGU7XG4gICAgICAgICAgICB0aGlzLnN0YXRlUGFyc2VkLmVtaXQoc3RhdGUpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLnNldFN0YXRlSW50ZXJuYWwoc3RhdGUsIGZlYXR1cmVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgRXZlbnQgZW1pdHRlZCB3aGVuIHNldCBzdGF0ZSBpcyBjYWxsZWQgd2l0aCBhIHN0cmluZy5cbiAgICAgKiBSZXR1cm5zIHRoZSBwYXJzZWQgc3RhdGUgb2JqZWN0IHNvIHRoYXQgaXQgY2FuIGJlIGZ1cnRoZXIgbW9kaWZpZWQgYmVmb3JlIGFwcGx5aW5nIHRvIHRoZSBncmlkLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnN0YXRlLnN0YXRlUGFyc2VkLnN1YnNjcmliZShwYXJzZWRTdGF0ZSA9PiBwYXJzZWRTdGF0ZS5zb3J0aW5nLmZvckVhY2goeCA9PiB4LnN0cmF0ZWd5ID0gTm9vcFNvcnRpbmdTdHJhdGVneS5pbnN0YW5jZSgpfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHN0YXRlUGFyc2VkID0gbmV3IEV2ZW50RW1pdHRlcjxJR3JpZFN0YXRlPigpO1xufVxuIl19