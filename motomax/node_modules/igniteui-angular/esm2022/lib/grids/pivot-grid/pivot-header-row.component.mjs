import { ChangeDetectionStrategy, Component, Inject, ViewChild, ViewChildren } from '@angular/core';
import { IgxChipComponent } from '../../chips/chip.component';
import { IgxChipsAreaComponent } from '../../chips/chips-area.component';
import { SortingDirection } from '../../data-operations/sorting-strategy';
import { IgxGridForOfDirective } from '../../directives/for-of/for_of.directive';
import { IgxDropDownComponent } from '../../drop-down/drop-down.component';
import { AbsoluteScrollStrategy, AutoPositionStrategy, VerticalAlignment } from '../../services/public_api';
import { IGX_GRID_BASE } from '../common/grid.interface';
import { IgxGridHeaderGroupComponent } from '../headers/grid-header-group.component';
import { IgxGridHeaderRowComponent } from '../headers/grid-header-row.component';
import { DropPosition } from '../moving/moving.service';
import { PivotUtil } from './pivot-util';
import { IgxGridTopLevelColumns } from '../common/pipes';
import { IgxHeaderGroupWidthPipe, IgxHeaderGroupStylePipe } from '../headers/pipes';
import { IgxExcelStyleSearchComponent } from '../filtering/excel-style/excel-style-search.component';
import { IgxGridExcelStyleFilteringComponent, IgxExcelStyleColumnOperationsTemplateDirective, IgxExcelStyleFilterOperationsTemplateDirective } from '../filtering/excel-style/excel-style-filtering.component';
import { IgxDropDownItemComponent } from '../../drop-down/drop-down-item.component';
import { IgxDropDownItemNavigationDirective } from '../../drop-down/drop-down-navigation.directive';
import { IgxSuffixDirective } from '../../directives/suffix/suffix.directive';
import { IgxBadgeComponent } from '../../badge/badge.component';
import { IgxPrefixDirective } from '../../directives/prefix/prefix.directive';
import { IgxIconComponent } from '../../icon/icon.component';
import { IgxDropDirective } from '../../directives/drag-drop/drag-drop.directive';
import { NgIf, NgFor, NgTemplateOutlet, NgClass, NgStyle } from '@angular/common';
import { IgxPivotRowHeaderGroupComponent } from './pivot-row-header-group.component';
import * as i0 from "@angular/core";
/**
 *
 * For all intents & purposes treat this component as what a <thead> usually is in the default <table> element.
 *
 * This container holds the pivot grid header elements and their behavior/interactions.
 *
 * @hidden @internal
 */
export class IgxPivotHeaderRowComponent extends IgxGridHeaderRowComponent {
    get headerForOf() {
        return this.headerContainers?.last;
    }
    constructor(grid, ref, cdr, renderer) {
        super(ref, cdr);
        this.grid = grid;
        this.renderer = renderer;
        this.aggregateList = [];
        this.filterDropdownDimensions = new Set();
        this.filterAreaDimensions = new Set();
        this._dropPos = DropPosition.AfterDropTarget;
        this._subMenuPositionSettings = {
            verticalStartPoint: VerticalAlignment.Bottom,
            closeAnimation: undefined
        };
        this._subMenuOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            positionStrategy: new AutoPositionStrategy(this._subMenuPositionSettings),
            scrollStrategy: new AbsoluteScrollStrategy()
        };
        /**
        * @hidden
        * @internal
        * Default is a single empty level since default depth is 1
        */
        this.columnDimensionsByLevel = [[]];
    }
    /**
    * @hidden @internal
    */
    get isFiltersButton() {
        let chipsWidth = 0;
        this.filterDropdownDimensions.clear();
        this.filterAreaDimensions.clear();
        if (this.filterArea?.chipsList && this.filterArea.chipsList.length !== 0) {
            const styles = getComputedStyle(this.pivotFilterContainer.nativeElement);
            const containerPaddings = parseFloat(styles.paddingLeft) + parseFloat(styles.paddingRight);
            chipsWidth += containerPaddings + (this.filtersButton && this.filterArea?.chipsList.length > 1 ? this.filtersButton.el.nativeElement.getBoundingClientRect().width : 0);
            this.filterArea.chipsList.forEach(chip => {
                const dim = this.grid.filterDimensions.find(x => x.memberName === chip.id);
                if (dim) {
                    // 8 px margin between chips
                    const currentChipWidth = chip.nativeElement.getBoundingClientRect().width + 8;
                    if (chipsWidth + currentChipWidth < this.grid.pivotRowWidths) {
                        this.filterAreaDimensions.add(dim);
                    }
                    else {
                        this.filterDropdownDimensions.add(dim);
                    }
                    chipsWidth += currentChipWidth;
                }
            });
            return this.filterDropdownDimensions.size > 0;
        }
        return false;
    }
    /**
    * @hidden
    * @internal
    */
    get totalDepth() {
        const columnDimensions = this.grid.columnDimensions;
        if (columnDimensions.length === 0) {
            return 1;
        }
        let totalDepth = columnDimensions.map(x => PivotUtil.getDimensionDepth(x) + 1).reduce((acc, val) => acc + val);
        if (this.grid.hasMultipleValues) {
            totalDepth += 1;
        }
        return totalDepth;
    }
    /**
    * @hidden
    * @internal
    */
    get maxContainerHeight() {
        return this.totalDepth * this.grid.renderedRowHeight;
    }
    /**
    * @hidden
    * @internal
    */
    calcHeight(col, index) {
        return !col.columnGroup && col.level < this.totalDepth && col.level === index ? (this.totalDepth - col.level) * this.grid.rowHeight : this.grid.rowHeight;
    }
    /**
    * @hidden
    * @internal
    */
    isDuplicateOfExistingParent(col, lvl) {
        const parentCollection = lvl > 0 ? this.columnDimensionsByLevel[lvl - 1] : [];
        const duplicate = parentCollection.indexOf(col) !== -1;
        return duplicate;
    }
    /**
    * @hidden
    * @internal
    */
    isMultiRow(col, lvl) {
        const isLeaf = !col.columnGroup;
        return isLeaf && lvl !== this.totalDepth - 1;
    }
    /**
    * @hidden
    * @internal
    */
    populateColumnDimensionsByLevel() {
        const res = [];
        for (let i = 0; i < this.totalDepth; i++) {
            res[i] = [];
        }
        const cols = this.unpinnedColumnCollection;
        // populate column dimension matrix recursively
        this.populateDimensionRecursively(cols.filter(x => x.level === 0), 0, res);
        this.columnDimensionsByLevel = res;
    }
    populateDimensionRecursively(currentLevelColumns, level = 0, res) {
        currentLevelColumns.forEach(col => {
            if (res[level]) {
                res[level].push(col);
                if (col.columnGroup && col.children.length > 0) {
                    const visibleColumns = col.children.toArray().filter(x => !x.hidden);
                    this.populateDimensionRecursively(visibleColumns, level + 1, res);
                }
                else if (level < this.totalDepth - 1) {
                    for (let i = level + 1; i <= this.totalDepth - 1; i++) {
                        res[i].push(col);
                    }
                }
            }
        });
    }
    /**
    * @hidden
    * @internal
    */
    ngOnChanges(changes) {
        if (changes.unpinnedColumnCollection) {
            this.populateColumnDimensionsByLevel();
        }
    }
    /**
    * @hidden
    * @internal
    */
    onDimDragStart(event, area) {
        this.cdr.detectChanges();
        for (const chip of this.notificationChips) {
            const parent = chip.nativeElement.parentElement;
            if (area.chipsList.toArray().indexOf(chip) === -1 &&
                parent.children.length > 0 &&
                parent.children.item(0).id !== 'empty') {
                chip.nativeElement.hidden = false;
                parent.parentElement.scrollTo({ left: chip.nativeElement.offsetLeft });
            }
        }
    }
    /**
    * @hidden
    * @internal
    */
    onDimDragEnd() {
        for (const chip of this.notificationChips) {
            chip.nativeElement.hidden = true;
        }
    }
    /**
    * @hidden
    * @internal
    */
    getAreaHeight(area) {
        const chips = area.chipsList;
        return chips && chips.length > 0 ? chips.first.nativeElement.offsetHeight : 0;
    }
    /**
    * @hidden
    * @internal
    */
    rowRemoved(event) {
        const row = this.grid.pivotConfiguration.rows.find(x => x.memberName === event.owner.id);
        this.grid.toggleDimension(row);
    }
    /**
    * @hidden
    * @internal
    */
    columnRemoved(event) {
        const col = this.grid.pivotConfiguration.columns.find(x => x.memberName === event.owner.id);
        this.grid.toggleDimension(col);
    }
    /**
    * @hidden
    * @internal
    */
    valueRemoved(event) {
        const value = this.grid.pivotConfiguration.values.find(x => x.member === event.owner.id || x.displayName === event.owner.id);
        this.grid.toggleValue(value);
    }
    /**
    * @hidden
    * @internal
    */
    filterRemoved(event) {
        const filter = this.grid.pivotConfiguration.filters.find(x => x.memberName === event.owner.id);
        this.grid.toggleDimension(filter);
        if (this.filterDropdownDimensions.size > 0) {
            this.onFiltersAreaDropdownClick({ target: this.filtersButton.el.nativeElement }, undefined, false);
        }
        else {
            this.grid.filteringService.hideESF();
        }
    }
    onFiltersSelectionChanged(event) {
        this.dropdownChips.chipsList.forEach(chip => {
            if (chip.id !== event.owner.id) {
                chip.selected = false;
            }
        });
        this.onFiltersAreaDropdownClick({ target: this.filtersButton.el.nativeElement }, this.grid.filterDimensions.find(dim => dim.memberName === event.owner.id), false);
    }
    /**
    * @hidden
    * @internal
    */
    onFilteringIconPointerDown(event) {
        event.stopPropagation();
        event.preventDefault();
    }
    /**
    * @hidden
    * @internal
    */
    onFilteringIconClick(event, dimension) {
        event.stopPropagation();
        event.preventDefault();
        const dim = dimension;
        const col = this.grid.dimensionDataColumns.find(x => x.field === dim.memberName || x.field === dim.member);
        this.grid.filteringService.toggleFilterDropdown(event.target, col);
    }
    /**
    * @hidden
    * @internal
    */
    onSummaryClick(eventArgs, value, dropdown, chip) {
        this._subMenuOverlaySettings.target = eventArgs.currentTarget;
        this.updateDropDown(value, dropdown, chip);
    }
    /**
     * @hidden @internal
     */
    onFiltersAreaDropdownClick(event, dimension, shouldReattach = true) {
        const dim = dimension || this.filterDropdownDimensions.values().next().value;
        const col = this.grid.dimensionDataColumns.find(x => x.field === dim.memberName || x.field === dim.member);
        if (shouldReattach) {
            this.dropdownChips.chipsList.forEach(chip => {
                chip.selected = false;
            });
            this.dropdownChips.chipsList.first.selected = true;
        }
        this.grid.filteringService.toggleFiltersESF(this.esf, event.target, col, shouldReattach);
    }
    /**
    * @hidden
    * @internal
    */
    onAggregationChange(event) {
        if (!this.isSelected(event.newSelection.value)) {
            this.value.aggregate = event.newSelection.value;
            this.grid.pipeTrigger++;
        }
    }
    /**
    * @hidden
    * @internal
    */
    isSelected(val) {
        return this.value.aggregate.key === val.key;
    }
    /**
    * @hidden
    * @internal
    */
    onChipSort(_event, dimension) {
        if (dimension.sortable === undefined || dimension.sortable) {
            const startDirection = dimension.sortDirection || SortingDirection.None;
            const direction = startDirection + 1 > SortingDirection.Desc ?
                SortingDirection.None : startDirection + 1;
            this.grid.sortDimension(dimension, direction);
        }
    }
    /**
    * @hidden
    * @internal
    */
    onDimDragOver(event, dimension) {
        if (!event.dragChip || !event.dragChip.data?.pivotArea)
            return;
        const typeMismatch = dimension !== undefined ? this.grid.pivotConfiguration.values.find(x => x.member === event.dragChip.id
            || x.displayName === event.dragChip.id) :
            !this.grid.pivotConfiguration.values.find(x => x.member === event.dragChip.id || x.displayName === event.dragChip.id);
        if (typeMismatch) {
            // cannot drag between dimensions and value
            return;
        }
        // if we are in the left half of the chip, drop on the left
        // else drop on the right of the chip
        const clientRect = event.owner.nativeElement.getBoundingClientRect();
        const pos = clientRect.width / 2;
        this._dropPos = event.originalEvent.offsetX > pos ? DropPosition.AfterDropTarget : DropPosition.BeforeDropTarget;
        if (this._dropPos === DropPosition.AfterDropTarget) {
            event.owner.nativeElement.previousElementSibling.style.visibility = 'hidden';
            event.owner.nativeElement.nextElementSibling.style.visibility = '';
        }
        else {
            event.owner.nativeElement.nextElementSibling.style.visibility = 'hidden';
            event.owner.nativeElement.previousElementSibling.style.visibility = '';
        }
    }
    /**
    * @hidden
    * @internal
    */
    onDimDragLeave(event) {
        event.owner.nativeElement.previousElementSibling.style.visibility = 'hidden';
        event.owner.nativeElement.nextElementSibling.style.visibility = 'hidden';
        this._dropPos = DropPosition.AfterDropTarget;
    }
    /**
    * @hidden
    * @internal
    */
    onAreaDragLeave(event, area) {
        const dataChips = area.chipsList.toArray().filter(x => this.notificationChips.toArray().indexOf(x) === -1);
        dataChips.forEach(element => {
            if (element.nativeElement.previousElementSibling) {
                element.nativeElement.previousElementSibling.style.visibility = 'hidden';
            }
            if (element.nativeElement.nextElementSibling) {
                element.nativeElement.nextElementSibling.style.visibility = 'hidden';
            }
        });
    }
    /**
    * @hidden
    * @internal
    */
    onValueDrop(event, area) {
        if (!(event.dragChip && event.dragChip.data?.pivotArea) && !(event.dragData?.chip && !!event.dragData.chip.data.pivotArea))
            return;
        //values can only be reordered
        const values = this.grid.pivotConfiguration.values;
        const dragId = event.dragChip?.id || event.dragData?.chip.id;
        const chipsArray = area.chipsList.toArray();
        let chipIndex = chipsArray.indexOf(event.owner) !== -1 ? chipsArray.indexOf(event.owner) : chipsArray.length;
        chipIndex = this._dropPos === DropPosition.AfterDropTarget ? chipIndex + 1 : chipIndex;
        const value = values.find(x => x.member === dragId || x.displayName === dragId);
        if (value) {
            const dragChipIndex = chipsArray.indexOf(event.dragChip || event.dragData.chip);
            this.grid.moveValue(value, dragChipIndex >= chipIndex ? chipIndex : chipIndex - 1);
        }
    }
    /**
    * @hidden
    * @internal
    */
    onDimDrop(event, area, dimensionType) {
        if (!(event.dragChip && event.dragChip.data?.pivotArea) && !(event.dragData?.chip && !!event.dragData.chip.data.pivotArea))
            return;
        const dragId = event.dragChip?.id || event.dragData?.chip.id;
        const currentDim = this.grid.getDimensionsByType(dimensionType);
        const chipsArray = area.chipsList.toArray();
        const chip = chipsArray.find(x => x.id === dragId);
        const isNewChip = chip === undefined;
        const isReorder = event.owner.id !== undefined;
        //const chipIndex = chipsArray.indexOf(event.owner) !== -1 ? chipsArray.indexOf(event.owner) : chipsArray.length;
        const chipIndex = currentDim.findIndex(x => x.memberName === event.owner.id) !== -1 ?
            currentDim.findIndex(x => x.memberName === event.owner.id) : currentDim.length;
        const targetIndex = this._dropPos === DropPosition.AfterDropTarget ? chipIndex + 1 : chipIndex;
        if (isNewChip) {
            // chip moved from an external collection
            const dim = this.grid.allDimensions.find(x => x && x.memberName === dragId);
            if (!dim) {
                // you have dragged something that is not a dimension
                return;
            }
            this.grid.moveDimension(dim, dimensionType, targetIndex);
        }
        else if (isReorder) {
            // chip from same collection, reordered.
            const newDim = currentDim.find(x => x.memberName === dragId);
            const dragChipIndex = currentDim.findIndex(x => x.memberName === dragId);
            this.grid.moveDimension(newDim, dimensionType, dragChipIndex > chipIndex ? targetIndex : targetIndex - 1);
        }
        this.grid.pipeTrigger++;
        this.grid.dimensionsChange.emit({ dimensions: currentDim, dimensionCollectionType: dimensionType });
        // clean states
        this.onDimDragEnd();
        this.onAreaDragLeave(event, area);
    }
    updateDropDown(value, dropdown, chip) {
        this.value = value;
        dropdown.width = chip.nativeElement.clientWidth + 'px';
        this.aggregateList = PivotUtil.getAggregateList(value, this.grid);
        this.cdr.detectChanges();
        dropdown.open(this._subMenuOverlaySettings);
    }
    getRowDimensionColumn(dim) {
        return this.grid.dimensionDataColumns ? this.grid.dimensionDataColumns.find((col) => col.field === dim.memberName) : null;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotHeaderRowComponent, deps: [{ token: IGX_GRID_BASE }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.4", type: IgxPivotHeaderRowComponent, isStandalone: true, selector: "igx-pivot-header-row", viewQueries: [{ propertyName: "esf", first: true, predicate: ["esf"], descendants: true }, { propertyName: "filterArea", first: true, predicate: ["filterAreaHidden"], descendants: true }, { propertyName: "filtersButton", first: true, predicate: ["filterIcon"], descendants: true }, { propertyName: "dropdownChips", first: true, predicate: ["dropdownChips"], descendants: true }, { propertyName: "pivotFilterContainer", first: true, predicate: ["pivotFilterContainer"], descendants: true }, { propertyName: "pivotRowContainer", first: true, predicate: ["pivotRowContainer"], descendants: true }, { propertyName: "notificationChips", predicate: ["notifyChip"], descendants: true }, { propertyName: "headerContainers", predicate: ["headerVirtualContainer"], descendants: true, read: IgxGridForOfDirective }, { propertyName: "rowDimensionHeaders", predicate: ["rowDimensionHeaders"], descendants: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: "<div>\n    <div class=\"igx-grid-thead__wrapper igx-grid-thead__wrapper--pivot\" role=\"row\" [style.width.px]=\"width\">\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]=\"width\">\n            <div class='igx-grid__tr-pivot--filter-container'>\n                <div #pivotFilterContainer *ngIf=\"grid.pivotUI.showConfiguration\"\n                     class=\"igx-grid__tr-pivot igx-grid__tr-pivot--filter\" [style.min-width.px]=\"grid.pivotRowWidths - 1\"\n                     [style.max-width.px]=\"grid.pivotRowWidths - 1\" (igxDragLeave)=\"onAreaDragLeave($event, filterArea)\"\n                     igxDrop (dropped)=\"onDimDrop($event, filterArea, 2)\" (pointerdown)=\"$event.preventDefault()\">\n                    <!-- Filter area -->\n                    <igx-chips-area #filterArea droppable='true'>\n                        <span id='empty' igxDrop (dropped)=\"onDimDrop($event, filterArea, 2)\"\n                          *ngIf=\"grid.filterDimensions.length === 0\"\n                          class='igx-grid__pivot-empty-chip-area'>{{grid.resourceStrings.igx_grid_pivot_empty_filter_drop_area}}</span>\n                        <ng-container *ngFor=\"let filter of this.filterAreaDimensions; let last = last;\">\n                        <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(filterArea)'></span>\n                            <igx-chip [id]=\"filter.memberName\" [draggable]=\"true\" [data]=\"{ pivotArea: 'filter' }\"\n                                      [removable]=\"true\" (remove)=\"filterRemoved($event)\" (dragOver)=\"onDimDragOver($event, 2)\"\n                                      (dragLeave)=\"onDimDragLeave($event)\" (dragDrop)=\"onDimDrop($event, filterArea, 2)\"\n                                      (moveStart)='onDimDragStart($event, filterArea)' (moveEnd)='onDimDragEnd()'>\n                                <igx-icon\n                                    family=\"default\"\n                                    name=\"filter_list\"\n                                    igxPrefix\n                                    (pointerdown)='onFilteringIconPointerDown($event)'\n                                    (click)='onFilteringIconClick($event, filter)'>\n                                </igx-icon>\n                                {{filter.displayName || filter.memberName}}\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(filterArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onDimDrop($event, filterArea, 2)\" #notifyChip [hidden]='true'>\n                            {{grid.resourceStrings.igx_grid_pivot_filter_drop_chip}}\n                        </igx-chip>\n                    </igx-chips-area>\n                    <div class=\"igx-grid__pivot-filter-toggle\" *ngIf=\"isFiltersButton && grid.filterDimensions.length !== 0\">\n                        <igx-icon\n                            family=\"default\"\n                            name=\"filter_list\"\n                            #filterIcon\n                            (pointerdown)='onFilteringIconPointerDown($event)'\n                            (click)='onFiltersAreaDropdownClick($event)'>\n                        </igx-icon>\n                        <igx-badge value=\"{{this.filterDropdownDimensions.size}}\"></igx-badge>\n                    </div>\n                </div>\n                <div class='igx-grid__tr-pivot--drop-row-area'>\n                    <div #pivotRowContainer *ngIf=\"grid.pivotUI.showConfiguration && grid.pivotUI.showRowHeaders\" [style.width.px]=\"grid.pivotRowWidths - 1\"\n                        class=\"igx-grid__tr-pivot igx-grid__tr-pivot--small-row-area\" igxDrop\n                        (igxDragLeave)=\"onAreaDragLeave($event, rowArea)\"\n                        (dropped)=\"onDimDrop($event, rowArea, 0)\">\n                        <igx-chips-area #rowArea droppable='true'>\n                            <span id='empty' igxDrop (dropped)=\"onDimDrop($event, rowArea, 0)\"\n                                *ngIf=\"grid.rowDimensions.length === 0\"\n                                class='igx-grid__pivot-empty-chip-area'>{{grid.resourceStrings.igx_grid_pivot_empty_row_drop_area}}</span>\n                            <ng-container *ngFor=\"let row of grid.rowDimensions; let last = last;\">\n                                <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                    [style.height.px]='getAreaHeight(rowArea)'></span>\n                                    <igx-chip [draggable]=\"true\" [id]=\"row.memberName\" [data]=\"{ pivotArea: 'row' }\"\n                                            [removable]=\"true\" (remove)=\"rowRemoved($event)\" (dragLeave)=\"onDimDragLeave($event)\"\n                                            (dragDrop)=\"onDimDrop($event, rowArea, 0)\" (dragOver)=\"onDimDragOver($event, 0)\"\n                                            (moveStart)='onDimDragStart($event, rowArea)' (moveEnd)='onDimDragEnd()'\n                                            (click)=\"onChipSort($event, row)\">\n                                        <igx-icon igxPrefix family=\"default\" name=\"table_rows\"></igx-icon>\n                                        <igx-icon\n                                            family=\"default\"\n                                            name=\"filter_list\"\n                                            igxPrefix\n                                            (pointerdown)='onFilteringIconPointerDown($event)'\n                                            (click)='onFilteringIconClick($event, row)'>\n                                        </igx-icon>\n                                        {{ row.displayName || row.memberName}}\n                                        <igx-icon\n                                            family=\"default\"\n                                            [name]=\"row.sortDirection < 2 ? 'sort_asc' : 'sort_desc'\"\n                                            *ngIf=\"row.sortDirection\"\n                                            igxSuffix>\n                                        </igx-icon>\n                                    </igx-chip>\n                                <ng-container *ngIf='last'>\n                                <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                    [style.height.px]='getAreaHeight(rowArea)'></span>\n                                </ng-container>\n                            </ng-container>\n                            <igx-chip igxDrop (dragDrop)=\"onDimDrop($event, rowArea, 0)\" #notifyChip [hidden]='true'>\n                                {{grid.resourceStrings.igx_grid_pivot_row_drop_chip}}\n                            </igx-chip>\n                        </igx-chips-area>\n                    </div>\n                </div>\n            </div>\n\n            <div class=\"igx-grid__tr-pivot-group\">\n                <div #pivotColumnContainer *ngIf=\"grid.pivotUI.showConfiguration\" class=\"igx-grid__tr-pivot\"\n                     (dropped)=\"onDimDrop($event, colArea, 1)\" igxDrop (igxDragLeave)=\"onAreaDragLeave($event, colArea)\">\n                    <!-- Columns area -->\n                    <igx-chips-area #colArea droppable='true'>\n                    <span id='empty' (dropped)=\"onDimDrop($event, colArea, 1)\" igxDrop\n                        *ngIf=\"grid.columnDimensions.length === 0\" class='igx-grid__pivot-empty-chip-area'>\n                        {{grid.resourceStrings.igx_grid_pivot_empty_column_drop_area}}</span>\n                        <ng-container *ngFor=\"let col of grid.columnDimensions; let last = last;\">\n                        <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(colArea)'></span>\n                            <igx-chip [draggable]=\"true\" [id]=\"col.memberName\" [data]=\"{ pivotArea: 'column' }\"\n                                      [removable]=\"true\" (remove)=\"columnRemoved($event)\" (dragOver)=\"onDimDragOver($event, 1)\"\n                                      (dragLeave)=\"onDimDragLeave($event)\" (dragDrop)=\"onDimDrop($event, colArea, 1)\"\n                                      (moveStart)='onDimDragStart($event, colArea)' (moveEnd)='onDimDragEnd()'\n                                      (click)=\"onChipSort($event, col)\">\n                                <igx-icon\n                                    family=\"default\"\n                                    name=\"view_column\"\n                                    igxPrefix>\n                                </igx-icon>\n                                <igx-icon\n                                    family=\"default\"\n                                    name=\"filter_list\"\n                                    igxPrefix\n                                    (pointerdown)='onFilteringIconPointerDown($event)'\n                                    (click)='onFilteringIconClick($event, col)'>\n                                </igx-icon>\n                                {{col.displayName || col.memberName}}\n                                <igx-icon\n                                    family=\"default\"\n                                    [name]=\"col.sortDirection < 2 ? 'sort_asc' : 'sort_desc'\"\n                                    *ngIf=\"col.sortDirection\"\n                                    igxSuffix>\n                                </igx-icon>\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(colArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onDimDrop($event, colArea, 1)\" #notifyChip [hidden]='true'>\n                            {{grid.resourceStrings.igx_grid_pivot_column_drop_chip}}\n                        </igx-chip>\n                    </igx-chips-area>\n                </div>\n\n                <div #pivotValueContainer *ngIf=\"grid.pivotUI.showConfiguration\" class=\"igx-grid__tr-pivot\"\n                     (pointerdown)=\"$event.preventDefault()\" (dropped)=\"onValueDrop($event, valueArea)\" igxDrop\n                     (igxDragLeave)=\"onAreaDragLeave($event, valueArea)\">\n                    <!-- Value area -->\n                    <igx-chips-area #valueArea droppable='true'>\n                    <span id='empty' (dropped)=\"onValueDrop($event, valueArea)\" igxDrop *ngIf=\"grid.values.length === 0\"\n                        class='igx-grid__pivot-empty-chip-area'>{{grid.resourceStrings.igx_grid_pivot_empty_value_drop_area}}</span>\n                    <ng-container *ngFor=\"let value of grid.values; let last = last;\">\n                        <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(valueArea)'></span>\n                            <igx-chip #currChip [draggable]=\"true\" [id]=\"value.displayName || value.member\" [data]=\"{ pivotArea: 'value' }\"\n                                    [removable]=\"true\" (remove)=\"valueRemoved($event)\"\n                                      (dragLeave)=\"onDimDragLeave($event)\" (dragOver)=\"onDimDragOver($event)\"\n                                      (dragDrop)=\"onValueDrop($event, valueArea)\">\n                                <div class=\"igx-grid__tr-pivot-toggle-icons\" igxPrefix\n                                     (click)='onSummaryClick($event, value, dropdown, currChip)'\n                                     (pointerdown)='$event.stopPropagation()' [igxDropDownItemNavigation]=\"dropdown\">\n                                    <igx-icon family=\"default\" name=\"functions\"></igx-icon>\n                                    <igx-icon family=\"default\" name=\"arrow_drop_down\"></igx-icon>\n                                </div>\n                                <ng-container *ngTemplateOutlet=\"grid.valueChipTemplate ? grid.valueChipTemplate : valueChipDefaultTemplate; context: { $implicit: value }\"></ng-container>\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(valueArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onValueDrop($event, valueArea)\" #notifyValueChip [hidden]='true'>\n                            {{grid.resourceStrings.igx_grid_pivot_value_drop_chip}}\n                        </igx-chip>\n                    </igx-chips-area>\n                </div>\n            </div>\n        </div>\n    </div>\n    <div role=\"rowgroup\" class=\"igx-grid-thead__wrapper\" [style.width.px]=\"width\"\n         [attr.aria-activedescendant]=\"activeDescendant\" [class.igx-grid__tr--mrl]=\"hasMRL\">\n\n        <!-- Column headers area -->\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]=\"width\">\n            <ng-container *ngIf=\"!grid.pivotUI.showRowHeaders || grid.rowDimensions.length === 0\">\n                <div #pivotContainer class=\"igx-grid__tr-pivot igx-grid__tr-pivot--row-area\"\n                    [style.width.px]=\"grid.pivotRowWidths - 1\" (igxDragLeave)=\"onAreaDragLeave($event, rowArea)\" igxDrop\n                    (dropped)=\"onDimDrop($event, rowArea, 0)\" (pointerdown)=\"$event.preventDefault()\">\n                    <!-- Row area -->\n                    <igx-chips-area #rowArea droppable='true'>\n                        <ng-container *ngIf=\"grid.pivotUI.showConfiguration || grid.rowDimensions.length === 0\">\n                            <span id='empty' igxDrop (dropped)=\"onDimDrop($event, rowArea, 0)\"\n                                *ngIf=\"grid.rowDimensions.length === 0\"\n                                class='igx-grid__pivot-empty-chip-area'>{{grid.resourceStrings.igx_grid_pivot_empty_row_drop_area}}</span>\n                            <ng-container *ngFor=\"let row of grid.rowDimensions; let last = last;\">\n                                <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                    [style.height.px]='getAreaHeight(rowArea)'></span>\n                                    <igx-chip [draggable]=\"true\" [id]=\"row.memberName\" [data]=\"{ pivotArea: 'row' }\"\n                                            [removable]=\"true\" (remove)=\"rowRemoved($event)\" (dragLeave)=\"onDimDragLeave($event)\"\n                                            (dragDrop)=\"onDimDrop($event, rowArea, 0)\" (dragOver)=\"onDimDragOver($event, 0)\"\n                                            (moveStart)='onDimDragStart($event, rowArea)' (moveEnd)='onDimDragEnd()'\n                                            (click)=\"onChipSort($event, row)\">\n                                        <igx-icon igxPrefix family=\"default\" name=\"table_rows\"></igx-icon>\n                                        <igx-icon\n                                            family=\"default\"\n                                            name=\"filter_list\"\n                                            igxPrefix\n                                            (pointerdown)='onFilteringIconPointerDown($event)'\n                                            (click)='onFilteringIconClick($event, row)'>\n                                        </igx-icon>\n                                        {{ row.displayName || row.memberName}}\n                                        <igx-icon\n                                            family=\"default\"\n                                            [name]=\"row.sortDirection < 2 ? 'sort_asc' : 'sort_desc'\"\n                                            *ngIf=\"row.sortDirection\"\n                                            igxSuffix>\n                                        </igx-icon>\n                                    </igx-chip>\n                                <ng-container *ngIf='last'>\n                                <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                    [style.height.px]='getAreaHeight(rowArea)'></span>\n                                </ng-container>\n                            </ng-container>\n                            <igx-chip igxDrop (dragDrop)=\"onDimDrop($event, rowArea, 0)\" #notifyChip [hidden]='true'>\n                                {{grid.resourceStrings.igx_grid_pivot_row_drop_chip}}\n                            </igx-chip>\n                        </ng-container>\n                    </igx-chips-area>\n                </div>\n            </ng-container>\n\n            <ng-container *ngIf=\"grid.pivotUI.showRowHeaders && grid.visibleRowDimensions.length > 0\">\n                <div class=\"igx-grid__tr igx-grid__tr-header-row\" role=\"row\" [style.width.px]=\"grid.pivotRowWidths - 1\">\n                    <ng-container *ngFor=\"let dim of grid.visibleRowDimensions; index as colIndex;last as isLast\">\n                        <igx-pivot-row-header-group #rowDimensionHeaders *ngIf=\"getRowDimensionColumn(dim) as dimCol\"\n                            [ngClass]=\"dimCol.headerGroupClasses\"\n                            [ngStyle]=\"dimCol.headerGroupStyles | igxHeaderGroupStyle:dimCol:grid.pipeTrigger\"\n                            [style.min-width]=\"grid.rowDimensionWidthToPixels(this.grid.visibleRowDimensions[colIndex]) | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                            [style.flex-basis]=\"grid.rowDimensionWidthToPixels(this.grid.visibleRowDimensions[colIndex]) | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                            [column]=\"dimCol\"\n                            [rootDimension]=\"grid.visibleRowDimensions[colIndex]\"\n                            [dimWidth]=\"grid.rowDimensionWidthToPixels(this.grid.visibleRowDimensions[colIndex])\"\n                            [rowIndex]=\"-1\" >\n                        </igx-pivot-row-header-group>\n                    </ng-container>\n                </div>\n            </ng-container>\n\n            <!-- Pinned columns collection from the start -->\n            <ng-container *ngIf=\"pinnedColumnCollection.length && grid.isPinningToStart\">\n                <ng-container *ngFor=\"let column of pinnedColumnCollection | igxTopLevel\">\n                    <igx-grid-header-group [ngClass]=\"column.headerGroupClasses\"\n                                           [ngStyle]=\"column.headerGroupStyles | igxHeaderGroupStyle:column:grid.pipeTrigger\" [column]=\"column\"\n                                           [style.min-width]=\"column.resolvedWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           [style.flex-basis]=\"column.resolvedWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           (pointerdown)=\"grid.navigation.focusOutRowHeader($event)\">\n                    </igx-grid-header-group>\n                </ng-container>\n            </ng-container>\n            <div class=\"igx-grid-thead--virtualizationWrapper\"  [style.max-height.px]='maxContainerHeight' (click)=\"grid.navigation.focusOutRowHeader($event)\">\n                <div class=\"igx-grid-thead__group igx-grid-thead--virtualizationContainer\" [style.height.px]='totalDepth > 1 ? grid.rowHeight : undefined' *ngFor='let dimLevelColumns of columnDimensionsByLevel; let i = index' [style.width.px]='grid.unpinnedWidth'>\n                    <ng-template igxGridFor #headerVirtualContainer let-column\n                                 [igxGridForOf]=\"dimLevelColumns\" [igxGridForOfUniqueSizeCache] = 'true' [igxForScrollContainer]=\"grid.parentVirtDir\"\n                                 [igxForContainerSize]=\"grid.unpinnedWidth\" [igxForTrackBy]=\"grid.trackColumnChanges\"\n                                 [igxForSizePropName]=\"'calcPixelWidth'\" [igxForScrollOrientation]=\"'horizontal'\">\n                        <igx-grid-header-group [ngClass]=\"column.headerGroupClasses\"\n                                               [style.height.px]='totalDepth > 1 ? calcHeight(column, i) : undefined'\n                                               [ngStyle]=\"column.headerGroupStyles |igxHeaderGroupStyle:column:grid.pipeTrigger\" [column]=\"column\"\n                                               [style.min-width]=\"column.resolvedWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                               [style.flex-basis]=\"column.resolvedWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                               [class.igx-grid__tr-pivot--columnDimensionLeaf] = 'isDuplicateOfExistingParent(column, i)'\n                                               [class.igx-grid__tr-pivot--columnMultiRowSpan] = 'isMultiRow(column, i)'\n                        >\n                        </igx-grid-header-group>\n                    </ng-template>\n                </div>\n            </div>\n\n            <!-- Pinned columns collection at the end -->\n            <ng-container *ngIf=\"pinnedColumnCollection.length && !grid.isPinningToStart\">\n                <ng-container *ngFor=\"let column of pinnedColumnCollection | igxTopLevel\">\n                    <igx-grid-header-group [ngClass]=\"column.headerGroupClasses\"\n                                           [ngStyle]=\"column.headerGroupStyles |igxHeaderGroupStyle:column:grid.pipeTrigger\" [column]=\"column\"\n                                           [style.min-width]=\"column.resolvedWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           [style.flex-basis]=\"column.resolvedWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           [style.left]=\"column.rightPinnedOffset\" (pointerdown)=\"grid.navigation.focusOutRowHeader($event)\">\n                    </igx-grid-header-group>\n                </ng-container>\n            </ng-container>\n        </div>\n    </div>\n</div>\n<!-- Header thumb area -->\n<div class=\"igx-grid-thead__thumb\" [hidden]=\"!grid.hasVerticalScroll()\" [style.width.px]=\"grid.scrollSize\">\n</div>\n\n<igx-drop-down #dropdown (selectionChanging)='onAggregationChange($event)'>\n    <igx-drop-down-item *ngFor=\"let item of aggregateList\" [selected]='isSelected(item)' [value]='item'>\n        {{ item.label }}\n    </igx-drop-down-item>\n</igx-drop-down>\n\n<div [hidden]='true'>\n    <igx-grid-excel-style-filtering [maxHeight]='grid.excelStyleFilterMaxHeight' [minHeight]='grid.excelStyleFilterMinHeight' #esf>\n        <div igxExcelStyleColumnOperations>\n            <igx-chips-area #dropdownChips>\n                <igx-chip *ngFor=\"let filter of this.filterDropdownDimensions\" [id]=\"filter.memberName\"\n                [removable]=\"true\" (remove)=\"filterRemoved($event)\"\n                (chipClick)='onFiltersSelectionChanged($event)' [selectable]='true' [selected]='filter === this.filterDropdownDimensions.values().next().value'>\n                {{filter.displayName || filter.memberName}}\n            </igx-chip>\n        </igx-chips-area>\n        </div>\n        <igx-excel-style-filter-operations>\n            <igx-excel-style-search></igx-excel-style-search>\n        </igx-excel-style-filter-operations>\n    </igx-grid-excel-style-filtering>\n</div>\n\n<div style=\"visibility: hidden; position: absolute; top: -10000px\">\n    <igx-chips-area #filterAreaHidden droppable='true'>\n        <igx-chip\n            *ngFor=\"let filter of grid.filterDimensions\"\n            [id]=\"filter.memberName\"\n            [draggable]=\"true\"\n            [removable]=\"true\"\n            (remove)=\"filterRemoved($event)\">\n            <igx-icon family=\"default\" name=\"filter_list\" igxPrefix></igx-icon>\n            {{filter.displayName || filter.memberName}}\n        </igx-chip>\n    </igx-chips-area>\n</div>\n\n<ng-template #valueChipDefaultTemplate let-value>\n    {{value.aggregate.key}}({{value.displayName || value.member}})\n</ng-template>\n", dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: IgxDropDirective, selector: "[igxDrop]", inputs: ["igxDrop", "dropChannel", "dropStrategy"], outputs: ["enter", "over", "leave", "dropped"], exportAs: ["drop"] }, { kind: "component", type: IgxChipsAreaComponent, selector: "igx-chips-area", inputs: ["width", "height"], outputs: ["reorder", "selectionChange", "moveStart", "moveEnd"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: IgxChipComponent, selector: "igx-chip", inputs: ["variant", "id", "tabIndex", "data", "draggable", "animateOnRelease", "hideBaseOnDrag", "removable", "removeIcon", "selectable", "selectIcon", "class", "disabled", "selected", "color", "resourceStrings"], outputs: ["selectedChange", "moveStart", "moveEnd", "remove", "chipClick", "selectedChanging", "selectedChanged", "keyDown", "dragEnter", "dragLeave", "dragOver", "dragDrop"] }, { kind: "component", type: IgxIconComponent, selector: "igx-icon", inputs: ["family", "name", "active"] }, { kind: "directive", type: IgxPrefixDirective, selector: "igx-prefix,[igxPrefix],[igxStart]" }, { kind: "component", type: IgxBadgeComponent, selector: "igx-badge", inputs: ["id", "type", "value", "icon", "iconSet", "shape", "outlined"] }, { kind: "directive", type: IgxSuffixDirective, selector: "igx-suffix,[igxSuffix],[igxEnd]" }, { kind: "directive", type: IgxDropDownItemNavigationDirective, selector: "[igxDropDownItemNavigation]", inputs: ["igxDropDownItemNavigation"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: IgxGridHeaderGroupComponent, selector: "igx-grid-header-group", inputs: ["column"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: IgxGridForOfDirective, selector: "[igxGridFor][igxGridForOf]", inputs: ["igxGridForOf", "igxGridForOfUniqueSizeCache", "igxGridForOfVariableSizes"], outputs: ["dataChanging"] }, { kind: "component", type: IgxDropDownComponent, selector: "igx-drop-down", inputs: ["allowItemsFocus", "labelledBy"], outputs: ["opening", "opened", "closing", "closed"] }, { kind: "component", type: IgxDropDownItemComponent, selector: "igx-drop-down-item" }, { kind: "component", type: IgxGridExcelStyleFilteringComponent, selector: "igx-grid-excel-style-filtering", inputs: ["column", "minHeight", "maxHeight"], outputs: ["loadingStart", "loadingEnd", "initialized", "sortingChanged", "columnChange", "listDataLoaded"] }, { kind: "directive", type: IgxExcelStyleColumnOperationsTemplateDirective, selector: "igx-excel-style-column-operations,[igxExcelStyleColumnOperations]" }, { kind: "directive", type: IgxExcelStyleFilterOperationsTemplateDirective, selector: "igx-excel-style-filter-operations,[igxExcelStyleFilterOperations]" }, { kind: "component", type: IgxExcelStyleSearchComponent, selector: "igx-excel-style-search", inputs: ["id"] }, { kind: "pipe", type: IgxHeaderGroupWidthPipe, name: "igxHeaderGroupWidth" }, { kind: "pipe", type: IgxHeaderGroupStylePipe, name: "igxHeaderGroupStyle" }, { kind: "pipe", type: IgxGridTopLevelColumns, name: "igxTopLevel" }, { kind: "component", type: IgxPivotRowHeaderGroupComponent, selector: "igx-pivot-row-header-group", inputs: ["rowIndex", "dimWidth", "rootDimension"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotHeaderRowComponent, decorators: [{
            type: Component,
            args: [{ changeDetection: ChangeDetectionStrategy.OnPush, selector: 'igx-pivot-header-row', standalone: true, imports: [NgIf, IgxDropDirective, IgxChipsAreaComponent, NgFor, IgxChipComponent, IgxIconComponent,
                        IgxPrefixDirective, IgxBadgeComponent, IgxSuffixDirective, IgxDropDownItemNavigationDirective,
                        NgTemplateOutlet, IgxGridHeaderGroupComponent, NgClass, NgStyle, IgxGridForOfDirective,
                        IgxDropDownComponent, IgxDropDownItemComponent, IgxGridExcelStyleFilteringComponent,
                        IgxExcelStyleColumnOperationsTemplateDirective, IgxExcelStyleFilterOperationsTemplateDirective,
                        IgxExcelStyleSearchComponent, IgxHeaderGroupWidthPipe, IgxHeaderGroupStylePipe, IgxGridTopLevelColumns,
                        IgxPivotRowHeaderGroupComponent], template: "<div>\n    <div class=\"igx-grid-thead__wrapper igx-grid-thead__wrapper--pivot\" role=\"row\" [style.width.px]=\"width\">\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]=\"width\">\n            <div class='igx-grid__tr-pivot--filter-container'>\n                <div #pivotFilterContainer *ngIf=\"grid.pivotUI.showConfiguration\"\n                     class=\"igx-grid__tr-pivot igx-grid__tr-pivot--filter\" [style.min-width.px]=\"grid.pivotRowWidths - 1\"\n                     [style.max-width.px]=\"grid.pivotRowWidths - 1\" (igxDragLeave)=\"onAreaDragLeave($event, filterArea)\"\n                     igxDrop (dropped)=\"onDimDrop($event, filterArea, 2)\" (pointerdown)=\"$event.preventDefault()\">\n                    <!-- Filter area -->\n                    <igx-chips-area #filterArea droppable='true'>\n                        <span id='empty' igxDrop (dropped)=\"onDimDrop($event, filterArea, 2)\"\n                          *ngIf=\"grid.filterDimensions.length === 0\"\n                          class='igx-grid__pivot-empty-chip-area'>{{grid.resourceStrings.igx_grid_pivot_empty_filter_drop_area}}</span>\n                        <ng-container *ngFor=\"let filter of this.filterAreaDimensions; let last = last;\">\n                        <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(filterArea)'></span>\n                            <igx-chip [id]=\"filter.memberName\" [draggable]=\"true\" [data]=\"{ pivotArea: 'filter' }\"\n                                      [removable]=\"true\" (remove)=\"filterRemoved($event)\" (dragOver)=\"onDimDragOver($event, 2)\"\n                                      (dragLeave)=\"onDimDragLeave($event)\" (dragDrop)=\"onDimDrop($event, filterArea, 2)\"\n                                      (moveStart)='onDimDragStart($event, filterArea)' (moveEnd)='onDimDragEnd()'>\n                                <igx-icon\n                                    family=\"default\"\n                                    name=\"filter_list\"\n                                    igxPrefix\n                                    (pointerdown)='onFilteringIconPointerDown($event)'\n                                    (click)='onFilteringIconClick($event, filter)'>\n                                </igx-icon>\n                                {{filter.displayName || filter.memberName}}\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(filterArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onDimDrop($event, filterArea, 2)\" #notifyChip [hidden]='true'>\n                            {{grid.resourceStrings.igx_grid_pivot_filter_drop_chip}}\n                        </igx-chip>\n                    </igx-chips-area>\n                    <div class=\"igx-grid__pivot-filter-toggle\" *ngIf=\"isFiltersButton && grid.filterDimensions.length !== 0\">\n                        <igx-icon\n                            family=\"default\"\n                            name=\"filter_list\"\n                            #filterIcon\n                            (pointerdown)='onFilteringIconPointerDown($event)'\n                            (click)='onFiltersAreaDropdownClick($event)'>\n                        </igx-icon>\n                        <igx-badge value=\"{{this.filterDropdownDimensions.size}}\"></igx-badge>\n                    </div>\n                </div>\n                <div class='igx-grid__tr-pivot--drop-row-area'>\n                    <div #pivotRowContainer *ngIf=\"grid.pivotUI.showConfiguration && grid.pivotUI.showRowHeaders\" [style.width.px]=\"grid.pivotRowWidths - 1\"\n                        class=\"igx-grid__tr-pivot igx-grid__tr-pivot--small-row-area\" igxDrop\n                        (igxDragLeave)=\"onAreaDragLeave($event, rowArea)\"\n                        (dropped)=\"onDimDrop($event, rowArea, 0)\">\n                        <igx-chips-area #rowArea droppable='true'>\n                            <span id='empty' igxDrop (dropped)=\"onDimDrop($event, rowArea, 0)\"\n                                *ngIf=\"grid.rowDimensions.length === 0\"\n                                class='igx-grid__pivot-empty-chip-area'>{{grid.resourceStrings.igx_grid_pivot_empty_row_drop_area}}</span>\n                            <ng-container *ngFor=\"let row of grid.rowDimensions; let last = last;\">\n                                <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                    [style.height.px]='getAreaHeight(rowArea)'></span>\n                                    <igx-chip [draggable]=\"true\" [id]=\"row.memberName\" [data]=\"{ pivotArea: 'row' }\"\n                                            [removable]=\"true\" (remove)=\"rowRemoved($event)\" (dragLeave)=\"onDimDragLeave($event)\"\n                                            (dragDrop)=\"onDimDrop($event, rowArea, 0)\" (dragOver)=\"onDimDragOver($event, 0)\"\n                                            (moveStart)='onDimDragStart($event, rowArea)' (moveEnd)='onDimDragEnd()'\n                                            (click)=\"onChipSort($event, row)\">\n                                        <igx-icon igxPrefix family=\"default\" name=\"table_rows\"></igx-icon>\n                                        <igx-icon\n                                            family=\"default\"\n                                            name=\"filter_list\"\n                                            igxPrefix\n                                            (pointerdown)='onFilteringIconPointerDown($event)'\n                                            (click)='onFilteringIconClick($event, row)'>\n                                        </igx-icon>\n                                        {{ row.displayName || row.memberName}}\n                                        <igx-icon\n                                            family=\"default\"\n                                            [name]=\"row.sortDirection < 2 ? 'sort_asc' : 'sort_desc'\"\n                                            *ngIf=\"row.sortDirection\"\n                                            igxSuffix>\n                                        </igx-icon>\n                                    </igx-chip>\n                                <ng-container *ngIf='last'>\n                                <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                    [style.height.px]='getAreaHeight(rowArea)'></span>\n                                </ng-container>\n                            </ng-container>\n                            <igx-chip igxDrop (dragDrop)=\"onDimDrop($event, rowArea, 0)\" #notifyChip [hidden]='true'>\n                                {{grid.resourceStrings.igx_grid_pivot_row_drop_chip}}\n                            </igx-chip>\n                        </igx-chips-area>\n                    </div>\n                </div>\n            </div>\n\n            <div class=\"igx-grid__tr-pivot-group\">\n                <div #pivotColumnContainer *ngIf=\"grid.pivotUI.showConfiguration\" class=\"igx-grid__tr-pivot\"\n                     (dropped)=\"onDimDrop($event, colArea, 1)\" igxDrop (igxDragLeave)=\"onAreaDragLeave($event, colArea)\">\n                    <!-- Columns area -->\n                    <igx-chips-area #colArea droppable='true'>\n                    <span id='empty' (dropped)=\"onDimDrop($event, colArea, 1)\" igxDrop\n                        *ngIf=\"grid.columnDimensions.length === 0\" class='igx-grid__pivot-empty-chip-area'>\n                        {{grid.resourceStrings.igx_grid_pivot_empty_column_drop_area}}</span>\n                        <ng-container *ngFor=\"let col of grid.columnDimensions; let last = last;\">\n                        <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(colArea)'></span>\n                            <igx-chip [draggable]=\"true\" [id]=\"col.memberName\" [data]=\"{ pivotArea: 'column' }\"\n                                      [removable]=\"true\" (remove)=\"columnRemoved($event)\" (dragOver)=\"onDimDragOver($event, 1)\"\n                                      (dragLeave)=\"onDimDragLeave($event)\" (dragDrop)=\"onDimDrop($event, colArea, 1)\"\n                                      (moveStart)='onDimDragStart($event, colArea)' (moveEnd)='onDimDragEnd()'\n                                      (click)=\"onChipSort($event, col)\">\n                                <igx-icon\n                                    family=\"default\"\n                                    name=\"view_column\"\n                                    igxPrefix>\n                                </igx-icon>\n                                <igx-icon\n                                    family=\"default\"\n                                    name=\"filter_list\"\n                                    igxPrefix\n                                    (pointerdown)='onFilteringIconPointerDown($event)'\n                                    (click)='onFilteringIconClick($event, col)'>\n                                </igx-icon>\n                                {{col.displayName || col.memberName}}\n                                <igx-icon\n                                    family=\"default\"\n                                    [name]=\"col.sortDirection < 2 ? 'sort_asc' : 'sort_desc'\"\n                                    *ngIf=\"col.sortDirection\"\n                                    igxSuffix>\n                                </igx-icon>\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(colArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onDimDrop($event, colArea, 1)\" #notifyChip [hidden]='true'>\n                            {{grid.resourceStrings.igx_grid_pivot_column_drop_chip}}\n                        </igx-chip>\n                    </igx-chips-area>\n                </div>\n\n                <div #pivotValueContainer *ngIf=\"grid.pivotUI.showConfiguration\" class=\"igx-grid__tr-pivot\"\n                     (pointerdown)=\"$event.preventDefault()\" (dropped)=\"onValueDrop($event, valueArea)\" igxDrop\n                     (igxDragLeave)=\"onAreaDragLeave($event, valueArea)\">\n                    <!-- Value area -->\n                    <igx-chips-area #valueArea droppable='true'>\n                    <span id='empty' (dropped)=\"onValueDrop($event, valueArea)\" igxDrop *ngIf=\"grid.values.length === 0\"\n                        class='igx-grid__pivot-empty-chip-area'>{{grid.resourceStrings.igx_grid_pivot_empty_value_drop_area}}</span>\n                    <ng-container *ngFor=\"let value of grid.values; let last = last;\">\n                        <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                              [style.height.px]='getAreaHeight(valueArea)'></span>\n                            <igx-chip #currChip [draggable]=\"true\" [id]=\"value.displayName || value.member\" [data]=\"{ pivotArea: 'value' }\"\n                                    [removable]=\"true\" (remove)=\"valueRemoved($event)\"\n                                      (dragLeave)=\"onDimDragLeave($event)\" (dragOver)=\"onDimDragOver($event)\"\n                                      (dragDrop)=\"onValueDrop($event, valueArea)\">\n                                <div class=\"igx-grid__tr-pivot-toggle-icons\" igxPrefix\n                                     (click)='onSummaryClick($event, value, dropdown, currChip)'\n                                     (pointerdown)='$event.stopPropagation()' [igxDropDownItemNavigation]=\"dropdown\">\n                                    <igx-icon family=\"default\" name=\"functions\"></igx-icon>\n                                    <igx-icon family=\"default\" name=\"arrow_drop_down\"></igx-icon>\n                                </div>\n                                <ng-container *ngTemplateOutlet=\"grid.valueChipTemplate ? grid.valueChipTemplate : valueChipDefaultTemplate; context: { $implicit: value }\"></ng-container>\n                            </igx-chip>\n                            <ng-container *ngIf='last'>\n                            <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                  [style.height.px]='getAreaHeight(valueArea)'></span>\n                            </ng-container>\n                        </ng-container>\n                        <igx-chip igxDrop (dragDrop)=\"onValueDrop($event, valueArea)\" #notifyValueChip [hidden]='true'>\n                            {{grid.resourceStrings.igx_grid_pivot_value_drop_chip}}\n                        </igx-chip>\n                    </igx-chips-area>\n                </div>\n            </div>\n        </div>\n    </div>\n    <div role=\"rowgroup\" class=\"igx-grid-thead__wrapper\" [style.width.px]=\"width\"\n         [attr.aria-activedescendant]=\"activeDescendant\" [class.igx-grid__tr--mrl]=\"hasMRL\">\n\n        <!-- Column headers area -->\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]=\"width\">\n            <ng-container *ngIf=\"!grid.pivotUI.showRowHeaders || grid.rowDimensions.length === 0\">\n                <div #pivotContainer class=\"igx-grid__tr-pivot igx-grid__tr-pivot--row-area\"\n                    [style.width.px]=\"grid.pivotRowWidths - 1\" (igxDragLeave)=\"onAreaDragLeave($event, rowArea)\" igxDrop\n                    (dropped)=\"onDimDrop($event, rowArea, 0)\" (pointerdown)=\"$event.preventDefault()\">\n                    <!-- Row area -->\n                    <igx-chips-area #rowArea droppable='true'>\n                        <ng-container *ngIf=\"grid.pivotUI.showConfiguration || grid.rowDimensions.length === 0\">\n                            <span id='empty' igxDrop (dropped)=\"onDimDrop($event, rowArea, 0)\"\n                                *ngIf=\"grid.rowDimensions.length === 0\"\n                                class='igx-grid__pivot-empty-chip-area'>{{grid.resourceStrings.igx_grid_pivot_empty_row_drop_area}}</span>\n                            <ng-container *ngFor=\"let row of grid.rowDimensions; let last = last;\">\n                                <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                    [style.height.px]='getAreaHeight(rowArea)'></span>\n                                    <igx-chip [draggable]=\"true\" [id]=\"row.memberName\" [data]=\"{ pivotArea: 'row' }\"\n                                            [removable]=\"true\" (remove)=\"rowRemoved($event)\" (dragLeave)=\"onDimDragLeave($event)\"\n                                            (dragDrop)=\"onDimDrop($event, rowArea, 0)\" (dragOver)=\"onDimDragOver($event, 0)\"\n                                            (moveStart)='onDimDragStart($event, rowArea)' (moveEnd)='onDimDragEnd()'\n                                            (click)=\"onChipSort($event, row)\">\n                                        <igx-icon igxPrefix family=\"default\" name=\"table_rows\"></igx-icon>\n                                        <igx-icon\n                                            family=\"default\"\n                                            name=\"filter_list\"\n                                            igxPrefix\n                                            (pointerdown)='onFilteringIconPointerDown($event)'\n                                            (click)='onFilteringIconClick($event, row)'>\n                                        </igx-icon>\n                                        {{ row.displayName || row.memberName}}\n                                        <igx-icon\n                                            family=\"default\"\n                                            [name]=\"row.sortDirection < 2 ? 'sort_asc' : 'sort_desc'\"\n                                            *ngIf=\"row.sortDirection\"\n                                            igxSuffix>\n                                        </igx-icon>\n                                    </igx-chip>\n                                <ng-container *ngIf='last'>\n                                <span class=\"igx-grid__tr-pivot--chip_drop_indicator\"\n                                    [style.height.px]='getAreaHeight(rowArea)'></span>\n                                </ng-container>\n                            </ng-container>\n                            <igx-chip igxDrop (dragDrop)=\"onDimDrop($event, rowArea, 0)\" #notifyChip [hidden]='true'>\n                                {{grid.resourceStrings.igx_grid_pivot_row_drop_chip}}\n                            </igx-chip>\n                        </ng-container>\n                    </igx-chips-area>\n                </div>\n            </ng-container>\n\n            <ng-container *ngIf=\"grid.pivotUI.showRowHeaders && grid.visibleRowDimensions.length > 0\">\n                <div class=\"igx-grid__tr igx-grid__tr-header-row\" role=\"row\" [style.width.px]=\"grid.pivotRowWidths - 1\">\n                    <ng-container *ngFor=\"let dim of grid.visibleRowDimensions; index as colIndex;last as isLast\">\n                        <igx-pivot-row-header-group #rowDimensionHeaders *ngIf=\"getRowDimensionColumn(dim) as dimCol\"\n                            [ngClass]=\"dimCol.headerGroupClasses\"\n                            [ngStyle]=\"dimCol.headerGroupStyles | igxHeaderGroupStyle:dimCol:grid.pipeTrigger\"\n                            [style.min-width]=\"grid.rowDimensionWidthToPixels(this.grid.visibleRowDimensions[colIndex]) | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                            [style.flex-basis]=\"grid.rowDimensionWidthToPixels(this.grid.visibleRowDimensions[colIndex]) | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                            [column]=\"dimCol\"\n                            [rootDimension]=\"grid.visibleRowDimensions[colIndex]\"\n                            [dimWidth]=\"grid.rowDimensionWidthToPixels(this.grid.visibleRowDimensions[colIndex])\"\n                            [rowIndex]=\"-1\" >\n                        </igx-pivot-row-header-group>\n                    </ng-container>\n                </div>\n            </ng-container>\n\n            <!-- Pinned columns collection from the start -->\n            <ng-container *ngIf=\"pinnedColumnCollection.length && grid.isPinningToStart\">\n                <ng-container *ngFor=\"let column of pinnedColumnCollection | igxTopLevel\">\n                    <igx-grid-header-group [ngClass]=\"column.headerGroupClasses\"\n                                           [ngStyle]=\"column.headerGroupStyles | igxHeaderGroupStyle:column:grid.pipeTrigger\" [column]=\"column\"\n                                           [style.min-width]=\"column.resolvedWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           [style.flex-basis]=\"column.resolvedWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           (pointerdown)=\"grid.navigation.focusOutRowHeader($event)\">\n                    </igx-grid-header-group>\n                </ng-container>\n            </ng-container>\n            <div class=\"igx-grid-thead--virtualizationWrapper\"  [style.max-height.px]='maxContainerHeight' (click)=\"grid.navigation.focusOutRowHeader($event)\">\n                <div class=\"igx-grid-thead__group igx-grid-thead--virtualizationContainer\" [style.height.px]='totalDepth > 1 ? grid.rowHeight : undefined' *ngFor='let dimLevelColumns of columnDimensionsByLevel; let i = index' [style.width.px]='grid.unpinnedWidth'>\n                    <ng-template igxGridFor #headerVirtualContainer let-column\n                                 [igxGridForOf]=\"dimLevelColumns\" [igxGridForOfUniqueSizeCache] = 'true' [igxForScrollContainer]=\"grid.parentVirtDir\"\n                                 [igxForContainerSize]=\"grid.unpinnedWidth\" [igxForTrackBy]=\"grid.trackColumnChanges\"\n                                 [igxForSizePropName]=\"'calcPixelWidth'\" [igxForScrollOrientation]=\"'horizontal'\">\n                        <igx-grid-header-group [ngClass]=\"column.headerGroupClasses\"\n                                               [style.height.px]='totalDepth > 1 ? calcHeight(column, i) : undefined'\n                                               [ngStyle]=\"column.headerGroupStyles |igxHeaderGroupStyle:column:grid.pipeTrigger\" [column]=\"column\"\n                                               [style.min-width]=\"column.resolvedWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                               [style.flex-basis]=\"column.resolvedWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                               [class.igx-grid__tr-pivot--columnDimensionLeaf] = 'isDuplicateOfExistingParent(column, i)'\n                                               [class.igx-grid__tr-pivot--columnMultiRowSpan] = 'isMultiRow(column, i)'\n                        >\n                        </igx-grid-header-group>\n                    </ng-template>\n                </div>\n            </div>\n\n            <!-- Pinned columns collection at the end -->\n            <ng-container *ngIf=\"pinnedColumnCollection.length && !grid.isPinningToStart\">\n                <ng-container *ngFor=\"let column of pinnedColumnCollection | igxTopLevel\">\n                    <igx-grid-header-group [ngClass]=\"column.headerGroupClasses\"\n                                           [ngStyle]=\"column.headerGroupStyles |igxHeaderGroupStyle:column:grid.pipeTrigger\" [column]=\"column\"\n                                           [style.min-width]=\"column.resolvedWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           [style.flex-basis]=\"column.resolvedWidth | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                                           [style.left]=\"column.rightPinnedOffset\" (pointerdown)=\"grid.navigation.focusOutRowHeader($event)\">\n                    </igx-grid-header-group>\n                </ng-container>\n            </ng-container>\n        </div>\n    </div>\n</div>\n<!-- Header thumb area -->\n<div class=\"igx-grid-thead__thumb\" [hidden]=\"!grid.hasVerticalScroll()\" [style.width.px]=\"grid.scrollSize\">\n</div>\n\n<igx-drop-down #dropdown (selectionChanging)='onAggregationChange($event)'>\n    <igx-drop-down-item *ngFor=\"let item of aggregateList\" [selected]='isSelected(item)' [value]='item'>\n        {{ item.label }}\n    </igx-drop-down-item>\n</igx-drop-down>\n\n<div [hidden]='true'>\n    <igx-grid-excel-style-filtering [maxHeight]='grid.excelStyleFilterMaxHeight' [minHeight]='grid.excelStyleFilterMinHeight' #esf>\n        <div igxExcelStyleColumnOperations>\n            <igx-chips-area #dropdownChips>\n                <igx-chip *ngFor=\"let filter of this.filterDropdownDimensions\" [id]=\"filter.memberName\"\n                [removable]=\"true\" (remove)=\"filterRemoved($event)\"\n                (chipClick)='onFiltersSelectionChanged($event)' [selectable]='true' [selected]='filter === this.filterDropdownDimensions.values().next().value'>\n                {{filter.displayName || filter.memberName}}\n            </igx-chip>\n        </igx-chips-area>\n        </div>\n        <igx-excel-style-filter-operations>\n            <igx-excel-style-search></igx-excel-style-search>\n        </igx-excel-style-filter-operations>\n    </igx-grid-excel-style-filtering>\n</div>\n\n<div style=\"visibility: hidden; position: absolute; top: -10000px\">\n    <igx-chips-area #filterAreaHidden droppable='true'>\n        <igx-chip\n            *ngFor=\"let filter of grid.filterDimensions\"\n            [id]=\"filter.memberName\"\n            [draggable]=\"true\"\n            [removable]=\"true\"\n            (remove)=\"filterRemoved($event)\">\n            <igx-icon family=\"default\" name=\"filter_list\" igxPrefix></igx-icon>\n            {{filter.displayName || filter.memberName}}\n        </igx-chip>\n    </igx-chips-area>\n</div>\n\n<ng-template #valueChipDefaultTemplate let-value>\n    {{value.aggregate.key}}({{value.displayName || value.member}})\n</ng-template>\n" }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i0.Renderer2 }], propDecorators: { esf: [{
                type: ViewChild,
                args: ['esf']
            }], filterArea: [{
                type: ViewChild,
                args: ['filterAreaHidden', { static: false }]
            }], filtersButton: [{
                type: ViewChild,
                args: ['filterIcon']
            }], dropdownChips: [{
                type: ViewChild,
                args: ['dropdownChips']
            }], pivotFilterContainer: [{
                type: ViewChild,
                args: ['pivotFilterContainer']
            }], pivotRowContainer: [{
                type: ViewChild,
                args: ['pivotRowContainer']
            }], notificationChips: [{
                type: ViewChildren,
                args: ['notifyChip']
            }], headerContainers: [{
                type: ViewChildren,
                args: ['headerVirtualContainer', { read: IgxGridForOfDirective }]
            }], rowDimensionHeaders: [{
                type: ViewChildren,
                args: ['rowDimensionHeaders']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGl2b3QtaGVhZGVyLXJvdy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZ3JpZHMvcGl2b3QtZ3JpZC9waXZvdC1oZWFkZXItcm93LmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy9waXZvdC1ncmlkL3Bpdm90LWhlYWRlci1yb3cuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNILHVCQUF1QixFQUV2QixTQUFTLEVBRVQsTUFBTSxFQUlOLFNBQVMsRUFFVCxZQUFZLEVBQ2YsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFzQixnQkFBZ0IsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQ2xGLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQ3pFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBQzFFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLDBDQUEwQyxDQUFDO0FBRWpGLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLHFDQUFxQyxDQUFDO0FBQzNFLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxvQkFBb0IsRUFBcUMsaUJBQWlCLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUMvSSxPQUFPLEVBQWMsYUFBYSxFQUFpQixNQUFNLDBCQUEwQixDQUFDO0FBQ3BGLE9BQU8sRUFBRSwyQkFBMkIsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBQ3JGLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLHNDQUFzQyxDQUFDO0FBQ2pGLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUV4RCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sY0FBYyxD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QUFDLElBQUksRUFBRSxnQkFBZ0IsRUFBRSxxQkFBcUIsRUFBRSxLQUFLLEVBQUUsZ0JBQWdCLEVBQUUsZ0JBQWdCO3dCQUM5RixrQkFBa0IsRUFBRSxpQkFBaUIsRUFBRSxrQkFBa0IsRUFBRSxrQ0FBa0M7d0JBQzdGLGdCQUFnQixFQUFFLDJCQUEyQixFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUscUJBQXFCO3dCQUN0RixvQkFBb0IsRUFBRSx3QkFBd0IsRUFBRSxtQ0FBbUM7d0JBQ25GLDhDQUE4QyxFQUFFLDhDQUE4Qzt3QkFDOUYsNEJBQTRCLEVBQUUsdUJBQXVCLEVBQUUsdUJBQXVCLEVBQUUsc0JBQXNCO3dCQUN0RywrQkFBK0IsQ0FBQzs7MEJBOEUvQixNQUFNOzJCQUFDLGFBQWE7MEhBdERBLEdBQUc7c0JBQTNCLFNBQVM7dUJBQUMsS0FBSztnQkFLeUMsVUFBVTtzQkFBbEUsU0FBUzt1QkFBQyxrQkFBa0IsRUFBRSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUU7Z0JBS2hCLGFBQWE7c0JBQTVDLFNBQVM7dUJBQUMsWUFBWTtnQkFLWSxhQUFhO3NCQUEvQyxTQUFTO3VCQUFDLGVBQWU7Z0JBS2dCLG9CQUFvQjtzQkFBN0QsU0FBUzt1QkFBQyxzQkFBc0I7Z0JBS00saUJBQWlCO3NCQUF2RCxTQUFTO3VCQUFDLG1CQUFtQjtnQkFPdkIsaUJBQWlCO3NCQUR2QixZQUFZO3VCQUFDLFlBQVk7Z0JBU25CLGdCQUFnQjtzQkFEdEIsWUFBWTt1QkFBQyx3QkFBd0IsRUFBRSxFQUFFLElBQUksRUFBRSxxQkFBcUIsRUFBRTtnQkFRaEUsbUJBQW1CO3NCQUR6QixZQUFZO3VCQUFDLHFCQUFxQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ29tcG9uZW50LFxuICAgIEVsZW1lbnRSZWYsXG4gICAgSW5qZWN0LFxuICAgIE9uQ2hhbmdlcyxcbiAgICBRdWVyeUxpc3QsXG4gICAgUmVuZGVyZXIyLFxuICAgIFZpZXdDaGlsZCxcbiAgICBTaW1wbGVDaGFuZ2VzLFxuICAgIFZpZXdDaGlsZHJlblxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElCYXNlQ2hpcEV2ZW50QXJncywgSWd4Q2hpcENvbXBvbmVudCB9IGZyb20gJy4uLy4uL2NoaXBzL2NoaXAuY29tcG9uZW50JztcbmltcG9ydCB7IElneENoaXBzQXJlYUNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2NoaXBzL2NoaXBzLWFyZWEuY29tcG9uZW50JztcbmltcG9ydCB7IFNvcnRpbmdEaXJlY3Rpb24gfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvc29ydGluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBJZ3hHcmlkRm9yT2ZEaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2Zvci1vZi9mb3Jfb2YuZGlyZWN0aXZlJztcbmltcG9ydCB7IElTZWxlY3Rpb25FdmVudEFyZ3MgfSBmcm9tICcuLi8uLi9kcm9wLWRvd24vZHJvcC1kb3duLmNvbW1vbic7XG5pbXBvcnQgeyBJZ3hEcm9wRG93bkNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2Ryb3AtZG93bi9kcm9wLWRvd24uY29tcG9uZW50JztcbmltcG9ydCB7IEFic29sdXRlU2Nyb2xsU3RyYXRlZ3ksIEF1dG9Qb3NpdGlvblN0cmF0ZWd5LCBPdmVybGF5U2V0dGluZ3MsIFBvc2l0aW9uU2V0dGluZ3MsIFZlcnRpY2FsQWxpZ25tZW50IH0gZnJvbSAnLi4vLi4vc2VydmljZXMvcHVibGljX2FwaSc7XG5pbXBvcnQgeyBDb2x1bW5UeXBlLCBJR1hfR1JJRF9CQVNFLCBQaXZvdEdyaWRUeXBlIH0gZnJvbSAnLi4vY29tbW9uL2dyaWQuaW50ZXJmYWNlJztcbmltcG9ydCB7IElneEdyaWRIZWFkZXJHcm91cENvbXBvbmVudCB9IGZyb20gJy4uL2hlYWRlcnMvZ3JpZC1oZWFkZXItZ3JvdXAuY29tcG9uZW50JztcbmltcG9ydCB7IElneEdyaWRIZWFkZXJSb3dDb21wb25lbnQgfSBmcm9tICcuLi9oZWFkZXJzL2dyaWQtaGVhZGVyLXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHsgRHJvcFBvc2l0aW9uIH0gZnJvbSAnLi4vbW92aW5nL21vdmluZy5zZXJ2aWNlJztcbmltcG9ydCB7IElQaXZvdEFnZ3JlZ2F0b3IsIElQaXZvdERpbWVuc2lvbiwgSVBpdm90VmFsdWUsIFBpdm90RGltZW5zaW9uVHlwZSB9IGZyb20gJy4vcGl2b3QtZ3JpZC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgUGl2b3RVdGlsIH0gZnJvbSAnLi9waXZvdC11dGlsJztcbmltcG9ydCB7IElneEdyaWRUb3BMZXZlbENvbHVtbnMgfSBmcm9tICcuLi9jb21tb24vcGlwZXMnO1xuaW1wb3J0IHsgSWd4SGVhZGVyR3JvdXBXaWR0aFBpcGUsIElneEhlYWRlckdyb3VwU3R5bGVQaXBlIH0gZnJvbSAnLi4vaGVhZGVycy9waXBlcyc7XG5pbXBvcnQgeyBJZ3hFeGNlbFN0eWxlU2VhcmNoQ29tcG9uZW50IH0gZnJvbSAnLi4vZmlsdGVyaW5nL2V4Y2VsLXN0eWxlL2V4Y2VsLXN0eWxlLXNlYXJjaC5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4R3JpZEV4Y2VsU3R5bGVGaWx0ZXJpbmdDb21wb25lbnQsIElneEV4Y2VsU3R5bGVDb2x1bW5PcGVyYXRpb25zVGVtcGxhdGVEaXJlY3RpdmUsIElneEV4Y2VsU3R5bGVGaWx0ZXJPcGVyYXRpb25zVGVtcGxhdGVEaXJlY3RpdmUgfSBmcm9tICcuLi9maWx0ZXJpbmcvZXhjZWwtc3R5bGUvZXhjZWwtc3R5bGUtZmlsdGVyaW5nLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hEcm9wRG93bkl0ZW1Db21wb25lbnQgfSBmcm9tICcuLi8uLi9kcm9wLWRvd24vZHJvcC1kb3duLWl0ZW0uY29tcG9uZW50JztcbmltcG9ydCB7IElneERyb3BEb3duSXRlbU5hdmlnYXRpb25EaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9kcm9wLWRvd24vZHJvcC1kb3duLW5hdmlnYXRpb24uZGlyZWN0aXZlJztcbmltcG9ydCB7IElneFN1ZmZpeERpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvc3VmZml4L3N1ZmZpeC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSWd4QmFkZ2VDb21wb25lbnQgfSBmcm9tICcuLi8uLi9iYWRnZS9iYWRnZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4UHJlZml4RGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9wcmVmaXgvcHJlZml4LmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJZ3hJY29uQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vaWNvbi9pY29uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hEcm9wRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9kcmFnLWRyb3AvZHJhZy1kcm9wLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBOZ0lmLCBOZ0ZvciwgTmdUZW1wbGF0ZU91dGxldCwgTmdDbGFzcywgTmdTdHlsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBJZ3hQaXZvdFJvd0hlYWRlckdyb3VwQ29tcG9uZW50IH0gZnJvbSAnLi9waXZvdC1yb3ctaGVhZGVyLWdyb3VwLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hQaXZvdFJvd0RpbWVuc2lvbkhlYWRlckdyb3VwQ29tcG9uZW50IH0gZnJvbSAnLi9waXZvdC1yb3ctZGltZW5zaW9uLWhlYWRlci1ncm91cC5jb21wb25lbnQnO1xuXG4vKipcbiAqXG4gKiBGb3IgYWxsIGludGVudHMgJiBwdXJwb3NlcyB0cmVhdCB0aGlzIGNvbXBvbmVudCBhcyB3aGF0IGEgPHRoZWFkPiB1c3VhbGx5IGlzIGluIHRoZSBkZWZhdWx0IDx0YWJsZT4gZWxlbWVudC5cbiAqXG4gKiBUaGlzIGNvbnRhaW5lciBob2xkcyB0aGUgcGl2b3QgZ3JpZCBoZWFkZXIgZWxlbWVudHMgYW5kIHRoZWlyIGJlaGF2aW9yL2ludGVyYWN0aW9ucy5cbiAqXG4gKiBAaGlkZGVuIEBpbnRlcm5hbFxuICovXG5AQ29tcG9uZW50KHtcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBzZWxlY3RvcjogJ2lneC1waXZvdC1oZWFkZXItcm93JyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vcGl2b3QtaGVhZGVyLXJvdy5jb21wb25lbnQuaHRtbCcsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgICBpbXBvcnRzOiBbTmdJZiwgSWd4RHJvcERpcmVjdGl2ZSwgSWd4Q2hpcHNBcmVhQ29tcG9uZW50LCBOZ0ZvciwgSWd4Q2hpcENvbXBvbmVudCwgSWd4SWNvbkNvbXBvbmVudCxcbiAgICAgICAgSWd4UHJlZml4RGlyZWN0aXZlLCBJZ3hCYWRnZUNvbXBvbmVudCwgSWd4U3VmZml4RGlyZWN0aXZlLCBJZ3hEcm9wRG93bkl0ZW1OYXZpZ2F0aW9uRGlyZWN0aXZlLFxuICAgICAgICBOZ1RlbXBsYXRlT3V0bGV0LCBJZ3hHcmlkSGVhZGVyR3JvdXBDb21wb25lbnQsIE5nQ2xhc3MsIE5nU3R5bGUsIElneEdyaWRGb3JPZkRpcmVjdGl2ZSxcbiAgICAgICAgSWd4RHJvcERvd25Db21wb25lbnQsIElneERyb3BEb3duSXRlbUNvbXBvbmVudCwgSWd4R3JpZEV4Y2VsU3R5bGVGaWx0ZXJpbmdDb21wb25lbnQsXG4gICAgICAgIElneEV4Y2VsU3R5bGVDb2x1bW5PcGVyYXRpb25zVGVtcGxhdGVEaXJlY3RpdmUsIElneEV4Y2VsU3R5bGVGaWx0ZXJPcGVyYXRpb25zVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgIElneEV4Y2VsU3R5bGVTZWFyY2hDb21wb25lbnQsIElneEhlYWRlckdyb3VwV2lkdGhQaXBlLCBJZ3hIZWFkZXJHcm91cFN0eWxlUGlwZSwgSWd4R3JpZFRvcExldmVsQ29sdW1ucyxcbiAgICAgICAgSWd4UGl2b3RSb3dIZWFkZXJHcm91cENvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgSWd4UGl2b3RIZWFkZXJSb3dDb21wb25lbnQgZXh0ZW5kcyBJZ3hHcmlkSGVhZGVyUm93Q29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgICBwdWJsaWMgYWdncmVnYXRlTGlzdDogSVBpdm90QWdncmVnYXRvcltdID0gW107XG5cbiAgICBwdWJsaWMgdmFsdWU6IElQaXZvdFZhbHVlO1xuICAgIHB1YmxpYyBmaWx0ZXJEcm9wZG93bkRpbWVuc2lvbnM6IFNldDxhbnk+ID0gbmV3IFNldDxhbnk+KCk7XG4gICAgcHVibGljIGZpbHRlckFyZWFEaW1lbnNpb25zOiBTZXQ8YW55PiA9IG5ldyBTZXQ8YW55PigpO1xuICAgIHByaXZhdGUgX2Ryb3BQb3MgPSBEcm9wUG9zaXRpb24uQWZ0ZXJEcm9wVGFyZ2V0O1xuICAgIHByaXZhdGUgdmFsdWVEYXRhOiBNYXA8c3RyaW5nLCBJUGl2b3RBZ2dyZWdhdG9yW10+O1xuICAgIHByaXZhdGUgX3N1Yk1lbnVQb3NpdGlvblNldHRpbmdzOiBQb3NpdGlvblNldHRpbmdzID0ge1xuICAgICAgICB2ZXJ0aWNhbFN0YXJ0UG9pbnQ6IFZlcnRpY2FsQWxpZ25tZW50LkJvdHRvbSxcbiAgICAgICAgY2xvc2VBbmltYXRpb246IHVuZGVmaW5lZFxuICAgIH07XG4gICAgcHJpdmF0ZSBfc3ViTWVudU92ZXJsYXlTZXR0aW5nczogT3ZlcmxheVNldHRpbmdzID0ge1xuICAgICAgICBjbG9zZU9uT3V0c2lkZUNsaWNrOiB0cnVlLFxuICAgICAgICBtb2RhbDogZmFsc2UsXG4gICAgICAgIHBvc2l0aW9uU3RyYXRlZ3k6IG5ldyBBdXRvUG9zaXRpb25TdHJhdGVneSh0aGlzLl9zdWJNZW51UG9zaXRpb25TZXR0aW5ncyksXG4gICAgICAgIHNjcm9sbFN0cmF0ZWd5OiBuZXcgQWJzb2x1dGVTY3JvbGxTdHJhdGVneSgpXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnZXNmJykgcHVibGljIGVzZjogYW55O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdmaWx0ZXJBcmVhSGlkZGVuJywgeyBzdGF0aWM6IGZhbHNlIH0pIHB1YmxpYyBmaWx0ZXJBcmVhO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdmaWx0ZXJJY29uJykgcHVibGljIGZpbHRlcnNCdXR0b247XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2Ryb3Bkb3duQ2hpcHMnKSBwdWJsaWMgZHJvcGRvd25DaGlwcztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgncGl2b3RGaWx0ZXJDb250YWluZXInKSBwdWJsaWMgcGl2b3RGaWx0ZXJDb250YWluZXI7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ3Bpdm90Um93Q29udGFpbmVyJykgcHVibGljIHBpdm90Um93Q29udGFpbmVyO1xuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIEBWaWV3Q2hpbGRyZW4oJ25vdGlmeUNoaXAnKVxuICAgIHB1YmxpYyBub3RpZmljYXRpb25DaGlwczogUXVlcnlMaXN0PElneENoaXBDb21wb25lbnQ+O1xuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqIFRoZSB2aXJ0dWFsaXplZCBwYXJ0IG9mIHRoZSBoZWFkZXIgcm93IGNvbnRhaW5pbmcgdGhlIHVucGlubmVkIGhlYWRlciBncm91cHMuXG4gICAgKi9cbiAgICBAVmlld0NoaWxkcmVuKCdoZWFkZXJWaXJ0dWFsQ29udGFpbmVyJywgeyByZWFkOiBJZ3hHcmlkRm9yT2ZEaXJlY3RpdmUgfSlcbiAgICBwdWJsaWMgaGVhZGVyQ29udGFpbmVyczogUXVlcnlMaXN0PElneEdyaWRGb3JPZkRpcmVjdGl2ZTxDb2x1bW5UeXBlLCBDb2x1bW5UeXBlW10+PjtcblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBAVmlld0NoaWxkcmVuKCdyb3dEaW1lbnNpb25IZWFkZXJzJylcbiAgICBwdWJsaWMgcm93RGltZW5zaW9uSGVhZGVyczogUXVlcnlMaXN0PElneFBpdm90Um93RGltZW5zaW9uSGVhZGVyR3JvdXBDb21wb25lbnQ+O1xuXG4gICAgcHVibGljIG92ZXJyaWRlIGdldCBoZWFkZXJGb3JPZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyQ29udGFpbmVycz8ubGFzdDtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgQEluamVjdChJR1hfR1JJRF9CQVNFKSBwdWJsaWMgb3ZlcnJpZGUgZ3JpZDogUGl2b3RHcmlkVHlwZSxcbiAgICAgICAgcmVmOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PixcbiAgICAgICAgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgcHJvdGVjdGVkIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKHJlZiwgY2RyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICogRGVmYXVsdCBpcyBhIHNpbmdsZSBlbXB0eSBsZXZlbCBzaW5jZSBkZWZhdWx0IGRlcHRoIGlzIDFcbiAgICAqL1xuICAgIHB1YmxpYyBjb2x1bW5EaW1lbnNpb25zQnlMZXZlbDogYW55W10gPSBbW11dO1xuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIGdldCBpc0ZpbHRlcnNCdXR0b24oKTogYm9vbGVhbiB7XG4gICAgICAgIGxldCBjaGlwc1dpZHRoID0gMDtcbiAgICAgICAgdGhpcy5maWx0ZXJEcm9wZG93bkRpbWVuc2lvbnMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5maWx0ZXJBcmVhRGltZW5zaW9ucy5jbGVhcigpO1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJBcmVhPy5jaGlwc0xpc3QgJiYgdGhpcy5maWx0ZXJBcmVhLmNoaXBzTGlzdC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5waXZvdEZpbHRlckNvbnRhaW5lci5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lclBhZGRpbmdzID0gcGFyc2VGbG9hdChzdHlsZXMucGFkZGluZ0xlZnQpICsgcGFyc2VGbG9hdChzdHlsZXMucGFkZGluZ1JpZ2h0KTtcbiAgICAgICAgICAgIGNoaXBzV2lkdGggKz0gY29udGFpbmVyUGFkZGluZ3MgKyAodGhpcy5maWx0ZXJzQnV0dG9uICYmIHRoaXMuZmlsdGVyQXJlYT8uY2hpcHNMaXN0Lmxlbmd0aCA+IDEgPyB0aGlzLmZpbHRlcnNCdXR0b24uZWwubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCA6IDApO1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJBcmVhLmNoaXBzTGlzdC5mb3JFYWNoKGNoaXAgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpbSA9IHRoaXMuZ3JpZC5maWx0ZXJEaW1lbnNpb25zLmZpbmQoeCA9PiB4Lm1lbWJlck5hbWUgPT09IGNoaXAuaWQpO1xuICAgICAgICAgICAgICAgIGlmIChkaW0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gOCBweCBtYXJnaW4gYmV0d2VlbiBjaGlwc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q2hpcFdpZHRoID0gY2hpcC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICsgODtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaXBzV2lkdGggKyBjdXJyZW50Q2hpcFdpZHRoIDwgdGhpcy5ncmlkLnBpdm90Um93V2lkdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckFyZWFEaW1lbnNpb25zLmFkZChkaW0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJEcm9wZG93bkRpbWVuc2lvbnMuYWRkKGRpbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hpcHNXaWR0aCArPSBjdXJyZW50Q2hpcFdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyRHJvcGRvd25EaW1lbnNpb25zLnNpemUgPiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIGdldCB0b3RhbERlcHRoKCkge1xuICAgICAgICBjb25zdCBjb2x1bW5EaW1lbnNpb25zID0gdGhpcy5ncmlkLmNvbHVtbkRpbWVuc2lvbnM7XG4gICAgICAgIGlmIChjb2x1bW5EaW1lbnNpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvdGFsRGVwdGggPSBjb2x1bW5EaW1lbnNpb25zLm1hcCh4ID0+IFBpdm90VXRpbC5nZXREaW1lbnNpb25EZXB0aCh4KSArIDEpLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCk7XG4gICAgICAgIGlmICh0aGlzLmdyaWQuaGFzTXVsdGlwbGVWYWx1ZXMpIHtcbiAgICAgICAgICAgIHRvdGFsRGVwdGggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWxEZXB0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIGdldCBtYXhDb250YWluZXJIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvdGFsRGVwdGggKiB0aGlzLmdyaWQucmVuZGVyZWRSb3dIZWlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBjYWxjSGVpZ2h0KGNvbDogQ29sdW1uVHlwZSwgaW5kZXg6IG51bWJlcikge1xuICAgICAgICByZXR1cm4gIWNvbC5jb2x1bW5Hcm91cCAmJiBjb2wubGV2ZWwgPCB0aGlzLnRvdGFsRGVwdGggJiYgY29sLmxldmVsID09PSBpbmRleCA/ICh0aGlzLnRvdGFsRGVwdGggLSBjb2wubGV2ZWwpICogdGhpcy5ncmlkLnJvd0hlaWdodCA6IHRoaXMuZ3JpZC5yb3dIZWlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBpc0R1cGxpY2F0ZU9mRXhpc3RpbmdQYXJlbnQoY29sOiBDb2x1bW5UeXBlLCBsdmw6IG51bWJlcikge1xuICAgICAgICBjb25zdCBwYXJlbnRDb2xsZWN0aW9uID0gbHZsID4gMCA/IHRoaXMuY29sdW1uRGltZW5zaW9uc0J5TGV2ZWxbbHZsIC0gMV0gOiBbXTtcbiAgICAgICAgY29uc3QgZHVwbGljYXRlID0gcGFyZW50Q29sbGVjdGlvbi5pbmRleE9mKGNvbCkgIT09IC0xO1xuXG4gICAgICAgIHJldHVybiBkdXBsaWNhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBpc011bHRpUm93KGNvbDogQ29sdW1uVHlwZSwgbHZsOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgaXNMZWFmID0gIWNvbC5jb2x1bW5Hcm91cDtcbiAgICAgICAgcmV0dXJuIGlzTGVhZiAmJiBsdmwgIT09IHRoaXMudG90YWxEZXB0aCAtIDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBwb3B1bGF0ZUNvbHVtbkRpbWVuc2lvbnNCeUxldmVsKCkge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRvdGFsRGVwdGg7IGkrKykge1xuICAgICAgICAgICAgcmVzW2ldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29scyA9IHRoaXMudW5waW5uZWRDb2x1bW5Db2xsZWN0aW9uO1xuICAgICAgICAvLyBwb3B1bGF0ZSBjb2x1bW4gZGltZW5zaW9uIG1hdHJpeCByZWN1cnNpdmVseVxuICAgICAgICB0aGlzLnBvcHVsYXRlRGltZW5zaW9uUmVjdXJzaXZlbHkoY29scy5maWx0ZXIoeCA9PiB4LmxldmVsID09PSAwKSwgMCwgcmVzKTtcbiAgICAgICAgdGhpcy5jb2x1bW5EaW1lbnNpb25zQnlMZXZlbCA9IHJlcztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcG9wdWxhdGVEaW1lbnNpb25SZWN1cnNpdmVseShjdXJyZW50TGV2ZWxDb2x1bW5zOiBDb2x1bW5UeXBlW10sIGxldmVsID0gMCwgcmVzOiBhbnlbXSkge1xuICAgICAgICBjdXJyZW50TGV2ZWxDb2x1bW5zLmZvckVhY2goY29sID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNbbGV2ZWxdKSB7XG4gICAgICAgICAgICAgICAgcmVzW2xldmVsXS5wdXNoKGNvbCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbC5jb2x1bW5Hcm91cCAmJiBjb2wuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aXNpYmxlQ29sdW1ucyA9IGNvbC5jaGlsZHJlbi50b0FycmF5KCkuZmlsdGVyKHggPT4gIXguaGlkZGVuKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3B1bGF0ZURpbWVuc2lvblJlY3Vyc2l2ZWx5KHZpc2libGVDb2x1bW5zLCBsZXZlbCArIDEsIHJlcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZXZlbCA8IHRoaXMudG90YWxEZXB0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxldmVsICsgMTsgaSA8PSB0aGlzLnRvdGFsRGVwdGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1tpXS5wdXNoKGNvbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy51bnBpbm5lZENvbHVtbkNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMucG9wdWxhdGVDb2x1bW5EaW1lbnNpb25zQnlMZXZlbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBvbkRpbURyYWdTdGFydChldmVudCwgYXJlYSkge1xuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIGZvciAoY29uc3QgY2hpcCBvZiB0aGlzLm5vdGlmaWNhdGlvbkNoaXBzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBjaGlwLm5hdGl2ZUVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIGlmIChhcmVhLmNoaXBzTGlzdC50b0FycmF5KCkuaW5kZXhPZihjaGlwKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5pdGVtKDApLmlkICE9PSAnZW1wdHknKSB7XG4gICAgICAgICAgICAgICAgY2hpcC5uYXRpdmVFbGVtZW50LmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHBhcmVudC5wYXJlbnRFbGVtZW50LnNjcm9sbFRvKHsgbGVmdDogY2hpcC5uYXRpdmVFbGVtZW50Lm9mZnNldExlZnQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIG9uRGltRHJhZ0VuZCgpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlwIG9mIHRoaXMubm90aWZpY2F0aW9uQ2hpcHMpIHtcbiAgICAgICAgICAgIGNoaXAubmF0aXZlRWxlbWVudC5oaWRkZW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBnZXRBcmVhSGVpZ2h0KGFyZWE6IElneENoaXBzQXJlYUNvbXBvbmVudCkge1xuICAgICAgICBjb25zdCBjaGlwcyA9IGFyZWEuY2hpcHNMaXN0O1xuICAgICAgICByZXR1cm4gY2hpcHMgJiYgY2hpcHMubGVuZ3RoID4gMCA/IGNoaXBzLmZpcnN0Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0SGVpZ2h0IDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIHJvd1JlbW92ZWQoZXZlbnQ6IElCYXNlQ2hpcEV2ZW50QXJncykge1xuICAgICAgICBjb25zdCByb3cgPSB0aGlzLmdyaWQucGl2b3RDb25maWd1cmF0aW9uLnJvd3MuZmluZCh4ID0+IHgubWVtYmVyTmFtZSA9PT0gZXZlbnQub3duZXIuaWQpO1xuICAgICAgICB0aGlzLmdyaWQudG9nZ2xlRGltZW5zaW9uKHJvdyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBjb2x1bW5SZW1vdmVkKGV2ZW50OiBJQmFzZUNoaXBFdmVudEFyZ3MpIHtcbiAgICAgICAgY29uc3QgY29sID0gdGhpcy5ncmlkLnBpdm90Q29uZmlndXJhdGlvbi5jb2x1bW5zLmZpbmQoeCA9PiB4Lm1lbWJlck5hbWUgPT09IGV2ZW50Lm93bmVyLmlkKTtcbiAgICAgICAgdGhpcy5ncmlkLnRvZ2dsZURpbWVuc2lvbihjb2wpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgdmFsdWVSZW1vdmVkKGV2ZW50OiBJQmFzZUNoaXBFdmVudEFyZ3MpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdyaWQucGl2b3RDb25maWd1cmF0aW9uLnZhbHVlcy5maW5kKHggPT4geC5tZW1iZXIgPT09IGV2ZW50Lm93bmVyLmlkIHx8IHguZGlzcGxheU5hbWUgPT09IGV2ZW50Lm93bmVyLmlkKTtcbiAgICAgICAgdGhpcy5ncmlkLnRvZ2dsZVZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIGZpbHRlclJlbW92ZWQoZXZlbnQ6IElCYXNlQ2hpcEV2ZW50QXJncykge1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLmdyaWQucGl2b3RDb25maWd1cmF0aW9uLmZpbHRlcnMuZmluZCh4ID0+IHgubWVtYmVyTmFtZSA9PT0gZXZlbnQub3duZXIuaWQpO1xuICAgICAgICB0aGlzLmdyaWQudG9nZ2xlRGltZW5zaW9uKGZpbHRlcik7XG4gICAgICAgIGlmICh0aGlzLmZpbHRlckRyb3Bkb3duRGltZW5zaW9ucy5zaXplID4gMCkge1xuICAgICAgICAgICAgdGhpcy5vbkZpbHRlcnNBcmVhRHJvcGRvd25DbGljayh7IHRhcmdldDogdGhpcy5maWx0ZXJzQnV0dG9uLmVsLm5hdGl2ZUVsZW1lbnQgfSwgdW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdyaWQuZmlsdGVyaW5nU2VydmljZS5oaWRlRVNGKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgb25GaWx0ZXJzU2VsZWN0aW9uQ2hhbmdlZChldmVudD86IElCYXNlQ2hpcEV2ZW50QXJncykge1xuICAgICAgICB0aGlzLmRyb3Bkb3duQ2hpcHMuY2hpcHNMaXN0LmZvckVhY2goY2hpcCA9PiB7XG4gICAgICAgICAgICBpZiAoY2hpcC5pZCAhPT0gZXZlbnQub3duZXIuaWQpIHtcbiAgICAgICAgICAgICAgICBjaGlwLnNlbGVjdGVkID0gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25GaWx0ZXJzQXJlYURyb3Bkb3duQ2xpY2soeyB0YXJnZXQ6IHRoaXMuZmlsdGVyc0J1dHRvbi5lbC5uYXRpdmVFbGVtZW50IH0sIHRoaXMuZ3JpZC5maWx0ZXJEaW1lbnNpb25zLmZpbmQoZGltID0+IGRpbS5tZW1iZXJOYW1lID09PSBldmVudC5vd25lci5pZCksIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIG9uRmlsdGVyaW5nSWNvblBvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgb25GaWx0ZXJpbmdJY29uQ2xpY2soZXZlbnQsIGRpbWVuc2lvbikge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29uc3QgZGltID0gZGltZW5zaW9uO1xuICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmdyaWQuZGltZW5zaW9uRGF0YUNvbHVtbnMuZmluZCh4ID0+IHguZmllbGQgPT09IGRpbS5tZW1iZXJOYW1lIHx8IHguZmllbGQgPT09IGRpbS5tZW1iZXIpO1xuICAgICAgICB0aGlzLmdyaWQuZmlsdGVyaW5nU2VydmljZS50b2dnbGVGaWx0ZXJEcm9wZG93bihldmVudC50YXJnZXQsIGNvbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBvblN1bW1hcnlDbGljayhldmVudEFyZ3MsIHZhbHVlOiBJUGl2b3RWYWx1ZSwgZHJvcGRvd246IElneERyb3BEb3duQ29tcG9uZW50LCBjaGlwOiBJZ3hDaGlwQ29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMuX3N1Yk1lbnVPdmVybGF5U2V0dGluZ3MudGFyZ2V0ID0gZXZlbnRBcmdzLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIHRoaXMudXBkYXRlRHJvcERvd24odmFsdWUsIGRyb3Bkb3duLCBjaGlwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBvbkZpbHRlcnNBcmVhRHJvcGRvd25DbGljayhldmVudCwgZGltZW5zaW9uPywgc2hvdWxkUmVhdHRhY2ggPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGRpbSA9IGRpbWVuc2lvbiB8fCB0aGlzLmZpbHRlckRyb3Bkb3duRGltZW5zaW9ucy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG4gICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuZ3JpZC5kaW1lbnNpb25EYXRhQ29sdW1ucy5maW5kKHggPT4geC5maWVsZCA9PT0gZGltLm1lbWJlck5hbWUgfHwgeC5maWVsZCA9PT0gZGltLm1lbWJlcik7XG4gICAgICAgIGlmIChzaG91bGRSZWF0dGFjaCkge1xuICAgICAgICAgICAgdGhpcy5kcm9wZG93bkNoaXBzLmNoaXBzTGlzdC5mb3JFYWNoKGNoaXAgPT4ge1xuICAgICAgICAgICAgICAgIGNoaXAuc2VsZWN0ZWQgPSBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duQ2hpcHMuY2hpcHNMaXN0LmZpcnN0LnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyaWQuZmlsdGVyaW5nU2VydmljZS50b2dnbGVGaWx0ZXJzRVNGKHRoaXMuZXNmLCBldmVudC50YXJnZXQsIGNvbCwgc2hvdWxkUmVhdHRhY2gpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgb25BZ2dyZWdhdGlvbkNoYW5nZShldmVudDogSVNlbGVjdGlvbkV2ZW50QXJncykge1xuICAgICAgICBpZiAoIXRoaXMuaXNTZWxlY3RlZChldmVudC5uZXdTZWxlY3Rpb24udmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlLmFnZ3JlZ2F0ZSA9IGV2ZW50Lm5ld1NlbGVjdGlvbi52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5waXBlVHJpZ2dlcisrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBpc1NlbGVjdGVkKHZhbDogSVBpdm90QWdncmVnYXRvcikge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5hZ2dyZWdhdGUua2V5ID09PSB2YWwua2V5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgb25DaGlwU29ydChfZXZlbnQsIGRpbWVuc2lvbjogSVBpdm90RGltZW5zaW9uKSB7XG4gICAgICAgIGlmIChkaW1lbnNpb24uc29ydGFibGUgPT09IHVuZGVmaW5lZCB8fCBkaW1lbnNpb24uc29ydGFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0RGlyZWN0aW9uID0gZGltZW5zaW9uLnNvcnREaXJlY3Rpb24gfHwgU29ydGluZ0RpcmVjdGlvbi5Ob25lO1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gc3RhcnREaXJlY3Rpb24gKyAxID4gU29ydGluZ0RpcmVjdGlvbi5EZXNjID9cbiAgICAgICAgICAgICAgICBTb3J0aW5nRGlyZWN0aW9uLk5vbmUgOiBzdGFydERpcmVjdGlvbiArIDE7XG4gICAgICAgICAgICB0aGlzLmdyaWQuc29ydERpbWVuc2lvbihkaW1lbnNpb24sIGRpcmVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIG9uRGltRHJhZ092ZXIoZXZlbnQsIGRpbWVuc2lvbj86IFBpdm90RGltZW5zaW9uVHlwZSkge1xuICAgICAgICBpZiAoIWV2ZW50LmRyYWdDaGlwIHx8ICFldmVudC5kcmFnQ2hpcC5kYXRhPy5waXZvdEFyZWEpIHJldHVybjtcbiAgICAgICAgY29uc3QgdHlwZU1pc21hdGNoID0gZGltZW5zaW9uICE9PSB1bmRlZmluZWQgPyB0aGlzLmdyaWQucGl2b3RDb25maWd1cmF0aW9uLnZhbHVlcy5maW5kKHggPT4geC5tZW1iZXIgPT09IGV2ZW50LmRyYWdDaGlwLmlkXG4gICAgICAgICAgICB8fCB4LmRpc3BsYXlOYW1lID09PSBldmVudC5kcmFnQ2hpcC5pZCkgOlxuICAgICAgICAgICAgIXRoaXMuZ3JpZC5waXZvdENvbmZpZ3VyYXRpb24udmFsdWVzLmZpbmQoeCA9PiB4Lm1lbWJlciA9PT0gZXZlbnQuZHJhZ0NoaXAuaWQgfHwgeC5kaXNwbGF5TmFtZSA9PT0gZXZlbnQuZHJhZ0NoaXAuaWQpO1xuICAgICAgICBpZiAodHlwZU1pc21hdGNoKSB7XG4gICAgICAgICAgICAvLyBjYW5ub3QgZHJhZyBiZXR3ZWVuIGRpbWVuc2lvbnMgYW5kIHZhbHVlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgYXJlIGluIHRoZSBsZWZ0IGhhbGYgb2YgdGhlIGNoaXAsIGRyb3Agb24gdGhlIGxlZnRcbiAgICAgICAgLy8gZWxzZSBkcm9wIG9uIHRoZSByaWdodCBvZiB0aGUgY2hpcFxuICAgICAgICBjb25zdCBjbGllbnRSZWN0ID0gZXZlbnQub3duZXIubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgcG9zID0gY2xpZW50UmVjdC53aWR0aCAvIDI7XG5cbiAgICAgICAgdGhpcy5fZHJvcFBvcyA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQub2Zmc2V0WCA+IHBvcyA/IERyb3BQb3NpdGlvbi5BZnRlckRyb3BUYXJnZXQgOiBEcm9wUG9zaXRpb24uQmVmb3JlRHJvcFRhcmdldDtcbiAgICAgICAgaWYgKHRoaXMuX2Ryb3BQb3MgPT09IERyb3BQb3NpdGlvbi5BZnRlckRyb3BUYXJnZXQpIHtcbiAgICAgICAgICAgIGV2ZW50Lm93bmVyLm5hdGl2ZUVsZW1lbnQucHJldmlvdXNFbGVtZW50U2libGluZy5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICBldmVudC5vd25lci5uYXRpdmVFbGVtZW50Lm5leHRFbGVtZW50U2libGluZy5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBldmVudC5vd25lci5uYXRpdmVFbGVtZW50Lm5leHRFbGVtZW50U2libGluZy5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICBldmVudC5vd25lci5uYXRpdmVFbGVtZW50LnByZXZpb3VzRWxlbWVudFNpYmxpbmcuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBvbkRpbURyYWdMZWF2ZShldmVudCkge1xuICAgICAgICBldmVudC5vd25lci5uYXRpdmVFbGVtZW50LnByZXZpb3VzRWxlbWVudFNpYmxpbmcuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICBldmVudC5vd25lci5uYXRpdmVFbGVtZW50Lm5leHRFbGVtZW50U2libGluZy5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIHRoaXMuX2Ryb3BQb3MgPSBEcm9wUG9zaXRpb24uQWZ0ZXJEcm9wVGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgb25BcmVhRHJhZ0xlYXZlKGV2ZW50LCBhcmVhKSB7XG4gICAgICAgIGNvbnN0IGRhdGFDaGlwcyA9IGFyZWEuY2hpcHNMaXN0LnRvQXJyYXkoKS5maWx0ZXIoeCA9PiB0aGlzLm5vdGlmaWNhdGlvbkNoaXBzLnRvQXJyYXkoKS5pbmRleE9mKHgpID09PSAtMSk7XG4gICAgICAgIGRhdGFDaGlwcy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQubmF0aXZlRWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5uYXRpdmVFbGVtZW50LnByZXZpb3VzRWxlbWVudFNpYmxpbmcuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsZW1lbnQubmF0aXZlRWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1YmxpYyBvblZhbHVlRHJvcChldmVudCwgYXJlYSkge1xuICAgICAgICBpZiAoIShldmVudC5kcmFnQ2hpcCAmJiBldmVudC5kcmFnQ2hpcC5kYXRhPy5waXZvdEFyZWEpICYmICEoZXZlbnQuZHJhZ0RhdGE/LmNoaXAgJiYgISFldmVudC5kcmFnRGF0YS5jaGlwLmRhdGEucGl2b3RBcmVhKSkgcmV0dXJuO1xuICAgICAgICAvL3ZhbHVlcyBjYW4gb25seSBiZSByZW9yZGVyZWRcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy5ncmlkLnBpdm90Q29uZmlndXJhdGlvbi52YWx1ZXM7XG4gICAgICAgIGNvbnN0IGRyYWdJZCA9IGV2ZW50LmRyYWdDaGlwPy5pZCB8fCBldmVudC5kcmFnRGF0YT8uY2hpcC5pZDtcbiAgICAgICAgY29uc3QgY2hpcHNBcnJheSA9IGFyZWEuY2hpcHNMaXN0LnRvQXJyYXkoKTtcbiAgICAgICAgbGV0IGNoaXBJbmRleCA9IGNoaXBzQXJyYXkuaW5kZXhPZihldmVudC5vd25lcikgIT09IC0xID8gY2hpcHNBcnJheS5pbmRleE9mKGV2ZW50Lm93bmVyKSA6IGNoaXBzQXJyYXkubGVuZ3RoO1xuICAgICAgICBjaGlwSW5kZXggPSB0aGlzLl9kcm9wUG9zID09PSBEcm9wUG9zaXRpb24uQWZ0ZXJEcm9wVGFyZ2V0ID8gY2hpcEluZGV4ICsgMSA6IGNoaXBJbmRleDtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXMuZmluZCh4ID0+IHgubWVtYmVyID09PSBkcmFnSWQgfHwgeC5kaXNwbGF5TmFtZSA9PT0gZHJhZ0lkKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBkcmFnQ2hpcEluZGV4ID0gY2hpcHNBcnJheS5pbmRleE9mKGV2ZW50LmRyYWdDaGlwIHx8IGV2ZW50LmRyYWdEYXRhLmNoaXApO1xuICAgICAgICAgICAgdGhpcy5ncmlkLm1vdmVWYWx1ZSh2YWx1ZSwgZHJhZ0NoaXBJbmRleCA+PSBjaGlwSW5kZXggPyBjaGlwSW5kZXggOiBjaGlwSW5kZXggLSAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgb25EaW1Ecm9wKGV2ZW50LCBhcmVhLCBkaW1lbnNpb25UeXBlOiBQaXZvdERpbWVuc2lvblR5cGUpIHtcbiAgICAgICAgaWYgKCEoZXZlbnQuZHJhZ0NoaXAgJiYgZXZlbnQuZHJhZ0NoaXAuZGF0YT8ucGl2b3RBcmVhKSAmJiAhKGV2ZW50LmRyYWdEYXRhPy5jaGlwICYmICEhZXZlbnQuZHJhZ0RhdGEuY2hpcC5kYXRhLnBpdm90QXJlYSkpIHJldHVybjtcbiAgICAgICAgY29uc3QgZHJhZ0lkID0gZXZlbnQuZHJhZ0NoaXA/LmlkIHx8IGV2ZW50LmRyYWdEYXRhPy5jaGlwLmlkO1xuICAgICAgICBjb25zdCBjdXJyZW50RGltID0gdGhpcy5ncmlkLmdldERpbWVuc2lvbnNCeVR5cGUoZGltZW5zaW9uVHlwZSk7XG4gICAgICAgIGNvbnN0IGNoaXBzQXJyYXkgPSBhcmVhLmNoaXBzTGlzdC50b0FycmF5KCk7XG4gICAgICAgIGNvbnN0IGNoaXAgPSBjaGlwc0FycmF5LmZpbmQoeCA9PiB4LmlkID09PSBkcmFnSWQpO1xuICAgICAgICBjb25zdCBpc05ld0NoaXAgPSBjaGlwID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGlzUmVvcmRlciA9IGV2ZW50Lm93bmVyLmlkICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIC8vY29uc3QgY2hpcEluZGV4ID0gY2hpcHNBcnJheS5pbmRleE9mKGV2ZW50Lm93bmVyKSAhPT0gLTEgPyBjaGlwc0FycmF5LmluZGV4T2YoZXZlbnQub3duZXIpIDogY2hpcHNBcnJheS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGNoaXBJbmRleCA9IGN1cnJlbnREaW0uZmluZEluZGV4KHggPT4geC5tZW1iZXJOYW1lID09PSBldmVudC5vd25lci5pZCkgIT09IC0xID9cbiAgICAgICAgICAgIGN1cnJlbnREaW0uZmluZEluZGV4KHggPT4geC5tZW1iZXJOYW1lID09PSBldmVudC5vd25lci5pZCkgOiBjdXJyZW50RGltLmxlbmd0aDtcbiAgICAgICAgY29uc3QgdGFyZ2V0SW5kZXggPSB0aGlzLl9kcm9wUG9zID09PSBEcm9wUG9zaXRpb24uQWZ0ZXJEcm9wVGFyZ2V0ID8gY2hpcEluZGV4ICsgMSA6IGNoaXBJbmRleDtcbiAgICAgICAgaWYgKGlzTmV3Q2hpcCkge1xuICAgICAgICAgICAgLy8gY2hpcCBtb3ZlZCBmcm9tIGFuIGV4dGVybmFsIGNvbGxlY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IGRpbSA9IHRoaXMuZ3JpZC5hbGxEaW1lbnNpb25zLmZpbmQoeCA9PiB4ICYmIHgubWVtYmVyTmFtZSA9PT0gZHJhZ0lkKTtcbiAgICAgICAgICAgIGlmICghZGltKSB7XG4gICAgICAgICAgICAgICAgLy8geW91IGhhdmUgZHJhZ2dlZCBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSBkaW1lbnNpb25cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmdyaWQubW92ZURpbWVuc2lvbihkaW0sIGRpbWVuc2lvblR5cGUsIHRhcmdldEluZGV4KTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1Jlb3JkZXIpIHtcbiAgICAgICAgICAgIC8vIGNoaXAgZnJvbSBzYW1lIGNvbGxlY3Rpb24sIHJlb3JkZXJlZC5cbiAgICAgICAgICAgIGNvbnN0IG5ld0RpbSA9IGN1cnJlbnREaW0uZmluZCh4ID0+IHgubWVtYmVyTmFtZSA9PT0gZHJhZ0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGRyYWdDaGlwSW5kZXggPSBjdXJyZW50RGltLmZpbmRJbmRleCh4ID0+IHgubWVtYmVyTmFtZSA9PT0gZHJhZ0lkKTtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5tb3ZlRGltZW5zaW9uKG5ld0RpbSwgZGltZW5zaW9uVHlwZSwgZHJhZ0NoaXBJbmRleCA+IGNoaXBJbmRleCA/IHRhcmdldEluZGV4IDogdGFyZ2V0SW5kZXggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyaWQucGlwZVRyaWdnZXIrKztcbiAgICAgICAgdGhpcy5ncmlkLmRpbWVuc2lvbnNDaGFuZ2UuZW1pdCh7IGRpbWVuc2lvbnM6IGN1cnJlbnREaW0sIGRpbWVuc2lvbkNvbGxlY3Rpb25UeXBlOiBkaW1lbnNpb25UeXBlIH0pO1xuICAgICAgICAvLyBjbGVhbiBzdGF0ZXNcbiAgICAgICAgdGhpcy5vbkRpbURyYWdFbmQoKTtcbiAgICAgICAgdGhpcy5vbkFyZWFEcmFnTGVhdmUoZXZlbnQsIGFyZWEpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCB1cGRhdGVEcm9wRG93bih2YWx1ZTogSVBpdm90VmFsdWUsIGRyb3Bkb3duOiBJZ3hEcm9wRG93bkNvbXBvbmVudCwgY2hpcDogSWd4Q2hpcENvbXBvbmVudCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGRyb3Bkb3duLndpZHRoID0gY2hpcC5uYXRpdmVFbGVtZW50LmNsaWVudFdpZHRoICsgJ3B4JztcbiAgICAgICAgdGhpcy5hZ2dyZWdhdGVMaXN0ID0gUGl2b3RVdGlsLmdldEFnZ3JlZ2F0ZUxpc3QodmFsdWUsIHRoaXMuZ3JpZCk7XG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgZHJvcGRvd24ub3Blbih0aGlzLl9zdWJNZW51T3ZlcmxheVNldHRpbmdzKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0Um93RGltZW5zaW9uQ29sdW1uKGRpbTogSVBpdm90RGltZW5zaW9uKTogQ29sdW1uVHlwZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZGltZW5zaW9uRGF0YUNvbHVtbnMgPyB0aGlzLmdyaWQuZGltZW5zaW9uRGF0YUNvbHVtbnMuZmluZCgoY29sKSA9PiBjb2wuZmllbGQgPT09IGRpbS5tZW1iZXJOYW1lKSA6IG51bGw7XG4gICAgfVxufVxuIiwiPGRpdj5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWQtdGhlYWRfX3dyYXBwZXIgaWd4LWdyaWQtdGhlYWRfX3dyYXBwZXItLXBpdm90XCIgcm9sZT1cInJvd1wiIFtzdHlsZS53aWR0aC5weF09XCJ3aWR0aFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3RyXCIgcm9sZT1cInJvd1wiIFtzdHlsZS53aWR0aC5weF09XCJ3aWR0aFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz0naWd4LWdyaWRfX3RyLXBpdm90LS1maWx0ZXItY29udGFpbmVyJz5cbiAgICAgICAgICAgICAgICA8ZGl2ICNwaXZvdEZpbHRlckNvbnRhaW5lciAqbmdJZj1cImdyaWQucGl2b3RVSS5zaG93Q29uZmlndXJhdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImlneC1ncmlkX190ci1waXZvdCBpZ3gtZ3JpZF9fdHItcGl2b3QtLWZpbHRlclwiIFtzdHlsZS5taW4td2lkdGgucHhdPVwiZ3JpZC5waXZvdFJvd1dpZHRocyAtIDFcIlxuICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLm1heC13aWR0aC5weF09XCJncmlkLnBpdm90Um93V2lkdGhzIC0gMVwiIChpZ3hEcmFnTGVhdmUpPVwib25BcmVhRHJhZ0xlYXZlKCRldmVudCwgZmlsdGVyQXJlYSlcIlxuICAgICAgICAgICAgICAgICAgICAgaWd4RHJvcCAoZHJvcHBlZCk9XCJvbkRpbURyb3AoJGV2ZW50LCBmaWx0ZXJBcmVhLCAyKVwiIChwb2ludGVyZG93bik9XCIkZXZlbnQucHJldmVudERlZmF1bHQoKVwiPlxuICAgICAgICAgICAgICAgICAgICA8IS0tIEZpbHRlciBhcmVhIC0tPlxuICAgICAgICAgICAgICAgICAgICA8aWd4LWNoaXBzLWFyZWEgI2ZpbHRlckFyZWEgZHJvcHBhYmxlPSd0cnVlJz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPSdlbXB0eScgaWd4RHJvcCAoZHJvcHBlZCk9XCJvbkRpbURyb3AoJGV2ZW50LCBmaWx0ZXJBcmVhLCAyKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiZ3JpZC5maWx0ZXJEaW1lbnNpb25zLmxlbmd0aCA9PT0gMFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPSdpZ3gtZ3JpZF9fcGl2b3QtZW1wdHktY2hpcC1hcmVhJz57e2dyaWQucmVzb3VyY2VTdHJpbmdzLmlneF9ncmlkX3Bpdm90X2VtcHR5X2ZpbHRlcl9kcm9wX2FyZWF9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGZpbHRlciBvZiB0aGlzLmZpbHRlckFyZWFEaW1lbnNpb25zOyBsZXQgbGFzdCA9IGxhc3Q7XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImlneC1ncmlkX190ci1waXZvdC0tY2hpcF9kcm9wX2luZGljYXRvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3R5bGUuaGVpZ2h0LnB4XT0nZ2V0QXJlYUhlaWdodChmaWx0ZXJBcmVhKSc+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtY2hpcCBbaWRdPVwiZmlsdGVyLm1lbWJlck5hbWVcIiBbZHJhZ2dhYmxlXT1cInRydWVcIiBbZGF0YV09XCJ7IHBpdm90QXJlYTogJ2ZpbHRlcicgfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtyZW1vdmFibGVdPVwidHJ1ZVwiIChyZW1vdmUpPVwiZmlsdGVyUmVtb3ZlZCgkZXZlbnQpXCIgKGRyYWdPdmVyKT1cIm9uRGltRHJhZ092ZXIoJGV2ZW50LCAyKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkcmFnTGVhdmUpPVwib25EaW1EcmFnTGVhdmUoJGV2ZW50KVwiIChkcmFnRHJvcCk9XCJvbkRpbURyb3AoJGV2ZW50LCBmaWx0ZXJBcmVhLCAyKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtb3ZlU3RhcnQpPSdvbkRpbURyYWdTdGFydCgkZXZlbnQsIGZpbHRlckFyZWEpJyAobW92ZUVuZCk9J29uRGltRHJhZ0VuZCgpJz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1pY29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYW1pbHk9XCJkZWZhdWx0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJmaWx0ZXJfbGlzdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZ3hQcmVmaXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwb2ludGVyZG93bik9J29uRmlsdGVyaW5nSWNvblBvaW50ZXJEb3duKCRldmVudCknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPSdvbkZpbHRlcmluZ0ljb25DbGljaygkZXZlbnQsIGZpbHRlciknPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2lneC1pY29uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e2ZpbHRlci5kaXNwbGF5TmFtZSB8fCBmaWx0ZXIubWVtYmVyTmFtZX19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9pZ3gtY2hpcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPSdsYXN0Jz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImlneC1ncmlkX190ci1waXZvdC0tY2hpcF9kcm9wX2luZGljYXRvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmhlaWdodC5weF09J2dldEFyZWFIZWlnaHQoZmlsdGVyQXJlYSknPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1jaGlwIGlneERyb3AgKGRyYWdEcm9wKT1cIm9uRGltRHJvcCgkZXZlbnQsIGZpbHRlckFyZWEsIDIpXCIgI25vdGlmeUNoaXAgW2hpZGRlbl09J3RydWUnPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7Z3JpZC5yZXNvdXJjZVN0cmluZ3MuaWd4X2dyaWRfcGl2b3RfZmlsdGVyX2Ryb3BfY2hpcH19XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2lneC1jaGlwPlxuICAgICAgICAgICAgICAgICAgICA8L2lneC1jaGlwcy1hcmVhPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Bpdm90LWZpbHRlci10b2dnbGVcIiAqbmdJZj1cImlzRmlsdGVyc0J1dHRvbiAmJiBncmlkLmZpbHRlckRpbWVuc2lvbnMubGVuZ3RoICE9PSAwXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aWd4LWljb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYW1pbHk9XCJkZWZhdWx0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwiZmlsdGVyX2xpc3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICNmaWx0ZXJJY29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBvaW50ZXJkb3duKT0nb25GaWx0ZXJpbmdJY29uUG9pbnRlckRvd24oJGV2ZW50KSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPSdvbkZpbHRlcnNBcmVhRHJvcGRvd25DbGljaygkZXZlbnQpJz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvaWd4LWljb24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aWd4LWJhZGdlIHZhbHVlPVwie3t0aGlzLmZpbHRlckRyb3Bkb3duRGltZW5zaW9ucy5zaXplfX1cIj48L2lneC1iYWRnZT5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0naWd4LWdyaWRfX3RyLXBpdm90LS1kcm9wLXJvdy1hcmVhJz5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiAjcGl2b3RSb3dDb250YWluZXIgKm5nSWY9XCJncmlkLnBpdm90VUkuc2hvd0NvbmZpZ3VyYXRpb24gJiYgZ3JpZC5waXZvdFVJLnNob3dSb3dIZWFkZXJzXCIgW3N0eWxlLndpZHRoLnB4XT1cImdyaWQucGl2b3RSb3dXaWR0aHMgLSAxXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiaWd4LWdyaWRfX3RyLXBpdm90IGlneC1ncmlkX190ci1waXZvdC0tc21hbGwtcm93LWFyZWFcIiBpZ3hEcm9wXG4gICAgICAgICAgICAgICAgICAgICAgICAoaWd4RHJhZ0xlYXZlKT1cIm9uQXJlYURyYWdMZWF2ZSgkZXZlbnQsIHJvd0FyZWEpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIChkcm9wcGVkKT1cIm9uRGltRHJvcCgkZXZlbnQsIHJvd0FyZWEsIDApXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aWd4LWNoaXBzLWFyZWEgI3Jvd0FyZWEgZHJvcHBhYmxlPSd0cnVlJz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0nZW1wdHknIGlneERyb3AgKGRyb3BwZWQpPVwib25EaW1Ecm9wKCRldmVudCwgcm93QXJlYSwgMClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImdyaWQucm93RGltZW5zaW9ucy5sZW5ndGggPT09IDBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz0naWd4LWdyaWRfX3Bpdm90LWVtcHR5LWNoaXAtYXJlYSc+e3tncmlkLnJlc291cmNlU3RyaW5ncy5pZ3hfZ3JpZF9waXZvdF9lbXB0eV9yb3dfZHJvcF9hcmVhfX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgcm93IG9mIGdyaWQucm93RGltZW5zaW9uczsgbGV0IGxhc3QgPSBsYXN0O1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImlneC1ncmlkX190ci1waXZvdC0tY2hpcF9kcm9wX2luZGljYXRvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3R5bGUuaGVpZ2h0LnB4XT0nZ2V0QXJlYUhlaWdodChyb3dBcmVhKSc+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1jaGlwIFtkcmFnZ2FibGVdPVwidHJ1ZVwiIFtpZF09XCJyb3cubWVtYmVyTmFtZVwiIFtkYXRhXT1cInsgcGl2b3RBcmVhOiAncm93JyB9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3JlbW92YWJsZV09XCJ0cnVlXCIgKHJlbW92ZSk9XCJyb3dSZW1vdmVkKCRldmVudClcIiAoZHJhZ0xlYXZlKT1cIm9uRGltRHJhZ0xlYXZlKCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZHJhZ0Ryb3ApPVwib25EaW1Ecm9wKCRldmVudCwgcm93QXJlYSwgMClcIiAoZHJhZ092ZXIpPVwib25EaW1EcmFnT3ZlcigkZXZlbnQsIDApXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1vdmVTdGFydCk9J29uRGltRHJhZ1N0YXJ0KCRldmVudCwgcm93QXJlYSknIChtb3ZlRW5kKT0nb25EaW1EcmFnRW5kKCknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjbGljayk9XCJvbkNoaXBTb3J0KCRldmVudCwgcm93KVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtaWNvbiBpZ3hQcmVmaXggZmFtaWx5PVwiZGVmYXVsdFwiIG5hbWU9XCJ0YWJsZV9yb3dzXCI+PC9pZ3gtaWNvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWd4LWljb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFtaWx5PVwiZGVmYXVsdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJmaWx0ZXJfbGlzdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlneFByZWZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocG9pbnRlcmRvd24pPSdvbkZpbHRlcmluZ0ljb25Qb2ludGVyRG93bigkZXZlbnQpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPSdvbkZpbHRlcmluZ0ljb25DbGljaygkZXZlbnQsIHJvdyknPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvaWd4LWljb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3sgcm93LmRpc3BsYXlOYW1lIHx8IHJvdy5tZW1iZXJOYW1lfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWd4LWljb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFtaWx5PVwiZGVmYXVsdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuYW1lXT1cInJvdy5zb3J0RGlyZWN0aW9uIDwgMiA/ICdzb3J0X2FzYycgOiAnc29ydF9kZXNjJ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpuZ0lmPVwicm93LnNvcnREaXJlY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZ3hTdWZmaXg+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9pZ3gtaWNvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvaWd4LWNoaXA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9J2xhc3QnPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImlneC1ncmlkX190ci1waXZvdC0tY2hpcF9kcm9wX2luZGljYXRvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3R5bGUuaGVpZ2h0LnB4XT0nZ2V0QXJlYUhlaWdodChyb3dBcmVhKSc+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWd4LWNoaXAgaWd4RHJvcCAoZHJhZ0Ryb3ApPVwib25EaW1Ecm9wKCRldmVudCwgcm93QXJlYSwgMClcIiAjbm90aWZ5Q2hpcCBbaGlkZGVuXT0ndHJ1ZSc+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7Z3JpZC5yZXNvdXJjZVN0cmluZ3MuaWd4X2dyaWRfcGl2b3Rfcm93X2Ryb3BfY2hpcH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9pZ3gtY2hpcD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvaWd4LWNoaXBzLWFyZWE+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fdHItcGl2b3QtZ3JvdXBcIj5cbiAgICAgICAgICAgICAgICA8ZGl2ICNwaXZvdENvbHVtbkNvbnRhaW5lciAqbmdJZj1cImdyaWQucGl2b3RVSS5zaG93Q29uZmlndXJhdGlvblwiIGNsYXNzPVwiaWd4LWdyaWRfX3RyLXBpdm90XCJcbiAgICAgICAgICAgICAgICAgICAgIChkcm9wcGVkKT1cIm9uRGltRHJvcCgkZXZlbnQsIGNvbEFyZWEsIDEpXCIgaWd4RHJvcCAoaWd4RHJhZ0xlYXZlKT1cIm9uQXJlYURyYWdMZWF2ZSgkZXZlbnQsIGNvbEFyZWEpXCI+XG4gICAgICAgICAgICAgICAgICAgIDwhLS0gQ29sdW1ucyBhcmVhIC0tPlxuICAgICAgICAgICAgICAgICAgICA8aWd4LWNoaXBzLWFyZWEgI2NvbEFyZWEgZHJvcHBhYmxlPSd0cnVlJz5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9J2VtcHR5JyAoZHJvcHBlZCk9XCJvbkRpbURyb3AoJGV2ZW50LCBjb2xBcmVhLCAxKVwiIGlneERyb3BcbiAgICAgICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiZ3JpZC5jb2x1bW5EaW1lbnNpb25zLmxlbmd0aCA9PT0gMFwiIGNsYXNzPSdpZ3gtZ3JpZF9fcGl2b3QtZW1wdHktY2hpcC1hcmVhJz5cbiAgICAgICAgICAgICAgICAgICAgICAgIHt7Z3JpZC5yZXNvdXJjZVN0cmluZ3MuaWd4X2dyaWRfcGl2b3RfZW1wdHlfY29sdW1uX2Ryb3BfYXJlYX19PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgY29sIG9mIGdyaWQuY29sdW1uRGltZW5zaW9uczsgbGV0IGxhc3QgPSBsYXN0O1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpZ3gtZ3JpZF9fdHItcGl2b3QtLWNoaXBfZHJvcF9pbmRpY2F0b3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmhlaWdodC5weF09J2dldEFyZWFIZWlnaHQoY29sQXJlYSknPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWd4LWNoaXAgW2RyYWdnYWJsZV09XCJ0cnVlXCIgW2lkXT1cImNvbC5tZW1iZXJOYW1lXCIgW2RhdGFdPVwieyBwaXZvdEFyZWE6ICdjb2x1bW4nIH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcmVtb3ZhYmxlXT1cInRydWVcIiAocmVtb3ZlKT1cImNvbHVtblJlbW92ZWQoJGV2ZW50KVwiIChkcmFnT3Zlcik9XCJvbkRpbURyYWdPdmVyKCRldmVudCwgMSlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZHJhZ0xlYXZlKT1cIm9uRGltRHJhZ0xlYXZlKCRldmVudClcIiAoZHJhZ0Ryb3ApPVwib25EaW1Ecm9wKCRldmVudCwgY29sQXJlYSwgMSlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobW92ZVN0YXJ0KT0nb25EaW1EcmFnU3RhcnQoJGV2ZW50LCBjb2xBcmVhKScgKG1vdmVFbmQpPSdvbkRpbURyYWdFbmQoKSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cIm9uQ2hpcFNvcnQoJGV2ZW50LCBjb2wpXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtaWNvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFtaWx5PVwiZGVmYXVsdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwidmlld19jb2x1bW5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWd4UHJlZml4PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2lneC1pY29uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWd4LWljb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbWlseT1cImRlZmF1bHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cImZpbHRlcl9saXN0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlneFByZWZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBvaW50ZXJkb3duKT0nb25GaWx0ZXJpbmdJY29uUG9pbnRlckRvd24oJGV2ZW50KSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjbGljayk9J29uRmlsdGVyaW5nSWNvbkNsaWNrKCRldmVudCwgY29sKSc+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvaWd4LWljb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7Y29sLmRpc3BsYXlOYW1lIHx8IGNvbC5tZW1iZXJOYW1lfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1pY29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYW1pbHk9XCJkZWZhdWx0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuYW1lXT1cImNvbC5zb3J0RGlyZWN0aW9uIDwgMiA/ICdzb3J0X2FzYycgOiAnc29ydF9kZXNjJ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImNvbC5zb3J0RGlyZWN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlneFN1ZmZpeD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9pZ3gtaWNvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2lneC1jaGlwPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9J2xhc3QnPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWd4LWdyaWRfX3RyLXBpdm90LS1jaGlwX2Ryb3BfaW5kaWNhdG9yXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3R5bGUuaGVpZ2h0LnB4XT0nZ2V0QXJlYUhlaWdodChjb2xBcmVhKSc+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aWd4LWNoaXAgaWd4RHJvcCAoZHJhZ0Ryb3ApPVwib25EaW1Ecm9wKCRldmVudCwgY29sQXJlYSwgMSlcIiAjbm90aWZ5Q2hpcCBbaGlkZGVuXT0ndHJ1ZSc+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3tncmlkLnJlc291cmNlU3RyaW5ncy5pZ3hfZ3JpZF9waXZvdF9jb2x1bW5fZHJvcF9jaGlwfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvaWd4LWNoaXA+XG4gICAgICAgICAgICAgICAgICAgIDwvaWd4LWNoaXBzLWFyZWE+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICA8ZGl2ICNwaXZvdFZhbHVlQ29udGFpbmVyICpuZ0lmPVwiZ3JpZC5waXZvdFVJLnNob3dDb25maWd1cmF0aW9uXCIgY2xhc3M9XCJpZ3gtZ3JpZF9fdHItcGl2b3RcIlxuICAgICAgICAgICAgICAgICAgICAgKHBvaW50ZXJkb3duKT1cIiRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCIgKGRyb3BwZWQpPVwib25WYWx1ZURyb3AoJGV2ZW50LCB2YWx1ZUFyZWEpXCIgaWd4RHJvcFxuICAgICAgICAgICAgICAgICAgICAgKGlneERyYWdMZWF2ZSk9XCJvbkFyZWFEcmFnTGVhdmUoJGV2ZW50LCB2YWx1ZUFyZWEpXCI+XG4gICAgICAgICAgICAgICAgICAgIDwhLS0gVmFsdWUgYXJlYSAtLT5cbiAgICAgICAgICAgICAgICAgICAgPGlneC1jaGlwcy1hcmVhICN2YWx1ZUFyZWEgZHJvcHBhYmxlPSd0cnVlJz5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9J2VtcHR5JyAoZHJvcHBlZCk9XCJvblZhbHVlRHJvcCgkZXZlbnQsIHZhbHVlQXJlYSlcIiBpZ3hEcm9wICpuZ0lmPVwiZ3JpZC52YWx1ZXMubGVuZ3RoID09PSAwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPSdpZ3gtZ3JpZF9fcGl2b3QtZW1wdHktY2hpcC1hcmVhJz57e2dyaWQucmVzb3VyY2VTdHJpbmdzLmlneF9ncmlkX3Bpdm90X2VtcHR5X3ZhbHVlX2Ryb3BfYXJlYX19PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCB2YWx1ZSBvZiBncmlkLnZhbHVlczsgbGV0IGxhc3QgPSBsYXN0O1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpZ3gtZ3JpZF9fdHItcGl2b3QtLWNoaXBfZHJvcF9pbmRpY2F0b3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmhlaWdodC5weF09J2dldEFyZWFIZWlnaHQodmFsdWVBcmVhKSc+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtY2hpcCAjY3VyckNoaXAgW2RyYWdnYWJsZV09XCJ0cnVlXCIgW2lkXT1cInZhbHVlLmRpc3BsYXlOYW1lIHx8IHZhbHVlLm1lbWJlclwiIFtkYXRhXT1cInsgcGl2b3RBcmVhOiAndmFsdWUnIH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3JlbW92YWJsZV09XCJ0cnVlXCIgKHJlbW92ZSk9XCJ2YWx1ZVJlbW92ZWQoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkcmFnTGVhdmUpPVwib25EaW1EcmFnTGVhdmUoJGV2ZW50KVwiIChkcmFnT3Zlcik9XCJvbkRpbURyYWdPdmVyKCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZHJhZ0Ryb3ApPVwib25WYWx1ZURyb3AoJGV2ZW50LCB2YWx1ZUFyZWEpXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fdHItcGl2b3QtdG9nZ2xlLWljb25zXCIgaWd4UHJlZml4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT0nb25TdW1tYXJ5Q2xpY2soJGV2ZW50LCB2YWx1ZSwgZHJvcGRvd24sIGN1cnJDaGlwKSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocG9pbnRlcmRvd24pPSckZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCknIFtpZ3hEcm9wRG93bkl0ZW1OYXZpZ2F0aW9uXT1cImRyb3Bkb3duXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWd4LWljb24gZmFtaWx5PVwiZGVmYXVsdFwiIG5hbWU9XCJmdW5jdGlvbnNcIj48L2lneC1pY29uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1pY29uIGZhbWlseT1cImRlZmF1bHRcIiBuYW1lPVwiYXJyb3dfZHJvcF9kb3duXCI+PC9pZ3gtaWNvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJncmlkLnZhbHVlQ2hpcFRlbXBsYXRlID8gZ3JpZC52YWx1ZUNoaXBUZW1wbGF0ZSA6IHZhbHVlQ2hpcERlZmF1bHRUZW1wbGF0ZTsgY29udGV4dDogeyAkaW1wbGljaXQ6IHZhbHVlIH1cIj48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2lneC1jaGlwPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9J2xhc3QnPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWd4LWdyaWRfX3RyLXBpdm90LS1jaGlwX2Ryb3BfaW5kaWNhdG9yXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3R5bGUuaGVpZ2h0LnB4XT0nZ2V0QXJlYUhlaWdodCh2YWx1ZUFyZWEpJz48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtY2hpcCBpZ3hEcm9wIChkcmFnRHJvcCk9XCJvblZhbHVlRHJvcCgkZXZlbnQsIHZhbHVlQXJlYSlcIiAjbm90aWZ5VmFsdWVDaGlwIFtoaWRkZW5dPSd0cnVlJz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e2dyaWQucmVzb3VyY2VTdHJpbmdzLmlneF9ncmlkX3Bpdm90X3ZhbHVlX2Ryb3BfY2hpcH19XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2lneC1jaGlwPlxuICAgICAgICAgICAgICAgICAgICA8L2lneC1jaGlwcy1hcmVhPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgcm9sZT1cInJvd2dyb3VwXCIgY2xhc3M9XCJpZ3gtZ3JpZC10aGVhZF9fd3JhcHBlclwiIFtzdHlsZS53aWR0aC5weF09XCJ3aWR0aFwiXG4gICAgICAgICBbYXR0ci5hcmlhLWFjdGl2ZWRlc2NlbmRhbnRdPVwiYWN0aXZlRGVzY2VuZGFudFwiIFtjbGFzcy5pZ3gtZ3JpZF9fdHItLW1ybF09XCJoYXNNUkxcIj5cblxuICAgICAgICA8IS0tIENvbHVtbiBoZWFkZXJzIGFyZWEgLS0+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fdHJcIiByb2xlPVwicm93XCIgW3N0eWxlLndpZHRoLnB4XT1cIndpZHRoXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIWdyaWQucGl2b3RVSS5zaG93Um93SGVhZGVycyB8fCBncmlkLnJvd0RpbWVuc2lvbnMubGVuZ3RoID09PSAwXCI+XG4gICAgICAgICAgICAgICAgPGRpdiAjcGl2b3RDb250YWluZXIgY2xhc3M9XCJpZ3gtZ3JpZF9fdHItcGl2b3QgaWd4LWdyaWRfX3RyLXBpdm90LS1yb3ctYXJlYVwiXG4gICAgICAgICAgICAgICAgICAgIFtzdHlsZS53aWR0aC5weF09XCJncmlkLnBpdm90Um93V2lkdGhzIC0gMVwiIChpZ3hEcmFnTGVhdmUpPVwib25BcmVhRHJhZ0xlYXZlKCRldmVudCwgcm93QXJlYSlcIiBpZ3hEcm9wXG4gICAgICAgICAgICAgICAgICAgIChkcm9wcGVkKT1cIm9uRGltRHJvcCgkZXZlbnQsIHJvd0FyZWEsIDApXCIgKHBvaW50ZXJkb3duKT1cIiRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCI+XG4gICAgICAgICAgICAgICAgICAgIDwhLS0gUm93IGFyZWEgLS0+XG4gICAgICAgICAgICAgICAgICAgIDxpZ3gtY2hpcHMtYXJlYSAjcm93QXJlYSBkcm9wcGFibGU9J3RydWUnPlxuICAgICAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImdyaWQucGl2b3RVSS5zaG93Q29uZmlndXJhdGlvbiB8fCBncmlkLnJvd0RpbWVuc2lvbnMubGVuZ3RoID09PSAwXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9J2VtcHR5JyBpZ3hEcm9wIChkcm9wcGVkKT1cIm9uRGltRHJvcCgkZXZlbnQsIHJvd0FyZWEsIDApXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJncmlkLnJvd0RpbWVuc2lvbnMubGVuZ3RoID09PSAwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9J2lneC1ncmlkX19waXZvdC1lbXB0eS1jaGlwLWFyZWEnPnt7Z3JpZC5yZXNvdXJjZVN0cmluZ3MuaWd4X2dyaWRfcGl2b3RfZW1wdHlfcm93X2Ryb3BfYXJlYX19PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IHJvdyBvZiBncmlkLnJvd0RpbWVuc2lvbnM7IGxldCBsYXN0ID0gbGFzdDtcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpZ3gtZ3JpZF9fdHItcGl2b3QtLWNoaXBfZHJvcF9pbmRpY2F0b3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmhlaWdodC5weF09J2dldEFyZWFIZWlnaHQocm93QXJlYSknPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpZ3gtY2hpcCBbZHJhZ2dhYmxlXT1cInRydWVcIiBbaWRdPVwicm93Lm1lbWJlck5hbWVcIiBbZGF0YV09XCJ7IHBpdm90QXJlYTogJ3JvdycgfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtyZW1vdmFibGVdPVwidHJ1ZVwiIChyZW1vdmUpPVwicm93UmVtb3ZlZCgkZXZlbnQpXCIgKGRyYWdMZWF2ZSk9XCJvbkRpbURyYWdMZWF2ZSgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRyYWdEcm9wKT1cIm9uRGltRHJvcCgkZXZlbnQsIHJvd0FyZWEsIDApXCIgKGRyYWdPdmVyKT1cIm9uRGltRHJhZ092ZXIoJGV2ZW50LCAwKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtb3ZlU3RhcnQpPSdvbkRpbURyYWdTdGFydCgkZXZlbnQsIHJvd0FyZWEpJyAobW92ZUVuZCk9J29uRGltRHJhZ0VuZCgpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwib25DaGlwU29ydCgkZXZlbnQsIHJvdylcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWd4LWljb24gaWd4UHJlZml4IGZhbWlseT1cImRlZmF1bHRcIiBuYW1lPVwidGFibGVfcm93c1wiPjwvaWd4LWljb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1pY29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbWlseT1cImRlZmF1bHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwiZmlsdGVyX2xpc3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZ3hQcmVmaXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBvaW50ZXJkb3duKT0nb25GaWx0ZXJpbmdJY29uUG9pbnRlckRvd24oJGV2ZW50KSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT0nb25GaWx0ZXJpbmdJY29uQ2xpY2soJGV2ZW50LCByb3cpJz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2lneC1pY29uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7IHJvdy5kaXNwbGF5TmFtZSB8fCByb3cubWVtYmVyTmFtZX19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1pY29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbWlseT1cImRlZmF1bHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmFtZV09XCJyb3cuc29ydERpcmVjdGlvbiA8IDIgPyAnc29ydF9hc2MnIDogJ3NvcnRfZGVzYydcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqbmdJZj1cInJvdy5zb3J0RGlyZWN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWd4U3VmZml4PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvaWd4LWljb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2lneC1jaGlwPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPSdsYXN0Jz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpZ3gtZ3JpZF9fdHItcGl2b3QtLWNoaXBfZHJvcF9pbmRpY2F0b3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmhlaWdodC5weF09J2dldEFyZWFIZWlnaHQocm93QXJlYSknPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1jaGlwIGlneERyb3AgKGRyYWdEcm9wKT1cIm9uRGltRHJvcCgkZXZlbnQsIHJvd0FyZWEsIDApXCIgI25vdGlmeUNoaXAgW2hpZGRlbl09J3RydWUnPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e2dyaWQucmVzb3VyY2VTdHJpbmdzLmlneF9ncmlkX3Bpdm90X3Jvd19kcm9wX2NoaXB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvaWd4LWNoaXA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgPC9pZ3gtY2hpcHMtYXJlYT5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiZ3JpZC5waXZvdFVJLnNob3dSb3dIZWFkZXJzICYmIGdyaWQudmlzaWJsZVJvd0RpbWVuc2lvbnMubGVuZ3RoID4gMFwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fdHIgaWd4LWdyaWRfX3RyLWhlYWRlci1yb3dcIiByb2xlPVwicm93XCIgW3N0eWxlLndpZHRoLnB4XT1cImdyaWQucGl2b3RSb3dXaWR0aHMgLSAxXCI+XG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGRpbSBvZiBncmlkLnZpc2libGVSb3dEaW1lbnNpb25zOyBpbmRleCBhcyBjb2xJbmRleDtsYXN0IGFzIGlzTGFzdFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGlneC1waXZvdC1yb3ctaGVhZGVyLWdyb3VwICNyb3dEaW1lbnNpb25IZWFkZXJzICpuZ0lmPVwiZ2V0Um93RGltZW5zaW9uQ29sdW1uKGRpbSkgYXMgZGltQ29sXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJkaW1Db2wuaGVhZGVyR3JvdXBDbGFzc2VzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdTdHlsZV09XCJkaW1Db2wuaGVhZGVyR3JvdXBTdHlsZXMgfCBpZ3hIZWFkZXJHcm91cFN0eWxlOmRpbUNvbDpncmlkLnBpcGVUcmlnZ2VyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3R5bGUubWluLXdpZHRoXT1cImdyaWQucm93RGltZW5zaW9uV2lkdGhUb1BpeGVscyh0aGlzLmdyaWQudmlzaWJsZVJvd0RpbWVuc2lvbnNbY29sSW5kZXhdKSB8IGlneEhlYWRlckdyb3VwV2lkdGg6Z3JpZC5kZWZhdWx0SGVhZGVyR3JvdXBNaW5XaWR0aDpoYXNNUkxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5mbGV4LWJhc2lzXT1cImdyaWQucm93RGltZW5zaW9uV2lkdGhUb1BpeGVscyh0aGlzLmdyaWQudmlzaWJsZVJvd0RpbWVuc2lvbnNbY29sSW5kZXhdKSB8IGlneEhlYWRlckdyb3VwV2lkdGg6Z3JpZC5kZWZhdWx0SGVhZGVyR3JvdXBNaW5XaWR0aDpoYXNNUkxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjb2x1bW5dPVwiZGltQ29sXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcm9vdERpbWVuc2lvbl09XCJncmlkLnZpc2libGVSb3dEaW1lbnNpb25zW2NvbEluZGV4XVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2RpbVdpZHRoXT1cImdyaWQucm93RGltZW5zaW9uV2lkdGhUb1BpeGVscyh0aGlzLmdyaWQudmlzaWJsZVJvd0RpbWVuc2lvbnNbY29sSW5kZXhdKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3Jvd0luZGV4XT1cIi0xXCIgPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9pZ3gtcGl2b3Qtcm93LWhlYWRlci1ncm91cD5cbiAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgICAgICAgICAgPCEtLSBQaW5uZWQgY29sdW1ucyBjb2xsZWN0aW9uIGZyb20gdGhlIHN0YXJ0IC0tPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInBpbm5lZENvbHVtbkNvbGxlY3Rpb24ubGVuZ3RoICYmIGdyaWQuaXNQaW5uaW5nVG9TdGFydFwiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiBwaW5uZWRDb2x1bW5Db2xsZWN0aW9uIHwgaWd4VG9wTGV2ZWxcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlneC1ncmlkLWhlYWRlci1ncm91cCBbbmdDbGFzc109XCJjb2x1bW4uaGVhZGVyR3JvdXBDbGFzc2VzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdTdHlsZV09XCJjb2x1bW4uaGVhZGVyR3JvdXBTdHlsZXMgfCBpZ3hIZWFkZXJHcm91cFN0eWxlOmNvbHVtbjpncmlkLnBpcGVUcmlnZ2VyXCIgW2NvbHVtbl09XCJjb2x1bW5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZS5taW4td2lkdGhdPVwiY29sdW1uLnJlc29sdmVkV2lkdGggfCBpZ3hIZWFkZXJHcm91cFdpZHRoOmdyaWQuZGVmYXVsdEhlYWRlckdyb3VwTWluV2lkdGg6aGFzTVJMXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3R5bGUuZmxleC1iYXNpc109XCJjb2x1bW4ucmVzb2x2ZWRXaWR0aCB8IGlneEhlYWRlckdyb3VwV2lkdGg6Z3JpZC5kZWZhdWx0SGVhZGVyR3JvdXBNaW5XaWR0aDpoYXNNUkxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwb2ludGVyZG93bik9XCJncmlkLm5hdmlnYXRpb24uZm9jdXNPdXRSb3dIZWFkZXIoJGV2ZW50KVwiPlxuICAgICAgICAgICAgICAgICAgICA8L2lneC1ncmlkLWhlYWRlci1ncm91cD5cbiAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlneC1ncmlkLXRoZWFkLS12aXJ0dWFsaXphdGlvbldyYXBwZXJcIiAgW3N0eWxlLm1heC1oZWlnaHQucHhdPSdtYXhDb250YWluZXJIZWlnaHQnIChjbGljayk9XCJncmlkLm5hdmlnYXRpb24uZm9jdXNPdXRSb3dIZWFkZXIoJGV2ZW50KVwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZC10aGVhZF9fZ3JvdXAgaWd4LWdyaWQtdGhlYWQtLXZpcnR1YWxpemF0aW9uQ29udGFpbmVyXCIgW3N0eWxlLmhlaWdodC5weF09J3RvdGFsRGVwdGggPiAxID8gZ3JpZC5yb3dIZWlnaHQgOiB1bmRlZmluZWQnICpuZ0Zvcj0nbGV0IGRpbUxldmVsQ29sdW1ucyBvZiBjb2x1bW5EaW1lbnNpb25zQnlMZXZlbDsgbGV0IGkgPSBpbmRleCcgW3N0eWxlLndpZHRoLnB4XT0nZ3JpZC51bnBpbm5lZFdpZHRoJz5cbiAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIGlneEdyaWRGb3IgI2hlYWRlclZpcnR1YWxDb250YWluZXIgbGV0LWNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2lneEdyaWRGb3JPZl09XCJkaW1MZXZlbENvbHVtbnNcIiBbaWd4R3JpZEZvck9mVW5pcXVlU2l6ZUNhY2hlXSA9ICd0cnVlJyBbaWd4Rm9yU2Nyb2xsQ29udGFpbmVyXT1cImdyaWQucGFyZW50VmlydERpclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaWd4Rm9yQ29udGFpbmVyU2l6ZV09XCJncmlkLnVucGlubmVkV2lkdGhcIiBbaWd4Rm9yVHJhY2tCeV09XCJncmlkLnRyYWNrQ29sdW1uQ2hhbmdlc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaWd4Rm9yU2l6ZVByb3BOYW1lXT1cIidjYWxjUGl4ZWxXaWR0aCdcIiBbaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb25dPVwiJ2hvcml6b250YWwnXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aWd4LWdyaWQtaGVhZGVyLWdyb3VwIFtuZ0NsYXNzXT1cImNvbHVtbi5oZWFkZXJHcm91cENsYXNzZXNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3R5bGUuaGVpZ2h0LnB4XT0ndG90YWxEZXB0aCA+IDEgPyBjYWxjSGVpZ2h0KGNvbHVtbiwgaSkgOiB1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1N0eWxlXT1cImNvbHVtbi5oZWFkZXJHcm91cFN0eWxlcyB8aWd4SGVhZGVyR3JvdXBTdHlsZTpjb2x1bW46Z3JpZC5waXBlVHJpZ2dlclwiIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLm1pbi13aWR0aF09XCJjb2x1bW4ucmVzb2x2ZWRXaWR0aCB8IGlneEhlYWRlckdyb3VwV2lkdGg6Z3JpZC5kZWZhdWx0SGVhZGVyR3JvdXBNaW5XaWR0aDpoYXNNUkxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3R5bGUuZmxleC1iYXNpc109XCJjb2x1bW4ucmVzb2x2ZWRXaWR0aCB8IGlneEhlYWRlckdyb3VwV2lkdGg6Z3JpZC5kZWZhdWx0SGVhZGVyR3JvdXBNaW5XaWR0aDpoYXNNUkxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY2xhc3MuaWd4LWdyaWRfX3RyLXBpdm90LS1jb2x1bW5EaW1lbnNpb25MZWFmXSA9ICdpc0R1cGxpY2F0ZU9mRXhpc3RpbmdQYXJlbnQoY29sdW1uLCBpKSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NsYXNzLmlneC1ncmlkX190ci1waXZvdC0tY29sdW1uTXVsdGlSb3dTcGFuXSA9ICdpc011bHRpUm93KGNvbHVtbiwgaSknXG4gICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2lneC1ncmlkLWhlYWRlci1ncm91cD5cbiAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8IS0tIFBpbm5lZCBjb2x1bW5zIGNvbGxlY3Rpb24gYXQgdGhlIGVuZCAtLT5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJwaW5uZWRDb2x1bW5Db2xsZWN0aW9uLmxlbmd0aCAmJiAhZ3JpZC5pc1Bpbm5pbmdUb1N0YXJ0XCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIHBpbm5lZENvbHVtbkNvbGxlY3Rpb24gfCBpZ3hUb3BMZXZlbFwiPlxuICAgICAgICAgICAgICAgICAgICA8aWd4LWdyaWQtaGVhZGVyLWdyb3VwIFtuZ0NsYXNzXT1cImNvbHVtbi5oZWFkZXJHcm91cENsYXNzZXNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1N0eWxlXT1cImNvbHVtbi5oZWFkZXJHcm91cFN0eWxlcyB8aWd4SGVhZGVyR3JvdXBTdHlsZTpjb2x1bW46Z3JpZC5waXBlVHJpZ2dlclwiIFtjb2x1bW5dPVwiY29sdW1uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3R5bGUubWluLXdpZHRoXT1cImNvbHVtbi5yZXNvbHZlZFdpZHRoIHwgaWd4SGVhZGVyR3JvdXBXaWR0aDpncmlkLmRlZmF1bHRIZWFkZXJHcm91cE1pbldpZHRoOmhhc01STFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlLmZsZXgtYmFzaXNdPVwiY29sdW1uLnJlc29sdmVkV2lkdGggfCBpZ3hIZWFkZXJHcm91cFdpZHRoOmdyaWQuZGVmYXVsdEhlYWRlckdyb3VwTWluV2lkdGg6aGFzTVJMXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3R5bGUubGVmdF09XCJjb2x1bW4ucmlnaHRQaW5uZWRPZmZzZXRcIiAocG9pbnRlcmRvd24pPVwiZ3JpZC5uYXZpZ2F0aW9uLmZvY3VzT3V0Um93SGVhZGVyKCRldmVudClcIj5cbiAgICAgICAgICAgICAgICAgICAgPC9pZ3gtZ3JpZC1oZWFkZXItZ3JvdXA+XG4gICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L2Rpdj5cbjwhLS0gSGVhZGVyIHRodW1iIGFyZWEgLS0+XG48ZGl2IGNsYXNzPVwiaWd4LWdyaWQtdGhlYWRfX3RodW1iXCIgW2hpZGRlbl09XCIhZ3JpZC5oYXNWZXJ0aWNhbFNjcm9sbCgpXCIgW3N0eWxlLndpZHRoLnB4XT1cImdyaWQuc2Nyb2xsU2l6ZVwiPlxuPC9kaXY+XG5cbjxpZ3gtZHJvcC1kb3duICNkcm9wZG93biAoc2VsZWN0aW9uQ2hhbmdpbmcpPSdvbkFnZ3JlZ2F0aW9uQ2hhbmdlKCRldmVudCknPlxuICAgIDxpZ3gtZHJvcC1kb3duLWl0ZW0gKm5nRm9yPVwibGV0IGl0ZW0gb2YgYWdncmVnYXRlTGlzdFwiIFtzZWxlY3RlZF09J2lzU2VsZWN0ZWQoaXRlbSknIFt2YWx1ZV09J2l0ZW0nPlxuICAgICAgICB7eyBpdGVtLmxhYmVsIH19XG4gICAgPC9pZ3gtZHJvcC1kb3duLWl0ZW0+XG48L2lneC1kcm9wLWRvd24+XG5cbjxkaXYgW2hpZGRlbl09J3RydWUnPlxuICAgIDxpZ3gtZ3JpZC1leGNlbC1zdHlsZS1maWx0ZXJpbmcgW21heEhlaWdodF09J2dyaWQuZXhjZWxTdHlsZUZpbHRlck1heEhlaWdodCcgW21pbkhlaWdodF09J2dyaWQuZXhjZWxTdHlsZUZpbHRlck1pbkhlaWdodCcgI2VzZj5cbiAgICAgICAgPGRpdiBpZ3hFeGNlbFN0eWxlQ29sdW1uT3BlcmF0aW9ucz5cbiAgICAgICAgICAgIDxpZ3gtY2hpcHMtYXJlYSAjZHJvcGRvd25DaGlwcz5cbiAgICAgICAgICAgICAgICA8aWd4LWNoaXAgKm5nRm9yPVwibGV0IGZpbHRlciBvZiB0aGlzLmZpbHRlckRyb3Bkb3duRGltZW5zaW9uc1wiIFtpZF09XCJmaWx0ZXIubWVtYmVyTmFtZVwiXG4gICAgICAgICAgICAgICAgW3JlbW92YWJsZV09XCJ0cnVlXCIgKHJlbW92ZSk9XCJmaWx0ZXJSZW1vdmVkKCRldmVudClcIlxuICAgICAgICAgICAgICAgIChjaGlwQ2xpY2spPSdvbkZpbHRlcnNTZWxlY3Rpb25DaGFuZ2VkKCRldmVudCknIFtzZWxlY3RhYmxlXT0ndHJ1ZScgW3NlbGVjdGVkXT0nZmlsdGVyID09PSB0aGlzLmZpbHRlckRyb3Bkb3duRGltZW5zaW9ucy52YWx1ZXMoKS5uZXh0KCkudmFsdWUnPlxuICAgICAgICAgICAgICAgIHt7ZmlsdGVyLmRpc3BsYXlOYW1lIHx8IGZpbHRlci5tZW1iZXJOYW1lfX1cbiAgICAgICAgICAgIDwvaWd4LWNoaXA+XG4gICAgICAgIDwvaWd4LWNoaXBzLWFyZWE+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8aWd4LWV4Y2VsLXN0eWxlLWZpbHRlci1vcGVyYXRpb25zPlxuICAgICAgICAgICAgPGlneC1leGNlbC1zdHlsZS1zZWFyY2g+PC9pZ3gtZXhjZWwtc3R5bGUtc2VhcmNoPlxuICAgICAgICA8L2lneC1leGNlbC1zdHlsZS1maWx0ZXItb3BlcmF0aW9ucz5cbiAgICA8L2lneC1ncmlkLWV4Y2VsLXN0eWxlLWZpbHRlcmluZz5cbjwvZGl2PlxuXG48ZGl2IHN0eWxlPVwidmlzaWJpbGl0eTogaGlkZGVuOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogLTEwMDAwcHhcIj5cbiAgICA8aWd4LWNoaXBzLWFyZWEgI2ZpbHRlckFyZWFIaWRkZW4gZHJvcHBhYmxlPSd0cnVlJz5cbiAgICAgICAgPGlneC1jaGlwXG4gICAgICAgICAgICAqbmdGb3I9XCJsZXQgZmlsdGVyIG9mIGdyaWQuZmlsdGVyRGltZW5zaW9uc1wiXG4gICAgICAgICAgICBbaWRdPVwiZmlsdGVyLm1lbWJlck5hbWVcIlxuICAgICAgICAgICAgW2RyYWdnYWJsZV09XCJ0cnVlXCJcbiAgICAgICAgICAgIFtyZW1vdmFibGVdPVwidHJ1ZVwiXG4gICAgICAgICAgICAocmVtb3ZlKT1cImZpbHRlclJlbW92ZWQoJGV2ZW50KVwiPlxuICAgICAgICAgICAgPGlneC1pY29uIGZhbWlseT1cImRlZmF1bHRcIiBuYW1lPVwiZmlsdGVyX2xpc3RcIiBpZ3hQcmVmaXg+PC9pZ3gtaWNvbj5cbiAgICAgICAgICAgIHt7ZmlsdGVyLmRpc3BsYXlOYW1lIHx8IGZpbHRlci5tZW1iZXJOYW1lfX1cbiAgICAgICAgPC9pZ3gtY2hpcD5cbiAgICA8L2lneC1jaGlwcy1hcmVhPlxuPC9kaXY+XG5cbjxuZy10ZW1wbGF0ZSAjdmFsdWVDaGlwRGVmYXVsdFRlbXBsYXRlIGxldC12YWx1ZT5cbiAgICB7e3ZhbHVlLmFnZ3JlZ2F0ZS5rZXl9fSh7e3ZhbHVlLmRpc3BsYXlOYW1lIHx8IHZhbHVlLm1lbWJlcn19KVxuPC9uZy10ZW1wbGF0ZT5cbiJdfQ==