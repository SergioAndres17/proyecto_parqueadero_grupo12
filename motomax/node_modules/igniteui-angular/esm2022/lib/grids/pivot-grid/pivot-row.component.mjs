import { ChangeDetectionStrategy, Component, forwardRef, HostBinding, Inject, Input } from '@angular/core';
import { IGX_GRID_BASE } from '../common/grid.interface';
import { IgxRowDirective } from '../row.directive';
import { PivotUtil } from './pivot-util';
import { IgxPivotGridCellStyleClassesPipe } from './pivot-grid.pipes';
import { IgxGridNotGroupedPipe, IgxGridCellStylesPipe, IgxGridDataMapperPipe, IgxGridTransactionStatePipe } from '../common/pipes';
import { IgxCheckboxComponent } from '../../checkbox/checkbox.component';
import { NgClass, NgStyle } from '@angular/common';
import { IgxGridCellComponent } from '../cell.component';
import { IgxGridForOfDirective } from '../../directives/for-of/for_of.directive';
import * as i0 from "@angular/core";
import * as i1 from "../selection/selection.service";
export class IgxPivotRowComponent extends IgxRowDirective {
    /**
     * @hidden
     */
    get selected() {
        let isSelected = false;
        for (const rowDim of this.data.dimensions) {
            const key = PivotUtil.getRecordKey(this.data, rowDim);
            if (this.selectionService.isPivotRowSelected(key)) {
                isSelected = true;
            }
        }
        return isSelected;
    }
    constructor(grid, selectionService, element, cdr, viewRef) {
        super(grid, selectionService, element, cdr);
        this.grid = grid;
        this.viewRef = viewRef;
        /**
         * @hidden
         * @internal
         */
        this.disabled = false;
    }
    /**
     * @hidden
     * @internal
     */
    get viewIndex() {
        return this.index;
    }
    /**
     * @hidden
     * @internal
     */
    get addRowUI() {
        return false;
    }
    /**
     * @hidden
     * @internal
     */
    get inEditMode() {
        return false;
    }
    /**
     * @hidden
     * @internal
     */
    set pinned(_value) {
    }
    get pinned() {
        return false;
    }
    /**
     * @hidden
     * @internal
     */
    delete() {
    }
    /**
     * @hidden
     * @internal
     */
    beginAddRow() {
    }
    /**
     * @hidden
     * @internal
     */
    update(_value) {
    }
    /**
     * @hidden
     * @internal
     */
    pin() {
        return false;
    }
    /**
    * @hidden
    * @internal
    */
    unpin() {
        return false;
    }
    /**
    *  The pivot record data passed to the row component.
    *
    * ```typescript
    * // get the pivot row data for the first selected row
    * let selectedRowData = this.grid.selectedRows[0].data;
    * ```
    */
    get data() {
        return this._data;
    }
    set data(v) {
        this._data = v;
    }
    /**
     * @hidden
     * @internal
     */
    get pivotAggregationData() {
        const aggregations = this.data.aggregationValues;
        const obj = {};
        aggregations.forEach((value, key) => {
            obj[key] = value;
        });
        return obj;
    }
    getCellClass(col) {
        const values = this.grid.values;
        if (values.length === 1) {
            return values[0].styles;
        }
        const colName = col.field.split(this.grid.pivotKeys.columnDimensionSeparator);
        const measureName = colName[colName.length - 1];
        return values.find(v => v.member === measureName)?.styles;
    }
    isCellActive(visibleColumnIndex) {
        const nav = this.grid.navigation;
        const node = nav.activeNode;
        return node && Object.keys(node).length !== 0 ?
            !nav.isRowHeaderActive &&
                !nav.isRowDimensionHeaderActive &&
                super.isCellActive(visibleColumnIndex) :
            false;
    }
    getColumnData(col) {
        const path = col.field.split(this.grid.pivotKeys.columnDimensionSeparator);
        const keyValueMap = new Map();
        const colDimensions = PivotUtil.flatten(this.grid.columnDimensions);
        for (const dim of colDimensions) {
            keyValueMap.set(dim.memberName, path.shift());
        }
        let pivotValue;
        if (this.grid.hasMultipleValues) {
            pivotValue = this.grid.values.find(x => x.member === path.shift());
        }
        else {
            pivotValue = this.grid.values ? this.grid.values[0] : undefined;
        }
        return {
            field: col.field,
            dimensions: this.grid.columnDimensions,
            dimensionValues: keyValueMap,
            value: pivotValue
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotRowComponent, deps: [{ token: IGX_GRID_BASE }, { token: i1.IgxGridSelectionService }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.4", type: IgxPivotRowComponent, isStandalone: true, selector: "igx-pivot-row", inputs: { selected: "selected", data: "data" }, host: { properties: { "attr.aria-selected": "this.selected" } }, providers: [{ provide: IgxRowDirective, useExisting: forwardRef(() => IgxPivotRowComponent) }], usesInheritance: true, ngImport: i0, template: "<ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\"\n    [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForSizePropName]='\"calcPixelWidth\"'\n    [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth'\n    [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n    <igx-grid-cell #cell class=\"igx-grid__td igx-grid__td--fw\"\n        [class.igx-grid__td--edited]=\"key | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.gridAPI.crudService.cell:grid.gridAPI.crudService.row\"\n\n        [class.igx-grid__td--number]=\"col.dataType === 'number' || col.dataType === 'percent' || col.dataType === 'currency'\"\n        [class.igx-grid__td--bool]=\"col.dataType === 'boolean'\"\n        [ngClass]=\"this.getCellClass(col) | igxPivotCellStyleClasses:data[col.field]:data:getColumnData(col):viewIndex:grid.pipeTrigger\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:pivotAggregationData[col.field]:pivotAggregationData:col.field:viewIndex:grid.pipeTrigger\"\n        [editMode]=\"col.editable && this.grid.crudService.targetInEdit(index, col.index)\" [column]=\"col\"\n        [formatter]=\"col.formatter\" [intRow]=\"this\" [active]=\"isCellActive(col.visibleIndex)\"\n        [rowData]=\"data\" [columnData]='getColumnData(col)'\n        [style.min-width]=\"col.resolvedWidth\" [style.max-width]=\"col.resolvedWidth\"\n        [style.flex-basis]=\"col.resolvedWidth\" [width]=\"col.getCellWidth()\" [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"pivotAggregationData[col.field] | dataMapper:col.field:grid.pipeTrigger:pivotAggregationData[col.field]:col.hasNestedPath\"\n        [cellTemplate]=\"col.bodyTemplate\" [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [cellSelectionMode]=\"grid.cellSelection\" [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n        (pointerdown)=\"grid.navigation.focusOutRowHeader($event)\">\n    </igx-grid-cell>\n</ng-template>\n\n<ng-template #rowSelectorBaseTemplate>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox [tabindex]=\"-1\" [readonly]=\"true\" [checked]=\"selected\" [disableRipple]=\"true\" [disabled]=\"deleted\"\n            [disableTransitions]=\"grid.disableTransitions\" [aria-label]=\"rowCheckboxAriaLabel\">\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n", dependencies: [{ kind: "directive", type: IgxGridForOfDirective, selector: "[igxGridFor][igxGridForOf]", inputs: ["igxGridForOf", "igxGridForOfUniqueSizeCache", "igxGridForOfVariableSizes"], outputs: ["dataChanging"] }, { kind: "component", type: IgxGridCellComponent, selector: "igx-grid-cell", inputs: ["column", "intRow", "row", "rowData", "columnData", "cellTemplate", "cellValidationErrorTemplate", "pinnedIndicator", "value", "formatter", "visibleColumnIndex", "cellSelectionMode", "lastSearchInfo", "lastPinned", "firstPinned", "editMode", "width", "active", "displayPinnedChip"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: IgxCheckboxComponent, selector: "igx-checkbox", inputs: ["id", "labelId", "value", "name", "tabindex", "labelPosition", "disableRipple", "required", "aria-labelledby", "aria-label", "indeterminate", "checked", "disabled", "invalid", "readonly", "disableTransitions"], outputs: ["change"] }, { kind: "pipe", type: IgxGridNotGroupedPipe, name: "igxNotGrouped" }, { kind: "pipe", type: IgxGridCellStylesPipe, name: "igxCellStyles" }, { kind: "pipe", type: IgxGridDataMapperPipe, name: "dataMapper" }, { kind: "pipe", type: IgxGridTransactionStatePipe, name: "transactionState" }, { kind: "pipe", type: IgxPivotGridCellStyleClassesPipe, name: "igxPivotCellStyleClasses" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotRowComponent, decorators: [{
            type: Component,
            args: [{ changeDetection: ChangeDetectionStrategy.OnPush, selector: 'igx-pivot-row', providers: [{ provide: IgxRowDirective, useExisting: forwardRef(() => IgxPivotRowComponent) }], standalone: true, imports: [IgxGridForOfDirective, IgxGridCellComponent, NgClass, NgStyle, IgxCheckboxComponent, IgxGridNotGroupedPipe, IgxGridCellStylesPipe, IgxGridDataMapperPipe, IgxGridTransactionStatePipe, IgxPivotGridCellStyleClassesPipe], template: "<ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\"\n    [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForSizePropName]='\"calcPixelWidth\"'\n    [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth'\n    [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n    <igx-grid-cell #cell class=\"igx-grid__td igx-grid__td--fw\"\n        [class.igx-grid__td--edited]=\"key | transactionState:col.field:grid.rowEditable:grid.transactions:grid.pipeTrigger:grid.gridAPI.crudService.cell:grid.gridAPI.crudService.row\"\n\n        [class.igx-grid__td--number]=\"col.dataType === 'number' || col.dataType === 'percent' || col.dataType === 'currency'\"\n        [class.igx-grid__td--bool]=\"col.dataType === 'boolean'\"\n        [ngClass]=\"this.getCellClass(col) | igxPivotCellStyleClasses:data[col.field]:data:getColumnData(col):viewIndex:grid.pipeTrigger\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:pivotAggregationData[col.field]:pivotAggregationData:col.field:viewIndex:grid.pipeTrigger\"\n        [editMode]=\"col.editable && this.grid.crudService.targetInEdit(index, col.index)\" [column]=\"col\"\n        [formatter]=\"col.formatter\" [intRow]=\"this\" [active]=\"isCellActive(col.visibleIndex)\"\n        [rowData]=\"data\" [columnData]='getColumnData(col)'\n        [style.min-width]=\"col.resolvedWidth\" [style.max-width]=\"col.resolvedWidth\"\n        [style.flex-basis]=\"col.resolvedWidth\" [width]=\"col.getCellWidth()\" [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"pivotAggregationData[col.field] | dataMapper:col.field:grid.pipeTrigger:pivotAggregationData[col.field]:col.hasNestedPath\"\n        [cellTemplate]=\"col.bodyTemplate\" [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [cellSelectionMode]=\"grid.cellSelection\" [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n        (pointerdown)=\"grid.navigation.focusOutRowHeader($event)\">\n    </igx-grid-cell>\n</ng-template>\n\n<ng-template #rowSelectorBaseTemplate>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox [tabindex]=\"-1\" [readonly]=\"true\" [checked]=\"selected\" [disableRipple]=\"true\" [disabled]=\"deleted\"\n            [disableTransitions]=\"grid.disableTransitions\" [aria-label]=\"rowCheckboxAriaLabel\">\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n" }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }, { type: i1.IgxGridSelectionService }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i0.ViewContainerRef }], propDecorators: { selected: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['attr.aria-selected']
            }], data: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGl2b3Qtcm93LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy9waXZvdC1ncmlkL3Bpdm90LXJvdy5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZ3JpZHMvcGl2b3QtZ3JpZC9waXZvdC1yb3cuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNILHVCQUF1QixFQUV2QixTQUFTLEVBRVQsVUFBVSxFQUNWLFdBQVcsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUM3QixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsYUFBYSxFQUFpQixNQUFNLDBCQUEwQixDQUFDO0FBQ3hFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUduRCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQ3pDLE9BQU8sRUFBRSxnQ0FBZ0MsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ3RFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxxQkFBcUIsRUFBRSxxQkFBcUIsRUFBRSwyQkFBMkIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ25JLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBQ3pFLE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDbkQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDekQsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sMENBQTBDLENBQUM7OztBQVVqRixNQUFNLE9BQU8sb0JBQXFCLFNBQVEsZUFBZTtJQUNyRDs7T0FFRztJQUNILElBRW9CLFFBQVE7UUFDeEIsSUFBSSxVQUFV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LEVBQUUsMkJBQTJCLEVBQUUsZ0NBQWdDLENBQUM7OzBCQW9CN04sTUFBTTsyQkFBQyxhQUFhO3VLQVpMLFFBQVE7c0JBRjNCLEtBQUs7O3NCQUNMLFdBQVc7dUJBQUMsb0JBQW9CO2dCQTZHYixJQUFJO3NCQUR2QixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBDb21wb25lbnQsXG4gICAgRWxlbWVudFJlZixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEhvc3RCaW5kaW5nLCBJbmplY3QsIElucHV0LCBWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWd4Q29sdW1uQ29tcG9uZW50IH0gZnJvbSAnLi4vY29sdW1ucy9jb2x1bW4uY29tcG9uZW50JztcbmltcG9ydCB7IElHWF9HUklEX0JBU0UsIFBpdm90R3JpZFR5cGUgfSBmcm9tICcuLi9jb21tb24vZ3JpZC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSWd4Um93RGlyZWN0aXZlIH0gZnJvbSAnLi4vcm93LmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJZ3hHcmlkU2VsZWN0aW9uU2VydmljZSB9IGZyb20gJy4uL3NlbGVjdGlvbi9zZWxlY3Rpb24uc2VydmljZSc7XG5pbXBvcnQgeyBJUGl2b3RHcmlkQ29sdW1uLCBJUGl2b3RHcmlkUmVjb3JkIH0gZnJvbSAnLi9waXZvdC1ncmlkLmludGVyZmFjZSc7XG5pbXBvcnQgeyBQaXZvdFV0aWwgfSBmcm9tICcuL3Bpdm90LXV0aWwnO1xuaW1wb3J0IHsgSWd4UGl2b3RHcmlkQ2VsbFN0eWxlQ2xhc3Nlc1BpcGUgfSBmcm9tICcuL3Bpdm90LWdyaWQucGlwZXMnO1xuaW1wb3J0IHsgSWd4R3JpZE5vdEdyb3VwZWRQaXBlLCBJZ3hHcmlkQ2VsbFN0eWxlc1BpcGUsIElneEdyaWREYXRhTWFwcGVyUGlwZSwgSWd4R3JpZFRyYW5zYWN0aW9uU3RhdGVQaXBlIH0gZnJvbSAnLi4vY29tbW9uL3BpcGVzJztcbmltcG9ydCB7IElneENoZWNrYm94Q29tcG9uZW50IH0gZnJvbSAnLi4vLi4vY2hlY2tib3gvY2hlY2tib3guY29tcG9uZW50JztcbmltcG9ydCB7IE5nQ2xhc3MsIE5nU3R5bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgSWd4R3JpZENlbGxDb21wb25lbnQgfSBmcm9tICcuLi9jZWxsLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hHcmlkRm9yT2ZEaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2Zvci1vZi9mb3Jfb2YuZGlyZWN0aXZlJztcblxuQENvbXBvbmVudCh7XG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgc2VsZWN0b3I6ICdpZ3gtcGl2b3Qtcm93JyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vcGl2b3Qtcm93LmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IElneFJvd0RpcmVjdGl2ZSwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gSWd4UGl2b3RSb3dDb21wb25lbnQpIH1dLFxuICAgIHN0YW5kYWxvbmU6IHRydWUsXG4gICAgaW1wb3J0czogW0lneEdyaWRGb3JPZkRpcmVjdGl2ZSwgSWd4R3JpZENlbGxDb21wb25lbnQsIE5nQ2xhc3MsIE5nU3R5bGUsIElneENoZWNrYm94Q29tcG9uZW50LCBJZ3hHcmlkTm90R3JvdXBlZFBpcGUsIElneEdyaWRDZWxsU3R5bGVzUGlwZSwgSWd4R3JpZERhdGFNYXBwZXJQaXBlLCBJZ3hHcmlkVHJhbnNhY3Rpb25TdGF0ZVBpcGUsIElneFBpdm90R3JpZENlbGxTdHlsZUNsYXNzZXNQaXBlXVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hQaXZvdFJvd0NvbXBvbmVudCBleHRlbmRzIElneFJvd0RpcmVjdGl2ZSB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtc2VsZWN0ZWQnKVxuICAgIHB1YmxpYyBvdmVycmlkZSBnZXQgc2VsZWN0ZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIGxldCBpc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3Qgcm93RGltIG9mIHRoaXMuZGF0YS5kaW1lbnNpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBQaXZvdFV0aWwuZ2V0UmVjb3JkS2V5KHRoaXMuZGF0YSwgcm93RGltKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvblNlcnZpY2UuaXNQaXZvdFJvd1NlbGVjdGVkKGtleSkpIHtcbiAgICAgICAgICAgICAgICBpc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTZWxlY3RlZDtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgQEluamVjdChJR1hfR1JJRF9CQVNFKSBwdWJsaWMgb3ZlcnJpZGUgZ3JpZDogUGl2b3RHcmlkVHlwZSxcbiAgICAgICAgc2VsZWN0aW9uU2VydmljZTogSWd4R3JpZFNlbGVjdGlvblNlcnZpY2UsXG4gICAgICAgIGVsZW1lbnQ6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+LFxuICAgICAgICBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBwcm90ZWN0ZWQgdmlld1JlZjogVmlld0NvbnRhaW5lclJlZlxuICAgICkge1xuICAgICAgICBzdXBlcihncmlkLCBzZWxlY3Rpb25TZXJ2aWNlLCBlbGVtZW50LCBjZHIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgZ2V0IHZpZXdJbmRleCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG92ZXJyaWRlIGRpc2FibGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG92ZXJyaWRlIGdldCBhZGRSb3dVSSgpOiBhbnkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBnZXQgaW5FZGl0TW9kZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgc2V0IHBpbm5lZChfdmFsdWU6IGJvb2xlYW4pIHtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgZ2V0IHBpbm5lZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgZGVsZXRlKCkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgYmVnaW5BZGRSb3coKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSB1cGRhdGUoX3ZhbHVlOiBhbnkpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG92ZXJyaWRlIHBpbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgdW5waW4oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqICBUaGUgcGl2b3QgcmVjb3JkIGRhdGEgcGFzc2VkIHRvIHRoZSByb3cgY29tcG9uZW50LlxuICAgICpcbiAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAqIC8vIGdldCB0aGUgcGl2b3Qgcm93IGRhdGEgZm9yIHRoZSBmaXJzdCBzZWxlY3RlZCByb3dcbiAgICAqIGxldCBzZWxlY3RlZFJvd0RhdGEgPSB0aGlzLmdyaWQuc2VsZWN0ZWRSb3dzWzBdLmRhdGE7XG4gICAgKiBgYGBcbiAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIG92ZXJyaWRlIGdldCBkYXRhKCk6IElQaXZvdEdyaWRSZWNvcmQge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgc2V0IGRhdGEodjogSVBpdm90R3JpZFJlY29yZCkge1xuICAgICAgICB0aGlzLl9kYXRhID0gdjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldCBwaXZvdEFnZ3JlZ2F0aW9uRGF0YSgpIHtcbiAgICAgICAgY29uc3QgYWdncmVnYXRpb25zID0gdGhpcy5kYXRhLmFnZ3JlZ2F0aW9uVmFsdWVzO1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgYWdncmVnYXRpb25zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRDZWxsQ2xhc3MoY29sOiBJZ3hDb2x1bW5Db21wb25lbnQpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy5ncmlkLnZhbHVlcztcbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbMF0uc3R5bGVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbE5hbWUgPSBjb2wuZmllbGQuc3BsaXQodGhpcy5ncmlkLnBpdm90S2V5cy5jb2x1bW5EaW1lbnNpb25TZXBhcmF0b3IpO1xuICAgICAgICBjb25zdCBtZWFzdXJlTmFtZSA9IGNvbE5hbWVbY29sTmFtZS5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5maW5kKHYgPT4gdi5tZW1iZXIgPT09IG1lYXN1cmVOYW1lKT8uc3R5bGVzO1xuICAgIH1cblxuICAgIHB1YmxpYyBvdmVycmlkZSBpc0NlbGxBY3RpdmUodmlzaWJsZUNvbHVtbkluZGV4KSB7XG4gICAgICAgIGNvbnN0IG5hdiA9IHRoaXMuZ3JpZC5uYXZpZ2F0aW9uXG4gICAgICAgIGNvbnN0IG5vZGUgPSBuYXYuYWN0aXZlTm9kZTtcbiAgICAgICAgcmV0dXJuIG5vZGUgJiYgT2JqZWN0LmtleXMobm9kZSkubGVuZ3RoICE9PSAwID9cbiAgICAgICAgICAgICFuYXYuaXNSb3dIZWFkZXJBY3RpdmUgJiZcbiAgICAgICAgICAgICFuYXYuaXNSb3dEaW1lbnNpb25IZWFkZXJBY3RpdmUgJiZcbiAgICAgICAgICAgIHN1cGVyLmlzQ2VsbEFjdGl2ZSh2aXNpYmxlQ29sdW1uSW5kZXgpIDpcbiAgICAgICAgICAgIGZhbHNlO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRDb2x1bW5EYXRhKGNvbDogSWd4Q29sdW1uQ29tcG9uZW50KSA6IElQaXZvdEdyaWRDb2x1bW4ge1xuICAgICAgICBjb25zdCBwYXRoID0gY29sLmZpZWxkLnNwbGl0KHRoaXMuZ3JpZC5waXZvdEtleXMuY29sdW1uRGltZW5zaW9uU2VwYXJhdG9yKTtcbiAgICAgICAgY29uc3Qga2V5VmFsdWVNYXAgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpO1xuICAgICAgICBjb25zdCBjb2xEaW1lbnNpb25zID0gUGl2b3RVdGlsLmZsYXR0ZW4odGhpcy5ncmlkLmNvbHVtbkRpbWVuc2lvbnMpO1xuICAgICAgICBmb3IgKGNvbnN0IGRpbSBvZiBjb2xEaW1lbnNpb25zKSB7XG4gICAgICAgICAgICBrZXlWYWx1ZU1hcC5zZXQoZGltLm1lbWJlck5hbWUsIHBhdGguc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBpdm90VmFsdWU7XG4gICAgICAgIGlmICh0aGlzLmdyaWQuaGFzTXVsdGlwbGVWYWx1ZXMpIHtcbiAgICAgICAgICAgIHBpdm90VmFsdWUgPSB0aGlzLmdyaWQudmFsdWVzLmZpbmQoeCA9PiB4Lm1lbWJlciA9PT0gcGF0aC5zaGlmdCgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBpdm90VmFsdWUgPSB0aGlzLmdyaWQudmFsdWVzID8gdGhpcy5ncmlkLnZhbHVlc1swXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmllbGQ6IGNvbC5maWVsZCxcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6IHRoaXMuZ3JpZC5jb2x1bW5EaW1lbnNpb25zLFxuICAgICAgICAgICAgZGltZW5zaW9uVmFsdWVzOiBrZXlWYWx1ZU1hcCxcbiAgICAgICAgICAgIHZhbHVlOiBwaXZvdFZhbHVlXG4gICAgICAgIH07XG4gICAgfVxufVxuIiwiPG5nLXRlbXBsYXRlIGlneEdyaWRGb3IgbGV0LWNvbCBbaWd4R3JpZEZvck9mXT1cInVucGlubmVkQ29sdW1ucyB8IGlneE5vdEdyb3VwZWRcIlxuICAgIFtpZ3hGb3JTY3JvbGxDb250YWluZXJdPVwiZ3JpZC5wYXJlbnRWaXJ0RGlyXCIgbGV0LWNvbEluZGV4PVwiaW5kZXhcIiBbaWd4Rm9yU2l6ZVByb3BOYW1lXT0nXCJjYWxjUGl4ZWxXaWR0aFwiJ1xuICAgIFtpZ3hGb3JTY3JvbGxPcmllbnRhdGlvbl09XCInaG9yaXpvbnRhbCdcIiBbaWd4Rm9yQ29udGFpbmVyU2l6ZV09J2dyaWQudW5waW5uZWRXaWR0aCdcbiAgICBbaWd4Rm9yVHJhY2tCeV09J2dyaWQudHJhY2tDb2x1bW5DaGFuZ2VzJyAjaWd4RGlyUmVmPlxuICAgIDxpZ3gtZ3JpZC1jZWxsICNjZWxsIGNsYXNzPVwiaWd4LWdyaWRfX3RkIGlneC1ncmlkX190ZC0tZndcIlxuICAgICAgICBbY2xhc3MuaWd4LWdyaWRfX3RkLS1lZGl0ZWRdPVwia2V5IHwgdHJhbnNhY3Rpb25TdGF0ZTpjb2wuZmllbGQ6Z3JpZC5yb3dFZGl0YWJsZTpncmlkLnRyYW5zYWN0aW9uczpncmlkLnBpcGVUcmlnZ2VyOmdyaWQuZ3JpZEFQSS5jcnVkU2VydmljZS5jZWxsOmdyaWQuZ3JpZEFQSS5jcnVkU2VydmljZS5yb3dcIlxuXG4gICAgICAgIFtjbGFzcy5pZ3gtZ3JpZF9fdGQtLW51bWJlcl09XCJjb2wuZGF0YVR5cGUgPT09ICdudW1iZXInIHx8IGNvbC5kYXRhVHlwZSA9PT0gJ3BlcmNlbnQnIHx8IGNvbC5kYXRhVHlwZSA9PT0gJ2N1cnJlbmN5J1wiXG4gICAgICAgIFtjbGFzcy5pZ3gtZ3JpZF9fdGQtLWJvb2xdPVwiY29sLmRhdGFUeXBlID09PSAnYm9vbGVhbidcIlxuICAgICAgICBbbmdDbGFzc109XCJ0aGlzLmdldENlbGxDbGFzcyhjb2wpIHwgaWd4UGl2b3RDZWxsU3R5bGVDbGFzc2VzOmRhdGFbY29sLmZpZWxkXTpkYXRhOmdldENvbHVtbkRhdGEoY29sKTp2aWV3SW5kZXg6Z3JpZC5waXBlVHJpZ2dlclwiXG4gICAgICAgIFtuZ1N0eWxlXT1cImNvbC5jZWxsU3R5bGVzIHwgaWd4Q2VsbFN0eWxlczpwaXZvdEFnZ3JlZ2F0aW9uRGF0YVtjb2wuZmllbGRdOnBpdm90QWdncmVnYXRpb25EYXRhOmNvbC5maWVsZDp2aWV3SW5kZXg6Z3JpZC5waXBlVHJpZ2dlclwiXG4gICAgICAgIFtlZGl0TW9kZV09XCJjb2wuZWRpdGFibGUgJiYgdGhpcy5ncmlkLmNydWRTZXJ2aWNlLnRhcmdldEluRWRpdChpbmRleCwgY29sLmluZGV4KVwiIFtjb2x1bW5dPVwiY29sXCJcbiAgICAgICAgW2Zvcm1hdHRlcl09XCJjb2wuZm9ybWF0dGVyXCIgW2ludFJvd109XCJ0aGlzXCIgW2FjdGl2ZV09XCJpc0NlbGxBY3RpdmUoY29sLnZpc2libGVJbmRleClcIlxuICAgICAgICBbcm93RGF0YV09XCJkYXRhXCIgW2NvbHVtbkRhdGFdPSdnZXRDb2x1bW5EYXRhKGNvbCknXG4gICAgICAgIFtzdHlsZS5taW4td2lkdGhdPVwiY29sLnJlc29sdmVkV2lkdGhcIiBbc3R5bGUubWF4LXdpZHRoXT1cImNvbC5yZXNvbHZlZFdpZHRoXCJcbiAgICAgICAgW3N0eWxlLmZsZXgtYmFzaXNdPVwiY29sLnJlc29sdmVkV2lkdGhcIiBbd2lkdGhdPVwiY29sLmdldENlbGxXaWR0aCgpXCIgW3Zpc2libGVDb2x1bW5JbmRleF09XCJjb2wudmlzaWJsZUluZGV4XCJcbiAgICAgICAgW3ZhbHVlXT1cInBpdm90QWdncmVnYXRpb25EYXRhW2NvbC5maWVsZF0gfCBkYXRhTWFwcGVyOmNvbC5maWVsZDpncmlkLnBpcGVUcmlnZ2VyOnBpdm90QWdncmVnYXRpb25EYXRhW2NvbC5maWVsZF06Y29sLmhhc05lc3RlZFBhdGhcIlxuICAgICAgICBbY2VsbFRlbXBsYXRlXT1cImNvbC5ib2R5VGVtcGxhdGVcIiBbbGFzdFNlYXJjaEluZm9dPVwiZ3JpZC5sYXN0U2VhcmNoSW5mb1wiXG4gICAgICAgIFtjZWxsU2VsZWN0aW9uTW9kZV09XCJncmlkLmNlbGxTZWxlY3Rpb25cIiBbZGlzcGxheVBpbm5lZENoaXBdPVwic2hvdWxkRGlzcGxheVBpbm5lZENoaXAoY29sLnZpc2libGVJbmRleClcIlxuICAgICAgICAocG9pbnRlcmRvd24pPVwiZ3JpZC5uYXZpZ2F0aW9uLmZvY3VzT3V0Um93SGVhZGVyKCRldmVudClcIj5cbiAgICA8L2lneC1ncmlkLWNlbGw+XG48L25nLXRlbXBsYXRlPlxuXG48bmctdGVtcGxhdGUgI3Jvd1NlbGVjdG9yQmFzZVRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fY2J4LXBhZGRpbmdcIj5cbiAgICAgICAgPGlneC1jaGVja2JveCBbdGFiaW5kZXhdPVwiLTFcIiBbcmVhZG9ubHldPVwidHJ1ZVwiIFtjaGVja2VkXT1cInNlbGVjdGVkXCIgW2Rpc2FibGVSaXBwbGVdPVwidHJ1ZVwiIFtkaXNhYmxlZF09XCJkZWxldGVkXCJcbiAgICAgICAgICAgIFtkaXNhYmxlVHJhbnNpdGlvbnNdPVwiZ3JpZC5kaXNhYmxlVHJhbnNpdGlvbnNcIiBbYXJpYS1sYWJlbF09XCJyb3dDaGVja2JveEFyaWFMYWJlbFwiPlxuICAgICAgICA8L2lneC1jaGVja2JveD5cbiAgICA8L2Rpdj5cbjwvbmctdGVtcGxhdGU+XG5cbiJdfQ==