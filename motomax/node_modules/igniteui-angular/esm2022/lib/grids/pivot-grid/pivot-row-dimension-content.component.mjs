import { ChangeDetectionStrategy, Component, createComponent, HostBinding, Inject, Input, TemplateRef, ViewChild, ViewChildren } from '@angular/core';
import { IgxColumnComponent } from '../columns/column.component';
import { IGX_GRID_BASE } from '../common/grid.interface';
import { IgxGridHeaderRowComponent } from '../headers/grid-header-row.component';
import { IgxPivotRowDimensionHeaderGroupComponent } from './pivot-row-dimension-header-group.component';
import { PivotUtil } from './pivot-util';
import { IgxHeaderGroupWidthPipe, IgxHeaderGroupStylePipe } from '../headers/pipes';
import { IgxIconComponent } from '../../icon/icon.component';
import { NgClass, NgStyle } from '@angular/common';
import * as i0 from "@angular/core";
/**
 *
 * For all intents & purposes treat this component as what a <thead> usually is in the default <table> element.
 *
 * This container holds the pivot grid header elements and their behavior/interactions.
 *
 * @hidden @internal
 */
export class IgxPivotRowDimensionContentComponent extends IgxGridHeaderRowComponent {
    get rowStart() {
        return this.layout ? `${this.layout.rowStart}` : "";
    }
    get rowsEnd() {
        return this.layout ? `${this.layout.rowEnd}` : "";
    }
    get colStart() {
        return this.layout ? `${this.layout.colStart}` : "";
    }
    get colEnd() {
        return this.layout ? `${this.layout.colEnd}` : "";
    }
    constructor(grid, ref, injector, envInjector, cdr, viewRef) {
        super(ref, cdr);
        this.grid = grid;
        this.injector = injector;
        this.envInjector = envInjector;
        this.viewRef = viewRef;
    }
    get rowDimensionColumn() {
        return this.rowDimensionData?.column;
    }
    /**
    * @hidden
    * @internal
    */
    ngOnChanges(changes) {
        if (changes.rowData) {
            // generate new rowDimension on row data change
            this.rowDimensionData = null;
            this.viewRef.clear();
            this.extractFromDimensions();
            this.viewRef.clear();
        }
        if (changes.width && this.rowDimensionData) {
            const data = this.rowDimensionData;
            data.column.width = this.grid.rowDimensionWidthToPixels(this.rootDimension) + 'px';
        }
    }
    /**
    * @hidden
    * @internal
    */
    toggleRowDimension(event) {
        this.grid.toggleRow(this.getRowDimensionKey());
        this.grid.navigation.onRowToggle(this.getExpandState(), this.dimension, this.rowData, this.layout);
        event?.stopPropagation();
    }
    /**
     * @hidden
     * @internal
     */
    getRowDimensionKey() {
        const dimData = this.rowDimensionData;
        const key = PivotUtil.getRecordKey(this.rowData, dimData.dimension);
        return key;
    }
    getExpandState() {
        return this.grid.gridAPI.get_row_expansion_state(this.getRowDimensionKey());
    }
    getLevel() {
        return this.grid.hasHorizontalLayout ? 0 : this.dimension.level;
    }
    getHeaderWidthFromDimension() {
        if (this.grid.hasHorizontalLayout) {
            return this.width === -1 ? 'fit-content' : this.width;
        }
        return this.grid.rowDimensionWidth(this.rootDimension);
    }
    extractFromDimensions() {
        if (this.dimension && this.rowData) {
            const col = this.extractFromDimension(this.dimension, this.rowData);
            const prevDims = [];
            this.rowDimensionData = {
                column: col,
                dimension: this.dimension,
                prevDimensions: prevDims
            };
        }
    }
    extractFromDimension(dim, rowData) {
        const field = dim.memberName;
        const header = rowData?.dimensionValues.get(field);
        const col = this._createColComponent(field, header, dim);
        return col;
    }
    _createColComponent(field, header, dim) {
        const ref = createComponent(IgxColumnComponent, { environmentInjector: this.envInjector, elementInjector: this.injector });
        ref.instance.field = field;
        ref.instance.header = header;
        ref.instance.width = this.grid.rowDimensionWidthToPixels(this.rootDimension) + 'px';
        ref.instance.resizable = this.grid.rowDimensionResizing;
        ref.instance._vIndex = this.grid.columns.length + this.rowIndex + this.rowIndex * this.grid.pivotConfiguration.rows.length;
        if (header && dim.childLevel && (!this.rowData.totalRecordDimensionName || this.rowData.totalRecordDimensionName !== dim.memberName)) {
            ref.instance.headerTemplate = this.headerTemplate;
        }
        else {
            ref.instance.headerTemplate = this.headerTemplateDefault;
        }
        return ref.instance;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotRowDimensionContentComponent, deps: [{ token: IGX_GRID_BASE }, { token: i0.ElementRef }, { token: i0.Injector }, { token: i0.EnvironmentInjector }, { token: i0.ChangeDetectorRef }, { token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.4", type: IgxPivotRowDimensionContentComponent, isStandalone: true, selector: "igx-pivot-row-dimension-content", inputs: { rowIndex: "rowIndex", colIndex: "colIndex", layout: "layout", dimension: "dimension", rootDimension: "rootDimension", rowData: "rowData" }, host: { properties: { "style.grid-row-start": "this.rowStart", "style.grid-row-end": "this.rowsEnd", "style.grid-column-start": "this.colStart", "style.grid-column-end": "this.colEnd" } }, viewQueries: [{ propertyName: "headerTemplate", first: true, predicate: ["headerTemplate"], descendants: true, read: TemplateRef, static: true }, { propertyName: "headerTemplateDefault", first: true, predicate: ["headerDefaultTemplate"], descendants: true, read: TemplateRef, static: true }, { propertyName: "headerGroups", predicate: IgxPivotRowDimensionHeaderGroupComponent, descendants: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: "<div role=\"rowgroup\" class=\"igx-grid-thead__wrapper\" [style.width.px]=\"width\"\n    [class.igx-grid__tr--mrl]=\"hasMRL\">\n    <div class=\"igx-grid__tr igx-grid__tr-header-row\" role=\"row\" [style.width.px]=\"width\">\n            <igx-pivot-row-dimension-header-group [ngClass]=\"rowDimensionColumn.headerGroupClasses\"\n                [ngStyle]=\"rowDimensionColumn.headerGroupStyles | igxHeaderGroupStyle:rowDimensionColumn:grid.pipeTrigger\" [column]=\"rowDimensionColumn\"\n                [style.min-width]=\"getHeaderWidthFromDimension() | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                [style.width]=\"getHeaderWidthFromDimension() | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                [style.flex-basis]=\"getHeaderWidthFromDimension() | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                [rowIndex]=\"rowIndex\"\n                [colIndex]=\"colIndex\"\n                [layout]=\"layout\"\n                [parent]='this'>\n            </igx-pivot-row-dimension-header-group>\n    </div>\n</div>\n\n<ng-template #headerTemplate let-column>\n    <div class='igx-grid__tr--header igx-grid__row-indentation--level-{{getLevel()}}'>\n        <igx-icon\n            family=\"default\"\n            [name]=\"getExpandState() ? 'tree_collapse' : 'tree_expand'\"\n            [attr.draggable]=\"false\"\n            (click)=\"toggleRowDimension($event)\"\n            >\n        </igx-icon>\n        {{column.header}}\n    </div>\n</ng-template>\n\n<ng-template #headerDefaultTemplate let-column>\n    <div class='igx-grid__tr--header igx-grid__row-indentation--level-{{getLevel()}}' style=\"--component-size: 3\">\n        <!--Using the igx-icon as a sizable spacer spacer here-->\n        <igx-icon style='flex-shrink: 0;' [attr.draggable]=\"false\"></igx-icon>\n        {{column.header}}\n    </div>\n</ng-template>\n", dependencies: [{ kind: "component", type: IgxPivotRowDimensionHeaderGroupComponent, selector: "igx-pivot-row-dimension-header-group", inputs: ["rowIndex", "colIndex", "layout", "parent"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: IgxIconComponent, selector: "igx-icon", inputs: ["family", "name", "active"] }, { kind: "pipe", type: IgxHeaderGroupWidthPipe, name: "igxHeaderGroupWidth" }, { kind: "pipe", type: IgxHeaderGroupStylePipe, name: "igxHeaderGroupStyle" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotRowDimensionContentComponent, decorators: [{
            type: Component,
            args: [{ changeDetection: ChangeDetectionStrategy.OnPush, selector: 'igx-pivot-row-dimension-content', standalone: true, imports: [IgxPivotRowDimensionHeaderGroupComponent, NgClass, NgStyle, IgxIconComponent, IgxHeaderGroupWidthPipe, IgxHeaderGroupStylePipe], template: "<div role=\"rowgroup\" class=\"igx-grid-thead__wrapper\" [style.width.px]=\"width\"\n    [class.igx-grid__tr--mrl]=\"hasMRL\">\n    <div class=\"igx-grid__tr igx-grid__tr-header-row\" role=\"row\" [style.width.px]=\"width\">\n            <igx-pivot-row-dimension-header-group [ngClass]=\"rowDimensionColumn.headerGroupClasses\"\n                [ngStyle]=\"rowDimensionColumn.headerGroupStyles | igxHeaderGroupStyle:rowDimensionColumn:grid.pipeTrigger\" [column]=\"rowDimensionColumn\"\n                [style.min-width]=\"getHeaderWidthFromDimension() | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                [style.width]=\"getHeaderWidthFromDimension() | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                [style.flex-basis]=\"getHeaderWidthFromDimension() | igxHeaderGroupWidth:grid.defaultHeaderGroupMinWidth:hasMRL\"\n                [rowIndex]=\"rowIndex\"\n                [colIndex]=\"colIndex\"\n                [layout]=\"layout\"\n                [parent]='this'>\n            </igx-pivot-row-dimension-header-group>\n    </div>\n</div>\n\n<ng-template #headerTemplate let-column>\n    <div class='igx-grid__tr--header igx-grid__row-indentation--level-{{getLevel()}}'>\n        <igx-icon\n            family=\"default\"\n            [name]=\"getExpandState() ? 'tree_collapse' : 'tree_expand'\"\n            [attr.draggable]=\"false\"\n            (click)=\"toggleRowDimension($event)\"\n            >\n        </igx-icon>\n        {{column.header}}\n    </div>\n</ng-template>\n\n<ng-template #headerDefaultTemplate let-column>\n    <div class='igx-grid__tr--header igx-grid__row-indentation--level-{{getLevel()}}' style=\"--component-size: 3\">\n        <!--Using the igx-icon as a sizable spacer spacer here-->\n        <igx-icon style='flex-shrink: 0;' [attr.draggable]=\"false\"></igx-icon>\n        {{column.header}}\n    </div>\n</ng-template>\n" }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }, { type: i0.ElementRef }, { type: i0.Injector }, { type: i0.EnvironmentInjector }, { type: i0.ChangeDetectorRef }, { type: i0.ViewContainerRef }], propDecorators: { rowStart: [{
                type: HostBinding,
                args: ['style.grid-row-start']
            }], rowsEnd: [{
                type: HostBinding,
                args: ['style.grid-row-end']
            }], colStart: [{
                type: HostBinding,
                args: ['style.grid-column-start']
            }], colEnd: [{
                type: HostBinding,
                args: ['style.grid-column-end']
            }], rowIndex: [{
                type: Input
            }], colIndex: [{
                type: Input
            }], layout: [{
                type: Input
            }], dimension: [{
                type: Input
            }], rootDimension: [{
                type: Input
            }], rowData: [{
                type: Input
            }], headerTemplate: [{
                type: ViewChild,
                args: ['headerTemplate', { read: TemplateRef, static: true }]
            }], headerTemplateDefault: [{
                type: ViewChild,
                args: ['headerDefaultTemplate', { read: TemplateRef, static: true }]
            }], headerGroups: [{
                type: ViewChildren,
                args: [IgxPivotRowDimensionHeaderGroupComponent]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGl2b3Qtcm93LWRpbWVuc2lvbi1jb250ZW50LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy9waXZvdC1ncmlkL3Bpdm90LXJvdy1kaW1lbnNpb24tY29udGVudC5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZ3JpZHMvcGl2b3QtZ3JpZC9waXZvdC1yb3ctZGltZW5zaW9uLWNvbnRlbnQuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNILHVCQUF1QixFQUV2QixTQUFTLEVBQ1QsZUFBZSxFQUdmLFdBQVcsRUFDWCxNQUFNLEVBRU4sS0FBSyxFQUlMLFdBQVcsRUFDWCxTQUFTLEVBQ1QsWUFBWSxFQUVmLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQ2pFLE9BQU8sRUFBRSxhQUFhLEVBQWlCLE1BQU0sMEJBQTBCLENBQUM7QUFDeEUsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0sc0NBQXNDLENBQUM7QUFFakYsT0FBTyxFQUFFLHdDQUF3QyxFQUFFLE1BQU0sOENBQThDLENBQUM7QUFDeEcsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUN6QyxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUNwRixPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUM3RCxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGlCQUFpQixDQUFDOztBQUduRDs7Ozs7OztHQU9HO0FBUUgsTUFBTSxPQUFPLG9DQUFxQyxTQUFRLHlCQUF5QjtJQUMvRSxJQUNX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SUFBSSxFQUFFO2dCQUloRSxZQUFZO3NCQURsQixZQUFZO3VCQUFDLHdDQUF3QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ29tcG9uZW50LFxuICAgIGNyZWF0ZUNvbXBvbmVudCxcbiAgICBFbGVtZW50UmVmLFxuICAgIEVudmlyb25tZW50SW5qZWN0b3IsXG4gICAgSG9zdEJpbmRpbmcsXG4gICAgSW5qZWN0LFxuICAgIEluamVjdG9yLFxuICAgIElucHV0LFxuICAgIE9uQ2hhbmdlcyxcbiAgICBRdWVyeUxpc3QsXG4gICAgU2ltcGxlQ2hhbmdlcyxcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBWaWV3Q2hpbGQsXG4gICAgVmlld0NoaWxkcmVuLFxuICAgIFZpZXdDb250YWluZXJSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJZ3hDb2x1bW5Db21wb25lbnQgfSBmcm9tICcuLi9jb2x1bW5zL2NvbHVtbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgSUdYX0dSSURfQkFTRSwgUGl2b3RHcmlkVHlwZSB9IGZyb20gJy4uL2NvbW1vbi9ncmlkLmludGVyZmFjZSc7XG5pbXBvcnQgeyBJZ3hHcmlkSGVhZGVyUm93Q29tcG9uZW50IH0gZnJvbSAnLi4vaGVhZGVycy9ncmlkLWhlYWRlci1yb3cuY29tcG9uZW50JztcbmltcG9ydCB7IElQaXZvdERpbWVuc2lvbiwgSVBpdm90RGltZW5zaW9uRGF0YSwgSVBpdm90R3JpZEdyb3VwUmVjb3JkIH0gZnJvbSAnLi9waXZvdC1ncmlkLmludGVyZmFjZSc7XG5pbXBvcnQgeyBJZ3hQaXZvdFJvd0RpbWVuc2lvbkhlYWRlckdyb3VwQ29tcG9uZW50IH0gZnJvbSAnLi9waXZvdC1yb3ctZGltZW5zaW9uLWhlYWRlci1ncm91cC5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGl2b3RVdGlsIH0gZnJvbSAnLi9waXZvdC11dGlsJztcbmltcG9ydCB7IElneEhlYWRlckdyb3VwV2lkdGhQaXBlLCBJZ3hIZWFkZXJHcm91cFN0eWxlUGlwZSB9IGZyb20gJy4uL2hlYWRlcnMvcGlwZXMnO1xuaW1wb3J0IHsgSWd4SWNvbkNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgTmdDbGFzcywgTmdTdHlsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBJTXVsdGlSb3dMYXlvdXROb2RlIH0gZnJvbSAnLi4vY29tbW9uL3R5cGVzJztcblxuLyoqXG4gKlxuICogRm9yIGFsbCBpbnRlbnRzICYgcHVycG9zZXMgdHJlYXQgdGhpcyBjb21wb25lbnQgYXMgd2hhdCBhIDx0aGVhZD4gdXN1YWxseSBpcyBpbiB0aGUgZGVmYXVsdCA8dGFibGU+IGVsZW1lbnQuXG4gKlxuICogVGhpcyBjb250YWluZXIgaG9sZHMgdGhlIHBpdm90IGdyaWQgaGVhZGVyIGVsZW1lbnRzIGFuZCB0aGVpciBiZWhhdmlvci9pbnRlcmFjdGlvbnMuXG4gKlxuICogQGhpZGRlbiBAaW50ZXJuYWxcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgc2VsZWN0b3I6ICdpZ3gtcGl2b3Qtcm93LWRpbWVuc2lvbi1jb250ZW50JyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vcGl2b3Qtcm93LWRpbWVuc2lvbi1jb250ZW50LmNvbXBvbmVudC5odG1sJyxcbiAgICBzdGFuZGFsb25lOiB0cnVlLFxuICAgIGltcG9ydHM6IFtJZ3hQaXZvdFJvd0RpbWVuc2lvbkhlYWRlckdyb3VwQ29tcG9uZW50LCBOZ0NsYXNzLCBOZ1N0eWxlLCBJZ3hJY29uQ29tcG9uZW50LCBJZ3hIZWFkZXJHcm91cFdpZHRoUGlwZSwgSWd4SGVhZGVyR3JvdXBTdHlsZVBpcGVdXG59KVxuZXhwb3J0IGNsYXNzIElneFBpdm90Um93RGltZW5zaW9uQ29udGVudENvbXBvbmVudCBleHRlbmRzIElneEdyaWRIZWFkZXJSb3dDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUuZ3JpZC1yb3ctc3RhcnQnKVxuICAgIHB1YmxpYyBnZXQgcm93U3RhcnQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0ID8gYCR7dGhpcy5sYXlvdXQucm93U3RhcnR9YCA6IFwiXCI7XG4gICAgfVxuXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5ncmlkLXJvdy1lbmQnKVxuICAgIHB1YmxpYyBnZXQgcm93c0VuZCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQgPyBgJHt0aGlzLmxheW91dC5yb3dFbmR9YCA6IFwiXCI7XG4gICAgfVxuXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5ncmlkLWNvbHVtbi1zdGFydCcpXG4gICAgcHVibGljIGdldCBjb2xTdGFydCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQgPyBgJHt0aGlzLmxheW91dC5jb2xTdGFydH1gIDogXCJcIjtcbiAgICB9XG5cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLmdyaWQtY29sdW1uLWVuZCcpXG4gICAgcHVibGljIGdldCBjb2xFbmQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0ID8gYCR7dGhpcy5sYXlvdXQuY29sRW5kfWAgOiBcIlwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyByb3dJbmRleDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGNvbEluZGV4OiBudW1iZXI7XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBsYXlvdXQ6IElNdWx0aVJvd0xheW91dE5vZGU7XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBkaW1lbnNpb246IElQaXZvdERpbWVuc2lvbjtcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHJvb3REaW1lbnNpb246IElQaXZvdERpbWVuc2lvbjtcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHJvd0RhdGE6IElQaXZvdEdyaWRHcm91cFJlY29yZDtcblxuICAgIC8qKlxuICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2hlYWRlclRlbXBsYXRlJywgeyByZWFkOiBUZW1wbGF0ZVJlZiwgc3RhdGljOiB0cnVlIH0pXG4gICAgcHVibGljIGhlYWRlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdoZWFkZXJEZWZhdWx0VGVtcGxhdGUnLCB7IHJlYWQ6IFRlbXBsYXRlUmVmLCBzdGF0aWM6IHRydWUgfSlcbiAgICBwdWJsaWMgaGVhZGVyVGVtcGxhdGVEZWZhdWx0OiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgQFZpZXdDaGlsZHJlbihJZ3hQaXZvdFJvd0RpbWVuc2lvbkhlYWRlckdyb3VwQ29tcG9uZW50KVxuICAgIHB1YmxpYyBoZWFkZXJHcm91cHM6IFF1ZXJ5TGlzdDxJZ3hQaXZvdFJvd0RpbWVuc2lvbkhlYWRlckdyb3VwQ29tcG9uZW50PlxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIEBJbmplY3QoSUdYX0dSSURfQkFTRSkgcHVibGljIG92ZXJyaWRlIGdyaWQ6IFBpdm90R3JpZFR5cGUsXG4gICAgICAgIHJlZjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sXG4gICAgICAgIHByb3RlY3RlZCBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgICAgIHByb3RlY3RlZCBlbnZJbmplY3RvcjogRW52aXJvbm1lbnRJbmplY3RvcixcbiAgICAgICAgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgcHJvdGVjdGVkIHZpZXdSZWY6IFZpZXdDb250YWluZXJSZWZcbiAgICApIHtcbiAgICAgICAgc3VwZXIocmVmLCBjZHIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIHJvd0RpbWVuc2lvbkRhdGE6IElQaXZvdERpbWVuc2lvbkRhdGE7XG5cbiAgICBwdWJsaWMgZ2V0IHJvd0RpbWVuc2lvbkNvbHVtbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93RGltZW5zaW9uRGF0YT8uY29sdW1uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5yb3dEYXRhKSB7XG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSBuZXcgcm93RGltZW5zaW9uIG9uIHJvdyBkYXRhIGNoYW5nZVxuICAgICAgICAgICAgdGhpcy5yb3dEaW1lbnNpb25EYXRhID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMudmlld1JlZi5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5leHRyYWN0RnJvbURpbWVuc2lvbnMoKTtcbiAgICAgICAgICAgIHRoaXMudmlld1JlZi5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLndpZHRoICYmIHRoaXMucm93RGltZW5zaW9uRGF0YSkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMucm93RGltZW5zaW9uRGF0YTtcbiAgICAgICAgICAgIGRhdGEuY29sdW1uLndpZHRoID0gdGhpcy5ncmlkLnJvd0RpbWVuc2lvbldpZHRoVG9QaXhlbHModGhpcy5yb290RGltZW5zaW9uKSArICdweCc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHVibGljIHRvZ2dsZVJvd0RpbWVuc2lvbihldmVudCkge1xuICAgICAgICB0aGlzLmdyaWQudG9nZ2xlUm93KHRoaXMuZ2V0Um93RGltZW5zaW9uS2V5KCkpO1xuICAgICAgICB0aGlzLmdyaWQubmF2aWdhdGlvbi5vblJvd1RvZ2dsZSh0aGlzLmdldEV4cGFuZFN0YXRlKCksIHRoaXMuZGltZW5zaW9uLCB0aGlzLnJvd0RhdGEsIHRoaXMubGF5b3V0KTtcbiAgICAgICAgZXZlbnQ/LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRSb3dEaW1lbnNpb25LZXkoKSB7XG4gICAgICAgIGNvbnN0IGRpbURhdGEgPSB0aGlzLnJvd0RpbWVuc2lvbkRhdGE7XG4gICAgICAgIGNvbnN0IGtleSA9IFBpdm90VXRpbC5nZXRSZWNvcmRLZXkodGhpcy5yb3dEYXRhLCBkaW1EYXRhLmRpbWVuc2lvbik7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldEV4cGFuZFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmdyaWRBUEkuZ2V0X3Jvd19leHBhbnNpb25fc3RhdGUodGhpcy5nZXRSb3dEaW1lbnNpb25LZXkoKSk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldExldmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmhhc0hvcml6b250YWxMYXlvdXQgPyAwIDogdGhpcy5kaW1lbnNpb24ubGV2ZWw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldEhlYWRlcldpZHRoRnJvbURpbWVuc2lvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZC5oYXNIb3Jpem9udGFsTGF5b3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aWR0aCA9PT0gLTEgPyAnZml0LWNvbnRlbnQnIDogdGhpcy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnJvd0RpbWVuc2lvbldpZHRoKHRoaXMucm9vdERpbWVuc2lvbik7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGV4dHJhY3RGcm9tRGltZW5zaW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMuZGltZW5zaW9uICYmIHRoaXMucm93RGF0YSkge1xuICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5leHRyYWN0RnJvbURpbWVuc2lvbih0aGlzLmRpbWVuc2lvbiwgdGhpcy5yb3dEYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZEaW1zID0gW107XG4gICAgICAgICAgICB0aGlzLnJvd0RpbWVuc2lvbkRhdGEgPSB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2wsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9uOiB0aGlzLmRpbWVuc2lvbixcbiAgICAgICAgICAgICAgICBwcmV2RGltZW5zaW9uczogcHJldkRpbXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZXh0cmFjdEZyb21EaW1lbnNpb24oZGltOiBJUGl2b3REaW1lbnNpb24sIHJvd0RhdGE6IElQaXZvdEdyaWRHcm91cFJlY29yZCkge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGRpbS5tZW1iZXJOYW1lO1xuICAgICAgICBjb25zdCBoZWFkZXIgPSByb3dEYXRhPy5kaW1lbnNpb25WYWx1ZXMuZ2V0KGZpZWxkKTtcbiAgICAgICAgY29uc3QgY29sID0gdGhpcy5fY3JlYXRlQ29sQ29tcG9uZW50KGZpZWxkLCBoZWFkZXIsIGRpbSk7XG4gICAgICAgIHJldHVybiBjb2w7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9jcmVhdGVDb2xDb21wb25lbnQoZmllbGQ6IHN0cmluZywgaGVhZGVyOiBzdHJpbmcsIGRpbTogSVBpdm90RGltZW5zaW9uKSB7XG4gICAgICAgIGNvbnN0IHJlZiA9IGNyZWF0ZUNvbXBvbmVudChJZ3hDb2x1bW5Db21wb25lbnQsIHsgZW52aXJvbm1lbnRJbmplY3RvcjogdGhpcy5lbnZJbmplY3RvciwgZWxlbWVudEluamVjdG9yOiB0aGlzLmluamVjdG9yfSk7XG4gICAgICAgIHJlZi5pbnN0YW5jZS5maWVsZCA9IGZpZWxkO1xuICAgICAgICByZWYuaW5zdGFuY2UuaGVhZGVyID0gaGVhZGVyO1xuICAgICAgICByZWYuaW5zdGFuY2Uud2lkdGggPSB0aGlzLmdyaWQucm93RGltZW5zaW9uV2lkdGhUb1BpeGVscyh0aGlzLnJvb3REaW1lbnNpb24pICsgJ3B4JztcbiAgICAgICAgcmVmLmluc3RhbmNlLnJlc2l6YWJsZSA9IHRoaXMuZ3JpZC5yb3dEaW1lbnNpb25SZXNpemluZztcbiAgICAgICAgKHJlZiBhcyBhbnkpLmluc3RhbmNlLl92SW5kZXggPSB0aGlzLmdyaWQuY29sdW1ucy5sZW5ndGggKyB0aGlzLnJvd0luZGV4ICsgdGhpcy5yb3dJbmRleCAqIHRoaXMuZ3JpZC5waXZvdENvbmZpZ3VyYXRpb24ucm93cy5sZW5ndGg7XG5cblxuICAgICAgICBpZiAoaGVhZGVyICYmIGRpbS5jaGlsZExldmVsICYmICghdGhpcy5yb3dEYXRhLnRvdGFsUmVjb3JkRGltZW5zaW9uTmFtZSB8fCB0aGlzLnJvd0RhdGEudG90YWxSZWNvcmREaW1lbnNpb25OYW1lICE9PSBkaW0ubWVtYmVyTmFtZSkpIHtcbiAgICAgICAgICAgIHJlZi5pbnN0YW5jZS5oZWFkZXJUZW1wbGF0ZSA9IHRoaXMuaGVhZGVyVGVtcGxhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWYuaW5zdGFuY2UuaGVhZGVyVGVtcGxhdGUgPSB0aGlzLmhlYWRlclRlbXBsYXRlRGVmYXVsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmLmluc3RhbmNlO1xuICAgIH1cbn1cbiIsIjxkaXYgcm9sZT1cInJvd2dyb3VwXCIgY2xhc3M9XCJpZ3gtZ3JpZC10aGVhZF9fd3JhcHBlclwiIFtzdHlsZS53aWR0aC5weF09XCJ3aWR0aFwiXG4gICAgW2NsYXNzLmlneC1ncmlkX190ci0tbXJsXT1cImhhc01STFwiPlxuICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fdHIgaWd4LWdyaWRfX3RyLWhlYWRlci1yb3dcIiByb2xlPVwicm93XCIgW3N0eWxlLndpZHRoLnB4XT1cIndpZHRoXCI+XG4gICAgICAgICAgICA8aWd4LXBpdm90LXJvdy1kaW1lbnNpb24taGVhZGVyLWdyb3VwIFtuZ0NsYXNzXT1cInJvd0RpbWVuc2lvbkNvbHVtbi5oZWFkZXJHcm91cENsYXNzZXNcIlxuICAgICAgICAgICAgICAgIFtuZ1N0eWxlXT1cInJvd0RpbWVuc2lvbkNvbHVtbi5oZWFkZXJHcm91cFN0eWxlcyB8IGlneEhlYWRlckdyb3VwU3R5bGU6cm93RGltZW5zaW9uQ29sdW1uOmdyaWQucGlwZVRyaWdnZXJcIiBbY29sdW1uXT1cInJvd0RpbWVuc2lvbkNvbHVtblwiXG4gICAgICAgICAgICAgICAgW3N0eWxlLm1pbi13aWR0aF09XCJnZXRIZWFkZXJXaWR0aEZyb21EaW1lbnNpb24oKSB8IGlneEhlYWRlckdyb3VwV2lkdGg6Z3JpZC5kZWZhdWx0SGVhZGVyR3JvdXBNaW5XaWR0aDpoYXNNUkxcIlxuICAgICAgICAgICAgICAgIFtzdHlsZS53aWR0aF09XCJnZXRIZWFkZXJXaWR0aEZyb21EaW1lbnNpb24oKSB8IGlneEhlYWRlckdyb3VwV2lkdGg6Z3JpZC5kZWZhdWx0SGVhZGVyR3JvdXBNaW5XaWR0aDpoYXNNUkxcIlxuICAgICAgICAgICAgICAgIFtzdHlsZS5mbGV4LWJhc2lzXT1cImdldEhlYWRlcldpZHRoRnJvbURpbWVuc2lvbigpIHwgaWd4SGVhZGVyR3JvdXBXaWR0aDpncmlkLmRlZmF1bHRIZWFkZXJHcm91cE1pbldpZHRoOmhhc01STFwiXG4gICAgICAgICAgICAgICAgW3Jvd0luZGV4XT1cInJvd0luZGV4XCJcbiAgICAgICAgICAgICAgICBbY29sSW5kZXhdPVwiY29sSW5kZXhcIlxuICAgICAgICAgICAgICAgIFtsYXlvdXRdPVwibGF5b3V0XCJcbiAgICAgICAgICAgICAgICBbcGFyZW50XT0ndGhpcyc+XG4gICAgICAgICAgICA8L2lneC1waXZvdC1yb3ctZGltZW5zaW9uLWhlYWRlci1ncm91cD5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuXG48bmctdGVtcGxhdGUgI2hlYWRlclRlbXBsYXRlIGxldC1jb2x1bW4+XG4gICAgPGRpdiBjbGFzcz0naWd4LWdyaWRfX3RyLS1oZWFkZXIgaWd4LWdyaWRfX3Jvdy1pbmRlbnRhdGlvbi0tbGV2ZWwte3tnZXRMZXZlbCgpfX0nPlxuICAgICAgICA8aWd4LWljb25cbiAgICAgICAgICAgIGZhbWlseT1cImRlZmF1bHRcIlxuICAgICAgICAgICAgW25hbWVdPVwiZ2V0RXhwYW5kU3RhdGUoKSA/ICd0cmVlX2NvbGxhcHNlJyA6ICd0cmVlX2V4cGFuZCdcIlxuICAgICAgICAgICAgW2F0dHIuZHJhZ2dhYmxlXT1cImZhbHNlXCJcbiAgICAgICAgICAgIChjbGljayk9XCJ0b2dnbGVSb3dEaW1lbnNpb24oJGV2ZW50KVwiXG4gICAgICAgICAgICA+XG4gICAgICAgIDwvaWd4LWljb24+XG4gICAgICAgIHt7Y29sdW1uLmhlYWRlcn19XG4gICAgPC9kaXY+XG48L25nLXRlbXBsYXRlPlxuXG48bmctdGVtcGxhdGUgI2hlYWRlckRlZmF1bHRUZW1wbGF0ZSBsZXQtY29sdW1uPlxuICAgIDxkaXYgY2xhc3M9J2lneC1ncmlkX190ci0taGVhZGVyIGlneC1ncmlkX19yb3ctaW5kZW50YXRpb24tLWxldmVsLXt7Z2V0TGV2ZWwoKX19JyBzdHlsZT1cIi0tY29tcG9uZW50LXNpemU6IDNcIj5cbiAgICAgICAgPCEtLVVzaW5nIHRoZSBpZ3gtaWNvbiBhcyBhIHNpemFibGUgc3BhY2VyIHNwYWNlciBoZXJlLS0+XG4gICAgICAgIDxpZ3gtaWNvbiBzdHlsZT0nZmxleC1zaHJpbms6IDA7JyBbYXR0ci5kcmFnZ2FibGVdPVwiZmFsc2VcIj48L2lneC1pY29uPlxuICAgICAgICB7e2NvbHVtbi5oZWFkZXJ9fVxuICAgIDwvZGl2PlxuPC9uZy10ZW1wbGF0ZT5cbiJdfQ==