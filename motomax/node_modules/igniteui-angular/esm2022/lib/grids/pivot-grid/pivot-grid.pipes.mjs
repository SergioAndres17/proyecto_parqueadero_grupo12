import { Inject, Pipe } from '@angular/core';
import { cloneArray, resolveNestedPath } from '../../core/utils';
import { DataUtil } from '../../data-operations/data-util';
import { FilteringExpressionsTree } from '../../data-operations/filtering-expressions-tree';
import { DefaultPivotGridRecordSortingStrategy } from '../../data-operations/pivot-sort-strategy';
import { FilterUtil } from '../../data-operations/filtering-strategy';
import { DimensionValuesFilteringStrategy, PivotColumnDimensionsStrategy, PivotRowDimensionsStrategy } from '../../data-operations/pivot-strategy';
import { IGX_GRID_BASE } from '../common/grid.interface';
import { DEFAULT_PIVOT_KEYS } from './pivot-grid.interface';
import { PivotSortUtil } from './pivot-sort-util';
import { PivotUtil } from './pivot-util';
import * as i0 from "@angular/core";
import * as i1 from "../api.service";
/**
 * @hidden
 */
export class IgxPivotRowPipe {
    constructor(grid) {
        this.grid = grid;
    }
    transform(collection, config, cloneStrategy, _, _pipeTrigger, __) {
        const pivotKeys = config.pivotKeys || DEFAULT_PIVOT_KEYS;
        const enabledRows = config.rows?.filter(x => x.enabled) || [];
        const enabledColumns = config.columns?.filter(x => x.enabled) || [];
        const enabledValues = config.values?.filter(x => x.enabled) || [];
        if (enabledRows.length === 0 && enabledColumns.length === 0 && enabledValues.length === 0) {
            // nothing to group and aggregate by ...
            return [];
        }
        const rowStrategy = config.rowStrategy || PivotRowDimensionsStrategy.instance();
        const data = cloneArray(collection, true);
        return rowStrategy.process(data, enabledRows, config.values, cloneStrategy, pivotKeys);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotRowPipe, deps: [{ token: IGX_GRID_BASE }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotRowPipe, isStandalone: true, name: "pivotGridRow" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotRowPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'pivotGridRow',
                    pure: true,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }] });
/**
 * @hidden
 * Transforms generic array data into IPivotGridRecord[]
 */
export class IgxPivotAutoTransform {
    transform(collection, config, _pipeTrigger, __) {
        let needsTransformation = false;
        if (collection.length > 0) {
            needsTransformation = !this.isPivotRecord(collection[0]);
        }
        if (!needsTransformation)
            return collection;
        const res = this.processCollectionToPivotRecord(config, collection);
        return res;
    }
    isPivotRecord(arg) {
        return !!arg.aggregationValues;
    }
    processCollectionToPivotRecord(config, collection) {
        const pivotKeys = config.pivotKeys || DEFAULT_PIVOT_KEYS;
        const enabledRows = config.rows.filter(x => x.enabled);
        const allFlat = PivotUtil.flatten(enabledRows);
        const result = [];
        for (const rec of collection) {
            const pivotRec = {
                dimensionValues: new Map(),
                aggregationValues: new Map(),
                children: new Map(),
                dimensions: []
            };
            const keys = Object.keys(rec);
            for (const key of keys) {
                const dim = allFlat.find(x => x.memberName === key);
                if (dim) {
                    //field has matching dimension
                    pivotRec.dimensions.push(dim);
                    pivotRec.dimensionValues.set(key, rec[key]);
                }
                else if (key.indexOf(pivotKeys.rowDimensionSeparator + pivotKeys.records) !== -1) {
                    // field that contains child collection
                    const dimKey = key.slice(0, key.indexOf(pivotKeys.rowDimensionSeparator + pivotKeys.records));
                    const childData = rec[key];
                    const childPivotData = this.processCollectionToPivotRecord(config, childData);
                    pivotRec.children.set(dimKey, childPivotData);
                }
                else {
                    // an aggregation
                    pivotRec.aggregationValues.set(key, rec[key]);
                }
            }
            const flattened = PivotUtil.flatten(config.rows);
            pivotRec.dimensions.sort((x, y) => flattened.indexOf(x) - flattened.indexOf(y));
            result.push(pivotRec);
        }
        return result;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotAutoTransform, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotAutoTransform, isStandalone: true, name: "pivotGridAutoTransform" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotAutoTransform, decorators: [{
            type: Pipe,
            args: [{
                    name: 'pivotGridAutoTransform',
                    pure: true,
                    standalone: true
                }]
        }] });
/**
 * @hidden
 */
export class IgxPivotRowExpansionPipe {
    constructor(grid) {
        this.grid = grid;
    }
    transform(collection, config, expansionStates, defaultExpand, _pipeTrigger, __) {
        const enabledRows = config.rows?.filter(x => x.enabled) || [];
        const data = collection ? cloneArray(collection, true) : [];
        const horizontalRowDimensions = [];
        for (const row of enabledRows) {
            if (this.grid?.hasHorizontalLayout) {
                PivotUtil.flattenGroupsHorizontally(data, row, expansionStates, defaultExpand, horizontalRowDimensions, this.grid.pivotUI.horizontalSummariesPosition);
            }
            else {
                PivotUtil.flattenGroups(data, row, expansionStates, defaultExpand);
            }
        }
        let finalData = data;
        if (this.grid?.hasHorizontalLayout) {
            const allRowDims = PivotUtil.flatten(this.grid.rowDimensions);
            this.grid.visibleRowDimensions = allRowDims.filter((rowDim) => horizontalRowDimensions.some(targetDim => targetDim.memberName === rowDim.memberName));
        }
        else {
            if (this.grid) {
                this.grid.visibleRowDimensions = enabledRows;
            }
            finalData = enabledRows.length > 0 ?
                finalData.filter(x => x.dimensions.length === enabledRows.length) : finalData;
        }
        if (this.grid) {
            this.grid.setFilteredSortedData(finalData, false);
        }
        return finalData;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotRowExpansionPipe, deps: [{ token: IGX_GRID_BASE }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotRowExpansionPipe, isStandalone: true, name: "pivotGridRowExpansion" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotRowExpansionPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'pivotGridRowExpansion',
                    pure: true,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }] });
/**
 * @hidden
 */
export class IgxPivotCellMergingPipe {
    constructor(grid) {
        this.grid = grid;
    }
    transform(collection, config, dim, _pipeTrigger) {
        if (collection.length === 0 || config.rows.length === 0)
            return collection;
        const data = collection ? cloneArray(collection, true) : [];
        const res = [];
        let groupData = [];
        let prevId;
        const enabledRows = this.grid.hasHorizontalLayout ? this.grid.visibleRowDimensions : config.rows?.filter(x => x.enabled);
        const dimIndex = enabledRows.indexOf(dim);
        for (const rec of data) {
            let currentDim;
            if (this.grid.hasHorizontalLayout) {
                currentDim = dim;
                rec.dimensions = enabledRows;
            }
            else {
                currentDim = rec.dimensions[dimIndex];
            }
            const id = PivotUtil.getRecordKey(rec, currentDim);
            if (groupData.length > 0 && prevId !== id) {
                const h = groupData.length > 1 ? groupData.length * this.grid.renderedRowHeight : undefined;
                groupData[0].height = h;
                groupData[0].rowSpan = groupData.length;
                res.push(groupData[0]);
                groupData = [];
            }
            groupData.push(rec);
            prevId = id;
        }
        if (groupData.length > 0) {
            const h = groupData.length > 1 ? groupData.length * this.grid.rowHeight + (groupData.length - 1) + 1 : undefined;
            groupData[0].height = h;
            groupData[0].rowSpan = groupData.length;
            res.push(groupData[0]);
        }
        return res;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotCellMergingPipe, deps: [{ token: IGX_GRID_BASE }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotCellMergingPipe, isStandalone: true, name: "pivotGridCellMerging" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotCellMergingPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'pivotGridCellMerging',
                    pure: true,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }] });
/**
 * @hidden
 */
export class IgxPivotGridHorizontalRowGrouping {
    constructor(grid) {
        this.grid = grid;
    }
    transform(collection, config, _pipeTrigger, _regroupTrigger) {
        if (collection.length === 0 || config.rows.length === 0)
            return null;
        const data = collection ? cloneArray(collection, true) : [];
        const res = [];
        const groupDim = config.rows.filter(dim => dim.enabled)[0];
        let curGroup = [];
        let curGroupValue = data[0].dimensionValues.get(groupDim.memberName);
        for (const [index, curRec] of data.entries()) {
            curRec.dataIndex = index;
            const curRecValue = curRec.dimensionValues.get(groupDim.memberName);
            if (curGroup.length === 0 || curRecValue === curGroupValue) {
                curGroup.push(curRec);
            }
            else {
                curGroup["height"] = this.grid.renderedRowHeight * curGroup.length;
                res.push(curGroup);
                curGroup = [curRec];
                curGroupValue = curRecValue;
            }
        }
        res.push(curGroup);
        return res;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotGridHorizontalRowGrouping, deps: [{ token: IGX_GRID_BASE }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotGridHorizontalRowGrouping, isStandalone: true, name: "pivotGridHorizontalRowGrouping" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotGridHorizontalRowGrouping, decorators: [{
            type: Pipe,
            args: [{
                    name: "pivotGridHorizontalRowGrouping",
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }] });
/**
 * @hidden
 */
export class IgxPivotGridHorizontalRowCellMerging {
    constructor(grid) {
        this.grid = grid;
    }
    transform(collection, config, _pipeTrigger) {
        if (collection.length === 0 || config.rows.length === 0)
            return [{
                    colStart: 1,
                    colSpan: 1,
                    rowStart: 1,
                    rowSpan: 1,
                    records: collection
                }];
        const data = collection ? cloneArray(collection, true) : [];
        const res = [];
        // Merge vertically for each row dimension.
        const verticalMergeGroups = [...data.map(_ => [])];
        for (let dimIndex = 0; dimIndex < this.grid.visibleRowDimensions.length; dimIndex++) {
            const curDim = this.grid.visibleRowDimensions[dimIndex];
            let curGroup = {
                colStart: dimIndex + 1,
                colSpan: 1,
                rowStart: 1,
                rowSpan: 1,
                value: data[0].dimensionValues.get(curDim.memberName),
                rootDimension: curDim,
                dimensions: [curDim],
                records: [data[0]]
            };
            for (let i = 1; i < data.length; i++) {
                const curRec = data[i];
                const curRecValue = curRec.dimensionValues.get(curDim.memberName);
                const previousRowCell = verticalMergeGroups[i][verticalMergeGroups[i].length - 1];
                if (curRecValue === curGroup.value && !previousRowCell) {
                    // If previousRowCell is non existing, its merged so we can push in this vertigal group as well.
                    curGroup.rowSpan++;
                    curGroup.records.push(curRec);
                }
                else {
                    verticalMergeGroups[curGroup.rowStart - 1].push(curGroup);
                    curGroup = {
                        colStart: dimIndex + 1,
                        colSpan: 1,
                        rowStart: curGroup.rowStart + curGroup.rowSpan,
                        rowSpan: 1,
                        value: curRec.dimensionValues.get(curDim.memberName),
                        rootDimension: curDim,
                        dimensions: [curDim],
                        records: [curRec]
                    };
                }
            }
            verticalMergeGroups[curGroup.rowStart - 1].push(curGroup);
        }
        // Merge rows in a single array
        const sortedGroups = verticalMergeGroups.reduce((prev, cur) => prev.concat(...cur), []);
        // Horizontally merge any groups that can be merged or have been
        res.push(sortedGroups[0]);
        let prevGroup = sortedGroups[0];
        for (let i = 1; i < sortedGroups.length; i++) {
            const curGroup = sortedGroups[i];
            if (curGroup.value && prevGroup.value !== curGroup.value) {
                prevGroup = curGroup;
                res.push(curGroup);
            }
            else {
                prevGroup.dimensions.push(curGroup.rootDimension);
                prevGroup.colSpan++;
            }
        }
        return res;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotGridHorizontalRowCellMerging, deps: [{ token: IGX_GRID_BASE }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotGridHorizontalRowCellMerging, isStandalone: true, name: "pivotGridHorizontalRowCellMerging" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotGridHorizontalRowCellMerging, decorators: [{
            type: Pipe,
            args: [{
                    name: "pivotGridHorizontalRowCellMerging",
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }] });
/**
 * @hidden
 */
export class IgxPivotColumnPipe {
    transform(collection, config, cloneStrategy, _, _pipeTrigger, __) {
        const pivotKeys = config.pivotKeys || DEFAULT_PIVOT_KEYS;
        const enabledColumns = config.columns?.filter(x => x.enabled) || [];
        const enabledValues = config.values?.filter(x => x.enabled) || [];
        const colStrategy = config.columnStrategy || PivotColumnDimensionsStrategy.instance();
        const data = cloneArray(collection, true);
        return colStrategy.process(data, enabledColumns, enabledValues, cloneStrategy, pivotKeys);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotColumnPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotColumnPipe, isStandalone: true, name: "pivotGridColumn" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotColumnPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'pivotGridColumn',
                    pure: true,
                    standalone: true
                }]
        }] });
/**
 * @hidden
 */
export class IgxPivotGridFilterPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, config, filterStrategy, advancedExpressionsTree, _filterPipeTrigger, _pipeTrigger) {
        const expressionsTree = PivotUtil.buildExpressionTree(config);
        const state = {
            expressionsTree,
            strategy: filterStrategy || new DimensionValuesFilteringStrategy(),
            advancedExpressionsTree
        };
        if (FilteringExpressionsTree.empty(state.expressionsTree) && FilteringExpressionsTree.empty(state.advancedExpressionsTree)) {
            return collection;
        }
        const result = FilterUtil.filter(cloneArray(collection, true), state, this.gridAPI.grid);
        return result;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotGridFilterPipe, deps: [{ token: i1.GridBaseAPIService }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotGridFilterPipe, isStandalone: true, name: "pivotGridFilter" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotGridFilterPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'pivotGridFilter',
                    pure: true,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.GridBaseAPIService }] });
/**
 * @hidden
 */
export class IgxPivotGridColumnSortingPipe {
    transform(collection, expressions, sorting, _pipeTrigger) {
        let result;
        if (!expressions.length) {
            result = collection;
        }
        else {
            for (const expr of expressions) {
                expr.strategy = DefaultPivotGridRecordSortingStrategy.instance();
            }
            result = PivotUtil.sort(cloneArray(collection, true), expressions, sorting);
        }
        return result;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotGridColumnSortingPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotGridColumnSortingPipe, isStandalone: true, name: "pivotGridColumnSort" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotGridColumnSortingPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'pivotGridColumnSort',
                    pure: true,
                    standalone: true
                }]
        }] });
/**
 * @hidden
 */
export class IgxPivotGridSortingPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, config, sorting, _pipeTrigger) {
        let result;
        const allDimensions = config.rows || [];
        const enabledDimensions = allDimensions.filter(x => x && x.enabled);
        const expressions = PivotSortUtil.generateDimensionSortingExpressions(enabledDimensions);
        if (!expressions.length) {
            result = collection;
        }
        else {
            result = DataUtil.sort(cloneArray(collection, true), expressions, sorting, this.gridAPI.grid);
        }
        return result;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotGridSortingPipe, deps: [{ token: i1.GridBaseAPIService }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotGridSortingPipe, isStandalone: true, name: "pivotGridSort" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotGridSortingPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'pivotGridSort',
                    pure: true,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.GridBaseAPIService }] });
/**
 * @hidden
 */
export class IgxFilterPivotItemsPipe {
    transform(collection, filterCriteria, _pipeTrigger) {
        if (!collection) {
            return collection;
        }
        let copy = collection.slice(0);
        if (filterCriteria && filterCriteria.length > 0) {
            const filterFunc = (c) => {
                const filterText = c.member || c.memberName;
                if (!filterText) {
                    return false;
                }
                return (filterText
                    .toLocaleLowerCase()
                    .indexOf(filterCriteria.toLocaleLowerCase()) >= 0 ||
                    (c.children?.some(filterFunc) ?? false));
            };
            copy = collection.filter(filterFunc);
        }
        return copy;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxFilterPivotItemsPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.4", ngImport: i0, type: IgxFilterPivotItemsPipe, isStandalone: true, name: "filterPivotItems" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxFilterPivotItemsPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: "filterPivotItems",
                    standalone: true
                }]
        }] });
export class IgxPivotGridCellStyleClassesPipe {
    transform(cssClasses, _, rowData, columnData, index, __) {
        if (!cssClasses) {
            return '';
        }
        const result = [];
        for (const cssClass of Object.keys(cssClasses)) {
            const callbackOrValue = cssClasses[cssClass];
            const apply = typeof callbackOrValue === 'function' ?
                callbackOrValue(rowData, columnData, resolveNestedPath(rowData, columnData.field), index) : callbackOrValue;
            if (apply) {
                result.push(cssClass);
            }
        }
        return result.join(' ');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotGridCellStyleClassesPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotGridCellStyleClassesPipe, isStandalone: true, name: "igxPivotCellStyleClasses" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxPivotGridCellStyleClassesPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'igxPivotCellStyleClasses',
                    standalone: true
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGl2b3QtZ3JpZC5waXBlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy9waXZvdC1ncmlkL3Bpdm90LWdyaWQucGlwZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQWlCLE1BQU0sZUFBZSxDQUFDO0FBQzVELE9BQU8sRUFBRSxVQUFVLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUNqRSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDM0QsT0FBTyxFQUFFLHdCQUF3QixFQUE2QixNQUFNLGtEQUFrRCxDQUFDO0FBQ3ZILE9BQU8sRUFBRSxxQ0FBcUMsRUFBRSxNQUFNLDJDQUEyQyxDQUFDO0FBQ2xHLE9BQU8sRUFBRSxVQUFVLEVBQXNCLE1BQU0sMENBQTBDLENBQUM7QUFDMUYsT0FBTyxFQUNILGdDQUFnQyxFQUFFLDZCQUE2QixFQUMvRCwwQkFBMEIsRUFDN0IsTUFBTSxzQ0FBc0MsQ0FBQztBQUc5QyxPQUFPLEVBQVksYUFBYSxFQUFpQixNQUFNLDBCQUEwQixDQUFDO0FBR2xGLE9BQU8sRUFBRSxrQkFBa0IsRUFBdUosTUFBTSx3QkFBd0IsQ0FBQztBQUNqTixPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDbEQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGNBQWMsQ0FBQzs7O0FBR3pDOztHQUVHO0FBTUgsTUFBTSxPQUFPLGVBQWU7SUFFeEIsWUFBMkMsSUFBb0I7UUFBcEIsU0FBSSxHQUFKLElBQUksQ0FBZ0I7SUFBSSxDQUFDO0lBRTdELFNBQVMsQ0FDWixVQUFlLEVBQ2YsTUFBMkIsRUFDM0IsYUFBaUMsRUFDakMsQ0FBb0IsRUFDcEIsWUFBcUIsRUFDckIsRUFBRztRQUVILE1BQU0sU0FBUyxHQUFH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QUMsZUFBZSxDQUFDO1lBQ2hILElBQUksS0FBSyxFQUFFLENBQUM7Z0JBQ1IsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUMxQixDQUFDO1FBQ0wsQ0FBQztRQUVELE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM1QixDQUFDOzhHQW5CUSxnQ0FBZ0M7NEdBQWhDLGdDQUFnQzs7MkZBQWhDLGdDQUFnQztrQkFKNUMsSUFBSTttQkFBQztvQkFDRixJQUFJLEVBQUUsMEJBQTBCO29CQUNoQyxVQUFVLEVBQUUsSUFBSTtpQkFDbkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3QsIFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGNsb25lQXJyYXksIHJlc29sdmVOZXN0ZWRQYXRoIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBEYXRhVXRpbCB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9kYXRhLXV0aWwnO1xuaW1wb3J0IHsgRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlLCBJRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2ZpbHRlcmluZy1leHByZXNzaW9ucy10cmVlJztcbmltcG9ydCB7IERlZmF1bHRQaXZvdEdyaWRSZWNvcmRTb3J0aW5nU3RyYXRlZ3kgfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvcGl2b3Qtc29ydC1zdHJhdGVneSc7XG5pbXBvcnQgeyBGaWx0ZXJVdGlsLCBJRmlsdGVyaW5nU3RyYXRlZ3kgfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZmlsdGVyaW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7XG4gICAgRGltZW5zaW9uVmFsdWVzRmlsdGVyaW5nU3RyYXRlZ3ksIFBpdm90Q29sdW1uRGltZW5zaW9uc1N0cmF0ZWd5LFxuICAgIFBpdm90Um93RGltZW5zaW9uc1N0cmF0ZWd5XG59IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9waXZvdC1zdHJhdGVneSc7XG5pbXBvcnQgeyBJU29ydGluZ0V4cHJlc3Npb24gfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvc29ydGluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBHcmlkQmFzZUFQSVNlcnZpY2UgfSBmcm9tICcuLi9hcGkuc2VydmljZSc7XG5pbXBvcnQgeyBHcmlkVHlwZSwgSUdYX0dSSURfQkFTRSwgUGl2b3RHcmlkVHlwZSB9IGZyb20gJy4uL2NvbW1vbi9ncmlkLmludGVyZmFjZSc7XG5pbXBvcnQgeyBJR3JpZFNvcnRpbmdTdHJhdGVneSB9IGZyb20gJy4uL2NvbW1vbi9zdHJhdGVneSc7XG5pbXBvcnQgeyBJZ3hHcmlkQmFzZURpcmVjdGl2ZSB9IGZyb20gJy4uL2dyaWQtYmFzZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgREVGQVVMVF9QSVZPVF9LRVlTLCBJUGl2b3RDb25maWd1cmF0aW9uLCBJUGl2b3REaW1lbnNpb24sIElQaXZvdEdyaWRDb2x1bW4sIElQaXZvdEdyaWRHcm91cFJlY29yZCwgSVBpdm90R3JpZEhvcml6b250YWxHcm91cCwgSVBpdm90R3JpZFJlY29yZCwgSVBpdm90S2V5cywgSVBpdm90VmFsdWUgfSBmcm9tICcuL3Bpdm90LWdyaWQuaW50ZXJmYWNlJztcbmltcG9ydCB7IFBpdm90U29ydFV0aWwgfSBmcm9tICcuL3Bpdm90LXNvcnQtdXRpbCc7XG5pbXBvcnQgeyBQaXZvdFV0aWwgfSBmcm9tICcuL3Bpdm90LXV0aWwnO1xuaW1wb3J0IHsgSURhdGFDbG9uZVN0cmF0ZWd5IH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2RhdGEtY2xvbmUtc3RyYXRlZ3knO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQFBpcGUoe1xuICAgIG5hbWU6ICdwaXZvdEdyaWRSb3cnLFxuICAgIHB1cmU6IHRydWUsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hQaXZvdFJvd1BpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcblxuICAgIGNvbnN0cnVjdG9yKEBJbmplY3QoSUdYX0dSSURfQkFTRSkgcHJpdmF0ZSBncmlkPzogUGl2b3RHcmlkVHlwZSkgeyB9XG5cbiAgICBwdWJsaWMgdHJhbnNmb3JtKFxuICAgICAgICBjb2xsZWN0aW9uOiBhbnksXG4gICAgICAgIGNvbmZpZzogSVBpdm90Q29uZmlndXJhdGlvbixcbiAgICAgICAgY2xvbmVTdHJhdGVneTogSURhdGFDbG9uZVN0cmF0ZWd5LFxuICAgICAgICBfOiBNYXA8YW55LCBib29sZWFuPixcbiAgICAgICAgX3BpcGVUcmlnZ2VyPzogbnVtYmVyLFxuICAgICAgICBfXz9cbiAgICApOiBJUGl2b3RHcmlkUmVjb3JkW10ge1xuICAgICAgICBjb25zdCBwaXZvdEtleXMgPSBjb25maWcucGl2b3RLZXlzIHx8IERFRkFVTFRfUElWT1RfS0VZUztcbiAgICAgICAgY29uc3QgZW5hYmxlZFJvd3MgPSBjb25maWcucm93cz8uZmlsdGVyKHggPT4geC5lbmFibGVkKSB8fCBbXTtcbiAgICAgICAgY29uc3QgZW5hYmxlZENvbHVtbnMgPSBjb25maWcuY29sdW1ucz8uZmlsdGVyKHggPT4geC5lbmFibGVkKSB8fCBbXTtcbiAgICAgICAgY29uc3QgZW5hYmxlZFZhbHVlcyA9IGNvbmZpZy52YWx1ZXM/LmZpbHRlcih4ID0+IHguZW5hYmxlZCkgfHwgW107XG4gICAgICAgIGlmIChlbmFibGVkUm93cy5sZW5ndGggPT09IDAgJiYgZW5hYmxlZENvbHVtbnMubGVuZ3RoID09PSAwICYmIGVuYWJsZWRWYWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nIHRvIGdyb3VwIGFuZCBhZ2dyZWdhdGUgYnkgLi4uXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm93U3RyYXRlZ3kgPSBjb25maWcucm93U3RyYXRlZ3kgfHwgUGl2b3RSb3dEaW1lbnNpb25zU3RyYXRlZ3kuaW5zdGFuY2UoKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGNsb25lQXJyYXkoY29sbGVjdGlvbiwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiByb3dTdHJhdGVneS5wcm9jZXNzKGRhdGEsIGVuYWJsZWRSb3dzLCBjb25maWcudmFsdWVzLCBjbG9uZVN0cmF0ZWd5LCBwaXZvdEtleXMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKiBUcmFuc2Zvcm1zIGdlbmVyaWMgYXJyYXkgZGF0YSBpbnRvIElQaXZvdEdyaWRSZWNvcmRbXVxuICovXG5AUGlwZSh7XG4gICAgbmFtZTogJ3Bpdm90R3JpZEF1dG9UcmFuc2Zvcm0nLFxuICAgIHB1cmU6IHRydWUsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hQaXZvdEF1dG9UcmFuc2Zvcm0gaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcbiAgICBwdWJsaWMgdHJhbnNmb3JtKFxuICAgICAgICBjb2xsZWN0aW9uOiBhbnlbXSxcbiAgICAgICAgY29uZmlnOiBJUGl2b3RDb25maWd1cmF0aW9uLFxuICAgICAgICBfcGlwZVRyaWdnZXI/OiBudW1iZXIsXG4gICAgICAgIF9fPyxcbiAgICApOiBJUGl2b3RHcmlkUmVjb3JkW10ge1xuICAgICAgICBsZXQgbmVlZHNUcmFuc2Zvcm1hdGlvbiA9IGZhbHNlO1xuICAgICAgICBpZiAoY29sbGVjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBuZWVkc1RyYW5zZm9ybWF0aW9uID0gIXRoaXMuaXNQaXZvdFJlY29yZChjb2xsZWN0aW9uWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbmVlZHNUcmFuc2Zvcm1hdGlvbikgcmV0dXJuIGNvbGxlY3Rpb247XG5cbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy5wcm9jZXNzQ29sbGVjdGlvblRvUGl2b3RSZWNvcmQoY29uZmlnLCBjb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgaXNQaXZvdFJlY29yZChhcmc6IElQaXZvdEdyaWRSZWNvcmQpOiBhcmcgaXMgSVBpdm90R3JpZFJlY29yZCB7XG4gICAgICAgIHJldHVybiAhIShhcmcgYXMgSVBpdm90R3JpZFJlY29yZCkuYWdncmVnYXRpb25WYWx1ZXM7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHByb2Nlc3NDb2xsZWN0aW9uVG9QaXZvdFJlY29yZChjb25maWc6IElQaXZvdENvbmZpZ3VyYXRpb24sIGNvbGxlY3Rpb246IGFueVtdKTogSVBpdm90R3JpZFJlY29yZFtdIHtcbiAgICAgICAgY29uc3QgcGl2b3RLZXlzOiBJUGl2b3RLZXlzID0gY29uZmlnLnBpdm90S2V5cyB8fCBERUZBVUxUX1BJVk9UX0tFWVM7XG4gICAgICAgIGNvbnN0IGVuYWJsZWRSb3dzID0gY29uZmlnLnJvd3MuZmlsdGVyKHggPT4geC5lbmFibGVkKTtcbiAgICAgICAgY29uc3QgYWxsRmxhdDogSVBpdm90RGltZW5zaW9uW10gPSBQaXZvdFV0aWwuZmxhdHRlbihlbmFibGVkUm93cyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogSVBpdm90R3JpZFJlY29yZFtdID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcmVjIG9mIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHBpdm90UmVjOiBJUGl2b3RHcmlkUmVjb3JkID0ge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvblZhbHVlczogbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKSxcbiAgICAgICAgICAgICAgICBhZ2dyZWdhdGlvblZhbHVlczogbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogbmV3IE1hcDxzdHJpbmcsIElQaXZvdEdyaWRSZWNvcmRbXT4oKSxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhyZWMpXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGltID0gYWxsRmxhdC5maW5kKHggPT4geC5tZW1iZXJOYW1lID09PSBrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChkaW0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy9maWVsZCBoYXMgbWF0Y2hpbmcgZGltZW5zaW9uXG4gICAgICAgICAgICAgICAgICAgIHBpdm90UmVjLmRpbWVuc2lvbnMucHVzaChkaW0pO1xuICAgICAgICAgICAgICAgICAgICBwaXZvdFJlYy5kaW1lbnNpb25WYWx1ZXMuc2V0KGtleSwgcmVjW2tleV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5LmluZGV4T2YocGl2b3RLZXlzLnJvd0RpbWVuc2lvblNlcGFyYXRvciArIHBpdm90S2V5cy5yZWNvcmRzKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmllbGQgdGhhdCBjb250YWlucyBjaGlsZCBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpbUtleSA9IGtleS5zbGljZSgwLCBrZXkuaW5kZXhPZihwaXZvdEtleXMucm93RGltZW5zaW9uU2VwYXJhdG9yICsgcGl2b3RLZXlzLnJlY29yZHMpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGREYXRhID0gcmVjW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkUGl2b3REYXRhID0gdGhpcy5wcm9jZXNzQ29sbGVjdGlvblRvUGl2b3RSZWNvcmQoY29uZmlnLCBjaGlsZERhdGEpO1xuICAgICAgICAgICAgICAgICAgICBwaXZvdFJlYy5jaGlsZHJlbi5zZXQoZGltS2V5LCBjaGlsZFBpdm90RGF0YSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYW4gYWdncmVnYXRpb25cbiAgICAgICAgICAgICAgICAgICAgcGl2b3RSZWMuYWdncmVnYXRpb25WYWx1ZXMuc2V0KGtleSwgcmVjW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZsYXR0ZW5lZCA9IFBpdm90VXRpbC5mbGF0dGVuKGNvbmZpZy5yb3dzKTtcbiAgICAgICAgICAgIHBpdm90UmVjLmRpbWVuc2lvbnMuc29ydCgoeCwgeSkgPT4gZmxhdHRlbmVkLmluZGV4T2YoeCkgLSBmbGF0dGVuZWQuaW5kZXhPZih5KSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwaXZvdFJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBQaXBlKHtcbiAgICBuYW1lOiAncGl2b3RHcmlkUm93RXhwYW5zaW9uJyxcbiAgICBwdXJlOiB0cnVlLFxuICAgIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgSWd4UGl2b3RSb3dFeHBhbnNpb25QaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG5cbiAgICBjb25zdHJ1Y3RvcihASW5qZWN0KElHWF9HUklEX0JBU0UpIHByaXZhdGUgZ3JpZD86IFBpdm90R3JpZFR5cGUpIHsgfVxuXG4gICAgcHVibGljIHRyYW5zZm9ybShcbiAgICAgICAgY29sbGVjdGlvbjogSVBpdm90R3JpZFJlY29yZFtdLFxuICAgICAgICBjb25maWc6IElQaXZvdENvbmZpZ3VyYXRpb24sXG4gICAgICAgIGV4cGFuc2lvblN0YXRlczogTWFwPGFueSwgYm9vbGVhbj4sXG4gICAgICAgIGRlZmF1bHRFeHBhbmQ6IGJvb2xlYW4sXG4gICAgICAgIF9waXBlVHJpZ2dlcj86IG51bWJlcixcbiAgICAgICAgX18/LFxuICAgICk6IElQaXZvdEdyaWRSZWNvcmRbXSB7XG4gICAgICAgIGNvbnN0IGVuYWJsZWRSb3dzID0gY29uZmlnLnJvd3M/LmZpbHRlcih4ID0+IHguZW5hYmxlZCkgfHwgW107XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjb2xsZWN0aW9uID8gY2xvbmVBcnJheShjb2xsZWN0aW9uLCB0cnVlKSA6IFtdO1xuICAgICAgICBjb25zdCBob3Jpem9udGFsUm93RGltZW5zaW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiBlbmFibGVkUm93cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZD8uaGFzSG9yaXpvbnRhbExheW91dCkge1xuICAgICAgICAgICAgICAgIFBpdm90VXRpbC5mbGF0dGVuR3JvdXBzSG9yaXpvbnRhbGx5KFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICByb3csXG4gICAgICAgICAgICAgICAgICAgIGV4cGFuc2lvblN0YXRlcyxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEV4cGFuZCxcbiAgICAgICAgICAgICAgICAgICAgaG9yaXpvbnRhbFJvd0RpbWVuc2lvbnMsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5waXZvdFVJLmhvcml6b250YWxTdW1tYXJpZXNQb3NpdGlvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgUGl2b3RVdGlsLmZsYXR0ZW5Hcm91cHMoZGF0YSwgcm93LCBleHBhbnNpb25TdGF0ZXMsIGRlZmF1bHRFeHBhbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZpbmFsRGF0YSA9IGRhdGE7XG4gICAgICAgIGlmICh0aGlzLmdyaWQ/Lmhhc0hvcml6b250YWxMYXlvdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGFsbFJvd0RpbXMgPSBQaXZvdFV0aWwuZmxhdHRlbih0aGlzLmdyaWQucm93RGltZW5zaW9ucyk7XG4gICAgICAgICAgICB0aGlzLmdyaWQudmlzaWJsZVJvd0RpbWVuc2lvbnMgPSBhbGxSb3dEaW1zLmZpbHRlcigocm93RGltKSA9PiBob3Jpem9udGFsUm93RGltZW5zaW9ucy5zb21lKHRhcmdldERpbSA9PiB0YXJnZXREaW0ubWVtYmVyTmFtZSA9PT0gcm93RGltLm1lbWJlck5hbWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQudmlzaWJsZVJvd0RpbWVuc2lvbnMgPSBlbmFibGVkUm93cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsRGF0YSA9IGVuYWJsZWRSb3dzLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgZmluYWxEYXRhLmZpbHRlcih4ID0+IHguZGltZW5zaW9ucy5sZW5ndGggPT09IGVuYWJsZWRSb3dzLmxlbmd0aCkgOiBmaW5hbERhdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ncmlkKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWQuc2V0RmlsdGVyZWRTb3J0ZWREYXRhKGZpbmFsRGF0YSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5hbERhdGE7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQFBpcGUoe1xuICAgIG5hbWU6ICdwaXZvdEdyaWRDZWxsTWVyZ2luZycsXG4gICAgcHVyZTogdHJ1ZSxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneFBpdm90Q2VsbE1lcmdpbmdQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IoQEluamVjdChJR1hfR1JJRF9CQVNFKSBwcml2YXRlIGdyaWQ6IFBpdm90R3JpZFR5cGUpIHsgfVxuICAgIHB1YmxpYyB0cmFuc2Zvcm0oXG4gICAgICAgIGNvbGxlY3Rpb246IElQaXZvdEdyaWRSZWNvcmRbXSxcbiAgICAgICAgY29uZmlnOiBJUGl2b3RDb25maWd1cmF0aW9uLFxuICAgICAgICBkaW06IElQaXZvdERpbWVuc2lvbixcbiAgICAgICAgX3BpcGVUcmlnZ2VyPzogbnVtYmVyXG4gICAgKTogSVBpdm90R3JpZEdyb3VwUmVjb3JkW10ge1xuICAgICAgICBpZiAoY29sbGVjdGlvbi5sZW5ndGggPT09IDAgfHwgY29uZmlnLnJvd3MubGVuZ3RoID09PSAwKSByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgICAgY29uc3QgZGF0YTogSVBpdm90R3JpZEdyb3VwUmVjb3JkW10gPSBjb2xsZWN0aW9uID8gY2xvbmVBcnJheShjb2xsZWN0aW9uLCB0cnVlKSA6IFtdO1xuICAgICAgICBjb25zdCByZXM6IElQaXZvdEdyaWRHcm91cFJlY29yZFtdID0gW107XG5cbiAgICAgICAgbGV0IGdyb3VwRGF0YTogSVBpdm90R3JpZEdyb3VwUmVjb3JkW10gPSBbXTtcbiAgICAgICAgbGV0IHByZXZJZDtcbiAgICAgICAgY29uc3QgZW5hYmxlZFJvd3MgPSB0aGlzLmdyaWQuaGFzSG9yaXpvbnRhbExheW91dCA/ICh0aGlzLmdyaWQgYXMgYW55KS52aXNpYmxlUm93RGltZW5zaW9ucyA6ICBjb25maWcucm93cz8uZmlsdGVyKHggPT4geC5lbmFibGVkKTtcbiAgICAgICAgY29uc3QgZGltSW5kZXggPSBlbmFibGVkUm93cy5pbmRleE9mKGRpbSk7XG4gICAgICAgIGZvciAoY29uc3QgcmVjIG9mIGRhdGEpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50RGltO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZC5oYXNIb3Jpem9udGFsTGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgY3VycmVudERpbSA9IGRpbTtcbiAgICAgICAgICAgICAgICByZWMuZGltZW5zaW9ucyA9IGVuYWJsZWRSb3dzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50RGltID0gcmVjLmRpbWVuc2lvbnNbZGltSW5kZXhdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpZCA9IFBpdm90VXRpbC5nZXRSZWNvcmRLZXkocmVjLCBjdXJyZW50RGltKTtcbiAgICAgICAgICAgIGlmIChncm91cERhdGEubGVuZ3RoID4gMCAmJiBwcmV2SWQgIT09IGlkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaCA9IGdyb3VwRGF0YS5sZW5ndGggPiAxID8gZ3JvdXBEYXRhLmxlbmd0aCAqIHRoaXMuZ3JpZC5yZW5kZXJlZFJvd0hlaWdodCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBncm91cERhdGFbMF0uaGVpZ2h0ID0gaDtcbiAgICAgICAgICAgICAgICBncm91cERhdGFbMF0ucm93U3BhbiA9IGdyb3VwRGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goZ3JvdXBEYXRhWzBdKTtcbiAgICAgICAgICAgICAgICBncm91cERhdGEgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyb3VwRGF0YS5wdXNoKHJlYyk7XG4gICAgICAgICAgICBwcmV2SWQgPSBpZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXBEYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGggPSBncm91cERhdGEubGVuZ3RoID4gMSA/IGdyb3VwRGF0YS5sZW5ndGggKiB0aGlzLmdyaWQucm93SGVpZ2h0ICsgKGdyb3VwRGF0YS5sZW5ndGggLSAxKSArIDEgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBncm91cERhdGFbMF0uaGVpZ2h0ID0gaDtcbiAgICAgICAgICAgIGdyb3VwRGF0YVswXS5yb3dTcGFuID0gZ3JvdXBEYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHJlcy5wdXNoKGdyb3VwRGF0YVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5AUGlwZSh7XG4gICAgbmFtZTogXCJwaXZvdEdyaWRIb3Jpem9udGFsUm93R3JvdXBpbmdcIixcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneFBpdm90R3JpZEhvcml6b250YWxSb3dHcm91cGluZyBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKEBJbmplY3QoSUdYX0dSSURfQkFTRSkgcHJpdmF0ZSBncmlkOiBHcmlkVHlwZSkgeyB9XG4gICAgcHVibGljIHRyYW5zZm9ybShcbiAgICAgICAgY29sbGVjdGlvbjogSVBpdm90R3JpZFJlY29yZFtdLFxuICAgICAgICBjb25maWc6IElQaXZvdENvbmZpZ3VyYXRpb24sXG4gICAgICAgIF9waXBlVHJpZ2dlcj86IG51bWJlcixcbiAgICAgICAgX3JlZ3JvdXBUcmlnZ2VyPzogbnVtYmVyXG4gICAgKTogSVBpdm90R3JpZFJlY29yZFtdW10ge1xuICAgICAgICBpZiAoY29sbGVjdGlvbi5sZW5ndGggPT09IDAgfHwgY29uZmlnLnJvd3MubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgZGF0YTogSVBpdm90R3JpZFJlY29yZFtdID0gY29sbGVjdGlvbiA/IGNsb25lQXJyYXkoY29sbGVjdGlvbiwgdHJ1ZSkgOiBbXTtcbiAgICAgICAgY29uc3QgcmVzOiBJUGl2b3RHcmlkUmVjb3JkW11bXSA9IFtdO1xuXG4gICAgICAgIGNvbnN0IGdyb3VwRGltID0gY29uZmlnLnJvd3MuZmlsdGVyKGRpbSA9PiBkaW0uZW5hYmxlZClbMF07XG4gICAgICAgIGxldCBjdXJHcm91cCA9IFtdO1xuICAgICAgICBsZXQgY3VyR3JvdXBWYWx1ZSA9IGRhdGFbMF0uZGltZW5zaW9uVmFsdWVzLmdldChncm91cERpbS5tZW1iZXJOYW1lKTtcbiAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGN1clJlY10gb2YgZGF0YS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGN1clJlYy5kYXRhSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGNvbnN0IGN1clJlY1ZhbHVlID0gY3VyUmVjLmRpbWVuc2lvblZhbHVlcy5nZXQoZ3JvdXBEaW0ubWVtYmVyTmFtZSk7XG4gICAgICAgICAgICBpZiAoY3VyR3JvdXAubGVuZ3RoID09PSAwIHx8IGN1clJlY1ZhbHVlID09PSBjdXJHcm91cFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY3VyR3JvdXAucHVzaChjdXJSZWMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJHcm91cFtcImhlaWdodFwiXSA9IHRoaXMuZ3JpZC5yZW5kZXJlZFJvd0hlaWdodCAqIGN1ckdyb3VwLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXMucHVzaChjdXJHcm91cCk7XG4gICAgICAgICAgICAgICAgY3VyR3JvdXAgPSBbY3VyUmVjXTtcbiAgICAgICAgICAgICAgICBjdXJHcm91cFZhbHVlID0gY3VyUmVjVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goY3VyR3JvdXApO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQFBpcGUoe1xuICAgIG5hbWU6IFwicGl2b3RHcmlkSG9yaXpvbnRhbFJvd0NlbGxNZXJnaW5nXCIsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hQaXZvdEdyaWRIb3Jpem9udGFsUm93Q2VsbE1lcmdpbmcgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3RvcihASW5qZWN0KElHWF9HUklEX0JBU0UpIHByaXZhdGUgZ3JpZDogUGl2b3RHcmlkVHlwZSkgeyB9XG4gICAgcHVibGljIHRyYW5zZm9ybShcbiAgICAgICAgY29sbGVjdGlvbjogSVBpdm90R3JpZFJlY29yZFtdLFxuICAgICAgICBjb25maWc6IElQaXZvdENvbmZpZ3VyYXRpb24sXG4gICAgICAgIF9waXBlVHJpZ2dlcj86IG51bWJlclxuICAgICk6IElQaXZvdEdyaWRIb3Jpem9udGFsR3JvdXBbXSB7XG4gICAgICAgIGlmIChjb2xsZWN0aW9uLmxlbmd0aCA9PT0gMCB8fCBjb25maWcucm93cy5sZW5ndGggPT09IDApIHJldHVybiBbe1xuICAgICAgICAgICAgY29sU3RhcnQ6IDEsXG4gICAgICAgICAgICBjb2xTcGFuOiAxLFxuICAgICAgICAgICAgcm93U3RhcnQ6IDEsXG4gICAgICAgICAgICByb3dTcGFuOiAxLFxuICAgICAgICAgICAgcmVjb3JkczogY29sbGVjdGlvblxuICAgICAgICB9XTtcbiAgICAgICAgY29uc3QgZGF0YTogSVBpdm90R3JpZFJlY29yZFtdID0gY29sbGVjdGlvbiA/IGNsb25lQXJyYXkoY29sbGVjdGlvbiwgdHJ1ZSkgOiBbXTtcbiAgICAgICAgY29uc3QgcmVzOiBJUGl2b3RHcmlkSG9yaXpvbnRhbEdyb3VwW10gPSBbXTtcblxuICAgICAgICAvLyBNZXJnZSB2ZXJ0aWNhbGx5IGZvciBlYWNoIHJvdyBkaW1lbnNpb24uXG4gICAgICAgIGNvbnN0IHZlcnRpY2FsTWVyZ2VHcm91cHM6IElQaXZvdEdyaWRIb3Jpem9udGFsR3JvdXBbXVtdID0gWyAuLi5kYXRhLm1hcChfID0+IFtdKSBdO1xuICAgICAgICBmb3IgKGxldCBkaW1JbmRleCA9IDA7IGRpbUluZGV4IDwgdGhpcy5ncmlkLnZpc2libGVSb3dEaW1lbnNpb25zLmxlbmd0aDsgZGltSW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgY3VyRGltID0gdGhpcy5ncmlkLnZpc2libGVSb3dEaW1lbnNpb25zW2RpbUluZGV4XTtcbiAgICAgICAgICAgIGxldCBjdXJHcm91cDogSVBpdm90R3JpZEhvcml6b250YWxHcm91cCA9IHtcbiAgICAgICAgICAgICAgICBjb2xTdGFydDogZGltSW5kZXggKyAxLFxuICAgICAgICAgICAgICAgIGNvbFNwYW46IDEsXG4gICAgICAgICAgICAgICAgcm93U3RhcnQ6IDEsXG4gICAgICAgICAgICAgICAgcm93U3BhbjogMSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGF0YVswXS5kaW1lbnNpb25WYWx1ZXMuZ2V0KGN1ckRpbS5tZW1iZXJOYW1lKSxcbiAgICAgICAgICAgICAgICByb290RGltZW5zaW9uOiBjdXJEaW0sXG4gICAgICAgICAgICAgICAgZGltZW5zaW9uczogW2N1ckRpbV0sXG4gICAgICAgICAgICAgICAgcmVjb3JkczogW2RhdGFbMF1dXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJSZWMgPSBkYXRhW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1clJlY1ZhbHVlID0gY3VyUmVjLmRpbWVuc2lvblZhbHVlcy5nZXQoY3VyRGltLm1lbWJlck5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzUm93Q2VsbCA9IHZlcnRpY2FsTWVyZ2VHcm91cHNbaV1bdmVydGljYWxNZXJnZUdyb3Vwc1tpXS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoY3VyUmVjVmFsdWUgPT09IGN1ckdyb3VwLnZhbHVlICYmICFwcmV2aW91c1Jvd0NlbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgcHJldmlvdXNSb3dDZWxsIGlzIG5vbiBleGlzdGluZywgaXRzIG1lcmdlZCBzbyB3ZSBjYW4gcHVzaCBpbiB0aGlzIHZlcnRpZ2FsIGdyb3VwIGFzIHdlbGwuXG4gICAgICAgICAgICAgICAgICAgIGN1ckdyb3VwLnJvd1NwYW4rKztcbiAgICAgICAgICAgICAgICAgICAgY3VyR3JvdXAucmVjb3Jkcy5wdXNoKGN1clJlYyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmVydGljYWxNZXJnZUdyb3Vwc1tjdXJHcm91cC5yb3dTdGFydCAtIDFdLnB1c2goY3VyR3JvdXApO1xuICAgICAgICAgICAgICAgICAgICBjdXJHcm91cCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbFN0YXJ0OiBkaW1JbmRleCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xTcGFuOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93U3RhcnQ6IGN1ckdyb3VwLnJvd1N0YXJ0ICsgY3VyR3JvdXAucm93U3BhbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd1NwYW46IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY3VyUmVjLmRpbWVuc2lvblZhbHVlcy5nZXQoY3VyRGltLm1lbWJlck5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdERpbWVuc2lvbjogY3VyRGltLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uczogW2N1ckRpbV0sXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRzOiBbY3VyUmVjXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmVydGljYWxNZXJnZUdyb3Vwc1tjdXJHcm91cC5yb3dTdGFydCAtIDFdLnB1c2goY3VyR3JvdXApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWVyZ2Ugcm93cyBpbiBhIHNpbmdsZSBhcnJheVxuICAgICAgICBjb25zdCBzb3J0ZWRHcm91cHMgPSB2ZXJ0aWNhbE1lcmdlR3JvdXBzLnJlZHVjZSgocHJldiwgY3VyKSA9PiBwcmV2LmNvbmNhdCguLi5jdXIpLCBbXSk7XG5cbiAgICAgICAgLy8gSG9yaXpvbnRhbGx5IG1lcmdlIGFueSBncm91cHMgdGhhdCBjYW4gYmUgbWVyZ2VkIG9yIGhhdmUgYmVlblxuICAgICAgICByZXMucHVzaChzb3J0ZWRHcm91cHNbMF0pO1xuICAgICAgICBsZXQgcHJldkdyb3VwID0gc29ydGVkR3JvdXBzWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNvcnRlZEdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY3VyR3JvdXAgPSBzb3J0ZWRHcm91cHNbaV07XG4gICAgICAgICAgICBpZiAoY3VyR3JvdXAudmFsdWUgJiYgcHJldkdyb3VwLnZhbHVlICE9PSBjdXJHcm91cC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHByZXZHcm91cCA9IGN1ckdyb3VwO1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGN1ckdyb3VwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJldkdyb3VwLmRpbWVuc2lvbnMucHVzaChjdXJHcm91cC5yb290RGltZW5zaW9uKTtcbiAgICAgICAgICAgICAgICBwcmV2R3JvdXAuY29sU3BhbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5AUGlwZSh7XG4gICAgbmFtZTogJ3Bpdm90R3JpZENvbHVtbicsXG4gICAgcHVyZTogdHJ1ZSxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneFBpdm90Q29sdW1uUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuXG4gICAgcHVibGljIHRyYW5zZm9ybShcbiAgICAgICAgY29sbGVjdGlvbjogSVBpdm90R3JpZFJlY29yZFtdLFxuICAgICAgICBjb25maWc6IElQaXZvdENvbmZpZ3VyYXRpb24sXG4gICAgICAgIGNsb25lU3RyYXRlZ3k6IElEYXRhQ2xvbmVTdHJhdGVneSxcbiAgICAgICAgXzogTWFwPGFueSwgYm9vbGVhbj4sXG4gICAgICAgIF9waXBlVHJpZ2dlcj86IG51bWJlcixcbiAgICAgICAgX18/XG4gICAgKTogSVBpdm90R3JpZFJlY29yZFtdIHtcbiAgICAgICAgY29uc3QgcGl2b3RLZXlzID0gY29uZmlnLnBpdm90S2V5cyB8fCBERUZBVUxUX1BJVk9UX0tFWVM7XG4gICAgICAgIGNvbnN0IGVuYWJsZWRDb2x1bW5zID0gY29uZmlnLmNvbHVtbnM/LmZpbHRlcih4ID0+IHguZW5hYmxlZCkgfHwgW107XG4gICAgICAgIGNvbnN0IGVuYWJsZWRWYWx1ZXMgPSBjb25maWcudmFsdWVzPy5maWx0ZXIoeCA9PiB4LmVuYWJsZWQpIHx8IFtdO1xuXG4gICAgICAgIGNvbnN0IGNvbFN0cmF0ZWd5ID0gY29uZmlnLmNvbHVtblN0cmF0ZWd5IHx8IFBpdm90Q29sdW1uRGltZW5zaW9uc1N0cmF0ZWd5Lmluc3RhbmNlKCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjbG9uZUFycmF5KGNvbGxlY3Rpb24sIHRydWUpO1xuICAgICAgICByZXR1cm4gY29sU3RyYXRlZ3kucHJvY2VzcyhkYXRhLCBlbmFibGVkQ29sdW1ucywgZW5hYmxlZFZhbHVlcywgY2xvbmVTdHJhdGVneSwgcGl2b3RLZXlzKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5AUGlwZSh7XG4gICAgbmFtZTogJ3Bpdm90R3JpZEZpbHRlcicsXG4gICAgcHVyZTogdHJ1ZSxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneFBpdm90R3JpZEZpbHRlclBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGdyaWRBUEk6IEdyaWRCYXNlQVBJU2VydmljZTxJZ3hHcmlkQmFzZURpcmVjdGl2ZSAmIEdyaWRUeXBlPikgeyB9XG4gICAgcHVibGljIHRyYW5zZm9ybShjb2xsZWN0aW9uOiBhbnlbXSxcbiAgICAgICAgY29uZmlnOiBJUGl2b3RDb25maWd1cmF0aW9uLFxuICAgICAgICBmaWx0ZXJTdHJhdGVneTogSUZpbHRlcmluZ1N0cmF0ZWd5LFxuICAgICAgICBhZHZhbmNlZEV4cHJlc3Npb25zVHJlZTogSUZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZSxcbiAgICAgICAgX2ZpbHRlclBpcGVUcmlnZ2VyOiBudW1iZXIsXG4gICAgICAgIF9waXBlVHJpZ2dlcjogbnVtYmVyKTogYW55W10ge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uc1RyZWUgPSBQaXZvdFV0aWwuYnVpbGRFeHByZXNzaW9uVHJlZShjb25maWcpO1xuXG4gICAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICAgICAgZXhwcmVzc2lvbnNUcmVlLFxuICAgICAgICAgICAgc3RyYXRlZ3k6IGZpbHRlclN0cmF0ZWd5IHx8IG5ldyBEaW1lbnNpb25WYWx1ZXNGaWx0ZXJpbmdTdHJhdGVneSgpLFxuICAgICAgICAgICAgYWR2YW5jZWRFeHByZXNzaW9uc1RyZWVcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlLmVtcHR5KHN0YXRlLmV4cHJlc3Npb25zVHJlZSkgJiYgRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlLmVtcHR5KHN0YXRlLmFkdmFuY2VkRXhwcmVzc2lvbnNUcmVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBGaWx0ZXJVdGlsLmZpbHRlcihjbG9uZUFycmF5KGNvbGxlY3Rpb24sIHRydWUpLCBzdGF0ZSwgdGhpcy5ncmlkQVBJLmdyaWQpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuXG5cbi8qKlxuICogQGhpZGRlblxuICovXG5AUGlwZSh7XG4gICAgbmFtZTogJ3Bpdm90R3JpZENvbHVtblNvcnQnLFxuICAgIHB1cmU6IHRydWUsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hQaXZvdEdyaWRDb2x1bW5Tb3J0aW5nUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuICAgIHB1YmxpYyB0cmFuc2Zvcm0oXG4gICAgICAgIGNvbGxlY3Rpb246IElQaXZvdEdyaWRSZWNvcmRbXSxcbiAgICAgICAgZXhwcmVzc2lvbnM6IElTb3J0aW5nRXhwcmVzc2lvbltdLFxuICAgICAgICBzb3J0aW5nOiBJR3JpZFNvcnRpbmdTdHJhdGVneSxcbiAgICAgICAgX3BpcGVUcmlnZ2VyOiBudW1iZXJcbiAgICApOiBJUGl2b3RHcmlkUmVjb3JkW10ge1xuICAgICAgICBsZXQgcmVzdWx0OiBJUGl2b3RHcmlkUmVjb3JkW107XG5cbiAgICAgICAgaWYgKCFleHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbGxlY3Rpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGV4cHIgb2YgZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgICAgICBleHByLnN0cmF0ZWd5ID0gRGVmYXVsdFBpdm90R3JpZFJlY29yZFNvcnRpbmdTdHJhdGVneS5pbnN0YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gUGl2b3RVdGlsLnNvcnQoY2xvbmVBcnJheShjb2xsZWN0aW9uLCB0cnVlKSwgZXhwcmVzc2lvbnMsIHNvcnRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQFBpcGUoe1xuICAgIG5hbWU6ICdwaXZvdEdyaWRTb3J0JyxcbiAgICBwdXJlOiB0cnVlLFxuICAgIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgSWd4UGl2b3RHcmlkU29ydGluZ1BpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGdyaWRBUEk6IEdyaWRCYXNlQVBJU2VydmljZTxJZ3hHcmlkQmFzZURpcmVjdGl2ZSAmIEdyaWRUeXBlPikgeyB9XG4gICAgcHVibGljIHRyYW5zZm9ybShjb2xsZWN0aW9uOiBhbnlbXSwgY29uZmlnOiBJUGl2b3RDb25maWd1cmF0aW9uLCBzb3J0aW5nOiBJR3JpZFNvcnRpbmdTdHJhdGVneSwgX3BpcGVUcmlnZ2VyOiBudW1iZXIpOiBhbnlbXSB7XG4gICAgICAgIGxldCByZXN1bHQ6IGFueVtdO1xuICAgICAgICBjb25zdCBhbGxEaW1lbnNpb25zID0gY29uZmlnLnJvd3MgfHwgW107XG4gICAgICAgIGNvbnN0IGVuYWJsZWREaW1lbnNpb25zID0gYWxsRGltZW5zaW9ucy5maWx0ZXIoeCA9PiB4ICYmIHguZW5hYmxlZCk7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25zID0gUGl2b3RTb3J0VXRpbC5nZW5lcmF0ZURpbWVuc2lvblNvcnRpbmdFeHByZXNzaW9ucyhlbmFibGVkRGltZW5zaW9ucyk7XG4gICAgICAgIGlmICghZXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjb2xsZWN0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gRGF0YVV0aWwuc29ydChjbG9uZUFycmF5KGNvbGxlY3Rpb24sIHRydWUpLCBleHByZXNzaW9ucywgc29ydGluZywgdGhpcy5ncmlkQVBJLmdyaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5AUGlwZSh7XG4gICAgbmFtZTogXCJmaWx0ZXJQaXZvdEl0ZW1zXCIsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hGaWx0ZXJQaXZvdEl0ZW1zUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuICAgIHB1YmxpYyB0cmFuc2Zvcm0oXG4gICAgICAgIGNvbGxlY3Rpb246IChJUGl2b3REaW1lbnNpb24gfCBJUGl2b3RWYWx1ZSlbXSxcbiAgICAgICAgZmlsdGVyQ3JpdGVyaWE6IHN0cmluZyxcbiAgICAgICAgX3BpcGVUcmlnZ2VyOiBudW1iZXJcbiAgICApOiBhbnlbXSB7XG4gICAgICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvcHkgPSBjb2xsZWN0aW9uLnNsaWNlKDApO1xuICAgICAgICBpZiAoZmlsdGVyQ3JpdGVyaWEgJiYgZmlsdGVyQ3JpdGVyaWEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyRnVuYyA9IChjKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyVGV4dCA9IGMubWVtYmVyIHx8IGMubWVtYmVyTmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbHRlclRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAudG9Mb2NhbGVMb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmluZGV4T2YoZmlsdGVyQ3JpdGVyaWEudG9Mb2NhbGVMb3dlckNhc2UoKSkgPj0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAoYy5jaGlsZHJlbj8uc29tZShmaWx0ZXJGdW5jKSA/PyBmYWxzZSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvcHkgPSBjb2xsZWN0aW9uLmZpbHRlcihmaWx0ZXJGdW5jKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JpZFN0eWxlQ1NTUHJvcGVydHkge1xuICAgIFtwcm9wOiBzdHJpbmddOiBhbnk7XG59XG5cbkBQaXBlKHtcbiAgICBuYW1lOiAnaWd4UGl2b3RDZWxsU3R5bGVDbGFzc2VzJyxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneFBpdm90R3JpZENlbGxTdHlsZUNsYXNzZXNQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG5cbiAgICBwdWJsaWMgdHJhbnNmb3JtKGNzc0NsYXNzZXM6IEdyaWRTdHlsZUNTU1Byb3BlcnR5LCBfOiBhbnksIHJvd0RhdGE6IElQaXZvdEdyaWRSZWNvcmQsIGNvbHVtbkRhdGE6IElQaXZvdEdyaWRDb2x1bW4sIGluZGV4OiBudW1iZXIsIF9fOiBudW1iZXIpOiBzdHJpbmcge1xuICAgICAgICBpZiAoIWNzc0NsYXNzZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3QgY3NzQ2xhc3Mgb2YgT2JqZWN0LmtleXMoY3NzQ2xhc3NlcykpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrT3JWYWx1ZSA9IGNzc0NsYXNzZXNbY3NzQ2xhc3NdO1xuICAgICAgICAgICAgY29uc3QgYXBwbHkgPSB0eXBlb2YgY2FsbGJhY2tPclZhbHVlID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgICBjYWxsYmFja09yVmFsdWUocm93RGF0YSwgY29sdW1uRGF0YSwgcmVzb2x2ZU5lc3RlZFBhdGgocm93RGF0YSwgY29sdW1uRGF0YS5maWVsZCksIGluZGV4KSA6IGNhbGxiYWNrT3JWYWx1ZTtcbiAgICAgICAgICAgIGlmIChhcHBseSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNzc0NsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignICcpO1xuICAgIH1cbn1cbiJdfQ==