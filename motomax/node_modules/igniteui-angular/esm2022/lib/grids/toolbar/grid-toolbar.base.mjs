import { Directive, Input, EventEmitter, Output, Inject, booleanAttribute } from '@angular/core';
import { Subject } from 'rxjs';
import { first, takeUntil } from 'rxjs/operators';
import { AbsoluteScrollStrategy } from '../../services/overlay/scroll/absolute-scroll-strategy';
import { ColumnDisplayOrder } from '../common/enums';
import { HorizontalAlignment, VerticalAlignment } from '../../services/overlay/utilities';
import { IgxToolbarToken } from './token';
import { ConnectedPositioningStrategy } from '../../services/overlay/position/connected-positioning-strategy';
import * as i0 from "@angular/core";
import * as i1 from "./token";
/* blazorInclude */
/* blazorElement */
/* blazorIndirectRender */
/* blazorAlternateBaseType: GridToolbarBaseAction */
/**
 * Base class for the pinning/hiding column and exporter actions.
 *
 * @hidden @internal
 */
export class BaseToolbarDirective {
    /**
     * Sets overlay settings
     */
    set overlaySettings(overlaySettings) {
        this._overlaySettings = overlaySettings;
    }
    /**
     * Returns overlay settings
     */
    get overlaySettings() {
        return this._overlaySettings;
    }
    /**
     * Returns the grid containing this component.
     * @hidden @internal
     */
    get grid() {
        return this.toolbar.grid;
    }
    constructor(toolbar) {
        this.toolbar = toolbar;
        /**
         * Emits an event before the toggle container is opened.
         */
        this.opening = new EventEmitter();
        /**
         * Emits an event after the toggle container is opened.
         */
        this.opened = new EventEmitter();
        /**
         * Emits an event before the toggle container is closed.
         */
        this.closing = new EventEmitter();
        /**
         * Emits an event after the toggle container is closed.
         */
        this.closed = new EventEmitter();
        /**
         * Emits when after a column's checked state is changed
         */
        this.columnToggle = new EventEmitter();
        this.$destroy = new Subject();
        this._overlaySettings = {
            positionStrategy: new ConnectedPositioningStrategy({
                horizontalDirection: HorizontalAlignment.Left,
                horizontalStartPoint: HorizontalAlignment.Right,
                verticalDirection: VerticalAlignment.Bottom,
                verticalStartPoint: VerticalAlignment.Bottom
            }),
            scrollStrategy: new AbsoluteScrollStrategy(),
            modal: false,
            closeOnEscape: true,
            closeOnOutsideClick: true
        };
    }
    /** @hidden @internal **/
    ngOnDestroy() {
        this.$destroy.next();
        this.$destroy.complete();
    }
    /** @hidden @internal */
    toggle(anchorElement, toggleRef, actions) {
        if (actions) {
            this._setupListeners(toggleRef, actions);
            const setHeight = () => actions.columnsAreaMaxHeight = actions.columnsAreaMaxHeight !== '100%'
                ? actions.columnsAreaMaxHeight :
                this.columnListHeight ??
                    `${Math.max(this.grid.calcHeight * 0.5, 200)}px`;
            toggleRef.opening.pipe(first()).subscribe(setHeight);
        }
        toggleRef.toggle({
            ...this.overlaySettings, ...{
                target: anchorElement, outlet: this.grid.outlet,
                excludeFromOutsideClick: [anchorElement]
            }
        });
    }
    /** @hidden @internal */
    focusSearch(columnActions) {
        columnActions.querySelector('input')?.focus();
    }
    _setupListeners(toggleRef, actions) {
        if (actions) {
            if (!this.$sub || this.$sub.closed) {
                this.$sub = actions.columnToggled.pipe(takeUntil(this.$destroy)).subscribe((event) => this.columnToggle.emit(event));
            }
        }
        /** The if statement prevents emitting open and close events twice  */
        if (toggleRef.collapsed) {
            toggleRef.opening.pipe(first(), takeUntil(this.$destroy)).subscribe((event) => this.opening.emit(event));
            toggleRef.opened.pipe(first(), takeUntil(this.$destroy)).subscribe((event) => this.opened.emit(event));
        }
        else {
            toggleRef.closing.pipe(first(), takeUntil(this.$destroy)).subscribe((event) => this.closing.emit(event));
            toggleRef.closed.pipe(first(), takeUntil(this.$destroy)).subscribe((event) => this.closed.emit(event));
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: BaseToolbarDirective, deps: [{ token: IgxToolbarToken }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.4", type: BaseToolbarDirective, inputs: { columnListHeight: "columnListHeight", title: "title", prompt: "prompt", overlaySettings: "overlaySettings" }, outputs: { opening: "opening", opened: "opened", closing: "closing", closed: "closed", columnToggle: "columnToggle" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: BaseToolbarDirective, decorators: [{
            type: Directive
        }], ctorParameters: () => [{ type: i1.IgxToolbarToken, decorators: [{
                    type: Inject,
                    args: [IgxToolbarToken]
                }] }], propDecorators: { columnListHeight: [{
                type: Input
            }], title: [{
                type: Input
            }], prompt: [{
                type: Input
            }], overlaySettings: [{
                type: Input
            }], opening: [{
                type: Output
            }], opened: [{
                type: Output
            }], closing: [{
                type: Output
            }], closed: [{
                type: Output
            }], columnToggle: [{
                type: Output
            }] } });
/* blazorElement */
/* blazorIndirectRender */
/**
 * @hidden @internal
 * Base class for pinning/hiding column actions
 */
export class BaseToolbarColumnActionsDirective extends BaseToolbarDirective {
    constructor() {
        super(...arguments);
        this.hideFilter = false;
        this.filterCriteria = '';
        this.columnDisplayOrder = ColumnDisplayOrder.DisplayOrder;
        this.columnsAreaMaxHeight = '100%';
        this.indentetion = 30;
    }
    checkAll() {
        this.columnActionsUI.checkAllColumns();
    }
    uncheckAll() {
        this.columnActionsUI.uncheckAllColumns();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: BaseToolbarColumnActionsDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "18.2.4", type: BaseToolbarColumnActionsDirective, inputs: { hideFilter: ["hideFilter", "hideFilter", booleanAttribute], filterCriteria: "filterCriteria", columnDisplayOrder: "columnDisplayOrder", columnsAreaMaxHeight: "columnsAreaMaxHeight", uncheckAllText: "uncheckAllText", checkAllText: "checkAllText", indentetion: "indentetion", buttonText: "buttonText" }, usesInheritance: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: BaseToolbarColumnActionsDirective, decorators: [{
            type: Directive
        }], propDecorators: { hideFilter: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], filterCriteria: [{
                type: Input
            }], columnDisplayOrder: [{
                type: Input
            }], columnsAreaMaxHeight: [{
                type: Input
            }], uncheckAllText: [{
                type: Input
            }], checkAllText: [{
                type: Input
            }], indentetion: [{
                type: Input
            }], buttonText: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC10b29sYmFyLmJhc2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZ3JpZHMvdG9vbGJhci9ncmlkLXRvb2xiYXIuYmFzZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQWEsTUFBTSxFQUFFLE1BQU0sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM1RyxPQUFPLEVBQUUsT0FBTyxFQUFnQixNQUFNLE1BQU0sQ0FBQztBQUM3QyxPQUFPLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRWxELE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLHdEQUF3RCxDQUFDO0FBQ2hHLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBSXJELE9BQU8sRUFBRSxtQkFBbUIsRUFBbUIsaUJBQWlCLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQztBQUMzRyxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sU0FBUyxDQUFDO0FBQzFDLE9BQU8sRUFBRSw0QkFBNEIsRUFBRSxNQUFNLGdFQUFnRSxDQUFDOzs7QUFFOUcsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQiwwQkFBMEI7QUFDMUIsb0RBQW9EO0FBQ3BEOzs7O0dBSUc7QUFFSCxNQUFNLE9BQWdCLG9CQUFvQjtJQW1CdEM7O09BRUc7SUFDSCxJQUNXLGVBQWUsQ0FBQyxlQUFnQztRQUN2RCxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsZUFBZSxDQUFDO0lBQzVDLENBQUM7SUFFRDs7T0FFRztJQUNILElBQVcsZUFBZTtRQUN0QixPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQztJQUNqQyxDQUFDO0lBK0NEOzs7T0FHRztJQUNILElBQVcsSUFBSTtRQUNYLE9BQU8sSUFBSSxDQUFD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QixLQUFLO2dCQUlDLFVBQVU7c0JBRGhCLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBFdmVudEVtaXR0ZXIsIE9uRGVzdHJveSwgT3V0cHV0LCBJbmplY3QsIGJvb2xlYW5BdHRyaWJ1dGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlyc3QsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgQWJzb2x1dGVTY3JvbGxTdHJhdGVneSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL292ZXJsYXkvc2Nyb2xsL2Fic29sdXRlLXNjcm9sbC1zdHJhdGVneSc7XG5pbXBvcnQgeyBDb2x1bW5EaXNwbGF5T3JkZXIgfSBmcm9tICcuLi9jb21tb24vZW51bXMnO1xuaW1wb3J0IHsgSUNvbHVtblRvZ2dsZWRFdmVudEFyZ3MgfSBmcm9tICcuLi9jb21tb24vZXZlbnRzJztcbmltcG9ydCB7IElneENvbHVtbkFjdGlvbnNDb21wb25lbnQgfSBmcm9tICcuLi9jb2x1bW4tYWN0aW9ucy9jb2x1bW4tYWN0aW9ucy5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4VG9nZ2xlRGlyZWN0aXZlLCBUb2dnbGVWaWV3Q2FuY2VsYWJsZUV2ZW50QXJncywgVG9nZ2xlVmlld0V2ZW50QXJncyB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvdG9nZ2xlL3RvZ2dsZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSG9yaXpvbnRhbEFsaWdubWVudCwgT3ZlcmxheVNldHRpbmdzLCBWZXJ0aWNhbEFsaWdubWVudCB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL292ZXJsYXkvdXRpbGl0aWVzJztcbmltcG9ydCB7IElneFRvb2xiYXJUb2tlbiB9IGZyb20gJy4vdG9rZW4nO1xuaW1wb3J0IHsgQ29ubmVjdGVkUG9zaXRpb25pbmdTdHJhdGVneSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL292ZXJsYXkvcG9zaXRpb24vY29ubmVjdGVkLXBvc2l0aW9uaW5nLXN0cmF0ZWd5JztcblxuLyogYmxhem9ySW5jbHVkZSAqL1xuLyogYmxhem9yRWxlbWVudCAqL1xuLyogYmxhem9ySW5kaXJlY3RSZW5kZXIgKi9cbi8qIGJsYXpvckFsdGVybmF0ZUJhc2VUeXBlOiBHcmlkVG9vbGJhckJhc2VBY3Rpb24gKi9cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgdGhlIHBpbm5pbmcvaGlkaW5nIGNvbHVtbiBhbmQgZXhwb3J0ZXIgYWN0aW9ucy5cbiAqXG4gKiBAaGlkZGVuIEBpbnRlcm5hbFxuICovXG5ARGlyZWN0aXZlKClcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlVG9vbGJhckRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBjb2x1bW4gbGlzdCBpbiB0aGUgZHJvcGRvd24uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgY29sdW1uTGlzdEhlaWdodDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGl0bGUgdGV4dCBmb3IgdGhlIGNvbHVtbiBhY3Rpb24gY29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdGl0bGU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBwbGFjZWhvbGRlciB0ZXh0IGZvciB0aGUgc2VhcmNoIGlucHV0LlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHByb21wdDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBvdmVybGF5IHNldHRpbmdzXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IG92ZXJsYXlTZXR0aW5ncyhvdmVybGF5U2V0dGluZ3M6IE92ZXJsYXlTZXR0aW5ncykge1xuICAgICAgICB0aGlzLl9vdmVybGF5U2V0dGluZ3MgPSBvdmVybGF5U2V0dGluZ3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvdmVybGF5IHNldHRpbmdzXG4gICAgICovXG4gICAgcHVibGljIGdldCBvdmVybGF5U2V0dGluZ3MoKTogT3ZlcmxheVNldHRpbmdzIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXlTZXR0aW5ncztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgYmVmb3JlIHRoZSB0b2dnbGUgY29udGFpbmVyIGlzIG9wZW5lZC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb3BlbmluZyA9IG5ldyBFdmVudEVtaXR0ZXI8VG9nZ2xlVmlld0NhbmNlbGFibGVFdmVudEFyZ3M+KCk7XG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgYWZ0ZXIgdGhlIHRvZ2dsZSBjb250YWluZXIgaXMgb3BlbmVkLlxuICAgICAqL1xuXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9wZW5lZCA9IG5ldyBFdmVudEVtaXR0ZXI8VG9nZ2xlVmlld0V2ZW50QXJncz4oKTtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBiZWZvcmUgdGhlIHRvZ2dsZSBjb250YWluZXIgaXMgY2xvc2VkLlxuICAgICAqL1xuXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGNsb3NpbmcgPSBuZXcgRXZlbnRFbWl0dGVyPFRvZ2dsZVZpZXdFdmVudEFyZ3M+KCk7XG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgYWZ0ZXIgdGhlIHRvZ2dsZSBjb250YWluZXIgaXMgY2xvc2VkLlxuICAgICAqL1xuXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGNsb3NlZCA9IG5ldyBFdmVudEVtaXR0ZXI8VG9nZ2xlVmlld0V2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIHdoZW4gYWZ0ZXIgYSBjb2x1bW4ncyBjaGVja2VkIHN0YXRlIGlzIGNoYW5nZWRcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgY29sdW1uVG9nZ2xlID0gbmV3IEV2ZW50RW1pdHRlcjxJQ29sdW1uVG9nZ2xlZEV2ZW50QXJncz4oKTtcblxuICAgIHByaXZhdGUgJGRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAgIHByaXZhdGUgJHN1YjogU3Vic2NyaXB0aW9uO1xuXG4gICAgcHJpdmF0ZSBfb3ZlcmxheVNldHRpbmdzOiBPdmVybGF5U2V0dGluZ3MgPSB7XG4gICAgICAgIHBvc2l0aW9uU3RyYXRlZ3k6IG5ldyBDb25uZWN0ZWRQb3NpdGlvbmluZ1N0cmF0ZWd5KHtcbiAgICAgICAgICAgIGhvcml6b250YWxEaXJlY3Rpb246IEhvcml6b250YWxBbGlnbm1lbnQuTGVmdCxcbiAgICAgICAgICAgIGhvcml6b250YWxTdGFydFBvaW50OiBIb3Jpem9udGFsQWxpZ25tZW50LlJpZ2h0LFxuICAgICAgICAgICAgdmVydGljYWxEaXJlY3Rpb246IFZlcnRpY2FsQWxpZ25tZW50LkJvdHRvbSxcbiAgICAgICAgICAgIHZlcnRpY2FsU3RhcnRQb2ludDogVmVydGljYWxBbGlnbm1lbnQuQm90dG9tXG4gICAgICAgIH0pLFxuICAgICAgICBzY3JvbGxTdHJhdGVneTogbmV3IEFic29sdXRlU2Nyb2xsU3RyYXRlZ3koKSxcbiAgICAgICAgbW9kYWw6IGZhbHNlLFxuICAgICAgICBjbG9zZU9uRXNjYXBlOiB0cnVlLFxuICAgICAgICBjbG9zZU9uT3V0c2lkZUNsaWNrOiB0cnVlXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGdyaWQgY29udGFpbmluZyB0aGlzIGNvbXBvbmVudC5cbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZ3JpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9vbGJhci5ncmlkO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKEBJbmplY3QoSWd4VG9vbGJhclRva2VuKSBwcm90ZWN0ZWQgdG9vbGJhcjogSWd4VG9vbGJhclRva2VuKSB7IH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqKi9cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuJGRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLiRkZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIHRvZ2dsZShhbmNob3JFbGVtZW50OiBIVE1MRWxlbWVudCwgdG9nZ2xlUmVmOiBJZ3hUb2dnbGVEaXJlY3RpdmUsIGFjdGlvbnM/OiBJZ3hDb2x1bW5BY3Rpb25zQ29tcG9uZW50KTogdm9pZCB7XG4gICAgICAgIGlmIChhY3Rpb25zKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXR1cExpc3RlbmVycyh0b2dnbGVSZWYsIGFjdGlvbnMpO1xuICAgICAgICAgICAgY29uc3Qgc2V0SGVpZ2h0ID0gKCkgPT5cbiAgICAgICAgICAgICAgICBhY3Rpb25zLmNvbHVtbnNBcmVhTWF4SGVpZ2h0ID0gYWN0aW9ucy5jb2x1bW5zQXJlYU1heEhlaWdodCAhPT0gJzEwMCUnXG4gICAgICAgICAgICAgICAgICAgID8gYWN0aW9ucy5jb2x1bW5zQXJlYU1heEhlaWdodCA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uTGlzdEhlaWdodCA/P1xuICAgICAgICAgICAgICAgICAgICBgJHtNYXRoLm1heCh0aGlzLmdyaWQuY2FsY0hlaWdodCAqIDAuNSwgMjAwKX1weGA7XG4gICAgICAgICAgICB0b2dnbGVSZWYub3BlbmluZy5waXBlKGZpcnN0KCkpLnN1YnNjcmliZShzZXRIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHRvZ2dsZVJlZi50b2dnbGUoe1xuICAgICAgICAgICAgLi4udGhpcy5vdmVybGF5U2V0dGluZ3MsIC4uLntcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGFuY2hvckVsZW1lbnQsIG91dGxldDogdGhpcy5ncmlkLm91dGxldCxcbiAgICAgICAgICAgICAgICBleGNsdWRlRnJvbU91dHNpZGVDbGljazogW2FuY2hvckVsZW1lbnRdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGZvY3VzU2VhcmNoKGNvbHVtbkFjdGlvbnM6IEhUTUxFbGVtZW50KSB7XG4gICAgICAgIGNvbHVtbkFjdGlvbnMucXVlcnlTZWxlY3RvcignaW5wdXQnKT8uZm9jdXMoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9zZXR1cExpc3RlbmVycyh0b2dnbGVSZWY6IElneFRvZ2dsZURpcmVjdGl2ZSwgYWN0aW9ucz86IElneENvbHVtbkFjdGlvbnNDb21wb25lbnQpIHtcbiAgICAgICAgaWYgKGFjdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy4kc3ViIHx8IHRoaXMuJHN1Yi5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRzdWIgPSBhY3Rpb25zLmNvbHVtblRvZ2dsZWQucGlwZSh0YWtlVW50aWwodGhpcy4kZGVzdHJveSkpLnN1YnNjcmliZSgoZXZlbnQpID0+IHRoaXMuY29sdW1uVG9nZ2xlLmVtaXQoZXZlbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiogVGhlIGlmIHN0YXRlbWVudCBwcmV2ZW50cyBlbWl0dGluZyBvcGVuIGFuZCBjbG9zZSBldmVudHMgdHdpY2UgICovXG4gICAgICAgIGlmICh0b2dnbGVSZWYuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICB0b2dnbGVSZWYub3BlbmluZy5waXBlKGZpcnN0KCksIHRha2VVbnRpbCh0aGlzLiRkZXN0cm95KSkuc3Vic2NyaWJlKChldmVudCkgPT4gdGhpcy5vcGVuaW5nLmVtaXQoZXZlbnQpKTtcbiAgICAgICAgICAgIHRvZ2dsZVJlZi5vcGVuZWQucGlwZShmaXJzdCgpLCB0YWtlVW50aWwodGhpcy4kZGVzdHJveSkpLnN1YnNjcmliZSgoZXZlbnQpID0+IHRoaXMub3BlbmVkLmVtaXQoZXZlbnQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvZ2dsZVJlZi5jbG9zaW5nLnBpcGUoZmlyc3QoKSwgdGFrZVVudGlsKHRoaXMuJGRlc3Ryb3kpKS5zdWJzY3JpYmUoKGV2ZW50KSA9PiB0aGlzLmNsb3NpbmcuZW1pdChldmVudCkpO1xuICAgICAgICAgICAgdG9nZ2xlUmVmLmNsb3NlZC5waXBlKGZpcnN0KCksIHRha2VVbnRpbCh0aGlzLiRkZXN0cm95KSkuc3Vic2NyaWJlKChldmVudCkgPT4gdGhpcy5jbG9zZWQuZW1pdChldmVudCkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKiBibGF6b3JFbGVtZW50ICovXG4vKiBibGF6b3JJbmRpcmVjdFJlbmRlciAqL1xuLyoqXG4gKiBAaGlkZGVuIEBpbnRlcm5hbFxuICogQmFzZSBjbGFzcyBmb3IgcGlubmluZy9oaWRpbmcgY29sdW1uIGFjdGlvbnNcbiAqL1xuQERpcmVjdGl2ZSgpXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVRvb2xiYXJDb2x1bW5BY3Rpb25zRGlyZWN0aXZlIGV4dGVuZHMgQmFzZVRvb2xiYXJEaXJlY3RpdmUge1xuICAgIEBJbnB1dCh7IHRyYW5zZm9ybTogYm9vbGVhbkF0dHJpYnV0ZSB9KVxuICAgIHB1YmxpYyBoaWRlRmlsdGVyID0gZmFsc2U7XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBmaWx0ZXJDcml0ZXJpYSA9ICcnO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgY29sdW1uRGlzcGxheU9yZGVyOiBDb2x1bW5EaXNwbGF5T3JkZXIgPSBDb2x1bW5EaXNwbGF5T3JkZXIuRGlzcGxheU9yZGVyO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgY29sdW1uc0FyZWFNYXhIZWlnaHQgPSAnMTAwJSc7XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB1bmNoZWNrQWxsVGV4dDogc3RyaW5nO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgY2hlY2tBbGxUZXh0OiBzdHJpbmc7XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpbmRlbnRldGlvbiA9IDMwO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgYnV0dG9uVGV4dDogc3RyaW5nO1xuXG4gICAgcHJvdGVjdGVkIGNvbHVtbkFjdGlvbnNVSTogSWd4Q29sdW1uQWN0aW9uc0NvbXBvbmVudDtcblxuICAgIHB1YmxpYyBjaGVja0FsbCgpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5BY3Rpb25zVUkuY2hlY2tBbGxDb2x1bW5zKCk7XG4gICAgfVxuXG4gICAgcHVibGljIHVuY2hlY2tBbGwoKSB7XG4gICAgICAgIHRoaXMuY29sdW1uQWN0aW9uc1VJLnVuY2hlY2tBbGxDb2x1bW5zKCk7XG4gICAgfVxufVxuIl19