import { Component, Inject, Input } from '@angular/core';
import { IgxToolbarToken } from './token';
import { IgxIconComponent } from '../../icon/icon.component';
import { NgClass, NgIf } from '@angular/common';
import { IgxRippleDirective } from '../../directives/ripple/ripple.directive';
import { IgxButtonDirective } from '../../directives/button/button.directive';
import { FilteringExpressionsTree } from '../../data-operations/filtering-expressions-tree';
import * as i0 from "@angular/core";
import * as i1 from "./token";
/* blazorElement */
/* wcElementTag: igc-grid-toolbar-advanced-filtering */
/* blazorIndirectRender */
/* blazorAlternateBaseType: GridToolbarBaseAction */
/* jsonAPIManageItemInMarkup */
/* singleInstanceIdentifier */
/**
 * Provides a pre-configured button to open the advanced filtering dialog of the grid.
 *
 *
 * @igxModule IgxGridToolbarModule
 * @igxParent IgxGridToolbarComponent
 *
 * @example
 * ```html
 * <igx-grid-toolbar-advanced-filtering></igx-grid-toolbar-advanced-filtering>
 * <igx-grid-toolbar-advanced-filtering>Custom text</igx-grid-toolbar-advanced-filtering>
 * ```
 */
export class IgxGridToolbarAdvancedFilteringComponent {
    /**
     * Returns the grid containing this component.
     * @hidden @internal
     */
    get grid() {
        return this.toolbar.grid;
    }
    constructor(toolbar) {
        this.toolbar = toolbar;
        this.grid?.advancedFilteringExpressionsTreeChange.subscribe(filteringTree => {
            this.numberOfColumns = this.extractUniqueFieldNamesFromFilterTree(filteringTree).length;
        });
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        this.numberOfColumns = this.grid?.advancedFilteringExpressionsTree ? this.extractUniqueFieldNamesFromFilterTree(this.grid?.advancedFilteringExpressionsTree).length : 0;
    }
    extractUniqueFieldNamesFromFilterTree(filteringTree) {
        const columnNames = [];
        if (!filteringTree)
            return columnNames;
        filteringTree.filteringOperands.forEach((expr) => {
            if (expr instanceof FilteringExpressionsTree) {
                columnNames.push(...this.extractUniqueFieldNamesFromFilterTree(expr));
            }
            else {
                columnNames.push(expr.fieldName);
            }
        });
        return [...new Set(columnNames)];
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxGridToolbarAdvancedFilteringComponent, deps: [{ token: IgxToolbarToken }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.4", type: IgxGridToolbarAdvancedFilteringComponent, isStandalone: true, selector: "igx-grid-toolbar-advanced-filtering", inputs: { overlaySettings: "overlaySettings" }, ngImport: i0, template: "<button igxButton=\"outlined\" type=\"button\" name=\"btnAdvancedFiltering\" igxRipple\n    [title]=\"grid?.resourceStrings.igx_grid_toolbar_advanced_filtering_button_tooltip\"\n    (click)=\"grid.openAdvancedFilteringDialog(overlaySettings)\"\n    class=\"igx-grid-toolbar__adv-filter\">\n    <igx-icon family=\"default\" name=\"filter_list\"></igx-icon>\n    <span #ref>\n        <ng-content></ng-content>\n    </span>\n    <!-- D.P. fix(elements): Angular trims child nodes, native doesn't leaving white space when other items project\n    textContent (avoids layout trash of innerText) should avoid wiping the default text without user set one -->\n    <span *ngIf=\"!ref.textContent.trim()\">{{ grid?.resourceStrings.igx_grid_toolbar_advanced_filtering_button_label }}</span>\n    <span class=\"igx-adv-filter--column-number\" *ngIf=\"grid?.advancedFilteringExpressionsTree\"> ({{ numberOfColumns }}) </span>\n</button>\n", dependencies: [{ kind: "directive", type: IgxButtonDirective, selector: "[igxButton]", inputs: ["selected", "igxButton", "igxLabel"], outputs: ["buttonSelected"] }, { kind: "directive", type: IgxRippleDirective, selector: "[igxRipple]", inputs: ["igxRippleTarget", "igxRipple", "igxRippleDuration", "igxRippleCentered", "igxRippleDisabled"] }, { kind: "component", type: IgxIconComponent, selector: "igx-icon", inputs: ["family", "name", "active"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxGridToolbarAdvancedFilteringComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-grid-toolbar-advanced-filtering', standalone: true, imports: [IgxButtonDirective, IgxRippleDirective, NgClass, IgxIconComponent, NgIf], template: "<button igxButton=\"outlined\" type=\"button\" name=\"btnAdvancedFiltering\" igxRipple\n    [title]=\"grid?.resourceStrings.igx_grid_toolbar_advanced_filtering_button_tooltip\"\n    (click)=\"grid.openAdvancedFilteringDialog(overlaySettings)\"\n    class=\"igx-grid-toolbar__adv-filter\">\n    <igx-icon family=\"default\" name=\"filter_list\"></igx-icon>\n    <span #ref>\n        <ng-content></ng-content>\n    </span>\n    <!-- D.P. fix(elements): Angular trims child nodes, native doesn't leaving white space when other items project\n    textContent (avoids layout trash of innerText) should avoid wiping the default text without user set one -->\n    <span *ngIf=\"!ref.textContent.trim()\">{{ grid?.resourceStrings.igx_grid_toolbar_advanced_filtering_button_label }}</span>\n    <span class=\"igx-adv-filter--column-number\" *ngIf=\"grid?.advancedFilteringExpressionsTree\"> ({{ numberOfColumns }}) </span>\n</button>\n" }]
        }], ctorParameters: () => [{ type: i1.IgxToolbarToken, decorators: [{
                    type: Inject,
                    args: [IgxToolbarToken]
                }] }], propDecorators: { overlaySettings: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC10b29sYmFyLWFkdmFuY2VkLWZpbHRlcmluZy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZ3JpZHMvdG9vbGJhci9ncmlkLXRvb2xiYXItYWR2YW5jZWQtZmlsdGVyaW5nLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy90b29sYmFyL2dyaWQtdG9vbGJhci1hZHZhbmNlZC1maWx0ZXJpbmcuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFpQixTQUFTLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN4RSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sU0FBUyxDQUFDO0FBRTFDLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQzdELE9BQU8sRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDaEQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sMENBQTBDLENBQUM7QUFDOUUsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sMENBQTBDLENBQUM7QUFDOUUsT0FBTyxFQUFFLHdCQUF3QixFQUE2QixNQUFNLGtEQUFrRCxDQUFDOzs7QUFHdkgsbUJBQW1CO0FBQ25CLHVEQUF1RDtBQUN2RCwwQkFBMEI7QUFDMUIsb0RBQW9EO0FBQ3BELCtCQUErQjtBQUMvQiw4QkFBOEI7QUFDOUI7Ozs7Ozs7Ozs7OztHQVlHO0FBT0gsTUFBTSxPQUFPLHdDQUF3QztJQUVqRDs7O09BR0c7SUFDSCxJQUFXLElBQUk7UUFDWCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO0lBQzdCLENBQUM7SUFLRCxZQUE4QyxPQUF3QjtRQUF4QixZQUFPLEdBQVAsT0FBTyxDQUFpQjtRQUNsRSxJQUFJLENBQUMsSUFBSSxFQUFFLHNDQUFzQyxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsRUFBRTtZQUN4RSxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxxQ0FBcUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxNQUFNLENBQUM7UUFDNUYsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxlQUFlO1FBQ2xCLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRSxnQ0FBZ0MsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLHFDQUFxQyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsZ0NBQWdDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1SyxDQUFDO0lBRVMscUNBQXFDLENBQUMsYUFBeUM7UUFDckYsTUFBTSxXQUFXLEdBQUcsRUFBRSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxhQUFhO1lBQUUsT0FBTyxXQUFXLENBQUM7UUFDdkMsYUFBYSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO1lBQzdDLElBQUksSUFBSSxZQUFZLHdCQUF3QixFQUFFLENBQUM7Z0JBQzNDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMscUNBQXFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUMxRSxDQUFDO2lCQUFNLENBQUM7Z0JBQ0osV0FBVyxDQUFDLElBQUksQ0FBRSxJQUE2QixDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQy9ELENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztRQUNILE9BQU8sQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7SUFDckMsQ0FBQzs4R0FyQ1Esd0NBQXdDLGtCQWE1QixlQUFlO2tHQWIzQix3Q0FBd0MsK0lDbkNyRCxnNkJBYUEsNENEb0JjLGtCQUFrQixvSUFBRSxrQkFBa0IsaUtBQVcsZ0JBQWdCLDJGQUFFLElBQUk7OzJGQUV4RSx3Q0FBd0M7a0JBTnBELFNBQVM7K0JBQ0kscUNBQXFDLGNBRW5DLElBQUksV0FDUCxDQUFDLGtCQUFrQixFQUFFLGtCQUFrQixFQUFFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxJQUFJLENBQUM7OzBCQWVwRSxNQUFNOzJCQUFDLGVBQWU7eUNBRjdCLGVBQWU7c0JBRHJCLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIEluamVjdCwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElneFRvb2xiYXJUb2tlbiB9IGZyb20gJy4vdG9rZW4nO1xuaW1wb3J0IHsgT3ZlcmxheVNldHRpbmdzIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvb3ZlcmxheS91dGlsaXRpZXMnO1xuaW1wb3J0IHsgSWd4SWNvbkNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgTmdDbGFzcywgTmdJZiB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBJZ3hSaXBwbGVEaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL3JpcHBsZS9yaXBwbGUuZGlyZWN0aXZlJztcbmltcG9ydCB7IElneEJ1dHRvbkRpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvYnV0dG9uL2J1dHRvbi5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlLCBJRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2ZpbHRlcmluZy1leHByZXNzaW9ucy10cmVlJztcbmltcG9ydCB7IElGaWx0ZXJpbmdFeHByZXNzaW9uIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2ZpbHRlcmluZy1leHByZXNzaW9uLmludGVyZmFjZSc7XG5cbi8qIGJsYXpvckVsZW1lbnQgKi9cbi8qIHdjRWxlbWVudFRhZzogaWdjLWdyaWQtdG9vbGJhci1hZHZhbmNlZC1maWx0ZXJpbmcgKi9cbi8qIGJsYXpvckluZGlyZWN0UmVuZGVyICovXG4vKiBibGF6b3JBbHRlcm5hdGVCYXNlVHlwZTogR3JpZFRvb2xiYXJCYXNlQWN0aW9uICovXG4vKiBqc29uQVBJTWFuYWdlSXRlbUluTWFya3VwICovXG4vKiBzaW5nbGVJbnN0YW5jZUlkZW50aWZpZXIgKi9cbi8qKlxuICogUHJvdmlkZXMgYSBwcmUtY29uZmlndXJlZCBidXR0b24gdG8gb3BlbiB0aGUgYWR2YW5jZWQgZmlsdGVyaW5nIGRpYWxvZyBvZiB0aGUgZ3JpZC5cbiAqXG4gKlxuICogQGlneE1vZHVsZSBJZ3hHcmlkVG9vbGJhck1vZHVsZVxuICogQGlneFBhcmVudCBJZ3hHcmlkVG9vbGJhckNvbXBvbmVudFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBodG1sXG4gKiA8aWd4LWdyaWQtdG9vbGJhci1hZHZhbmNlZC1maWx0ZXJpbmc+PC9pZ3gtZ3JpZC10b29sYmFyLWFkdmFuY2VkLWZpbHRlcmluZz5cbiAqIDxpZ3gtZ3JpZC10b29sYmFyLWFkdmFuY2VkLWZpbHRlcmluZz5DdXN0b20gdGV4dDwvaWd4LWdyaWQtdG9vbGJhci1hZHZhbmNlZC1maWx0ZXJpbmc+XG4gKiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtZ3JpZC10b29sYmFyLWFkdmFuY2VkLWZpbHRlcmluZycsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2dyaWQtdG9vbGJhci1hZHZhbmNlZC1maWx0ZXJpbmcuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0YW5kYWxvbmU6IHRydWUsXG4gICAgaW1wb3J0czogW0lneEJ1dHRvbkRpcmVjdGl2ZSwgSWd4UmlwcGxlRGlyZWN0aXZlLCBOZ0NsYXNzLCBJZ3hJY29uQ29tcG9uZW50LCBOZ0lmXVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hHcmlkVG9vbGJhckFkdmFuY2VkRmlsdGVyaW5nQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG4gICAgcHJvdGVjdGVkIG51bWJlck9mQ29sdW1uczogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGdyaWQgY29udGFpbmluZyB0aGlzIGNvbXBvbmVudC5cbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZ3JpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9vbGJhci5ncmlkO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIG92ZXJsYXlTZXR0aW5nczogT3ZlcmxheVNldHRpbmdzO1xuXG4gICAgY29uc3RydWN0b3IoIEBJbmplY3QoSWd4VG9vbGJhclRva2VuKSBwcml2YXRlIHRvb2xiYXI6IElneFRvb2xiYXJUb2tlbikge1xuICAgICAgICB0aGlzLmdyaWQ/LmFkdmFuY2VkRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlQ2hhbmdlLnN1YnNjcmliZShmaWx0ZXJpbmdUcmVlID0+IHtcbiAgICAgICAgICAgIHRoaXMubnVtYmVyT2ZDb2x1bW5zID0gdGhpcy5leHRyYWN0VW5pcXVlRmllbGROYW1lc0Zyb21GaWx0ZXJUcmVlKGZpbHRlcmluZ1RyZWUpLmxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubnVtYmVyT2ZDb2x1bW5zID0gdGhpcy5ncmlkPy5hZHZhbmNlZEZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZSA/IHRoaXMuZXh0cmFjdFVuaXF1ZUZpZWxkTmFtZXNGcm9tRmlsdGVyVHJlZSh0aGlzLmdyaWQ/LmFkdmFuY2VkRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlKS5sZW5ndGggOiAwO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBleHRyYWN0VW5pcXVlRmllbGROYW1lc0Zyb21GaWx0ZXJUcmVlKGZpbHRlcmluZ1RyZWU/OiBJRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlKSA6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3QgY29sdW1uTmFtZXMgPSBbXTtcbiAgICAgICAgaWYgKCFmaWx0ZXJpbmdUcmVlKSByZXR1cm4gY29sdW1uTmFtZXM7XG4gICAgICAgIGZpbHRlcmluZ1RyZWUuZmlsdGVyaW5nT3BlcmFuZHMuZm9yRWFjaCgoZXhwcikgPT4ge1xuICAgICAgICAgICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWUpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5OYW1lcy5wdXNoKC4uLnRoaXMuZXh0cmFjdFVuaXF1ZUZpZWxkTmFtZXNGcm9tRmlsdGVyVHJlZShleHByKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbHVtbk5hbWVzLnB1c2goKGV4cHIgYXMgSUZpbHRlcmluZ0V4cHJlc3Npb24pLmZpZWxkTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gWy4uLm5ldyBTZXQoY29sdW1uTmFtZXMpXTtcbiAgICB9XG59XG4iLCI8YnV0dG9uIGlneEJ1dHRvbj1cIm91dGxpbmVkXCIgdHlwZT1cImJ1dHRvblwiIG5hbWU9XCJidG5BZHZhbmNlZEZpbHRlcmluZ1wiIGlneFJpcHBsZVxuICAgIFt0aXRsZV09XCJncmlkPy5yZXNvdXJjZVN0cmluZ3MuaWd4X2dyaWRfdG9vbGJhcl9hZHZhbmNlZF9maWx0ZXJpbmdfYnV0dG9uX3Rvb2x0aXBcIlxuICAgIChjbGljayk9XCJncmlkLm9wZW5BZHZhbmNlZEZpbHRlcmluZ0RpYWxvZyhvdmVybGF5U2V0dGluZ3MpXCJcbiAgICBjbGFzcz1cImlneC1ncmlkLXRvb2xiYXJfX2Fkdi1maWx0ZXJcIj5cbiAgICA8aWd4LWljb24gZmFtaWx5PVwiZGVmYXVsdFwiIG5hbWU9XCJmaWx0ZXJfbGlzdFwiPjwvaWd4LWljb24+XG4gICAgPHNwYW4gI3JlZj5cbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDwvc3Bhbj5cbiAgICA8IS0tIEQuUC4gZml4KGVsZW1lbnRzKTogQW5ndWxhciB0cmltcyBjaGlsZCBub2RlcywgbmF0aXZlIGRvZXNuJ3QgbGVhdmluZyB3aGl0ZSBzcGFjZSB3aGVuIG90aGVyIGl0ZW1zIHByb2plY3RcbiAgICB0ZXh0Q29udGVudCAoYXZvaWRzIGxheW91dCB0cmFzaCBvZiBpbm5lclRleHQpIHNob3VsZCBhdm9pZCB3aXBpbmcgdGhlIGRlZmF1bHQgdGV4dCB3aXRob3V0IHVzZXIgc2V0IG9uZSAtLT5cbiAgICA8c3BhbiAqbmdJZj1cIiFyZWYudGV4dENvbnRlbnQudHJpbSgpXCI+e3sgZ3JpZD8ucmVzb3VyY2VTdHJpbmdzLmlneF9ncmlkX3Rvb2xiYXJfYWR2YW5jZWRfZmlsdGVyaW5nX2J1dHRvbl9sYWJlbCB9fTwvc3Bhbj5cbiAgICA8c3BhbiBjbGFzcz1cImlneC1hZHYtZmlsdGVyLS1jb2x1bW4tbnVtYmVyXCIgKm5nSWY9XCJncmlkPy5hZHZhbmNlZEZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZVwiPiAoe3sgbnVtYmVyT2ZDb2x1bW5zIH19KSA8L3NwYW4+XG48L2J1dHRvbj5cbiJdfQ==