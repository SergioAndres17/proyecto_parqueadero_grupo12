import { Component, ChangeDetectionStrategy, Input, Output, EventEmitter, ContentChild, ViewChildren, QueryList, ViewChild, TemplateRef, HostBinding, ContentChildren, CUSTOM_ELEMENTS_SCHEMA, booleanAttribute } from '@angular/core';
import { NgIf, NgTemplateOutlet, NgClass, NgFor, NgStyle } from '@angular/common';
import { IgxGridBaseDirective } from '../grid-base.directive';
import { IgxGridNavigationService } from '../grid-navigation.service';
import { IgxGridAPIService } from './grid-api.service';
import { cloneArray } from '../../core/utils';
import { IgxGroupByRowTemplateDirective, IgxGridDetailTemplateDirective } from '../grid.directives';
import { IgxGridGroupByRowComponent } from './groupby-row.component';
import { IgxGridForOfDirective } from '../../directives/for-of/for_of.directive';
import { take, takeUntil } from 'rxjs/operators';
import { IgxFilteringService } from '../filtering/grid-filtering.service';
import { IgxColumnResizingService } from '../resizing/resizing.service';
import { IgxGridSummaryService } from '../summaries/grid-summary.service';
import { IgxGridSelectionService } from '../selection/selection.service';
import { IgxForOfSyncService, IgxForOfScrollSyncService } from '../../directives/for-of/for_of.sync.service';
import { IgxGridMRLNavigationService } from '../grid-mrl-navigation.service';
import { FilterMode } from '../common/enums';
import { IGX_GRID_BASE, IGX_GRID_SERVICE_BASE } from '../common/grid.interface';
import { IgxGroupByRowSelectorDirective } from '../selection/row-selectors';
import { IgxGridCRUDService } from '../common/crud.service';
import { IgxGridRow, IgxGroupByRow, IgxSummaryRow } from '../grid-public-row';
import { IgxGridCell } from '../grid-public-cell';
import { IgxGridValidationService } from './grid-validation.service';
import { IgxGridDetailsPipe } from './grid.details.pipe';
import { IgxGridSummaryPipe } from './grid.summary.pipe';
import { IgxGridGroupingPipe, IgxGridPagingPipe, IgxGridSortingPipe, IgxGridFilteringPipe } from './grid.pipes';
import { IgxSummaryDataPipe } from '../summaries/grid-root-summary.pipe';
import { IgxGridTransactionPipe, IgxHasVisibleColumnsPipe, IgxGridRowPinningPipe, IgxGridAddRowPipe, IgxGridRowClassesPipe, IgxGridRowStylesPipe, IgxStringReplacePipe } from '../common/pipes';
import { IgxGridColumnResizerComponent } from '../resizing/resizer.component';
import { IgxRowEditTabStopDirective } from '../grid.rowEdit.directive';
import { IgxIconComponent } from '../../icon/icon.component';
import { IgxRippleDirective } from '../../directives/ripple/ripple.directive';
import { IgxButtonDirective } from '../../directives/button/button.directive';
import { IgxSnackbarComponent } from '../../snackbar/snackbar.component';
import { IgxCircularProgressBarComponent } from '../../progressbar/progressbar.component';
import { IgxOverlayOutletDirective, IgxToggleDirective } from '../../directives/toggle/toggle.directive';
import { IgxSummaryRowComponent } from '../summaries/summary-row.component';
import { IgxGridRowComponent } from './grid-row.component';
import { IgxTemplateOutletDirective } from '../../directives/template-outlet/template_outlet.directive';
import { IgxColumnMovingDropDirective } from '../moving/moving.drop.directive';
import { IgxGridDragSelectDirective } from '../selection/drag-select.directive';
import { IgxGridBodyDirective } from '../grid.common';
import { IgxGridHeaderRowComponent } from '../headers/grid-header-row.component';
import { IgxGridGroupByAreaComponent } from '../grouping/grid-group-by-area.component';
import { Subject } from 'rxjs';
import * as i0 from "@angular/core";
let NEXT_ID = 0;
/* blazorAdditionalDependency: Column */
/* blazorAdditionalDependency: ColumnGroup */
/* blazorAdditionalDependency: ColumnLayout */
/* blazorAdditionalDependency: GridToolbar */
/* blazorAdditionalDependency: GridToolbarActions */
/* blazorAdditionalDependency: GridToolbarTitle */
/* blazorAdditionalDependency: GridToolbarAdvancedFiltering */
/* blazorAdditionalDependency: GridToolbarExporter */
/* blazorAdditionalDependency: GridToolbarHiding */
/* blazorAdditionalDependency: GridToolbarPinning */
/* blazorAdditionalDependency: ActionStrip */
/* blazorAdditionalDependency: GridActionsBaseDirective */
/* blazorAdditionalDependency: GridEditingActions */
/* blazorAdditionalDependency: GridPinningActions */
/* blazorIndirectRender */
/**
 * Grid provides a way to present and manipulate tabular data.
 *
 * @igxModule IgxGridModule
 * @igxGroup Grids & Lists
 * @igxKeywords grid, table
 * @igxTheme igx-grid-theme
 * @remarks
 * The Ignite UI Grid is used for presenting and manipulating tabular data in the simplest way possible.  Once data
 * has been bound, it can be manipulated through filtering, sorting & editing operations.
 * @example
 * ```html
 * <igx-grid [data]="employeeData" [autoGenerate]="false">
 *   <igx-column field="first" header="First Name"></igx-column>
 *   <igx-column field="last" header="Last Name"></igx-column>
 *   <igx-column field="role" header="Role"></igx-column>
 * </igx-grid>
 * ```
 */
export class IgxGridComponent extends IgxGridBaseDirective {
    constructor() {
        super(...arguments);
        /**
         * Emitted when a new chunk of data is loaded from virtualization.
         *
         * @example
         * ```typescript
         *  <igx-grid #grid [data]="localData" [autoGenerate]="true" (dataPreLoad)='handleDataPreloadEvent()'></igx-grid>
         * ```
         */
        this.dataPreLoad = new EventEmitter();
        /**
         * @hidden
         */
        this.groupingExpressionsChange = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.groupingExpansionStateChange = new EventEmitter();
        /**
         * Emitted when columns are grouped/ungrouped.
         *
         * @remarks
         * The `groupingDone` event would be raised only once if several columns get grouped at once by calling
         * the `groupBy()` or `clearGrouping()` API methods and passing an array as an argument.
         * The event arguments provide the `expressions`, `groupedColumns` and `ungroupedColumns` properties, which contain
         * the `ISortingExpression` and the `IgxColumnComponent` related to the grouping/ungrouping operation.
         * Please note that `groupedColumns` and `ungroupedColumns` show only the **newly** changed columns (affected by the **last**
         * grouping/ungrouping operation), not all columns which are currently grouped/ungrouped.
         * columns.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" (groupingDone)="groupingDone($event)" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.groupingDone = new EventEmitter();
        /**
         * Gets/Sets whether created groups are rendered expanded or collapsed.
         *
         * @remarks
         * The default rendered state is expanded.
         * @example
         * ```html
         * <igx-grid #grid [data]="Data" [groupsExpanded]="false" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.groupsExpanded = true;
        /**
         * @hidden @internal
         */
        this.role = 'grid';
        /**
         * Gets/Sets the value of the `id` attribute.
         *
         * @remarks
         * If not provided it will be automatically generated.
         * @example
         * ```html
         * <igx-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.id = `igx-grid-${NEXT_ID++}`;
        this._groupsRecords = [];
        /**
         * @hidden
         */
        this._groupingExpressions = [];
        /**
         * @hidden
         */
        this._groupingExpandState = [];
        this._hideGroupedColumns = false;
        this._dropAreaMessage = null;
        this._showGroupArea = true;
        this.childDetailTemplates = new Map();
        /**
         * @hidden @internal
         */
        this.groupingPerformedSubject = new Subject();
        /**
         * @hidden @internal
         */
        this.groupingPerformed$ = this.groupingPerformedSubject.asObservable();
    }
    /**
     * Returns a reference to the master-detail template.
     * ```typescript
     * let detailTemplate = this.grid.detailTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get detailTemplate() {
        return this._detailTemplate;
    }
    /**
     * Sets the master-detail template.
     * ```html
     * <ng-template #detailTemplate igxGridDetail let-dataItem>
     *    <div>
     *       <div><span class='categoryStyle'>City:</span> {{dataItem.City}}</div>
     *       <div><span class='categoryStyle'>Address:</span> {{dataItem.Address}}</div>
     *    </div>
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'detailTemplate'", {read: TemplateRef })
     * public detailTemplate: TemplateRef<any>;
     * this.grid.detailTemplate = this.detailTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set detailTemplate(template) {
        this._detailTemplate = template;
    }
    /**
     * Gets the hierarchical representation of the group by records.
     *
     * @example
     * ```typescript
     * let groupRecords = this.grid.groupsRecords;
     * ```
     */
    get groupsRecords() {
        return this._groupsRecords;
    }
    /**
     * Gets/Sets the array of data that populates the component.
     *
     * @example
     * ```html
     * <igx-grid [data]="Data" [autoGenerate]="true"></igx-grid>
     * ```
     */
    /* treatAsRef */
    get data() {
        return this._data;
    }
    set data(value) {
        const dataLoaded = (!this._data || this._data.length === 0) && value && value.length > 0;
        const oldData = this._data;
        this._data = value || [];
        this.summaryService.clearSummaryCache();
        if (!this._init) {
            this.validation.updateAll(this._data);
        }
        if (this.autoGenerate && this._data.length > 0 && this.shouldRecreateColumns(oldData, this._data)) {
            this.setupColumns();
        }
        this.cdr.markForCheck();
        if (this.isPercentHeight) {
            this.notifyChanges(true);
        }
        // check if any columns have width auto and if so recalculate their auto-size on data loaded.
        if (dataLoaded && this._columns.some(x => x._width === 'auto')) {
            this.recalculateAutoSizes();
        }
    }
    /**
     * Gets/Sets the total number of records in the data source.
     *
     * @remarks
     * This property is required for remote grid virtualization to function when it is bound to remote data.
     * @example
     * ```typescript
     * const itemCount = this.grid1.totalItemCount;
     * this.grid1.totalItemCount = 55;
     * ```
     */
    set totalItemCount(count) {
        this.verticalScrollContainer.totalItemCount = count;
    }
    get totalItemCount() {
        return this.verticalScrollContainer.totalItemCount;
    }
    get _gridAPI() {
        return this.gridAPI;
    }
    /* mustSetInCodePlatforms: WebComponents;Blazor;React */
    /**
     * Gets/Sets the group by state.
     *
     * @example
     * ```typescript
     * let groupByState = this.grid.groupingExpressions;
     * this.grid.groupingExpressions = [...];
     * ```
     * @remarks
     * Supports two-way data binding.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(groupingExpressions)]="model.groupingExpressions"></igx-grid>
     * ```
     */
    get groupingExpressions() {
        return this._groupingExpressions;
    }
    set groupingExpressions(value) {
        if (this.groupingExpressions === value) {
            return;
        }
        if (value && value.length > 10) {
            throw Error('Maximum amount of grouped columns is 10.');
        }
        const oldExpressions = this.groupingExpressions;
        const newExpressions = value;
        this._groupingExpressions = cloneArray(value);
        this.groupingExpressionsChange.emit(this._groupingExpressions);
        if (this._gridAPI.grid) {
            /* grouping and sorting are working separate from each other */
            this._applyGrouping();
            this.notifyChanges();
        }
        if (!this._init && JSON.stringify(oldExpressions, this.stringifyCallback) !== JSON.stringify(newExpressions, this.stringifyCallback) && this._columns) {
            const groupedCols = [];
            const ungroupedCols = [];
            const groupedColsArr = newExpressions.filter((obj) => !oldExpressions.some((obj2) => obj.fieldName === obj2.fieldName));
            groupedColsArr.forEach((elem) => {
                groupedCols.push(this.getColumnByName(elem.fieldName));
            }, this);
            const ungroupedColsArr = oldExpressions.filter((obj) => !newExpressions.some((obj2) => obj.fieldName === obj2.fieldName));
            ungroupedColsArr.forEach((elem) => {
                ungroupedCols.push(this.getColumnByName(elem.fieldName));
            }, this);
            this.notifyChanges();
            const groupingDoneArgs = {
                expressions: newExpressions,
                groupedColumns: groupedCols,
                ungroupedColumns: ungroupedCols
            };
            this.groupingPerformed$.pipe(take(1)).subscribe(() => {
                this.groupingDone.emit(groupingDoneArgs);
            });
        }
    }
    /**
     * Gets/Sets a list of expansion states for group rows.
     *
     * @remarks
     * Includes only states that differ from the default one (controlled through groupsExpanded and states that the user has changed.
     * Contains the expansion state (expanded: boolean) and the unique identifier for the group row (Array).
     * Supports two-way data binding.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(groupingExpansionState)]="model.groupingExpansionState"></igx-grid>
     * ```
     */
    get groupingExpansionState() {
        return this._groupingExpandState;
    }
    set groupingExpansionState(value) {
        if (value !== this._groupingExpandState) {
            this.groupingExpansionStateChange.emit(value);
        }
        this._groupingExpandState = value;
        if (this.gridAPI.grid) {
            this.cdr.detectChanges();
        }
    }
    /**
     * Gets/Sets whether the grouped columns should be hidden.
     *
     * @remarks
     * The default value is "false"
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [hideGroupedColumns]="true" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get hideGroupedColumns() {
        return this._hideGroupedColumns;
    }
    set hideGroupedColumns(value) {
        if (value) {
            this.groupingDiffer = this.differs.find(this.groupingExpressions).create();
        }
        else {
            this.groupingDiffer = null;
        }
        if (this._columns && this.groupingExpressions) {
            this._setGroupColsVisibility(value);
        }
        this._hideGroupedColumns = value;
    }
    /**
     * Gets/Sets the grouping strategy of the grid.
     *
     * @remarks The default IgxGrouping extends from IgxSorting and a custom one can be used as a `sortStrategy` as well.
     *
     * @example
     * ```html
     *  <igx-grid #grid [data]="localData" [groupStrategy]="groupStrategy"></igx-grid>
     * ```
     */
    get groupStrategy() {
        return this._groupStrategy;
    }
    set groupStrategy(value) {
        this._groupStrategy = value;
    }
    /**
     * Gets/Sets the message displayed inside the GroupBy drop area where columns can be dragged on.
     *
     * @remarks
     * The grid needs to have at least one groupable column in order the GroupBy area to be displayed.
     * @example
     * ```html
     * <igx-grid dropAreaMessage="Drop here to group!">
     *      <igx-column [groupable]="true" field="ID"></igx-column>
     * </igx-grid>
     * ```
     */
    set dropAreaMessage(value) {
        this._dropAreaMessage = value;
        this.notifyChanges();
    }
    get dropAreaMessage() {
        return this._dropAreaMessage || this.resourceStrings.igx_grid_groupByArea_message;
    }
    /**
     * @hidden @internal
     */
    get groupsRowList() {
        const res = new QueryList();
        if (!this._groupsRowList) {
            return res;
        }
        const rList = this._groupsRowList.filter(item => item.element.nativeElement.parentElement !== null)
            .sort((item1, item2) => item1.index - item2.index);
        res.reset(rList);
        return res;
    }
    /**
     * Gets the group by row selector template.
     */
    get groupByRowSelectorTemplate() {
        return this._groupByRowSelectorTemplate || this.groupByRowSelectorsTemplates?.first;
    }
    /**
     * Sets the group by row selector template.
     * ```html
     * <ng-template #template igxGroupByRowSelector let-groupByRowContext>
     * {{ groupByRowContext.selectedCount }} / {{ groupByRowContext.totalCount  }}
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'template'", {read: TemplateRef })
     * public template: TemplateRef<any>;
     * this.grid.groupByRowSelectorTemplate = this.template;
     * ```
     */
    set groupByRowSelectorTemplate(template) {
        this._groupByRowSelectorTemplate = template;
    }
    /**
     * @hidden @internal
     */
    getDetailsContext(rowData, index) {
        return {
            $implicit: rowData,
            index
        };
    }
    /**
     * @hidden @internal
     */
    detailsViewFocused(container, rowIndex) {
        this.navigation.setActiveNode({ row: rowIndex });
    }
    /**
     * @hidden @internal
     */
    get hasDetails() {
        return !!this.detailTemplate;
    }
    /**
     * @hidden @internal
     */
    getRowTemplate(rowData) {
        if (this.isGroupByRecord(rowData)) {
            return this.defaultGroupTemplate;
        }
        else if (this.isSummaryRow(rowData)) {
            return this.summaryTemplate;
        }
        else if (this.hasDetails && this.isDetailRecord(rowData)) {
            return this.detailTemplateContainer;
        }
        else {
            return this.recordTemplate;
        }
    }
    /**
     * @hidden @internal
     */
    isDetailRecord(record) {
        return record && record.detailsData !== undefined;
    }
    /**
     * @hidden @internal
     */
    isDetailActive(rowIndex) {
        return this.navigation.activeNode ? this.navigation.activeNode.row === rowIndex : false;
    }
    /**
     * Gets/Sets the template reference for the group row.
     *
     * @example
     * ```
     * const groupRowTemplate = this.grid.groupRowTemplate;
     * this.grid.groupRowTemplate = myRowTemplate;
     * ```
     */
    get groupRowTemplate() {
        return this._groupRowTemplate;
    }
    set groupRowTemplate(template) {
        this._groupRowTemplate = template;
        this.notifyChanges();
    }
    /**
     * Groups by a new `IgxColumnComponent` based on the provided expression, or modifies an existing one.
     *
     * @remarks
     * Also allows for multiple columns to be grouped at once if an array of `ISortingExpression` is passed.
     * The `groupingDone` event would get raised only **once** if this method gets called multiple times with the same arguments.
     * @example
     * ```typescript
     * this.grid.groupBy({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
     * this.grid.groupBy([
     *     { fieldName: name1, dir: SortingDirection.Asc, ignoreCase: false },
     *     { fieldName: name2, dir: SortingDirection.Desc, ignoreCase: true },
     *     { fieldName: name3, dir: SortingDirection.Desc, ignoreCase: false }
     * ]);
     * ```
     */
    groupBy(expression) {
        if (this.checkIfNoColumnField(expression)) {
            return;
        }
        this.crudService.endEdit(false);
        if (expression instanceof Array) {
            this._gridAPI.groupBy_multiple(expression);
        }
        else {
            this._gridAPI.groupBy(expression);
        }
        this.notifyChanges(true);
    }
    /**
     * Clears grouping for particular column, array of columns or all columns.
     *
     * @remarks
     * Clears all grouping in the grid, if no parameter is passed.
     * If a parameter is provided, clears grouping for a particular column or an array of columns.
     * @example
     * ```typescript
     * this.grid.clearGrouping(); //clears all grouping
     * this.grid.clearGrouping("ID"); //ungroups a single column
     * this.grid.clearGrouping(["ID", "Column1", "Column2"]); //ungroups multiple columns
     * ```
     * @param name Name of column or array of column names to be ungrouped.
     */
    clearGrouping(name) {
        this._gridAPI.clear_groupby(name);
        this.calculateGridSizes();
        this.notifyChanges(true);
        this.groupingPerformedSubject.next();
    }
    /**
     * Returns if a group is expanded or not.
     *
     * @param group The group record.
     * @example
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const expandedGroup = this.grid.isExpandedGroup(this.groupRow);
     * ```
     */
    isExpandedGroup(group) {
        const state = this._getStateForGroupRow(group);
        return state ? state.expanded : this.groupsExpanded;
    }
    /**
     * Toggles the expansion state of a group.
     *
     * @param groupRow The group record to toggle.
     * @example
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const toggleExpGroup = this.grid.toggleGroup(this.groupRow);
     * ```
     */
    toggleGroup(groupRow) {
        this._toggleGroup(groupRow);
        this.notifyChanges();
    }
    /**
     * Select all rows within a group.
     *
     * @param groupRow: The group record which rows would be selected.
     * @param clearCurrentSelection if true clears the current selection
     * @example
     * ```typescript
     * this.grid.selectRowsInGroup(this.groupRow, true);
     * ```
     */
    selectRowsInGroup(groupRow, clearPrevSelection) {
        this._gridAPI.groupBy_select_all_rows_in_group(groupRow, clearPrevSelection);
        this.notifyChanges();
    }
    /**
     * Deselect all rows within a group.
     *
     * @param groupRow The group record which rows would be deselected.
     * @example
     * ```typescript
     * public groupRow: IGroupByRecord;
     * this.grid.deselectRowsInGroup(this.groupRow);
     * ```
     */
    deselectRowsInGroup(groupRow) {
        this._gridAPI.groupBy_deselect_all_rows_in_group(groupRow);
        this.notifyChanges();
    }
    /**
     * Expands the specified group and all of its parent groups.
     *
     * @param groupRow The group record to fully expand.
     * @example
     * ```typescript
     * public groupRow: IGroupByRecord;
     * this.grid.fullyExpandGroup(this.groupRow);
     * ```
     */
    fullyExpandGroup(groupRow) {
        this._fullyExpandGroup(groupRow);
        this.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    isGroupByRecord(record) {
        // return record.records instance of GroupedRecords fails under Webpack
        return record && record?.records && record.records?.length &&
            record.expression && record.expression?.fieldName;
    }
    /**
     * Toggles the expansion state of all group rows recursively.
     *
     * @example
     * ```typescript
     * this.grid.toggleAllGroupRows;
     * ```
     */
    toggleAllGroupRows() {
        this.groupingExpansionState = [];
        this.groupsExpanded = !this.groupsExpanded;
        this.notifyChanges();
    }
    /** @hidden @internal */
    get hasGroupableColumns() {
        return this._columns.some((col) => col.groupable && !col.columnGroup);
    }
    /**
     * Returns whether the `IgxGridComponent` has group area.
     *
     * @example
     * ```typescript
     * let isGroupAreaVisible = this.grid.showGroupArea;
     * ```
     *
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [showGroupArea]="false"></igx-grid>
     * ```
     */
    get showGroupArea() {
        return this._showGroupArea;
    }
    set showGroupArea(value) {
        this._showGroupArea = value;
        this.notifyChanges(true);
    }
    /**
     * @hidden @internal
     */
    isColumnGrouped(fieldName) {
        return this.groupingExpressions.find(exp => exp.fieldName === fieldName) ? true : false;
    }
    /**
     * @hidden @internal
     */
    getContext(rowData, rowIndex, pinned) {
        if (this.isDetailRecord(rowData)) {
            const cachedData = this.childDetailTemplates.get(rowData.detailsData);
            const rowID = this.primaryKey ? rowData.detailsData[this.primaryKey] : rowData.detailsData;
            if (cachedData) {
                const view = cachedData.view;
                const tmlpOutlet = cachedData.owner;
                return {
                    $implicit: rowData.detailsData,
                    moveView: view,
                    owner: tmlpOutlet,
                    index: this.dataView.indexOf(rowData),
                    templateID: {
                        type: 'detailRow',
                        id: rowID
                    }
                };
            }
            else {
                // child rows contain unique grids, hence should have unique templates
                return {
                    $implicit: rowData.detailsData,
                    templateID: {
                        type: 'detailRow',
                        id: rowID
                    },
                    index: this.dataView.indexOf(rowData)
                };
            }
        }
        return {
            $implicit: this.isGhostRecord(rowData) ? rowData.recordRef : rowData,
            index: this.getDataViewIndex(rowIndex, pinned),
            templateID: {
                type: this.isGroupByRecord(rowData) ? 'groupRow' : this.isSummaryRow(rowData) ? 'summaryRow' : 'dataRow',
                id: null
            },
            disabled: this.isGhostRecord(rowData)
        };
    }
    /**
     * @hidden @internal
     */
    viewCreatedHandler(args) {
        if (args.context.templateID.type === 'detailRow') {
            this.childDetailTemplates.set(args.context.$implicit, args);
        }
    }
    /**
     * @hidden @internal
     */
    viewMovedHandler(args) {
        if (args.context.templateID.type === 'detailRow') {
            // view was moved, update owner in cache
            const key = args.context.$implicit;
            const cachedData = this.childDetailTemplates.get(key);
            cachedData.owner = args.owner;
        }
    }
    /**
     * @hidden @internal
     */
    get iconTemplate() {
        if (this.groupsExpanded) {
            return this.headerExpandedIndicatorTemplate || this.defaultExpandedTemplate;
        }
        else {
            return this.headerCollapsedIndicatorTemplate || this.defaultCollapsedTemplate;
        }
    }
    /**
     * @hidden @internal
     */
    ngAfterContentInit() {
        super.ngAfterContentInit();
        if (this.allowFiltering && this.hasColumnLayouts) {
            this.filterMode = FilterMode.excelStyleFilter;
        }
        if (this.groupTemplate) {
            this._groupRowTemplate = this.groupTemplate.template;
        }
        if (this.detailTemplateDirective) {
            this._detailTemplate = this.detailTemplateDirective;
        }
        if (this.hideGroupedColumns && this._columns && this.groupingExpressions) {
            this._setGroupColsVisibility(this.hideGroupedColumns);
        }
        this._setupNavigationService();
    }
    /**
     * @hidden @internal
     */
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this.verticalScrollContainer.beforeViewDestroyed.pipe(takeUntil(this.destroy$)).subscribe((view) => {
            const rowData = view.context.$implicit;
            if (this.isDetailRecord(rowData)) {
                const cachedData = this.childDetailTemplates.get(rowData.detailsData);
                if (cachedData) {
                    const tmlpOutlet = cachedData.owner;
                    tmlpOutlet._viewContainerRef.detach(0);
                }
            }
        });
        this.sortingExpressionsChange.pipe(takeUntil(this.destroy$)).subscribe((sortingExpressions) => {
            if (!this.groupingExpressions || !this.groupingExpressions.length) {
                return;
            }
            sortingExpressions.forEach((sortExpr) => {
                const fieldName = sortExpr.fieldName;
                const groupingExpr = this.groupingExpressions.find(ex => ex.fieldName === fieldName);
                if (groupingExpr) {
                    groupingExpr.dir = sortExpr.dir;
                }
            });
        });
    }
    /**
     * @hidden @internal
     */
    ngOnInit() {
        super.ngOnInit();
        this.trackChanges = (_, rec) => (rec?.detailsData !== undefined ? rec.detailsData : rec);
        this.groupingDone.pipe(takeUntil(this.destroy$)).subscribe((args) => {
            this.crudService.endEdit(false);
            this.summaryService.updateSummaryCache(args);
            this._headerFeaturesWidth = NaN;
        });
    }
    /**
     * @hidden @internal
     */
    ngDoCheck() {
        if (this.groupingDiffer && this._columns && !this.hasColumnLayouts) {
            const changes = this.groupingDiffer.diff(this.groupingExpressions);
            if (changes && this._columns.length > 0) {
                changes.forEachAddedItem((rec) => {
                    const col = this.getColumnByName(rec.item.fieldName);
                    if (col) {
                        col.hidden = true;
                    }
                });
                changes.forEachRemovedItem((rec) => {
                    const col = this.getColumnByName(rec.item.fieldName);
                    col.hidden = false;
                });
            }
        }
        super.ngDoCheck();
    }
    /**
     * @hidden @internal
     */
    dataLoading(event) {
        this.dataPreLoad.emit(event);
    }
    /**
     *
     * Returns an array of the current cell selection in the form of `[{ column.field: cell.value }, ...]`.
     *
     * @remarks
     * If `formatters` is enabled, the cell value will be formatted by its respective column formatter (if any).
     * If `headers` is enabled, it will use the column header (if any) instead of the column field.
     */
    getSelectedData(formatters = false, headers = false) {
        if (this.groupingExpressions.length || this.hasDetails) {
            const source = [];
            const process = (record) => {
                if (record.expression || record.summaries || this.isDetailRecord(record)) {
                    source.push(null);
                    return;
                }
                source.push(record);
            };
            this.dataView.forEach(process);
            return this.extractDataFromSelection(source, formatters, headers);
        }
        else {
            return super.getSelectedData(formatters, headers);
        }
    }
    /**
     * Returns the `IgxGridRow` by index.
     *
     * @example
     * ```typescript
     * const myRow = grid.getRowByIndex(1);
     * ```
     * @param index
     */
    getRowByIndex(index) {
        let row;
        if (index < 0) {
            return undefined;
        }
        if (this.dataView.length >= this.virtualizationState.startIndex + this.virtualizationState.chunkSize) {
            row = this.createRow(index);
        }
        else {
            if (!(index < this.virtualizationState.startIndex) && !(index > this.virtualizationState.startIndex + this.virtualizationState.chunkSize)) {
                row = this.createRow(index);
            }
        }
        if (this.pagingMode === 1 && this.page !== 0) {
            row.index = index + this.perPage * this.page;
        }
        return row;
    }
    /**
     * Returns `IgxGridRow` object by the specified primary key.
     *
     * @remarks
     * Requires that the `primaryKey` property is set.
     * @example
     * ```typescript
     * const myRow = this.grid1.getRowByKey("cell5");
     * ```
     * @param keyValue
     */
    getRowByKey(key) {
        const rec = this.filteredSortedData ? this.primaryKey ?
            this.filteredSortedData.find(record => record[this.primaryKey] === key) :
            this.filteredSortedData.find(record => record === key) : undefined;
        const index = this.dataView.indexOf(rec);
        if (index < 0 || index > this.dataView.length) {
            return undefined;
        }
        return new IgxGridRow(this, index, rec);
    }
    /**
     * @hidden @internal
     */
    allRows() {
        return this.dataView.map((rec, index) => {
            this.pagingMode === 1 && this.page !== 0 ? index = index + this.perPage * this.page : index = this.dataRowList.first.index + index;
            return this.createRow(index);
        });
    }
    /**
     * Returns the collection of `IgxGridRow`s for current page.
     *
     * @hidden @internal
     */
    dataRows() {
        return this.allRows().filter(row => row instanceof IgxGridRow);
    }
    /**
     * Returns an array of the selected `IgxGridCell`s.
     *
     * @example
     * ```typescript
     * const selectedCells = this.grid.selectedCells;
     * ```
     */
    get selectedCells() {
        return this.dataRows().map((row) => row.cells.filter((cell) => cell.selected))
            .reduce((a, b) => a.concat(b), []);
    }
    /**
     * Returns a `CellType` object that matches the conditions.
     *
     * @example
     * ```typescript
     * const myCell = this.grid1.getCellByColumn(2, "UnitPrice");
     * ```
     * @param rowIndex
     * @param columnField
     */
    getCellByColumn(rowIndex, columnField) {
        const row = this.getRowByIndex(rowIndex);
        const column = this._columns.find((col) => col.field === columnField);
        if (row && row instanceof IgxGridRow && !row.data?.detailsData && column) {
            if (this.pagingMode === 1 && this.page !== 0) {
                row.index = rowIndex + this.perPage * this.page;
            }
            return new IgxGridCell(this, row.index, column);
        }
    }
    /**
     * Returns a `CellType` object that matches the conditions.
     *
     * @remarks
     * Requires that the primaryKey property is set.
     * @example
     * ```typescript
     * grid.getCellByKey(1, 'index');
     * ```
     * @param rowSelector match any rowID
     * @param columnField
     */
    getCellByKey(rowSelector, columnField) {
        const row = this.getRowByKey(rowSelector);
        const column = this._columns.find((col) => col.field === columnField);
        if (row && column) {
            return new IgxGridCell(this, row.index, column);
        }
    }
    pinRow(rowID, index) {
        const row = this.getRowByKey(rowID);
        return super.pinRow(rowID, index, row);
    }
    unpinRow(rowID) {
        const row = this.getRowByKey(rowID);
        return super.unpinRow(rowID, row);
    }
    /**
     * @hidden @internal
     */
    createRow(index, data) {
        let row;
        const dataIndex = this._getDataViewIndex(index);
        const rec = data ?? this.dataView[dataIndex];
        if (rec && this.isGroupByRecord(rec)) {
            row = new IgxGroupByRow(this, index, rec);
        }
        if (rec && this.isSummaryRow(rec)) {
            row = new IgxSummaryRow(this, index, rec.summaries);
        }
        // if found record is a no a groupby or summary row, return IgxGridRow instance
        if (!row && rec) {
            row = new IgxGridRow(this, index, rec);
        }
        return row;
    }
    /**
     * @hidden @internal
     */
    get defaultTargetBodyHeight() {
        const allItems = this.totalItemCount || this.dataLength;
        return this.renderedActualRowHeight * Math.min(this._defaultTargetRecordNumber, this.paginator ? Math.min(allItems, this.perPage) : allItems);
    }
    /**
     * @hidden @internal
     */
    getGroupAreaHeight() {
        return this.groupArea ? this.getComputedHeight(this.groupArea.nativeElement) : 0;
    }
    /**
     * @hidden @internal
     */
    onColumnsAddedOrRemoved() {
        // update grouping states
        this.groupablePipeTrigger++;
        if (this.groupingExpressions && this.hideGroupedColumns) {
            this._setGroupColsVisibility(this.hideGroupedColumns);
        }
        super.onColumnsAddedOrRemoved();
    }
    /**
     * @hidden @internal
     */
    scrollTo(row, column) {
        if (this.groupingExpressions && this.groupingExpressions.length
            && typeof (row) !== 'number') {
            const rowIndex = this.groupingResult.indexOf(row);
            const groupByRecord = this.groupingMetadata[rowIndex];
            if (groupByRecord) {
                this._fullyExpandGroup(groupByRecord);
            }
        }
        super.scrollTo(row, column, this.groupingFlatResult);
    }
    /**
     * @hidden @internal
     */
    _getStateForGroupRow(groupRow) {
        return this._gridAPI.groupBy_get_expanded_for_group(groupRow);
    }
    /**
     * @hidden
     */
    _toggleGroup(groupRow) {
        this._gridAPI.groupBy_toggle_group(groupRow);
    }
    /**
     * @hidden @internal
     */
    _fullyExpandGroup(groupRow) {
        this._gridAPI.groupBy_fully_expand_group(groupRow);
    }
    /**
     * @hidden @internal
     */
    _applyGrouping() {
        this._gridAPI.sort_groupBy_multiple(this._groupingExpressions);
    }
    _setupNavigationService() {
        if (this.hasColumnLayouts) {
            this.navigation = new IgxGridMRLNavigationService(this.platform);
            this.navigation.grid = this;
        }
    }
    checkIfNoColumnField(expression) {
        if (expression instanceof Array) {
            for (const singleExpression of expression) {
                if (!singleExpression.fieldName) {
                    return true;
                }
            }
            return false;
        }
        return !expression.fieldName;
    }
    _setGroupColsVisibility(value) {
        if (this._columns.length > 0 && !this.hasColumnLayouts) {
            this.groupingExpressions.forEach((expr) => {
                const col = this.getColumnByName(expr.fieldName);
                col.hidden = value;
            });
        }
    }
    stringifyCallback(key, val) {
        // Workaround for Blazor, since its wrappers inject this externalObject that cannot serialize.
        if (key === 'externalObject') {
            return undefined;
        }
        return val;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxGridComponent, deps: null, target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "18.2.4", type: IgxGridComponent, isStandalone: true, selector: "igx-grid", inputs: { groupsExpanded: ["groupsExpanded", "groupsExpanded", booleanAttribute], dropAreaTemplate: "dropAreaTemplate", detailTemplate: "detailTemplate", id: "id", data: "data", totalItemCount: "totalItemCount", groupingExpressions: "groupingExpressions", groupingExpansionState: "groupingExpansionState", hideGroupedColumns: ["hideGroupedColumns", "hideGroupedColumns", booleanAttribute], groupStrategy: "groupStrategy", dropAreaMessage: "dropAreaMessage", groupByRowSelectorTemplate: "groupByRowSelectorTemplate", groupRowTemplate: "groupRowTemplate", showGroupArea: ["showGroupArea", "showGroupArea", booleanAttribute] }, outputs: { dataPreLoad: "dataPreLoad", groupingExpressionsChange: "groupingExpressionsChange", groupingExpansionStateChange: "groupingExpansionStateChange", groupingDone: "groupingDone" }, host: { properties: { "attr.role": "this.role", "attr.id": "this.id" } }, providers: [
            IgxGridCRUDService,
            IgxGridNavigationService,
            IgxGridSummaryService,
            IgxGridSelectionService,
            IgxGridValidationService,
            { provide: IGX_GRID_SERVICE_BASE, useClass: IgxGridAPIService },
            { provide: IGX_GRID_BASE, useExisting: IgxGridComponent },
            IgxFilteringService,
            IgxColumnResizingService,
            IgxForOfSyncService,
            IgxForOfScrollSyncService,
        ], queries: [{ propertyName: "detailTemplateDirective", first: true, predicate: IgxGridDetailTemplateDirective, descendants: true, read: TemplateRef }, { propertyName: "groupTemplate", first: true, predicate: IgxGroupByRowTemplateDirective, descendants: true, read: IgxGroupByRowTemplateDirective }, { propertyName: "groupByRowSelectorsTemplates", predicate: IgxGroupByRowSelectorDirective, read: TemplateRef }], viewQueries: [{ propertyName: "recordTemplate", first: true, predicate: ["record_template"], descendants: true, read: TemplateRef, static: true }, { propertyName: "detailTemplateContainer", first: true, predicate: ["detail_template_container"], descendants: true, read: TemplateRef, static: true }, { propertyName: "defaultGroupTemplate", first: true, predicate: ["group_template"], descendants: true, read: TemplateRef, static: true }, { propertyName: "summaryTemplate", first: true, predicate: ["summary_template"], descendants: true, read: TemplateRef, static: true }, { propertyName: "_groupsRowList", predicate: IgxGridGroupByRowComponent, descendants: true, read: IgxGridGroupByRowComponent }], usesInheritance: true, ngImport: i0, template: "<!-- Toolbar area -->\n<ng-content select=\"igx-grid-toolbar,igc-grid-toolbar\"></ng-content>\n\n<!-- Group-by area -->\n<ng-container *ngIf=\"showGroupArea && (groupingExpressions.length > 0 || hasGroupableColumns)\">\n    <igx-grid-group-by-area #groupArea [style.flex-basis.px]=\"outerWidth\"\n        [grid]=\"this\"\n        [expressions]=\"groupingExpressions\"\n        [sortingExpressions]=\"sortingExpressions\"\n        [dropAreaTemplate]=\"dropAreaTemplate\"\n        [dropAreaMessage]=\"dropAreaMessage\"\n    >\n    </igx-grid-group-by-area>\n</ng-container>\n\n<!-- Grid table head row area -->\n<igx-grid-header-row class=\"igx-grid-thead\" tabindex=\"0\"\n    [grid]=\"this\"\n    [hasMRL]=\"hasColumnLayouts\"\n    [activeDescendant]=\"activeDescendant\"\n    [width]=\"calcWidth\"\n    [pinnedColumnCollection]=\"pinnedColumns\"\n    [unpinnedColumnCollection]=\"unpinnedColumns\"\n    (keydown.meta.c)=\"copyHandler($event)\"\n    (keydown.control.c)=\"copyHandler($event)\"\n    (copy)=\"copyHandler($event)\"\n    (keydown)=\"navigation.headerNavigation($event)\"\n    (scroll)=\"preventHeaderScroll($event)\"\n    (focus)=\"navigation.focusFirstCell()\"\n>\n</igx-grid-header-row>\n\n<div igxGridBody (keydown.control.c)=\"copyHandler($event)\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\" role=\"rowgroup\">\n    <div class=\"igx-grid__tbody-content\" tabindex=\"0\" [attr.role]=\"dataView.length ? null : 'row'\" (keydown)=\"navigation.handleNavigation($event)\" (focus)=\"navigation.focusTbody($event)\"\n        (dragStop)=\"selectionService.dragMode = $event\" (scroll)=\"preventContainerScroll($event)\"\n        (dragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\"\n        [style.height.px]=\"totalHeight\" [style.width.px]=\"calcWidth || null\" #tbody [attr.aria-activedescendant]=\"activeDescendant\">\n        <span *ngIf=\"moving && columnInDrag && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"moving && columnInDrag && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n    <ng-container *ngTemplateOutlet=\"hasPinnedRecords && isRowPinningToTop ? pinnedRecordsTemplate : null\">\n    </ng-container>\n    <ng-template #pinnedRecordsTemplate>\n        <ng-container *ngIf=\"data\n        | gridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | gridAddRow:true:pipeTrigger\n        | gridRowPinning:id:true:pipeTrigger\n        | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger:true\n        | gridSort:sortingExpressions:groupingExpressions:sortStrategy:id:pipeTrigger:true as pinnedData\">\n            <div #pinContainer *ngIf=\"pinnedData.length > 0\"\n                [ngClass]=\"{\n                    'igx-grid__tr--pinned-bottom':  !isRowPinningToTop,\n                    'igx-grid__tr--pinned-top': isRowPinningToTop\n                }\"\n                class=\"igx-grid__tr--pinned\" [style.width.px]=\"calcWidth\">\n                <ng-container *ngFor=\"let rowData of pinnedData; let rowIndex = index\">\n                    <ng-container *ngTemplateOutlet=\"pinned_record_template; context: getContext(rowData, rowIndex, true)\">\n                    </ng-container>\n                </ng-container>\n            </div>\n        </ng-container>\n    </ng-template>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | gridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger\n        | gridSort:sortingExpressions:groupingExpressions:sortStrategy:id:pipeTrigger\n        | gridGroupBy:groupingExpressions:groupingExpansionState:groupStrategy:groupsExpanded:id:groupsRecords:pipeTrigger\n        | gridPaging:!!paginator:page:perPage:pipeTrigger\n        | gridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:id:showSummaryOnCollapse:pipeTrigger:summaryPipeTrigger\n        | gridDetails:hasDetails:expansionStates:pipeTrigger\n        | gridAddRow:false:pipeTrigger\n        | gridRowPinning:id:false:pipeTrigger\"\n            let-rowIndex=\"index\" [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]=\"verticalScroll\"\n            [igxForContainerSize]=\"calcHeight\"\n            [igxForItemSize]=\"hasColumnLayouts ? rowHeight * multiRowLayoutRowSize + 1 : renderedRowHeight\"\n            [igxForTrackBy]=\"trackChanges\"\n            #verticalScrollContainer (chunkPreload)=\"dataLoading($event)\" (dataChanging)=\"dataRebinding($event)\" (dataChanged)=\"dataRebound($event)\">\n            <ng-template\n                [igxTemplateOutlet]=\"getRowTemplate(rowData)\"\n                [igxTemplateOutletContext]=\"getContext(rowData, rowIndex)\"\n                (cachedViewLoaded)=\"cachedViewLoaded($event)\"\n                (viewCreated)=\"viewCreatedHandler($event)\"\n                (viewMoved)=\"viewMovedHandler($event)\">\n            </ng-template>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && !isRowPinningToTop ? pinnedRecordsTemplate : null\">\n        </ng-container>\n        <ng-template #record_template let-rowIndex=\"index\" let-rowData let-disabledRow=\"disabled\">\n            <igx-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [data]=\"rowData\" [disabled]=\"disabledRow\"\n                [ngClass]=\"rowClasses | igxGridRowClasses:row:row.inEditMode:row.selected:row.dirty:row.deleted:row.dragging:rowIndex:hasColumnLayouts:false:rowData:pipeTrigger\"\n                [ngStyle]=\"rowStyles | igxGridRowStyles:rowData:rowIndex:pipeTrigger\" #row>\n            </igx-grid-row>\n        </ng-template>\n        <ng-template #pinned_record_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [data]=\"rowData\"\n                [ngClass]=\"rowClasses | igxGridRowClasses:row:row.inEditMode:row.selected:row.dirty:row.deleted:row.dragging:rowIndex:hasColumnLayouts:false:rowData:pipeTrigger\"\n                [ngStyle]=\"rowStyles | igxGridRowStyles:rowData:rowIndex:pipeTrigger\"#row #pinnedRow>\n            </igx-grid-row>\n        </ng-template>\n        <ng-template #group_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-groupby-row [gridID]=\"id\" [index]=\"rowIndex\" [groupRow]=\"rowData\" [hideGroupRowSelectors]=\"hideRowSelectors\" [rowDraggable]=\"rowDraggable\" #row>\n            </igx-grid-groupby-row>\n        </ng-template>\n        <ng-template #summary_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-summary-row role=\"row\" [gridID]=\"id\" [summaries]=\"rowData.summaries\" [index]=\"rowIndex\"\n                class=\"igx-grid__summaries--body\" #summaryRow>\n            </igx-grid-summary-row>\n        </ng-template>\n        <ng-template #detail_template_container let-rowIndex=\"index\" let-rowData>\n            <div detail=\"true\" id=\"{{id}}_{{rowIndex}}\" (pointerdown)=\"detailsViewFocused(detailsContainer, rowIndex)\" #detailsContainer [attr.data-rowindex]=\"rowIndex\"\n                [ngClass]=\"{\n                'igx-grid__tr-container': true,\n                'igx-grid__tr-container--active': isDetailActive(rowIndex)\n            }\">\n                <div class=\"igx-grid__hierarchical-indent\">\n                        <ng-container *ngIf=\"this.groupingExpressions.length > 0\">\n                                <div class=\"igx-grid__row-indentation igx-grid__row-indentation--level-{{groupingExpressions.length}}\"></div>\n                        </ng-container>\n                        <ng-template\n                    [ngTemplateOutlet]=\"detailTemplate\"\n                    [ngTemplateOutletContext]=\"getDetailsContext(rowData, rowIndex)\">\n                    </ng-template>\n                </div>\n            </div>\n        </ng-template>\n\n        <ng-container *ngTemplateOutlet=\"template; context: { $implicit: this }\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n        <igc-trial-watermark></igc-trial-watermark>\n    </div>\n    <div igxToggle #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\" *ngIf=\"shouldOverlayLoading\">\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"moving && columnInDrag\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div [hidden]=\"!hasVerticalScroll()\" class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollSize\" (pointerdown)=\"$event.preventDefault()\">\n        <div class=\"igx-grid__tbody-scrollbar-start\" [style.height.px]=\"isRowPinningToTop ? pinnedRowHeight : 0\"></div>\n        <div class=\"igx-grid__tbody-scrollbar-main\" [style.height.px]=\"calcHeight\">\n            <ng-template igxGridFor [igxGridForOf]=\"[]\" #verticalScrollHolder></ng-template>\n        </div>\n        <div class=\"igx-grid__tbody-scrollbar-end\" [style.height.px]=\"!isRowPinningToTop ? pinnedRowHeight : 0\"></div>\n    </div>\n\n    <div class=\"igx-grid__addrow-snackbar\">\n        <igx-snackbar #addRowSnackbar [outlet]=\"igxBodyOverlayOutlet\" [actionText]=\"resourceStrings.igx_grid_snackbar_addrow_actiontext\" [displayTime]=\"snackbarDisplayTime\">{{resourceStrings.igx_grid_snackbar_addrow_label}}</igx-snackbar>\n    </div>\n\n    <div #igxBodyOverlayOutlet=\"overlay-outlet\" igxOverlayOutlet></div>\n    <div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n</div>\n\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]=\"summaryRowHeight\" #tfoot>\n    <div tabindex=\"0\" (focus)=\"navigation.focusFirstCell(false)\" (keydown)=\"navigation.summaryNav($event)\" [attr.aria-activedescendant]=\"activeDescendant\">\n        <igx-grid-summary-row [style.width.px]=\"calcWidth\"  [style.height.px]=\"summaryRowHeight\"\n            *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\" role=\"row\"\n            [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"dataView.length\"\n            class=\"igx-grid__summaries\" #summaryRow>\n        </igx-grid-summary-row>\n        <div class=\"igx-grid__tfoot-thumb\" [hidden]=\"!hasVerticalScroll()\" [style.height.px]=\"summaryRowHeight\"\n            [style.width.px]=\"scrollSize\"></div>\n    </div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height.px]=\"scrollSize\" #scr [hidden]=\"isHorizontalScrollHidden\" (pointerdown)=\"$event.preventDefault()\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]=\"isPinningToStart ? pinnedWidth : headerFeaturesWidth\" [style.min-width.px]=\"isPinningToStart ? pinnedWidth : headerFeaturesWidth\"></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]=\"unpinnedWidth\">\n        <ng-template igxGridFor [igxGridForOf]=\"EMPTY_DATA\" #scrollContainer>\n        </ng-template>\n    </div>\n    <div class=\"igx-grid__scroll-end\" [style.float]=\"'right'\" [style.width.px]=\"pinnedWidth\" [style.min-width.px]=\"pinnedWidth\" [hidden]=\"pinnedWidth === 0 || isPinningToStart\"></div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer,igc-grid-footer\"></ng-content>\n    <ng-content select=\"igx-paginator,igc-paginator\"></ng-content>\n</div>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\" role=\"cell\">\n        <span>{{emptyFilteredGridMessage}}</span>\n        <span *ngIf=\"showAddButton\">\n            <ng-container *ngTemplateOutlet=\"addRowEmptyTemplate || defaultAddRowEmptyTemplate\"></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\" role=\"cell\">\n        <span>{{emptyGridMessage}}</span>\n        <span *ngIf=\"showAddButton\">\n            <ng-container *ngTemplateOutlet=\"addRowEmptyTemplate || defaultAddRowEmptyTemplate\"></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultAddRowEmptyTemplate>\n    <button type=\"button\" igxButton=\"contained\" igxRipple (click)=\"this.crudService.enterAddRowMode(null, false, $event)\">\n        {{resourceStrings.igx_grid_add_row_label}}\n    </button>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<ng-template #defaultExpandedTemplate>\n    <igx-icon\n        family=\"default\"\n        name=\"unfold_less\"\n        role=\"button\"\n        [ngClass]=\"{\n            'igx-grid__group-expand-btn': true,\n            'igx-grid__group-expand-btn--push': filteringService.isFilterRowVisible\n        }\"\n    >\n    </igx-icon>\n</ng-template>\n\n <ng-template #defaultCollapsedTemplate>\n    <igx-icon\n        family=\"default\"\n        name=\"unfold_more\"\n        role=\"button\"\n        [ngClass]=\"{\n            'igx-grid__group-expand-btn': true,\n            'igx-grid__group-expand-btn--push': filteringService.isFilterRowVisible\n        }\"\n    ></igx-icon>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle #rowEditingOverlay>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: this.endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditText>\n    {{ this.resourceStrings.igx_grid_row_edit_text | igxStringReplace:'{0}':rowChangesCount.toString() | igxStringReplace:'{1}':hiddenColumnsCount.toString() }}\n</ng-template>\n\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop type=\"button\" (click)=\"this.endRowEditTabStop(false, $event)\">{{ this.resourceStrings.igx_grid_row_edit_btn_cancel }}</button>\n    <button igxButton igxRowEditTabStop type=\"button\" (click)=\"this.endRowEditTabStop(true, $event)\">{{ this.resourceStrings.igx_grid_row_edit_btn_done }}</button>\n</ng-template>\n\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"this.crudService.row?.getClassName() === 'IgxAddRow' ? rowAddTextTemplate : rowEditTextTemplate ? rowEditTextTemplate : defaultRowEditText;\n                context: { $implicit: this.crudService.row?.getClassName() !== 'IgxAddRow' ? rowChangesCount : null }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActionsTemplate ? rowEditActionsTemplate : defaultRowEditActions; context: { $implicit: this.endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon family=\"default\" name=\"drag_indicator\"></igx-icon>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet></div>\n@if (platform.isElements) {\n    <div #sink style=\"display: none;\">\n        <ng-content select=\"igx-grid-state,igc-grid-state\"></ng-content>\n        <ng-content select=\"igx-column,igc-column,igx-column-group,igc-column-group,igx-column-layout,igc-column-layout,igx-action-strip,igc-action-strip\"></ng-content>\n    </div>\n}\n", dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: IgxGridGroupByAreaComponent, selector: "igx-grid-group-by-area", inputs: ["sortingExpressions", "grid"] }, { kind: "component", type: IgxGridHeaderRowComponent, selector: "igx-grid-header-row", inputs: ["grid", "pinnedColumnCollection", "unpinnedColumnCollection", "activeDescendant", "hasMRL", "width"] }, { kind: "directive", type: IgxGridBodyDirective, selector: "[igxGridBody]" }, { kind: "directive", type: IgxGridDragSelectDirective, selector: "[igxGridDragSelect]", inputs: ["igxGridDragSelect"], outputs: ["dragStop", "dragScroll"] }, { kind: "directive", type: IgxColumnMovingDropDirective, selector: "[igxColumnMovingDrop]", inputs: ["igxColumnMovingDrop"] }, { kind: "directive", type: IgxGridForOfDirective, selector: "[igxGridFor][igxGridForOf]", inputs: ["igxGridForOf", "igxGridForOfUniqueSizeCache", "igxGridForOfVariableSizes"], outputs: ["dataChanging"] }, { kind: "directive", type: IgxTemplateOutletDirective, selector: "[igxTemplateOutlet]", inputs: ["igxTemplateOutletContext", "igxTemplateOutlet"], outputs: ["viewCreated", "viewMoved", "cachedViewLoaded", "beforeViewDetach"] }, { kind: "component", type: IgxGridRowComponent, selector: "igx-grid-row" }, { kind: "component", type: IgxGridGroupByRowComponent, selector: "igx-grid-groupby-row", inputs: ["hideGroupRowSelectors", "rowDraggable", "index", "gridID", "groupRow", "isFocused"] }, { kind: "component", type: IgxSummaryRowComponent, selector: "igx-grid-summary-row", inputs: ["summaries", "gridID", "index", "firstCellIndentation"] }, { kind: "directive", type: IgxOverlayOutletDirective, selector: "[igxOverlayOutlet]", exportAs: ["overlay-outlet"] }, { kind: "directive", type: IgxToggleDirective, selector: "[igxToggle]", inputs: ["id"], outputs: ["opened", "opening", "closed", "closing", "appended"], exportAs: ["toggle"] }, { kind: "component", type: IgxCircularProgressBarComponent, selector: "igx-circular-bar", inputs: ["id", "isIndeterminate", "textVisibility", "text"] }, { kind: "component", type: IgxSnackbarComponent, selector: "igx-snackbar", inputs: ["id", "actionText", "positionSettings"], outputs: ["clicked", "animationStarted", "animationDone"] }, { kind: "directive", type: IgxButtonDirective, selector: "[igxButton]", inputs: ["selected", "igxButton", "igxLabel"], outputs: ["buttonSelected"] }, { kind: "directive", type: IgxRippleDirective, selector: "[igxRipple]", inputs: ["igxRippleTarget", "igxRipple", "igxRippleDuration", "igxRippleCentered", "igxRippleDisabled"] }, { kind: "component", type: IgxIconComponent, selector: "igx-icon", inputs: ["family", "name", "active"] }, { kind: "directive", type: IgxRowEditTabStopDirective, selector: "[igxRowEditTabStop]" }, { kind: "component", type: IgxGridColumnResizerComponent, selector: "igx-grid-column-resizer", inputs: ["restrictResizerTop"] }, { kind: "pipe", type: IgxGridTransactionPipe, name: "gridTransaction" }, { kind: "pipe", type: IgxHasVisibleColumnsPipe, name: "visibleColumns" }, { kind: "pipe", type: IgxGridRowPinningPipe, name: "gridRowPinning" }, { kind: "pipe", type: IgxGridAddRowPipe, name: "gridAddRow" }, { kind: "pipe", type: IgxGridRowClassesPipe, name: "igxGridRowClasses" }, { kind: "pipe", type: IgxGridRowStylesPipe, name: "igxGridRowStyles" }, { kind: "pipe", type: IgxSummaryDataPipe, name: "igxGridSummaryDataPipe" }, { kind: "pipe", type: IgxGridGroupingPipe, name: "gridGroupBy" }, { kind: "pipe", type: IgxGridPagingPipe, name: "gridPaging" }, { kind: "pipe", type: IgxGridSortingPipe, name: "gridSort" }, { kind: "pipe", type: IgxGridFilteringPipe, name: "gridFiltering" }, { kind: "pipe", type: IgxGridSummaryPipe, name: "gridSummary" }, { kind: "pipe", type: IgxGridDetailsPipe, name: "gridDetails" }, { kind: "pipe", type: IgxStringReplacePipe, name: "igxStringReplace" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxGridComponent, decorators: [{
            type: Component,
            args: [{ changeDetection: ChangeDetectionStrategy.OnPush, preserveWhitespaces: false, providers: [
                        IgxGridCRUDService,
                        IgxGridNavigationService,
                        IgxGridSummaryService,
                        IgxGridSelectionService,
                        IgxGridValidationService,
                        { provide: IGX_GRID_SERVICE_BASE, useClass: IgxGridAPIService },
                        { provide: IGX_GRID_BASE, useExisting: IgxGridComponent },
                        IgxFilteringService,
                        IgxColumnResizingService,
                        IgxForOfSyncService,
                        IgxForOfScrollSyncService,
                    ], selector: 'igx-grid', standalone: true, imports: [
                        NgIf,
                        NgClass,
                        NgFor,
                        NgStyle,
                        NgTemplateOutlet,
                        IgxGridGroupByAreaComponent,
                        IgxGridHeaderRowComponent,
                        IgxGridBodyDirective,
                        IgxGridDragSelectDirective,
                        IgxColumnMovingDropDirective,
                        IgxGridForOfDirective,
                        IgxTemplateOutletDirective,
                        IgxGridRowComponent,
                        IgxGridGroupByRowComponent,
                        IgxSummaryRowComponent,
                        IgxOverlayOutletDirective,
                        IgxToggleDirective,
                        IgxCircularProgressBarComponent,
                        IgxSnackbarComponent,
                        IgxButtonDirective,
                        IgxRippleDirective,
                        IgxIconComponent,
                        IgxRowEditTabStopDirective,
                        IgxGridColumnResizerComponent,
                        IgxGridTransactionPipe,
                        IgxHasVisibleColumnsPipe,
                        IgxGridRowPinningPipe,
                        IgxGridAddRowPipe,
                        IgxGridRowClassesPipe,
                        IgxGridRowStylesPipe,
                        IgxSummaryDataPipe,
                        IgxGridGroupingPipe,
                        IgxGridPagingPipe,
                        IgxGridSortingPipe,
                        IgxGridFilteringPipe,
                        IgxGridSummaryPipe,
                        IgxGridDetailsPipe,
                        IgxStringReplacePipe
                    ], schemas: [CUSTOM_ELEMENTS_SCHEMA], template: "<!-- Toolbar area -->\n<ng-content select=\"igx-grid-toolbar,igc-grid-toolbar\"></ng-content>\n\n<!-- Group-by area -->\n<ng-container *ngIf=\"showGroupArea && (groupingExpressions.length > 0 || hasGroupableColumns)\">\n    <igx-grid-group-by-area #groupArea [style.flex-basis.px]=\"outerWidth\"\n        [grid]=\"this\"\n        [expressions]=\"groupingExpressions\"\n        [sortingExpressions]=\"sortingExpressions\"\n        [dropAreaTemplate]=\"dropAreaTemplate\"\n        [dropAreaMessage]=\"dropAreaMessage\"\n    >\n    </igx-grid-group-by-area>\n</ng-container>\n\n<!-- Grid table head row area -->\n<igx-grid-header-row class=\"igx-grid-thead\" tabindex=\"0\"\n    [grid]=\"this\"\n    [hasMRL]=\"hasColumnLayouts\"\n    [activeDescendant]=\"activeDescendant\"\n    [width]=\"calcWidth\"\n    [pinnedColumnCollection]=\"pinnedColumns\"\n    [unpinnedColumnCollection]=\"unpinnedColumns\"\n    (keydown.meta.c)=\"copyHandler($event)\"\n    (keydown.control.c)=\"copyHandler($event)\"\n    (copy)=\"copyHandler($event)\"\n    (keydown)=\"navigation.headerNavigation($event)\"\n    (scroll)=\"preventHeaderScroll($event)\"\n    (focus)=\"navigation.focusFirstCell()\"\n>\n</igx-grid-header-row>\n\n<div igxGridBody (keydown.control.c)=\"copyHandler($event)\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\" role=\"rowgroup\">\n    <div class=\"igx-grid__tbody-content\" tabindex=\"0\" [attr.role]=\"dataView.length ? null : 'row'\" (keydown)=\"navigation.handleNavigation($event)\" (focus)=\"navigation.focusTbody($event)\"\n        (dragStop)=\"selectionService.dragMode = $event\" (scroll)=\"preventContainerScroll($event)\"\n        (dragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\"\n        [style.height.px]=\"totalHeight\" [style.width.px]=\"calcWidth || null\" #tbody [attr.aria-activedescendant]=\"activeDescendant\">\n        <span *ngIf=\"moving && columnInDrag && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"moving && columnInDrag && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n    <ng-container *ngTemplateOutlet=\"hasPinnedRecords && isRowPinningToTop ? pinnedRecordsTemplate : null\">\n    </ng-container>\n    <ng-template #pinnedRecordsTemplate>\n        <ng-container *ngIf=\"data\n        | gridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | gridAddRow:true:pipeTrigger\n        | gridRowPinning:id:true:pipeTrigger\n        | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger:true\n        | gridSort:sortingExpressions:groupingExpressions:sortStrategy:id:pipeTrigger:true as pinnedData\">\n            <div #pinContainer *ngIf=\"pinnedData.length > 0\"\n                [ngClass]=\"{\n                    'igx-grid__tr--pinned-bottom':  !isRowPinningToTop,\n                    'igx-grid__tr--pinned-top': isRowPinningToTop\n                }\"\n                class=\"igx-grid__tr--pinned\" [style.width.px]=\"calcWidth\">\n                <ng-container *ngFor=\"let rowData of pinnedData; let rowIndex = index\">\n                    <ng-container *ngTemplateOutlet=\"pinned_record_template; context: getContext(rowData, rowIndex, true)\">\n                    </ng-container>\n                </ng-container>\n            </div>\n        </ng-container>\n    </ng-template>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | gridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger\n        | gridSort:sortingExpressions:groupingExpressions:sortStrategy:id:pipeTrigger\n        | gridGroupBy:groupingExpressions:groupingExpansionState:groupStrategy:groupsExpanded:id:groupsRecords:pipeTrigger\n        | gridPaging:!!paginator:page:perPage:pipeTrigger\n        | gridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:id:showSummaryOnCollapse:pipeTrigger:summaryPipeTrigger\n        | gridDetails:hasDetails:expansionStates:pipeTrigger\n        | gridAddRow:false:pipeTrigger\n        | gridRowPinning:id:false:pipeTrigger\"\n            let-rowIndex=\"index\" [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]=\"verticalScroll\"\n            [igxForContainerSize]=\"calcHeight\"\n            [igxForItemSize]=\"hasColumnLayouts ? rowHeight * multiRowLayoutRowSize + 1 : renderedRowHeight\"\n            [igxForTrackBy]=\"trackChanges\"\n            #verticalScrollContainer (chunkPreload)=\"dataLoading($event)\" (dataChanging)=\"dataRebinding($event)\" (dataChanged)=\"dataRebound($event)\">\n            <ng-template\n                [igxTemplateOutlet]=\"getRowTemplate(rowData)\"\n                [igxTemplateOutletContext]=\"getContext(rowData, rowIndex)\"\n                (cachedViewLoaded)=\"cachedViewLoaded($event)\"\n                (viewCreated)=\"viewCreatedHandler($event)\"\n                (viewMoved)=\"viewMovedHandler($event)\">\n            </ng-template>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && !isRowPinningToTop ? pinnedRecordsTemplate : null\">\n        </ng-container>\n        <ng-template #record_template let-rowIndex=\"index\" let-rowData let-disabledRow=\"disabled\">\n            <igx-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [data]=\"rowData\" [disabled]=\"disabledRow\"\n                [ngClass]=\"rowClasses | igxGridRowClasses:row:row.inEditMode:row.selected:row.dirty:row.deleted:row.dragging:rowIndex:hasColumnLayouts:false:rowData:pipeTrigger\"\n                [ngStyle]=\"rowStyles | igxGridRowStyles:rowData:rowIndex:pipeTrigger\" #row>\n            </igx-grid-row>\n        </ng-template>\n        <ng-template #pinned_record_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [data]=\"rowData\"\n                [ngClass]=\"rowClasses | igxGridRowClasses:row:row.inEditMode:row.selected:row.dirty:row.deleted:row.dragging:rowIndex:hasColumnLayouts:false:rowData:pipeTrigger\"\n                [ngStyle]=\"rowStyles | igxGridRowStyles:rowData:rowIndex:pipeTrigger\"#row #pinnedRow>\n            </igx-grid-row>\n        </ng-template>\n        <ng-template #group_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-groupby-row [gridID]=\"id\" [index]=\"rowIndex\" [groupRow]=\"rowData\" [hideGroupRowSelectors]=\"hideRowSelectors\" [rowDraggable]=\"rowDraggable\" #row>\n            </igx-grid-groupby-row>\n        </ng-template>\n        <ng-template #summary_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-summary-row role=\"row\" [gridID]=\"id\" [summaries]=\"rowData.summaries\" [index]=\"rowIndex\"\n                class=\"igx-grid__summaries--body\" #summaryRow>\n            </igx-grid-summary-row>\n        </ng-template>\n        <ng-template #detail_template_container let-rowIndex=\"index\" let-rowData>\n            <div detail=\"true\" id=\"{{id}}_{{rowIndex}}\" (pointerdown)=\"detailsViewFocused(detailsContainer, rowIndex)\" #detailsContainer [attr.data-rowindex]=\"rowIndex\"\n                [ngClass]=\"{\n                'igx-grid__tr-container': true,\n                'igx-grid__tr-container--active': isDetailActive(rowIndex)\n            }\">\n                <div class=\"igx-grid__hierarchical-indent\">\n                        <ng-container *ngIf=\"this.groupingExpressions.length > 0\">\n                                <div class=\"igx-grid__row-indentation igx-grid__row-indentation--level-{{groupingExpressions.length}}\"></div>\n                        </ng-container>\n                        <ng-template\n                    [ngTemplateOutlet]=\"detailTemplate\"\n                    [ngTemplateOutletContext]=\"getDetailsContext(rowData, rowIndex)\">\n                    </ng-template>\n                </div>\n            </div>\n        </ng-template>\n\n        <ng-container *ngTemplateOutlet=\"template; context: { $implicit: this }\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n        <igc-trial-watermark></igc-trial-watermark>\n    </div>\n    <div igxToggle #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\" *ngIf=\"shouldOverlayLoading\">\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"moving && columnInDrag\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div [hidden]=\"!hasVerticalScroll()\" class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollSize\" (pointerdown)=\"$event.preventDefault()\">\n        <div class=\"igx-grid__tbody-scrollbar-start\" [style.height.px]=\"isRowPinningToTop ? pinnedRowHeight : 0\"></div>\n        <div class=\"igx-grid__tbody-scrollbar-main\" [style.height.px]=\"calcHeight\">\n            <ng-template igxGridFor [igxGridForOf]=\"[]\" #verticalScrollHolder></ng-template>\n        </div>\n        <div class=\"igx-grid__tbody-scrollbar-end\" [style.height.px]=\"!isRowPinningToTop ? pinnedRowHeight : 0\"></div>\n    </div>\n\n    <div class=\"igx-grid__addrow-snackbar\">\n        <igx-snackbar #addRowSnackbar [outlet]=\"igxBodyOverlayOutlet\" [actionText]=\"resourceStrings.igx_grid_snackbar_addrow_actiontext\" [displayTime]=\"snackbarDisplayTime\">{{resourceStrings.igx_grid_snackbar_addrow_label}}</igx-snackbar>\n    </div>\n\n    <div #igxBodyOverlayOutlet=\"overlay-outlet\" igxOverlayOutlet></div>\n    <div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n</div>\n\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]=\"summaryRowHeight\" #tfoot>\n    <div tabindex=\"0\" (focus)=\"navigation.focusFirstCell(false)\" (keydown)=\"navigation.summaryNav($event)\" [attr.aria-activedescendant]=\"activeDescendant\">\n        <igx-grid-summary-row [style.width.px]=\"calcWidth\"  [style.height.px]=\"summaryRowHeight\"\n            *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\" role=\"row\"\n            [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"dataView.length\"\n            class=\"igx-grid__summaries\" #summaryRow>\n        </igx-grid-summary-row>\n        <div class=\"igx-grid__tfoot-thumb\" [hidden]=\"!hasVerticalScroll()\" [style.height.px]=\"summaryRowHeight\"\n            [style.width.px]=\"scrollSize\"></div>\n    </div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height.px]=\"scrollSize\" #scr [hidden]=\"isHorizontalScrollHidden\" (pointerdown)=\"$event.preventDefault()\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]=\"isPinningToStart ? pinnedWidth : headerFeaturesWidth\" [style.min-width.px]=\"isPinningToStart ? pinnedWidth : headerFeaturesWidth\"></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]=\"unpinnedWidth\">\n        <ng-template igxGridFor [igxGridForOf]=\"EMPTY_DATA\" #scrollContainer>\n        </ng-template>\n    </div>\n    <div class=\"igx-grid__scroll-end\" [style.float]=\"'right'\" [style.width.px]=\"pinnedWidth\" [style.min-width.px]=\"pinnedWidth\" [hidden]=\"pinnedWidth === 0 || isPinningToStart\"></div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer,igc-grid-footer\"></ng-content>\n    <ng-content select=\"igx-paginator,igc-paginator\"></ng-content>\n</div>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\" role=\"cell\">\n        <span>{{emptyFilteredGridMessage}}</span>\n        <span *ngIf=\"showAddButton\">\n            <ng-container *ngTemplateOutlet=\"addRowEmptyTemplate || defaultAddRowEmptyTemplate\"></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\" role=\"cell\">\n        <span>{{emptyGridMessage}}</span>\n        <span *ngIf=\"showAddButton\">\n            <ng-container *ngTemplateOutlet=\"addRowEmptyTemplate || defaultAddRowEmptyTemplate\"></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultAddRowEmptyTemplate>\n    <button type=\"button\" igxButton=\"contained\" igxRipple (click)=\"this.crudService.enterAddRowMode(null, false, $event)\">\n        {{resourceStrings.igx_grid_add_row_label}}\n    </button>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<ng-template #defaultExpandedTemplate>\n    <igx-icon\n        family=\"default\"\n        name=\"unfold_less\"\n        role=\"button\"\n        [ngClass]=\"{\n            'igx-grid__group-expand-btn': true,\n            'igx-grid__group-expand-btn--push': filteringService.isFilterRowVisible\n        }\"\n    >\n    </igx-icon>\n</ng-template>\n\n <ng-template #defaultCollapsedTemplate>\n    <igx-icon\n        family=\"default\"\n        name=\"unfold_more\"\n        role=\"button\"\n        [ngClass]=\"{\n            'igx-grid__group-expand-btn': true,\n            'igx-grid__group-expand-btn--push': filteringService.isFilterRowVisible\n        }\"\n    ></igx-icon>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle #rowEditingOverlay>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: this.endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditText>\n    {{ this.resourceStrings.igx_grid_row_edit_text | igxStringReplace:'{0}':rowChangesCount.toString() | igxStringReplace:'{1}':hiddenColumnsCount.toString() }}\n</ng-template>\n\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop type=\"button\" (click)=\"this.endRowEditTabStop(false, $event)\">{{ this.resourceStrings.igx_grid_row_edit_btn_cancel }}</button>\n    <button igxButton igxRowEditTabStop type=\"button\" (click)=\"this.endRowEditTabStop(true, $event)\">{{ this.resourceStrings.igx_grid_row_edit_btn_done }}</button>\n</ng-template>\n\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"this.crudService.row?.getClassName() === 'IgxAddRow' ? rowAddTextTemplate : rowEditTextTemplate ? rowEditTextTemplate : defaultRowEditText;\n                context: { $implicit: this.crudService.row?.getClassName() !== 'IgxAddRow' ? rowChangesCount : null }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActionsTemplate ? rowEditActionsTemplate : defaultRowEditActions; context: { $implicit: this.endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon family=\"default\" name=\"drag_indicator\"></igx-icon>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet></div>\n@if (platform.isElements) {\n    <div #sink style=\"display: none;\">\n        <ng-content select=\"igx-grid-state,igc-grid-state\"></ng-content>\n        <ng-content select=\"igx-column,igc-column,igx-column-group,igc-column-group,igx-column-layout,igc-column-layout,igx-action-strip,igc-action-strip\"></ng-content>\n    </div>\n}\n" }]
        }], propDecorators: { dataPreLoad: [{
                type: Output
            }], groupingExpressionsChange: [{
                type: Output
            }], groupingExpansionStateChange: [{
                type: Output
            }], groupingDone: [{
                type: Output
            }], groupsExpanded: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], dropAreaTemplate: [{
                type: Input
            }], detailTemplateDirective: [{
                type: ContentChild,
                args: [IgxGridDetailTemplateDirective, { read: TemplateRef }]
            }], detailTemplate: [{
                type: Input,
                args: ['detailTemplate']
            }], role: [{
                type: HostBinding,
                args: ['attr.role']
            }], id: [{
                type: HostBinding,
                args: ['attr.id']
            }, {
                type: Input
            }], recordTemplate: [{
                type: ViewChild,
                args: ['record_template', { read: TemplateRef, static: true }]
            }], detailTemplateContainer: [{
                type: ViewChild,
                args: ['detail_template_container', { read: TemplateRef, static: true }]
            }], defaultGroupTemplate: [{
                type: ViewChild,
                args: ['group_template', { read: TemplateRef, static: true }]
            }], summaryTemplate: [{
                type: ViewChild,
                args: ['summary_template', { read: TemplateRef, static: true }]
            }], groupTemplate: [{
                type: ContentChild,
                args: [IgxGroupByRowTemplateDirective, { read: IgxGroupByRowTemplateDirective }]
            }], groupByRowSelectorsTemplates: [{
                type: ContentChildren,
                args: [IgxGroupByRowSelectorDirective, { read: TemplateRef, descendants: false }]
            }], _groupsRowList: [{
                type: ViewChildren,
                args: [IgxGridGroupByRowComponent, { read: IgxGridGroupByRowComponent }]
            }], data: [{
                type: Input
            }], totalItemCount: [{
                type: Input
            }], groupingExpressions: [{
                type: Input
            }], groupingExpansionState: [{
                type: Input
            }], hideGroupedColumns: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], groupStrategy: [{
                type: Input
            }], dropAreaMessage: [{
                type: Input
            }], groupByRowSelectorTemplate: [{
                type: Input
            }], groupRowTemplate: [{
                type: Input
            }], showGroupArea: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZ3JpZHMvZ3JpZC9ncmlkLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy9ncmlkL2dyaWQuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNILFNBQVMsRUFBRSx1QkFBdUIsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUMzRixTQUFTLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBNkIsV0FBVyxFQUNsRCxlQUFlLEVBQUUsc0JBQXNCLEVBQUUsZ0JBQWdCLEVBQ25GLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxJQUFJLEVBQUUsZ0JBQWdCLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUVsRixPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUM5RCxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUN0RSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUN2RCxPQUFPLEVBQUUsVUFBVSxFQUFrQixNQUFNLGtCQUFrQixDQUFDO0FBRTlELE9BQU8sRUFBRSw4QkFBOEIsRUFBRSw4QkFBOEIsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ3BHLE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBRXJFLE9BQU8sRUFBZSxxQkFBcUIsRUFBRSxNQUFNLDBDQUEwQyxDQUFDO0FBRTlGLE9BQU8sRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENB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c0JBRHZCLEtBQUs7Z0JBc0JLLGVBQWU7c0JBRHpCLEtBQUs7Z0JBNEJLLDBCQUEwQjtzQkFEcEMsS0FBSztnQkFxRkssZ0JBQWdCO3NCQUQxQixLQUFLO2dCQW9MSyxhQUFhO3NCQUR2QixLQUFLO3VCQUFDLEVBQUUsU0FBUyxFQUFFLGdCQUFnQixFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBDb21wb25lbnQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIENvbnRlbnRDaGlsZCwgVmlld0NoaWxkcmVuLFxuICAgIFF1ZXJ5TGlzdCwgVmlld0NoaWxkLCBUZW1wbGF0ZVJlZiwgRG9DaGVjaywgQWZ0ZXJDb250ZW50SW5pdCwgSG9zdEJpbmRpbmcsXG4gICAgT25Jbml0LCBBZnRlclZpZXdJbml0LCBDb250ZW50Q2hpbGRyZW4sIENVU1RPTV9FTEVNRU5UU19TQ0hFTUEsIGJvb2xlYW5BdHRyaWJ1dGVcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ0lmLCBOZ1RlbXBsYXRlT3V0bGV0LCBOZ0NsYXNzLCBOZ0ZvciwgTmdTdHlsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbmltcG9ydCB7IElneEdyaWRCYXNlRGlyZWN0aXZlIH0gZnJvbSAnLi4vZ3JpZC1iYXNlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJZ3hHcmlkTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuLi9ncmlkLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hHcmlkQVBJU2VydmljZSB9IGZyb20gJy4vZ3JpZC1hcGkuc2VydmljZSc7XG5pbXBvcnQgeyBjbG9uZUFycmF5LCBJQmFzZUV2ZW50QXJncyB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgSUdyb3VwQnlSZWNvcmQgfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZ3JvdXBieS1yZWNvcmQuaW50ZXJmYWNlJztcbmltcG9ydCB7IElneEdyb3VwQnlSb3dUZW1wbGF0ZURpcmVjdGl2ZSwgSWd4R3JpZERldGFpbFRlbXBsYXRlRGlyZWN0aXZlIH0gZnJvbSAnLi4vZ3JpZC5kaXJlY3RpdmVzJztcbmltcG9ydCB7IElneEdyaWRHcm91cEJ5Um93Q29tcG9uZW50IH0gZnJvbSAnLi9ncm91cGJ5LXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHsgSUdyb3VwQnlFeHBhbmRTdGF0ZSB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9ncm91cGJ5LWV4cGFuZC1zdGF0ZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSUZvck9mU3RhdGUsIElneEdyaWRGb3JPZkRpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvZm9yLW9mL2Zvcl9vZi5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSWd4Q29sdW1uQ29tcG9uZW50IH0gZnJvbSAnLi4vY29sdW1ucy9jb2x1bW4uY29tcG9uZW50JztcbmltcG9ydCB7IHRha2UsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IElneEZpbHRlcmluZ1NlcnZpY2UgfSBmcm9tICcuLi9maWx0ZXJpbmcvZ3JpZC1maWx0ZXJpbmcuc2VydmljZSc7XG5pbXBvcnQgeyBJR3JvdXBpbmdFeHByZXNzaW9uIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2dyb3VwaW5nLWV4cHJlc3Npb24uaW50ZXJmYWNlJztcbmltcG9ydCB7IElneENvbHVtblJlc2l6aW5nU2VydmljZSB9IGZyb20gJy4uL3Jlc2l6aW5nL3Jlc2l6aW5nLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4R3JpZFN1bW1hcnlTZXJ2aWNlIH0gZnJvbSAnLi4vc3VtbWFyaWVzL2dyaWQtc3VtbWFyeS5zZXJ2aWNlJztcbmltcG9ydCB7IElneEdyaWRTZWxlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi4vc2VsZWN0aW9uL3NlbGVjdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IElneEZvck9mU3luY1NlcnZpY2UsIElneEZvck9mU2Nyb2xsU3luY1NlcnZpY2UgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2Zvci1vZi9mb3Jfb2Yuc3luYy5zZXJ2aWNlJztcbmltcG9ydCB7IElneEdyaWRNUkxOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4uL2dyaWQtbXJsLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBGaWx0ZXJNb2RlIH0gZnJvbSAnLi4vY29tbW9uL2VudW1zJztcbmltcG9ydCB7IENlbGxUeXBlLCBHcmlkVHlwZSwgSWd4R3JpZE1hc3RlckRldGFpbENvbnRleHQsIElneEdyb3VwQnlSb3dTZWxlY3RvclRlbXBsYXRlQ29udGV4dCwgSWd4R3JvdXBCeVJvd1RlbXBsYXRlQ29udGV4dCwgSUdYX0dSSURfQkFTRSwgSUdYX0dSSURfU0VSVklDRV9CQVNFLCBSb3dUeXBlIH0gZnJvbSAnLi4vY29tbW9uL2dyaWQuaW50ZXJmYWNlJztcbmltcG9ydCB7IElneEdyb3VwQnlSb3dTZWxlY3RvckRpcmVjdGl2ZSB9IGZyb20gJy4uL3NlbGVjdGlvbi9yb3ctc2VsZWN0b3JzJztcbmltcG9ydCB7IElneEdyaWRDUlVEU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9jcnVkLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4R3JpZFJvdywgSWd4R3JvdXBCeVJvdywgSWd4U3VtbWFyeVJvdyB9IGZyb20gJy4uL2dyaWQtcHVibGljLXJvdyc7XG5pbXBvcnQgeyBJZ3hHcmlkQ2VsbCB9IGZyb20gJy4uL2dyaWQtcHVibGljLWNlbGwnO1xuaW1wb3J0IHsgSVNvcnRpbmdFeHByZXNzaW9uIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL3NvcnRpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgSUdyaWRHcm91cGluZ1N0cmF0ZWd5IH0gZnJvbSAnLi4vY29tbW9uL3N0cmF0ZWd5JztcbmltcG9ydCB7IElneEdyaWRWYWxpZGF0aW9uU2VydmljZSB9IGZyb20gJy4vZ3JpZC12YWxpZGF0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4R3JpZERldGFpbHNQaXBlIH0gZnJvbSAnLi9ncmlkLmRldGFpbHMucGlwZSc7XG5pbXBvcnQgeyBJZ3hHcmlkU3VtbWFyeVBpcGUgfSBmcm9tICcuL2dyaWQuc3VtbWFyeS5waXBlJztcbmltcG9ydCB7IElneEdyaWRHcm91cGluZ1BpcGUsIElneEdyaWRQYWdpbmdQaXBlLCBJZ3hHcmlkU29ydGluZ1BpcGUsIElneEdyaWRGaWx0ZXJpbmdQaXBlIH0gZnJvbSAnLi9ncmlkLnBpcGVzJztcbmltcG9ydCB7IElneFN1bW1hcnlEYXRhUGlwZSB9IGZyb20gJy4uL3N1bW1hcmllcy9ncmlkLXJvb3Qtc3VtbWFyeS5waXBlJztcbmltcG9ydCB7IElneEdyaWRUcmFuc2FjdGlvblBpcGUsIElneEhhc1Zpc2libGVDb2x1bW5zUGlwZSwgSWd4R3JpZFJvd1Bpbm5pbmdQaXBlLCBJZ3hHcmlkQWRkUm93UGlwZSwgSWd4R3JpZFJvd0NsYXNzZXNQaXBlLCBJZ3hHcmlkUm93U3R5bGVzUGlwZSwgSWd4U3RyaW5nUmVwbGFjZVBpcGUgfSBmcm9tICcuLi9jb21tb24vcGlwZXMnO1xuaW1wb3J0IHsgSWd4R3JpZENvbHVtblJlc2l6ZXJDb21wb25lbnQgfSBmcm9tICcuLi9yZXNpemluZy9yZXNpemVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hSb3dFZGl0VGFiU3RvcERpcmVjdGl2ZSB9IGZyb20gJy4uL2dyaWQucm93RWRpdC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSWd4SWNvbkNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4UmlwcGxlRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9yaXBwbGUvcmlwcGxlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJZ3hCdXR0b25EaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2J1dHRvbi9idXR0b24uZGlyZWN0aXZlJztcbmltcG9ydCB7IElneFNuYWNrYmFyQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vc25hY2tiYXIvc25hY2tiYXIuY29tcG9uZW50JztcbmltcG9ydCB7IElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnQgfSBmcm9tICcuLi8uLi9wcm9ncmVzc2Jhci9wcm9ncmVzc2Jhci5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4T3ZlcmxheU91dGxldERpcmVjdGl2ZSwgSWd4VG9nZ2xlRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy90b2dnbGUvdG9nZ2xlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJZ3hTdW1tYXJ5Um93Q29tcG9uZW50IH0gZnJvbSAnLi4vc3VtbWFyaWVzL3N1bW1hcnktcm93LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hHcmlkUm93Q29tcG9uZW50IH0gZnJvbSAnLi9ncmlkLXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4VGVtcGxhdGVPdXRsZXREaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL3RlbXBsYXRlLW91dGxldC90ZW1wbGF0ZV9vdXRsZXQuZGlyZWN0aXZlJztcbmltcG9ydCB7IElneENvbHVtbk1vdmluZ0Ryb3BEaXJlY3RpdmUgfSBmcm9tICcuLi9tb3ZpbmcvbW92aW5nLmRyb3AuZGlyZWN0aXZlJztcbmltcG9ydCB7IElneEdyaWREcmFnU2VsZWN0RGlyZWN0aXZlIH0gZnJvbSAnLi4vc2VsZWN0aW9uL2RyYWctc2VsZWN0LmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJZ3hHcmlkQm9keURpcmVjdGl2ZSB9IGZyb20gJy4uL2dyaWQuY29tbW9uJztcbmltcG9ydCB7IElneEdyaWRIZWFkZXJSb3dDb21wb25lbnQgfSBmcm9tICcuLi9oZWFkZXJzL2dyaWQtaGVhZGVyLXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4R3JpZEdyb3VwQnlBcmVhQ29tcG9uZW50IH0gZnJvbSAnLi4vZ3JvdXBpbmcvZ3JpZC1ncm91cC1ieS1hcmVhLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbmxldCBORVhUX0lEID0gMDtcblxuZXhwb3J0IGludGVyZmFjZSBJR3JvdXBpbmdEb25lRXZlbnRBcmdzIGV4dGVuZHMgSUJhc2VFdmVudEFyZ3Mge1xuICAgIGV4cHJlc3Npb25zOiBBcnJheTxJU29ydGluZ0V4cHJlc3Npb24+IHwgSVNvcnRpbmdFeHByZXNzaW9uO1xuICAgIGdyb3VwZWRDb2x1bW5zOiBBcnJheTxJZ3hDb2x1bW5Db21wb25lbnQ+IHwgSWd4Q29sdW1uQ29tcG9uZW50O1xuICAgIHVuZ3JvdXBlZENvbHVtbnM6IEFycmF5PElneENvbHVtbkNvbXBvbmVudD4gfCBJZ3hDb2x1bW5Db21wb25lbnQ7XG59XG5cbi8qIGJsYXpvckFkZGl0aW9uYWxEZXBlbmRlbmN5OiBDb2x1bW4gKi9cbi8qIGJsYXpvckFkZGl0aW9uYWxEZXBlbmRlbmN5OiBDb2x1bW5Hcm91cCAqL1xuLyogYmxhem9yQWRkaXRpb25hbERlcGVuZGVuY3k6IENvbHVtbkxheW91dCAqL1xuLyogYmxhem9yQWRkaXRpb25hbERlcGVuZGVuY3k6IEdyaWRUb29sYmFyICovXG4vKiBibGF6b3JBZGRpdGlvbmFsRGVwZW5kZW5jeTogR3JpZFRvb2xiYXJBY3Rpb25zICovXG4vKiBibGF6b3JBZGRpdGlvbmFsRGVwZW5kZW5jeTogR3JpZFRvb2xiYXJUaXRsZSAqL1xuLyogYmxhem9yQWRkaXRpb25hbERlcGVuZGVuY3k6IEdyaWRUb29sYmFyQWR2YW5jZWRGaWx0ZXJpbmcgKi9cbi8qIGJsYXpvckFkZGl0aW9uYWxEZXBlbmRlbmN5OiBHcmlkVG9vbGJhckV4cG9ydGVyICovXG4vKiBibGF6b3JBZGRpdGlvbmFsRGVwZW5kZW5jeTogR3JpZFRvb2xiYXJIaWRpbmcgKi9cbi8qIGJsYXpvckFkZGl0aW9uYWxEZXBlbmRlbmN5OiBHcmlkVG9vbGJhclBpbm5pbmcgKi9cbi8qIGJsYXpvckFkZGl0aW9uYWxEZXBlbmRlbmN5OiBBY3Rpb25TdHJpcCAqL1xuLyogYmxhem9yQWRkaXRpb25hbERlcGVuZGVuY3k6IEdyaWRBY3Rpb25zQmFzZURpcmVjdGl2ZSAqL1xuLyogYmxhem9yQWRkaXRpb25hbERlcGVuZGVuY3k6IEdyaWRFZGl0aW5nQWN0aW9ucyAqL1xuLyogYmxhem9yQWRkaXRpb25hbERlcGVuZGVuY3k6IEdyaWRQaW5uaW5nQWN0aW9ucyAqL1xuLyogYmxhem9ySW5kaXJlY3RSZW5kZXIgKi9cbi8qKlxuICogR3JpZCBwcm92aWRlcyBhIHdheSB0byBwcmVzZW50IGFuZCBtYW5pcHVsYXRlIHRhYnVsYXIgZGF0YS5cbiAqXG4gKiBAaWd4TW9kdWxlIElneEdyaWRNb2R1bGVcbiAqIEBpZ3hHcm91cCBHcmlkcyAmIExpc3RzXG4gKiBAaWd4S2V5d29yZHMgZ3JpZCwgdGFibGVcbiAqIEBpZ3hUaGVtZSBpZ3gtZ3JpZC10aGVtZVxuICogQHJlbWFya3NcbiAqIFRoZSBJZ25pdGUgVUkgR3JpZCBpcyB1c2VkIGZvciBwcmVzZW50aW5nIGFuZCBtYW5pcHVsYXRpbmcgdGFidWxhciBkYXRhIGluIHRoZSBzaW1wbGVzdCB3YXkgcG9zc2libGUuICBPbmNlIGRhdGFcbiAqIGhhcyBiZWVuIGJvdW5kLCBpdCBjYW4gYmUgbWFuaXB1bGF0ZWQgdGhyb3VnaCBmaWx0ZXJpbmcsIHNvcnRpbmcgJiBlZGl0aW5nIG9wZXJhdGlvbnMuXG4gKiBAZXhhbXBsZVxuICogYGBgaHRtbFxuICogPGlneC1ncmlkIFtkYXRhXT1cImVtcGxveWVlRGF0YVwiIFthdXRvR2VuZXJhdGVdPVwiZmFsc2VcIj5cbiAqICAgPGlneC1jb2x1bW4gZmllbGQ9XCJmaXJzdFwiIGhlYWRlcj1cIkZpcnN0IE5hbWVcIj48L2lneC1jb2x1bW4+XG4gKiAgIDxpZ3gtY29sdW1uIGZpZWxkPVwibGFzdFwiIGhlYWRlcj1cIkxhc3QgTmFtZVwiPjwvaWd4LWNvbHVtbj5cbiAqICAgPGlneC1jb2x1bW4gZmllbGQ9XCJyb2xlXCIgaGVhZGVyPVwiUm9sZVwiPjwvaWd4LWNvbHVtbj5cbiAqIDwvaWd4LWdyaWQ+XG4gKiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIElneEdyaWRDUlVEU2VydmljZSxcbiAgICAgICAgSWd4R3JpZE5hdmlnYXRpb25TZXJ2aWNlLFxuICAgICAgICBJZ3hHcmlkU3VtbWFyeVNlcnZpY2UsXG4gICAgICAgIElneEdyaWRTZWxlY3Rpb25TZXJ2aWNlLFxuICAgICAgICBJZ3hHcmlkVmFsaWRhdGlvblNlcnZpY2UsXG4gICAgICAgIHsgcHJvdmlkZTogSUdYX0dSSURfU0VSVklDRV9CQVNFLCB1c2VDbGFzczogSWd4R3JpZEFQSVNlcnZpY2UgfSxcbiAgICAgICAgeyBwcm92aWRlOiBJR1hfR1JJRF9CQVNFLCB1c2VFeGlzdGluZzogSWd4R3JpZENvbXBvbmVudCB9LFxuICAgICAgICBJZ3hGaWx0ZXJpbmdTZXJ2aWNlLFxuICAgICAgICBJZ3hDb2x1bW5SZXNpemluZ1NlcnZpY2UsXG4gICAgICAgIElneEZvck9mU3luY1NlcnZpY2UsXG4gICAgICAgIElneEZvck9mU2Nyb2xsU3luY1NlcnZpY2UsXG4gICAgXSxcbiAgICBzZWxlY3RvcjogJ2lneC1ncmlkJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vZ3JpZC5jb21wb25lbnQuaHRtbCcsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIE5nSWYsXG4gICAgICAgIE5nQ2xhc3MsXG4gICAgICAgIE5nRm9yLFxuICAgICAgICBOZ1N0eWxlLFxuICAgICAgICBOZ1RlbXBsYXRlT3V0bGV0LFxuICAgICAgICBJZ3hHcmlkR3JvdXBCeUFyZWFDb21wb25lbnQsXG4gICAgICAgIElneEdyaWRIZWFkZXJSb3dDb21wb25lbnQsXG4gICAgICAgIElneEdyaWRCb2R5RGlyZWN0aXZlLFxuICAgICAgICBJZ3hHcmlkRHJhZ1NlbGVjdERpcmVjdGl2ZSxcbiAgICAgICAgSWd4Q29sdW1uTW92aW5nRHJvcERpcmVjdGl2ZSxcbiAgICAgICAgSWd4R3JpZEZvck9mRGlyZWN0aXZlLFxuICAgICAgICBJZ3hUZW1wbGF0ZU91dGxldERpcmVjdGl2ZSxcbiAgICAgICAgSWd4R3JpZFJvd0NvbXBvbmVudCxcbiAgICAgICAgSWd4R3JpZEdyb3VwQnlSb3dDb21wb25lbnQsXG4gICAgICAgIElneFN1bW1hcnlSb3dDb21wb25lbnQsXG4gICAgICAgIElneE92ZXJsYXlPdXRsZXREaXJlY3RpdmUsXG4gICAgICAgIElneFRvZ2dsZURpcmVjdGl2ZSxcbiAgICAgICAgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudCxcbiAgICAgICAgSWd4U25hY2tiYXJDb21wb25lbnQsXG4gICAgICAgIElneEJ1dHRvbkRpcmVjdGl2ZSxcbiAgICAgICAgSWd4UmlwcGxlRGlyZWN0aXZlLFxuICAgICAgICBJZ3hJY29uQ29tcG9uZW50LFxuICAgICAgICBJZ3hSb3dFZGl0VGFiU3RvcERpcmVjdGl2ZSxcbiAgICAgICAgSWd4R3JpZENvbHVtblJlc2l6ZXJDb21wb25lbnQsXG4gICAgICAgIElneEdyaWRUcmFuc2FjdGlvblBpcGUsXG4gICAgICAgIElneEhhc1Zpc2libGVDb2x1bW5zUGlwZSxcbiAgICAgICAgSWd4R3JpZFJvd1Bpbm5pbmdQaXBlLFxuICAgICAgICBJZ3hHcmlkQWRkUm93UGlwZSxcbiAgICAgICAgSWd4R3JpZFJvd0NsYXNzZXNQaXBlLFxuICAgICAgICBJZ3hHcmlkUm93U3R5bGVzUGlwZSxcbiAgICAgICAgSWd4U3VtbWFyeURhdGFQaXBlLFxuICAgICAgICBJZ3hHcmlkR3JvdXBpbmdQaXBlLFxuICAgICAgICBJZ3hHcmlkUGFnaW5nUGlwZSxcbiAgICAgICAgSWd4R3JpZFNvcnRpbmdQaXBlLFxuICAgICAgICBJZ3hHcmlkRmlsdGVyaW5nUGlwZSxcbiAgICAgICAgSWd4R3JpZFN1bW1hcnlQaXBlLFxuICAgICAgICBJZ3hHcmlkRGV0YWlsc1BpcGUsXG4gICAgICAgIElneFN0cmluZ1JlcGxhY2VQaXBlXG5dLFxuICAgIHNjaGVtYXM6IFtDVVNUT01fRUxFTUVOVFNfU0NIRU1BXVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hHcmlkQ29tcG9uZW50IGV4dGVuZHMgSWd4R3JpZEJhc2VEaXJlY3RpdmUgaW1wbGVtZW50cyBHcmlkVHlwZSwgT25Jbml0LCBEb0NoZWNrLCBBZnRlckNvbnRlbnRJbml0LCBBZnRlclZpZXdJbml0IHtcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gYSBuZXcgY2h1bmsgb2YgZGF0YSBpcyBsb2FkZWQgZnJvbSB2aXJ0dWFsaXphdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqICA8aWd4LWdyaWQgI2dyaWQgW2RhdGFdPVwibG9jYWxEYXRhXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCIgKGRhdGFQcmVMb2FkKT0naGFuZGxlRGF0YVByZWxvYWRFdmVudCgpJz48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBkYXRhUHJlTG9hZCA9IG5ldyBFdmVudEVtaXR0ZXI8SUZvck9mU3RhdGU+KCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGdyb3VwaW5nRXhwcmVzc2lvbnNDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPElHcm91cGluZ0V4cHJlc3Npb25bXT4oKTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGdyb3VwaW5nRXhwYW5zaW9uU3RhdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPElHcm91cEJ5RXhwYW5kU3RhdGVbXT4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiBjb2x1bW5zIGFyZSBncm91cGVkL3VuZ3JvdXBlZC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGBncm91cGluZ0RvbmVgIGV2ZW50IHdvdWxkIGJlIHJhaXNlZCBvbmx5IG9uY2UgaWYgc2V2ZXJhbCBjb2x1bW5zIGdldCBncm91cGVkIGF0IG9uY2UgYnkgY2FsbGluZ1xuICAgICAqIHRoZSBgZ3JvdXBCeSgpYCBvciBgY2xlYXJHcm91cGluZygpYCBBUEkgbWV0aG9kcyBhbmQgcGFzc2luZyBhbiBhcnJheSBhcyBhbiBhcmd1bWVudC5cbiAgICAgKiBUaGUgZXZlbnQgYXJndW1lbnRzIHByb3ZpZGUgdGhlIGBleHByZXNzaW9uc2AsIGBncm91cGVkQ29sdW1uc2AgYW5kIGB1bmdyb3VwZWRDb2x1bW5zYCBwcm9wZXJ0aWVzLCB3aGljaCBjb250YWluXG4gICAgICogdGhlIGBJU29ydGluZ0V4cHJlc3Npb25gIGFuZCB0aGUgYElneENvbHVtbkNvbXBvbmVudGAgcmVsYXRlZCB0byB0aGUgZ3JvdXBpbmcvdW5ncm91cGluZyBvcGVyYXRpb24uXG4gICAgICogUGxlYXNlIG5vdGUgdGhhdCBgZ3JvdXBlZENvbHVtbnNgIGFuZCBgdW5ncm91cGVkQ29sdW1uc2Agc2hvdyBvbmx5IHRoZSAqKm5ld2x5KiogY2hhbmdlZCBjb2x1bW5zIChhZmZlY3RlZCBieSB0aGUgKipsYXN0KipcbiAgICAgKiBncm91cGluZy91bmdyb3VwaW5nIG9wZXJhdGlvbiksIG5vdCBhbGwgY29sdW1ucyB3aGljaCBhcmUgY3VycmVudGx5IGdyb3VwZWQvdW5ncm91cGVkLlxuICAgICAqIGNvbHVtbnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkICNncmlkIFtkYXRhXT1cImxvY2FsRGF0YVwiIChncm91cGluZ0RvbmUpPVwiZ3JvdXBpbmdEb25lKCRldmVudClcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBncm91cGluZ0RvbmUgPSBuZXcgRXZlbnRFbWl0dGVyPElHcm91cGluZ0RvbmVFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgd2hldGhlciBjcmVhdGVkIGdyb3VwcyBhcmUgcmVuZGVyZWQgZXhwYW5kZWQgb3IgY29sbGFwc2VkLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgZGVmYXVsdCByZW5kZXJlZCBzdGF0ZSBpcyBleHBhbmRlZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgI2dyaWQgW2RhdGFdPVwiRGF0YVwiIFtncm91cHNFeHBhbmRlZF09XCJmYWxzZVwiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KHsgdHJhbnNmb3JtOiBib29sZWFuQXR0cmlidXRlIH0pXG4gICAgcHVibGljIGdyb3Vwc0V4cGFuZGVkID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgdGVtcGxhdGUgdGhhdCB3aWxsIGJlIHJlbmRlcmVkIGFzIGEgR3JvdXBCeSBkcm9wIGFyZWEuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBncmlkIG5lZWRzIHRvIGhhdmUgYXQgbGVhc3Qgb25lIGdyb3VwYWJsZSBjb2x1bW4gaW4gb3JkZXIgdGhlIEdyb3VwQnkgYXJlYSB0byBiZSBkaXNwbGF5ZWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkIFtkcm9wQXJlYVRlbXBsYXRlXT1cImRyb3BBcmVhUmVmXCI+XG4gICAgICogPC9pZ3gtZ3JpZD5cbiAgICAgKiA8bmctdGVtcGxhdGUgI215RHJvcEFyZWE+XG4gICAgICogICAgICA8c3Bhbj4gQ3VzdG9tIGRyb3AgYXJlYSEgPC9zcGFuPlxuICAgICAqIDwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZHJvcEFyZWFUZW1wbGF0ZTogVGVtcGxhdGVSZWY8dm9pZD47XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoSWd4R3JpZERldGFpbFRlbXBsYXRlRGlyZWN0aXZlLCB7IHJlYWQ6IFRlbXBsYXRlUmVmIH0pXG4gICAgcHVibGljIGRldGFpbFRlbXBsYXRlRGlyZWN0aXZlOiBUZW1wbGF0ZVJlZjxJZ3hHcmlkTWFzdGVyRGV0YWlsQ29udGV4dD47XG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIG1hc3Rlci1kZXRhaWwgdGVtcGxhdGUuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBkZXRhaWxUZW1wbGF0ZSA9IHRoaXMuZ3JpZC5kZXRhaWxUZW1wbGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoJ2RldGFpbFRlbXBsYXRlJylcbiAgICBwdWJsaWMgZ2V0IGRldGFpbFRlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPElneEdyaWRNYXN0ZXJEZXRhaWxDb250ZXh0PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXRhaWxUZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWFzdGVyLWRldGFpbCB0ZW1wbGF0ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlICNkZXRhaWxUZW1wbGF0ZSBpZ3hHcmlkRGV0YWlsIGxldC1kYXRhSXRlbT5cbiAgICAgKiAgICA8ZGl2PlxuICAgICAqICAgICAgIDxkaXY+PHNwYW4gY2xhc3M9J2NhdGVnb3J5U3R5bGUnPkNpdHk6PC9zcGFuPiB7e2RhdGFJdGVtLkNpdHl9fTwvZGl2PlxuICAgICAqICAgICAgIDxkaXY+PHNwYW4gY2xhc3M9J2NhdGVnb3J5U3R5bGUnPkFkZHJlc3M6PC9zcGFuPiB7e2RhdGFJdGVtLkFkZHJlc3N9fTwvZGl2PlxuICAgICAqICAgIDwvZGl2PlxuICAgICAqIDwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCInZGV0YWlsVGVtcGxhdGUnXCIsIHtyZWFkOiBUZW1wbGF0ZVJlZiB9KVxuICAgICAqIHB1YmxpYyBkZXRhaWxUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAgKiB0aGlzLmdyaWQuZGV0YWlsVGVtcGxhdGUgPSB0aGlzLmRldGFpbFRlbXBsYXRlO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgZGV0YWlsVGVtcGxhdGUodGVtcGxhdGU6IFRlbXBsYXRlUmVmPElneEdyaWRNYXN0ZXJEZXRhaWxDb250ZXh0Pikge1xuICAgICAgICB0aGlzLl9kZXRhaWxUZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLnJvbGUnKVxuICAgIHB1YmxpYyByb2xlID0gJ2dyaWQnO1xuXG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSB2YWx1ZSBvZiB0aGUgYGlkYCBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIG5vdCBwcm92aWRlZCBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCBbaWRdPVwiJ2lneC1ncmlkLTEnXCIgW2RhdGFdPVwiRGF0YVwiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmlkJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpZCA9IGBpZ3gtZ3JpZC0ke05FWFRfSUQrK31gO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdyZWNvcmRfdGVtcGxhdGUnLCB7IHJlYWQ6IFRlbXBsYXRlUmVmLCBzdGF0aWM6IHRydWUgfSlcbiAgICBwcm90ZWN0ZWQgcmVjb3JkVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICBAVmlld0NoaWxkKCdkZXRhaWxfdGVtcGxhdGVfY29udGFpbmVyJywgeyByZWFkOiBUZW1wbGF0ZVJlZiwgc3RhdGljOiB0cnVlIH0pXG4gICAgcHJvdGVjdGVkIGRldGFpbFRlbXBsYXRlQ29udGFpbmVyOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgQFZpZXdDaGlsZCgnZ3JvdXBfdGVtcGxhdGUnLCB7IHJlYWQ6IFRlbXBsYXRlUmVmLCBzdGF0aWM6IHRydWUgfSlcbiAgICBwcm90ZWN0ZWQgZGVmYXVsdEdyb3VwVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICBAVmlld0NoaWxkKCdzdW1tYXJ5X3RlbXBsYXRlJywgeyByZWFkOiBUZW1wbGF0ZVJlZiwgc3RhdGljOiB0cnVlIH0pXG4gICAgcHJvdGVjdGVkIHN1bW1hcnlUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hHcm91cEJ5Um93VGVtcGxhdGVEaXJlY3RpdmUsIHsgcmVhZDogSWd4R3JvdXBCeVJvd1RlbXBsYXRlRGlyZWN0aXZlIH0pXG4gICAgcHJvdGVjdGVkIGdyb3VwVGVtcGxhdGU6IElneEdyb3VwQnlSb3dUZW1wbGF0ZURpcmVjdGl2ZTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkcmVuKElneEdyb3VwQnlSb3dTZWxlY3RvckRpcmVjdGl2ZSwgeyByZWFkOiBUZW1wbGF0ZVJlZiwgZGVzY2VuZGFudHM6IGZhbHNlIH0pXG4gICAgcHJvdGVjdGVkIGdyb3VwQnlSb3dTZWxlY3RvcnNUZW1wbGF0ZXM6IFF1ZXJ5TGlzdDxUZW1wbGF0ZVJlZjxJZ3hHcm91cEJ5Um93U2VsZWN0b3JUZW1wbGF0ZUNvbnRleHQ+PjtcblxuICAgIEBWaWV3Q2hpbGRyZW4oSWd4R3JpZEdyb3VwQnlSb3dDb21wb25lbnQsIHsgcmVhZDogSWd4R3JpZEdyb3VwQnlSb3dDb21wb25lbnQgfSlcbiAgICBwcml2YXRlIF9ncm91cHNSb3dMaXN0OiBRdWVyeUxpc3Q8SWd4R3JpZEdyb3VwQnlSb3dDb21wb25lbnQ+O1xuXG4gICAgcHJpdmF0ZSBfZ3JvdXBzUmVjb3JkczogSUdyb3VwQnlSZWNvcmRbXSA9IFtdO1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGhpZXJhcmNoaWNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ3JvdXAgYnkgcmVjb3Jkcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBncm91cFJlY29yZHMgPSB0aGlzLmdyaWQuZ3JvdXBzUmVjb3JkcztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGdyb3Vwc1JlY29yZHMoKTogSUdyb3VwQnlSZWNvcmRbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ncm91cHNSZWNvcmRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogSW5jbHVkZXMgY2hpbGRyZW4gb2YgY29sbGFwc2VkIGdyb3VwIHJvd3MuXG4gICAgICovXG4gICAgcHVibGljIGdyb3VwaW5nUmVzdWx0OiBhbnlbXTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdyb3VwaW5nTWV0YWRhdGE6IGFueVtdO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBEb2VzIG5vdCBpbmNsdWRlIGNoaWxkcmVuIG9mIGNvbGxhcHNlZCBncm91cCByb3dzLlxuICAgICAqL1xuICAgIHB1YmxpYyBncm91cGluZ0ZsYXRSZXN1bHQ6IGFueVtdO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2dyb3VwaW5nRXhwcmVzc2lvbnM6IElHcm91cGluZ0V4cHJlc3Npb25bXSA9IFtdO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2dyb3VwaW5nRXhwYW5kU3RhdGU6IElHcm91cEJ5RXhwYW5kU3RhdGVbXSA9IFtdO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2dyb3VwUm93VGVtcGxhdGU6IFRlbXBsYXRlUmVmPElneEdyb3VwQnlSb3dUZW1wbGF0ZUNvbnRleHQ+O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZ3JvdXBTdHJhdGVneTogSUdyaWRHcm91cGluZ1N0cmF0ZWd5O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ3JvdXBpbmdEaWZmZXI7XG4gICAgcHJpdmF0ZSBfZGF0YT86IGFueVtdIHwgbnVsbDtcbiAgICBwcml2YXRlIF9oaWRlR3JvdXBlZENvbHVtbnMgPSBmYWxzZTtcbiAgICBwcml2YXRlIF9kcm9wQXJlYU1lc3NhZ2UgPSBudWxsO1xuICAgIHByaXZhdGUgX3Nob3dHcm91cEFyZWEgPSB0cnVlO1xuXG4gICAgcHJpdmF0ZSBfZ3JvdXBCeVJvd1NlbGVjdG9yVGVtcGxhdGU6IFRlbXBsYXRlUmVmPElneEdyb3VwQnlSb3dTZWxlY3RvclRlbXBsYXRlQ29udGV4dD47XG4gICAgcHJpdmF0ZSBfZGV0YWlsVGVtcGxhdGU7XG5cblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgYXJyYXkgb2YgZGF0YSB0aGF0IHBvcHVsYXRlcyB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkIFtkYXRhXT1cIkRhdGFcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIC8qIHRyZWF0QXNSZWYgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgZGF0YSgpOiBhbnlbXSB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IGRhdGEodmFsdWU6IGFueVtdIHwgbnVsbCkge1xuICAgICAgICBjb25zdCBkYXRhTG9hZGVkID0gKCF0aGlzLl9kYXRhIHx8IHRoaXMuX2RhdGEubGVuZ3RoID09PSAwKSAmJiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPiAwO1xuICAgICAgICBjb25zdCBvbGREYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgdGhpcy5fZGF0YSA9IHZhbHVlIHx8IFtdO1xuICAgICAgICB0aGlzLnN1bW1hcnlTZXJ2aWNlLmNsZWFyU3VtbWFyeUNhY2hlKCk7XG4gICAgICAgIGlmICghdGhpcy5faW5pdCkge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0aW9uLnVwZGF0ZUFsbCh0aGlzLl9kYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmF1dG9HZW5lcmF0ZSAmJiB0aGlzLl9kYXRhLmxlbmd0aCA+IDAgJiYgdGhpcy5zaG91bGRSZWNyZWF0ZUNvbHVtbnMob2xkRGF0YSwgdGhpcy5fZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dXBDb2x1bW5zKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgaWYgKHRoaXMuaXNQZXJjZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeUNoYW5nZXModHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgaWYgYW55IGNvbHVtbnMgaGF2ZSB3aWR0aCBhdXRvIGFuZCBpZiBzbyByZWNhbGN1bGF0ZSB0aGVpciBhdXRvLXNpemUgb24gZGF0YSBsb2FkZWQuXG4gICAgICAgIGlmIChkYXRhTG9hZGVkICYmIHRoaXMuX2NvbHVtbnMuc29tZSh4ID0+ICh4IGFzIGFueSkuX3dpZHRoID09PSAnYXV0bycpKSB7XG4gICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlQXV0b1NpemVzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgdGhlIHRvdGFsIG51bWJlciBvZiByZWNvcmRzIGluIHRoZSBkYXRhIHNvdXJjZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhpcyBwcm9wZXJ0eSBpcyByZXF1aXJlZCBmb3IgcmVtb3RlIGdyaWQgdmlydHVhbGl6YXRpb24gdG8gZnVuY3Rpb24gd2hlbiBpdCBpcyBib3VuZCB0byByZW1vdGUgZGF0YS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBpdGVtQ291bnQgPSB0aGlzLmdyaWQxLnRvdGFsSXRlbUNvdW50O1xuICAgICAqIHRoaXMuZ3JpZDEudG90YWxJdGVtQ291bnQgPSA1NTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgdG90YWxJdGVtQ291bnQoY291bnQpIHtcbiAgICAgICAgdGhpcy52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci50b3RhbEl0ZW1Db3VudCA9IGNvdW50O1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgdG90YWxJdGVtQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLnRvdGFsSXRlbUNvdW50O1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0IF9ncmlkQVBJKCk6IElneEdyaWRBUElTZXJ2aWNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZEFQSSBhcyBJZ3hHcmlkQVBJU2VydmljZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNoaWxkRGV0YWlsVGVtcGxhdGVzOiBNYXA8YW55LCBhbnk+ID0gbmV3IE1hcCgpO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ3JvdXBpbmdQZXJmb3JtZWRTdWJqZWN0ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdyb3VwaW5nUGVyZm9ybWVkJDogT2JzZXJ2YWJsZTx2b2lkPiA9IHRoaXMuZ3JvdXBpbmdQZXJmb3JtZWRTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuXG4gICAgLyogbXVzdFNldEluQ29kZVBsYXRmb3JtczogV2ViQ29tcG9uZW50cztCbGF6b3I7UmVhY3QgKi9cbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgdGhlIGdyb3VwIGJ5IHN0YXRlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGdyb3VwQnlTdGF0ZSA9IHRoaXMuZ3JpZC5ncm91cGluZ0V4cHJlc3Npb25zO1xuICAgICAqIHRoaXMuZ3JpZC5ncm91cGluZ0V4cHJlc3Npb25zID0gWy4uLl07XG4gICAgICogYGBgXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBTdXBwb3J0cyB0d28td2F5IGRhdGEgYmluZGluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgI2dyaWQgW2RhdGFdPVwiRGF0YVwiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiIFsoZ3JvdXBpbmdFeHByZXNzaW9ucyldPVwibW9kZWwuZ3JvdXBpbmdFeHByZXNzaW9uc1wiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGdyb3VwaW5nRXhwcmVzc2lvbnMoKTogSUdyb3VwaW5nRXhwcmVzc2lvbltdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3VwaW5nRXhwcmVzc2lvbnM7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBncm91cGluZ0V4cHJlc3Npb25zKHZhbHVlOiBJR3JvdXBpbmdFeHByZXNzaW9uW10pIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucyA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUubGVuZ3RoID4gMTApIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdNYXhpbXVtIGFtb3VudCBvZiBncm91cGVkIGNvbHVtbnMgaXMgMTAuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkRXhwcmVzc2lvbnM6IElHcm91cGluZ0V4cHJlc3Npb25bXSA9IHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucztcbiAgICAgICAgY29uc3QgbmV3RXhwcmVzc2lvbnM6IElHcm91cGluZ0V4cHJlc3Npb25bXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9ncm91cGluZ0V4cHJlc3Npb25zID0gY2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9uc0NoYW5nZS5lbWl0KHRoaXMuX2dyb3VwaW5nRXhwcmVzc2lvbnMpO1xuICAgICAgICBpZiAodGhpcy5fZ3JpZEFQSS5ncmlkKSB7XG4gICAgICAgICAgICAvKiBncm91cGluZyBhbmQgc29ydGluZyBhcmUgd29ya2luZyBzZXBhcmF0ZSBmcm9tIGVhY2ggb3RoZXIgKi9cbiAgICAgICAgICAgIHRoaXMuX2FwcGx5R3JvdXBpbmcoKTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faW5pdCAmJiBKU09OLnN0cmluZ2lmeShvbGRFeHByZXNzaW9ucywgdGhpcy5zdHJpbmdpZnlDYWxsYmFjaykgIT09IEpTT04uc3RyaW5naWZ5KG5ld0V4cHJlc3Npb25zLCB0aGlzLnN0cmluZ2lmeUNhbGxiYWNrKSAmJiB0aGlzLl9jb2x1bW5zKSB7XG4gICAgICAgICAgICBjb25zdCBncm91cGVkQ29sczogSWd4Q29sdW1uQ29tcG9uZW50W10gPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHVuZ3JvdXBlZENvbHM6IElneENvbHVtbkNvbXBvbmVudFtdID0gW107XG4gICAgICAgICAgICBjb25zdCBncm91cGVkQ29sc0FyciA9IG5ld0V4cHJlc3Npb25zLmZpbHRlcigob2JqKSA9PiAhb2xkRXhwcmVzc2lvbnMuc29tZSgob2JqMikgPT4gb2JqLmZpZWxkTmFtZSA9PT0gb2JqMi5maWVsZE5hbWUpKTtcbiAgICAgICAgICAgIGdyb3VwZWRDb2xzQXJyLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgICAgICAgICAgICBncm91cGVkQ29scy5wdXNoKHRoaXMuZ2V0Q29sdW1uQnlOYW1lKGVsZW0uZmllbGROYW1lKSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IHVuZ3JvdXBlZENvbHNBcnIgPSBvbGRFeHByZXNzaW9ucy5maWx0ZXIoKG9iaikgPT4gIW5ld0V4cHJlc3Npb25zLnNvbWUoKG9iajIpID0+IG9iai5maWVsZE5hbWUgPT09IG9iajIuZmllbGROYW1lKSk7XG4gICAgICAgICAgICB1bmdyb3VwZWRDb2xzQXJyLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgICAgICAgICAgICB1bmdyb3VwZWRDb2xzLnB1c2godGhpcy5nZXRDb2x1bW5CeU5hbWUoZWxlbS5maWVsZE5hbWUpKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VzKCk7XG4gICAgICAgICAgICBjb25zdCBncm91cGluZ0RvbmVBcmdzOiBJR3JvdXBpbmdEb25lRXZlbnRBcmdzID0ge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zOiBuZXdFeHByZXNzaW9ucyxcbiAgICAgICAgICAgICAgICBncm91cGVkQ29sdW1uczogZ3JvdXBlZENvbHMsXG4gICAgICAgICAgICAgICAgdW5ncm91cGVkQ29sdW1uczogdW5ncm91cGVkQ29sc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBpbmdQZXJmb3JtZWQkLnBpcGUodGFrZSgxKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwaW5nRG9uZS5lbWl0KGdyb3VwaW5nRG9uZUFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgYSBsaXN0IG9mIGV4cGFuc2lvbiBzdGF0ZXMgZm9yIGdyb3VwIHJvd3MuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEluY2x1ZGVzIG9ubHkgc3RhdGVzIHRoYXQgZGlmZmVyIGZyb20gdGhlIGRlZmF1bHQgb25lIChjb250cm9sbGVkIHRocm91Z2ggZ3JvdXBzRXhwYW5kZWQgYW5kIHN0YXRlcyB0aGF0IHRoZSB1c2VyIGhhcyBjaGFuZ2VkLlxuICAgICAqIENvbnRhaW5zIHRoZSBleHBhbnNpb24gc3RhdGUgKGV4cGFuZGVkOiBib29sZWFuKSBhbmQgdGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgZ3JvdXAgcm93IChBcnJheSkuXG4gICAgICogU3VwcG9ydHMgdHdvLXdheSBkYXRhIGJpbmRpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkICNncmlkIFtkYXRhXT1cIkRhdGFcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIiBbKGdyb3VwaW5nRXhwYW5zaW9uU3RhdGUpXT1cIm1vZGVsLmdyb3VwaW5nRXhwYW5zaW9uU3RhdGVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBncm91cGluZ0V4cGFuc2lvblN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBpbmdFeHBhbmRTdGF0ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IGdyb3VwaW5nRXhwYW5zaW9uU3RhdGUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9ncm91cGluZ0V4cGFuZFN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwaW5nRXhwYW5zaW9uU3RhdGVDaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ3JvdXBpbmdFeHBhbmRTdGF0ZSA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5ncmlkQVBJLmdyaWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB3aGV0aGVyIHRoZSBncm91cGVkIGNvbHVtbnMgc2hvdWxkIGJlIGhpZGRlbi5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgXCJmYWxzZVwiXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkICNncmlkIFtkYXRhXT1cImxvY2FsRGF0YVwiIFtoaWRlR3JvdXBlZENvbHVtbnNdPVwidHJ1ZVwiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KHsgdHJhbnNmb3JtOiBib29sZWFuQXR0cmlidXRlIH0pXG4gICAgcHVibGljIGdldCBoaWRlR3JvdXBlZENvbHVtbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oaWRlR3JvdXBlZENvbHVtbnM7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBoaWRlR3JvdXBlZENvbHVtbnModmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwaW5nRGlmZmVyID0gdGhpcy5kaWZmZXJzLmZpbmQodGhpcy5ncm91cGluZ0V4cHJlc3Npb25zKS5jcmVhdGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBpbmdEaWZmZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jb2x1bW5zICYmIHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucykge1xuICAgICAgICAgICAgdGhpcy5fc2V0R3JvdXBDb2xzVmlzaWJpbGl0eSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9oaWRlR3JvdXBlZENvbHVtbnMgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgdGhlIGdyb3VwaW5nIHN0cmF0ZWd5IG9mIHRoZSBncmlkLlxuICAgICAqXG4gICAgICogQHJlbWFya3MgVGhlIGRlZmF1bHQgSWd4R3JvdXBpbmcgZXh0ZW5kcyBmcm9tIElneFNvcnRpbmcgYW5kIGEgY3VzdG9tIG9uZSBjYW4gYmUgdXNlZCBhcyBhIGBzb3J0U3RyYXRlZ3lgIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiAgPGlneC1ncmlkICNncmlkIFtkYXRhXT1cImxvY2FsRGF0YVwiIFtncm91cFN0cmF0ZWd5XT1cImdyb3VwU3RyYXRlZ3lcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBncm91cFN0cmF0ZWd5KCk6IElHcmlkR3JvdXBpbmdTdHJhdGVneSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ncm91cFN0cmF0ZWd5O1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgZ3JvdXBTdHJhdGVneSh2YWx1ZTogSUdyaWRHcm91cGluZ1N0cmF0ZWd5KSB7XG4gICAgICAgIHRoaXMuX2dyb3VwU3RyYXRlZ3kgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgdGhlIG1lc3NhZ2UgZGlzcGxheWVkIGluc2lkZSB0aGUgR3JvdXBCeSBkcm9wIGFyZWEgd2hlcmUgY29sdW1ucyBjYW4gYmUgZHJhZ2dlZCBvbi5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGdyaWQgbmVlZHMgdG8gaGF2ZSBhdCBsZWFzdCBvbmUgZ3JvdXBhYmxlIGNvbHVtbiBpbiBvcmRlciB0aGUgR3JvdXBCeSBhcmVhIHRvIGJlIGRpc3BsYXllZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgZHJvcEFyZWFNZXNzYWdlPVwiRHJvcCBoZXJlIHRvIGdyb3VwIVwiPlxuICAgICAqICAgICAgPGlneC1jb2x1bW4gW2dyb3VwYWJsZV09XCJ0cnVlXCIgZmllbGQ9XCJJRFwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiA8L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBkcm9wQXJlYU1lc3NhZ2UodmFsdWU6IHN0cmluZykge1xuICAgICAgICB0aGlzLl9kcm9wQXJlYU1lc3NhZ2UgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBkcm9wQXJlYU1lc3NhZ2UoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ryb3BBcmVhTWVzc2FnZSB8fCB0aGlzLnJlc291cmNlU3RyaW5ncy5pZ3hfZ3JpZF9ncm91cEJ5QXJlYV9tZXNzYWdlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldCBncm91cHNSb3dMaXN0KCkge1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgUXVlcnlMaXN0PGFueT4oKTtcbiAgICAgICAgaWYgKCF0aGlzLl9ncm91cHNSb3dMaXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJMaXN0ID0gdGhpcy5fZ3JvdXBzUm93TGlzdC5maWx0ZXIoaXRlbSA9PiBpdGVtLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50ICE9PSBudWxsKVxuICAgICAgICAgICAgLnNvcnQoKGl0ZW0xLCBpdGVtMikgPT4gaXRlbTEuaW5kZXggLSBpdGVtMi5pbmRleCk7XG4gICAgICAgIHJlcy5yZXNldChyTGlzdCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZ3JvdXAgYnkgcm93IHNlbGVjdG9yIHRlbXBsYXRlLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBncm91cEJ5Um93U2VsZWN0b3JUZW1wbGF0ZSgpOiBUZW1wbGF0ZVJlZjxJZ3hHcm91cEJ5Um93U2VsZWN0b3JUZW1wbGF0ZUNvbnRleHQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3VwQnlSb3dTZWxlY3RvclRlbXBsYXRlIHx8IHRoaXMuZ3JvdXBCeVJvd1NlbGVjdG9yc1RlbXBsYXRlcz8uZmlyc3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZ3JvdXAgYnkgcm93IHNlbGVjdG9yIHRlbXBsYXRlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgI3RlbXBsYXRlIGlneEdyb3VwQnlSb3dTZWxlY3RvciBsZXQtZ3JvdXBCeVJvd0NvbnRleHQ+XG4gICAgICoge3sgZ3JvdXBCeVJvd0NvbnRleHQuc2VsZWN0ZWRDb3VudCB9fSAvIHt7IGdyb3VwQnlSb3dDb250ZXh0LnRvdGFsQ291bnQgIH19XG4gICAgICogPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcIid0ZW1wbGF0ZSdcIiwge3JlYWQ6IFRlbXBsYXRlUmVmIH0pXG4gICAgICogcHVibGljIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgICAqIHRoaXMuZ3JpZC5ncm91cEJ5Um93U2VsZWN0b3JUZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGU7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHNldCBncm91cEJ5Um93U2VsZWN0b3JUZW1wbGF0ZSh0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8SWd4R3JvdXBCeVJvd1NlbGVjdG9yVGVtcGxhdGVDb250ZXh0Pikge1xuICAgICAgICB0aGlzLl9ncm91cEJ5Um93U2VsZWN0b3JUZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldERldGFpbHNDb250ZXh0KHJvd0RhdGEsIGluZGV4KTogSWd4R3JpZERldGFpbFRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICRpbXBsaWNpdDogcm93RGF0YSxcbiAgICAgICAgICAgIGluZGV4XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZGV0YWlsc1ZpZXdGb2N1c2VkKGNvbnRhaW5lciwgcm93SW5kZXgpIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uLnNldEFjdGl2ZU5vZGUoeyByb3c6IHJvd0luZGV4IH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG92ZXJyaWRlIGdldCBoYXNEZXRhaWxzKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmRldGFpbFRlbXBsYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldFJvd1RlbXBsYXRlKHJvd0RhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNHcm91cEJ5UmVjb3JkKHJvd0RhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0R3JvdXBUZW1wbGF0ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzU3VtbWFyeVJvdyhyb3dEYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VtbWFyeVRlbXBsYXRlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzRGV0YWlscyAmJiB0aGlzLmlzRGV0YWlsUmVjb3JkKHJvd0RhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXRhaWxUZW1wbGF0ZUNvbnRhaW5lcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY29yZFRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgaXNEZXRhaWxSZWNvcmQocmVjb3JkKSB7XG4gICAgICAgIHJldHVybiByZWNvcmQgJiYgcmVjb3JkLmRldGFpbHNEYXRhICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgaXNEZXRhaWxBY3RpdmUocm93SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdGlvbi5hY3RpdmVOb2RlID8gdGhpcy5uYXZpZ2F0aW9uLmFjdGl2ZU5vZGUucm93ID09PSByb3dJbmRleCA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgdGVtcGxhdGUgcmVmZXJlbmNlIGZvciB0aGUgZ3JvdXAgcm93LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCBncm91cFJvd1RlbXBsYXRlID0gdGhpcy5ncmlkLmdyb3VwUm93VGVtcGxhdGU7XG4gICAgICogdGhpcy5ncmlkLmdyb3VwUm93VGVtcGxhdGUgPSBteVJvd1RlbXBsYXRlO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBncm91cFJvd1RlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPElneEdyb3VwQnlSb3dUZW1wbGF0ZUNvbnRleHQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3VwUm93VGVtcGxhdGU7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBncm91cFJvd1RlbXBsYXRlKHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxJZ3hHcm91cEJ5Um93VGVtcGxhdGVDb250ZXh0Pikge1xuICAgICAgICB0aGlzLl9ncm91cFJvd1RlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyB0cmFja0NoYW5nZXM6IChpbmRleCwgcmVjKSA9PiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBHcm91cHMgYnkgYSBuZXcgYElneENvbHVtbkNvbXBvbmVudGAgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGV4cHJlc3Npb24sIG9yIG1vZGlmaWVzIGFuIGV4aXN0aW5nIG9uZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogQWxzbyBhbGxvd3MgZm9yIG11bHRpcGxlIGNvbHVtbnMgdG8gYmUgZ3JvdXBlZCBhdCBvbmNlIGlmIGFuIGFycmF5IG9mIGBJU29ydGluZ0V4cHJlc3Npb25gIGlzIHBhc3NlZC5cbiAgICAgKiBUaGUgYGdyb3VwaW5nRG9uZWAgZXZlbnQgd291bGQgZ2V0IHJhaXNlZCBvbmx5ICoqb25jZSoqIGlmIHRoaXMgbWV0aG9kIGdldHMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC5ncm91cEJ5KHsgZmllbGROYW1lOiBuYW1lLCBkaXI6IFNvcnRpbmdEaXJlY3Rpb24uQXNjLCBpZ25vcmVDYXNlOiBmYWxzZSB9KTtcbiAgICAgKiB0aGlzLmdyaWQuZ3JvdXBCeShbXG4gICAgICogICAgIHsgZmllbGROYW1lOiBuYW1lMSwgZGlyOiBTb3J0aW5nRGlyZWN0aW9uLkFzYywgaWdub3JlQ2FzZTogZmFsc2UgfSxcbiAgICAgKiAgICAgeyBmaWVsZE5hbWU6IG5hbWUyLCBkaXI6IFNvcnRpbmdEaXJlY3Rpb24uRGVzYywgaWdub3JlQ2FzZTogdHJ1ZSB9LFxuICAgICAqICAgICB7IGZpZWxkTmFtZTogbmFtZTMsIGRpcjogU29ydGluZ0RpcmVjdGlvbi5EZXNjLCBpZ25vcmVDYXNlOiBmYWxzZSB9XG4gICAgICogXSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdyb3VwQnkoZXhwcmVzc2lvbjogSUdyb3VwaW5nRXhwcmVzc2lvbiB8IEFycmF5PElHcm91cGluZ0V4cHJlc3Npb24+KTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrSWZOb0NvbHVtbkZpZWxkKGV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jcnVkU2VydmljZS5lbmRFZGl0KGZhbHNlKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgdGhpcy5fZ3JpZEFQSS5ncm91cEJ5X211bHRpcGxlKGV4cHJlc3Npb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZ3JpZEFQSS5ncm91cEJ5KGV4cHJlc3Npb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcyh0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgZ3JvdXBpbmcgZm9yIHBhcnRpY3VsYXIgY29sdW1uLCBhcnJheSBvZiBjb2x1bW5zIG9yIGFsbCBjb2x1bW5zLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBDbGVhcnMgYWxsIGdyb3VwaW5nIGluIHRoZSBncmlkLCBpZiBubyBwYXJhbWV0ZXIgaXMgcGFzc2VkLlxuICAgICAqIElmIGEgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCBjbGVhcnMgZ3JvdXBpbmcgZm9yIGEgcGFydGljdWxhciBjb2x1bW4gb3IgYW4gYXJyYXkgb2YgY29sdW1ucy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQuY2xlYXJHcm91cGluZygpOyAvL2NsZWFycyBhbGwgZ3JvdXBpbmdcbiAgICAgKiB0aGlzLmdyaWQuY2xlYXJHcm91cGluZyhcIklEXCIpOyAvL3VuZ3JvdXBzIGEgc2luZ2xlIGNvbHVtblxuICAgICAqIHRoaXMuZ3JpZC5jbGVhckdyb3VwaW5nKFtcIklEXCIsIFwiQ29sdW1uMVwiLCBcIkNvbHVtbjJcIl0pOyAvL3VuZ3JvdXBzIG11bHRpcGxlIGNvbHVtbnNcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIGNvbHVtbiBvciBhcnJheSBvZiBjb2x1bW4gbmFtZXMgdG8gYmUgdW5ncm91cGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBjbGVhckdyb3VwaW5nKG5hbWU/OiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2dyaWRBUEkuY2xlYXJfZ3JvdXBieShuYW1lKTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVHcmlkU2l6ZXMoKTtcbiAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VzKHRydWUpO1xuICAgICAgICB0aGlzLmdyb3VwaW5nUGVyZm9ybWVkU3ViamVjdC5uZXh0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiBhIGdyb3VwIGlzIGV4cGFuZGVkIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBncm91cCBUaGUgZ3JvdXAgcmVjb3JkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBncm91cFJvdzogSUdyb3VwQnlSZWNvcmQ7XG4gICAgICogY29uc3QgZXhwYW5kZWRHcm91cCA9IHRoaXMuZ3JpZC5pc0V4cGFuZGVkR3JvdXAodGhpcy5ncm91cFJvdyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIG92ZXJyaWRlIGlzRXhwYW5kZWRHcm91cChncm91cDogSUdyb3VwQnlSZWNvcmQpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3Qgc3RhdGU6IElHcm91cEJ5RXhwYW5kU3RhdGUgPSB0aGlzLl9nZXRTdGF0ZUZvckdyb3VwUm93KGdyb3VwKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlID8gc3RhdGUuZXhwYW5kZWQgOiB0aGlzLmdyb3Vwc0V4cGFuZGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIGV4cGFuc2lvbiBzdGF0ZSBvZiBhIGdyb3VwLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdyb3VwUm93IFRoZSBncm91cCByZWNvcmQgdG8gdG9nZ2xlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBncm91cFJvdzogSUdyb3VwQnlSZWNvcmQ7XG4gICAgICogY29uc3QgdG9nZ2xlRXhwR3JvdXAgPSB0aGlzLmdyaWQudG9nZ2xlR3JvdXAodGhpcy5ncm91cFJvdyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHRvZ2dsZUdyb3VwKGdyb3VwUm93OiBJR3JvdXBCeVJlY29yZCkge1xuICAgICAgICB0aGlzLl90b2dnbGVHcm91cChncm91cFJvdyk7XG4gICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBhbGwgcm93cyB3aXRoaW4gYSBncm91cC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBncm91cFJvdzogVGhlIGdyb3VwIHJlY29yZCB3aGljaCByb3dzIHdvdWxkIGJlIHNlbGVjdGVkLlxuICAgICAqIEBwYXJhbSBjbGVhckN1cnJlbnRTZWxlY3Rpb24gaWYgdHJ1ZSBjbGVhcnMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5ncmlkLnNlbGVjdFJvd3NJbkdyb3VwKHRoaXMuZ3JvdXBSb3csIHRydWUpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBzZWxlY3RSb3dzSW5Hcm91cChncm91cFJvdzogSUdyb3VwQnlSZWNvcmQsIGNsZWFyUHJldlNlbGVjdGlvbj86IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fZ3JpZEFQSS5ncm91cEJ5X3NlbGVjdF9hbGxfcm93c19pbl9ncm91cChncm91cFJvdywgY2xlYXJQcmV2U2VsZWN0aW9uKTtcbiAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzZWxlY3QgYWxsIHJvd3Mgd2l0aGluIGEgZ3JvdXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ3JvdXBSb3cgVGhlIGdyb3VwIHJlY29yZCB3aGljaCByb3dzIHdvdWxkIGJlIGRlc2VsZWN0ZWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGdyb3VwUm93OiBJR3JvdXBCeVJlY29yZDtcbiAgICAgKiB0aGlzLmdyaWQuZGVzZWxlY3RSb3dzSW5Hcm91cCh0aGlzLmdyb3VwUm93KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZGVzZWxlY3RSb3dzSW5Hcm91cChncm91cFJvdzogSUdyb3VwQnlSZWNvcmQpIHtcbiAgICAgICAgdGhpcy5fZ3JpZEFQSS5ncm91cEJ5X2Rlc2VsZWN0X2FsbF9yb3dzX2luX2dyb3VwKGdyb3VwUm93KTtcbiAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwYW5kcyB0aGUgc3BlY2lmaWVkIGdyb3VwIGFuZCBhbGwgb2YgaXRzIHBhcmVudCBncm91cHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ3JvdXBSb3cgVGhlIGdyb3VwIHJlY29yZCB0byBmdWxseSBleHBhbmQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGdyb3VwUm93OiBJR3JvdXBCeVJlY29yZDtcbiAgICAgKiB0aGlzLmdyaWQuZnVsbHlFeHBhbmRHcm91cCh0aGlzLmdyb3VwUm93KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZnVsbHlFeHBhbmRHcm91cChncm91cFJvdzogSUdyb3VwQnlSZWNvcmQpIHtcbiAgICAgICAgdGhpcy5fZnVsbHlFeHBhbmRHcm91cChncm91cFJvdyk7XG4gICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG92ZXJyaWRlIGlzR3JvdXBCeVJlY29yZChyZWNvcmQ6IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICAvLyByZXR1cm4gcmVjb3JkLnJlY29yZHMgaW5zdGFuY2Ugb2YgR3JvdXBlZFJlY29yZHMgZmFpbHMgdW5kZXIgV2VicGFja1xuICAgICAgICByZXR1cm4gcmVjb3JkICYmIHJlY29yZD8ucmVjb3JkcyAmJiByZWNvcmQucmVjb3Jkcz8ubGVuZ3RoICYmXG4gICAgICAgICAgICByZWNvcmQuZXhwcmVzc2lvbiAmJiByZWNvcmQuZXhwcmVzc2lvbj8uZmllbGROYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIGV4cGFuc2lvbiBzdGF0ZSBvZiBhbGwgZ3JvdXAgcm93cyByZWN1cnNpdmVseS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC50b2dnbGVBbGxHcm91cFJvd3M7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHRvZ2dsZUFsbEdyb3VwUm93cygpIHtcbiAgICAgICAgdGhpcy5ncm91cGluZ0V4cGFuc2lvblN0YXRlID0gW107XG4gICAgICAgIHRoaXMuZ3JvdXBzRXhwYW5kZWQgPSAhdGhpcy5ncm91cHNFeHBhbmRlZDtcbiAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGdldCBoYXNHcm91cGFibGVDb2x1bW5zKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sdW1ucy5zb21lKChjb2wpID0+IGNvbC5ncm91cGFibGUgJiYgIWNvbC5jb2x1bW5Hcm91cCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBgSWd4R3JpZENvbXBvbmVudGAgaGFzIGdyb3VwIGFyZWEuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaXNHcm91cEFyZWFWaXNpYmxlID0gdGhpcy5ncmlkLnNob3dHcm91cEFyZWE7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgI2dyaWQgW2RhdGFdPVwiRGF0YVwiIFtzaG93R3JvdXBBcmVhXT1cImZhbHNlXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoeyB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGUgfSlcbiAgICBwdWJsaWMgZ2V0IHNob3dHcm91cEFyZWEoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaG93R3JvdXBBcmVhO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IHNob3dHcm91cEFyZWEodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fc2hvd0dyb3VwQXJlYSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm5vdGlmeUNoYW5nZXModHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgaXNDb2x1bW5Hcm91cGVkKGZpZWxkTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMuZmluZChleHAgPT4gZXhwLmZpZWxkTmFtZSA9PT0gZmllbGROYW1lKSA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRDb250ZXh0KHJvd0RhdGE6IGFueSwgcm93SW5kZXg6IG51bWJlciwgcGlubmVkPzogYm9vbGVhbik6IGFueSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGV0YWlsUmVjb3JkKHJvd0RhdGEpKSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZWREYXRhID0gdGhpcy5jaGlsZERldGFpbFRlbXBsYXRlcy5nZXQocm93RGF0YS5kZXRhaWxzRGF0YSk7XG4gICAgICAgICAgICBjb25zdCByb3dJRCA9IHRoaXMucHJpbWFyeUtleSA/IHJvd0RhdGEuZGV0YWlsc0RhdGFbdGhpcy5wcmltYXJ5S2V5XSA6IHJvd0RhdGEuZGV0YWlsc0RhdGE7XG4gICAgICAgICAgICBpZiAoY2FjaGVkRGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBjYWNoZWREYXRhLnZpZXc7XG4gICAgICAgICAgICAgICAgY29uc3QgdG1scE91dGxldCA9IGNhY2hlZERhdGEub3duZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgJGltcGxpY2l0OiByb3dEYXRhLmRldGFpbHNEYXRhLFxuICAgICAgICAgICAgICAgICAgICBtb3ZlVmlldzogdmlldyxcbiAgICAgICAgICAgICAgICAgICAgb3duZXI6IHRtbHBPdXRsZXQsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLmRhdGFWaWV3LmluZGV4T2Yocm93RGF0YSksXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlSUQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkZXRhaWxSb3cnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHJvd0lEXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjaGlsZCByb3dzIGNvbnRhaW4gdW5pcXVlIGdyaWRzLCBoZW5jZSBzaG91bGQgaGF2ZSB1bmlxdWUgdGVtcGxhdGVzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgJGltcGxpY2l0OiByb3dEYXRhLmRldGFpbHNEYXRhLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZUlEOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGV0YWlsUm93JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiByb3dJRFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5kYXRhVmlldy5pbmRleE9mKHJvd0RhdGEpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJGltcGxpY2l0OiB0aGlzLmlzR2hvc3RSZWNvcmQocm93RGF0YSkgPyByb3dEYXRhLnJlY29yZFJlZiA6IHJvd0RhdGEsXG4gICAgICAgICAgICBpbmRleDogdGhpcy5nZXREYXRhVmlld0luZGV4KHJvd0luZGV4LCBwaW5uZWQpLFxuICAgICAgICAgICAgdGVtcGxhdGVJRDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMuaXNHcm91cEJ5UmVjb3JkKHJvd0RhdGEpID8gJ2dyb3VwUm93JyA6IHRoaXMuaXNTdW1tYXJ5Um93KHJvd0RhdGEpID8gJ3N1bW1hcnlSb3cnIDogJ2RhdGFSb3cnLFxuICAgICAgICAgICAgICAgIGlkOiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlzYWJsZWQ6IHRoaXMuaXNHaG9zdFJlY29yZChyb3dEYXRhKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIHZpZXdDcmVhdGVkSGFuZGxlcihhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzLmNvbnRleHQudGVtcGxhdGVJRC50eXBlID09PSAnZGV0YWlsUm93Jykge1xuICAgICAgICAgICAgdGhpcy5jaGlsZERldGFpbFRlbXBsYXRlcy5zZXQoYXJncy5jb250ZXh0LiRpbXBsaWNpdCwgYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyB2aWV3TW92ZWRIYW5kbGVyKGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3MuY29udGV4dC50ZW1wbGF0ZUlELnR5cGUgPT09ICdkZXRhaWxSb3cnKSB7XG4gICAgICAgICAgICAvLyB2aWV3IHdhcyBtb3ZlZCwgdXBkYXRlIG93bmVyIGluIGNhY2hlXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBhcmdzLmNvbnRleHQuJGltcGxpY2l0O1xuICAgICAgICAgICAgY29uc3QgY2FjaGVkRGF0YSA9IHRoaXMuY2hpbGREZXRhaWxUZW1wbGF0ZXMuZ2V0KGtleSk7XG4gICAgICAgICAgICBjYWNoZWREYXRhLm93bmVyID0gYXJncy5vd25lcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldCBpY29uVGVtcGxhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmdyb3Vwc0V4cGFuZGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJFeHBhbmRlZEluZGljYXRvclRlbXBsYXRlIHx8IHRoaXMuZGVmYXVsdEV4cGFuZGVkVGVtcGxhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJDb2xsYXBzZWRJbmRpY2F0b3JUZW1wbGF0ZSB8fCB0aGlzLmRlZmF1bHRDb2xsYXBzZWRUZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG92ZXJyaWRlIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgc3VwZXIubmdBZnRlckNvbnRlbnRJbml0KCk7XG4gICAgICAgIGlmICh0aGlzLmFsbG93RmlsdGVyaW5nICYmIHRoaXMuaGFzQ29sdW1uTGF5b3V0cykge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJNb2RlID0gRmlsdGVyTW9kZS5leGNlbFN0eWxlRmlsdGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdyb3VwVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2dyb3VwUm93VGVtcGxhdGUgPSB0aGlzLmdyb3VwVGVtcGxhdGUudGVtcGxhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kZXRhaWxUZW1wbGF0ZURpcmVjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGV0YWlsVGVtcGxhdGUgPSB0aGlzLmRldGFpbFRlbXBsYXRlRGlyZWN0aXZlO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodGhpcy5oaWRlR3JvdXBlZENvbHVtbnMgJiYgdGhpcy5fY29sdW1ucyAmJiB0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEdyb3VwQ29sc1Zpc2liaWxpdHkodGhpcy5oaWRlR3JvdXBlZENvbHVtbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldHVwTmF2aWdhdGlvblNlcnZpY2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHN1cGVyLm5nQWZ0ZXJWaWV3SW5pdCgpO1xuICAgICAgICB0aGlzLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLmJlZm9yZVZpZXdEZXN0cm95ZWQucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZSgodmlldykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgcm93RGF0YSA9IHZpZXcuY29udGV4dC4kaW1wbGljaXQ7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0RldGFpbFJlY29yZChyb3dEYXRhKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZERhdGEgPSB0aGlzLmNoaWxkRGV0YWlsVGVtcGxhdGVzLmdldChyb3dEYXRhLmRldGFpbHNEYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0bWxwT3V0bGV0ID0gY2FjaGVkRGF0YS5vd25lcjtcbiAgICAgICAgICAgICAgICAgICAgdG1scE91dGxldC5fdmlld0NvbnRhaW5lclJlZi5kZXRhY2goMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnNvcnRpbmdFeHByZXNzaW9uc0NoYW5nZS5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKChzb3J0aW5nRXhwcmVzc2lvbnM6IElTb3J0aW5nRXhwcmVzc2lvbltdKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucyB8fCAhdGhpcy5ncm91cGluZ0V4cHJlc3Npb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc29ydGluZ0V4cHJlc3Npb25zLmZvckVhY2goKHNvcnRFeHByOiBJU29ydGluZ0V4cHJlc3Npb24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBzb3J0RXhwci5maWVsZE5hbWU7XG4gICAgICAgICAgICAgICAgY29uc3QgZ3JvdXBpbmdFeHByID0gdGhpcy5ncm91cGluZ0V4cHJlc3Npb25zLmZpbmQoZXggPT4gZXguZmllbGROYW1lID09PSBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChncm91cGluZ0V4cHIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBpbmdFeHByLmRpciA9IHNvcnRFeHByLmRpcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgbmdPbkluaXQoKSB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIHRoaXMudHJhY2tDaGFuZ2VzID0gKF8sIHJlYykgPT4gKHJlYz8uZGV0YWlsc0RhdGEgIT09IHVuZGVmaW5lZCA/IHJlYy5kZXRhaWxzRGF0YSA6IHJlYyk7XG4gICAgICAgIHRoaXMuZ3JvdXBpbmdEb25lLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoKGFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY3J1ZFNlcnZpY2UuZW5kRWRpdChmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnN1bW1hcnlTZXJ2aWNlLnVwZGF0ZVN1bW1hcnlDYWNoZShhcmdzKTtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlckZlYXR1cmVzV2lkdGggPSBOYU47XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG92ZXJyaWRlIG5nRG9DaGVjaygpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBpbmdEaWZmZXIgJiYgdGhpcy5fY29sdW1ucyAmJiAhdGhpcy5oYXNDb2x1bW5MYXlvdXRzKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5ncm91cGluZ0RpZmZlci5kaWZmKHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucyk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcyAmJiB0aGlzLl9jb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLmZvckVhY2hBZGRlZEl0ZW0oKHJlYykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmdldENvbHVtbkJ5TmFtZShyZWMuaXRlbS5maWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2wuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNoYW5nZXMuZm9yRWFjaFJlbW92ZWRJdGVtKChyZWMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5nZXRDb2x1bW5CeU5hbWUocmVjLml0ZW0uZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29sLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyLm5nRG9DaGVjaygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGRhdGFMb2FkaW5nKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZGF0YVByZUxvYWQuZW1pdChldmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBjdXJyZW50IGNlbGwgc2VsZWN0aW9uIGluIHRoZSBmb3JtIG9mIGBbeyBjb2x1bW4uZmllbGQ6IGNlbGwudmFsdWUgfSwgLi4uXWAuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIGBmb3JtYXR0ZXJzYCBpcyBlbmFibGVkLCB0aGUgY2VsbCB2YWx1ZSB3aWxsIGJlIGZvcm1hdHRlZCBieSBpdHMgcmVzcGVjdGl2ZSBjb2x1bW4gZm9ybWF0dGVyIChpZiBhbnkpLlxuICAgICAqIElmIGBoZWFkZXJzYCBpcyBlbmFibGVkLCBpdCB3aWxsIHVzZSB0aGUgY29sdW1uIGhlYWRlciAoaWYgYW55KSBpbnN0ZWFkIG9mIHRoZSBjb2x1bW4gZmllbGQuXG4gICAgICovXG4gICAgcHVibGljIG92ZXJyaWRlIGdldFNlbGVjdGVkRGF0YShmb3JtYXR0ZXJzID0gZmFsc2UsIGhlYWRlcnMgPSBmYWxzZSk6IGFueVtdIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucy5sZW5ndGggfHwgdGhpcy5oYXNEZXRhaWxzKSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBbXTtcblxuICAgICAgICAgICAgY29uc3QgcHJvY2VzcyA9IChyZWNvcmQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmV4cHJlc3Npb24gfHwgcmVjb3JkLnN1bW1hcmllcyB8fCB0aGlzLmlzRGV0YWlsUmVjb3JkKHJlY29yZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc291cmNlLnB1c2gocmVjb3JkKTtcblxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5kYXRhVmlldy5mb3JFYWNoKHByb2Nlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdERhdGFGcm9tU2VsZWN0aW9uKHNvdXJjZSwgZm9ybWF0dGVycywgaGVhZGVycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuZ2V0U2VsZWN0ZWREYXRhKGZvcm1hdHRlcnMsIGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYElneEdyaWRSb3dgIGJ5IGluZGV4LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgbXlSb3cgPSBncmlkLmdldFJvd0J5SW5kZXgoMSk7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgICovXG4gICAgcHVibGljIGdldFJvd0J5SW5kZXgoaW5kZXg6IG51bWJlcik6IFJvd1R5cGUge1xuICAgICAgICBsZXQgcm93OiBSb3dUeXBlO1xuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRhdGFWaWV3Lmxlbmd0aCA+PSB0aGlzLnZpcnR1YWxpemF0aW9uU3RhdGUuc3RhcnRJbmRleCArIHRoaXMudmlydHVhbGl6YXRpb25TdGF0ZS5jaHVua1NpemUpIHtcbiAgICAgICAgICAgIHJvdyA9IHRoaXMuY3JlYXRlUm93KGluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghKGluZGV4IDwgdGhpcy52aXJ0dWFsaXphdGlvblN0YXRlLnN0YXJ0SW5kZXgpICYmICEoaW5kZXggPiB0aGlzLnZpcnR1YWxpemF0aW9uU3RhdGUuc3RhcnRJbmRleCArIHRoaXMudmlydHVhbGl6YXRpb25TdGF0ZS5jaHVua1NpemUpKSB7XG4gICAgICAgICAgICAgICAgcm93ID0gdGhpcy5jcmVhdGVSb3coaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGFnaW5nTW9kZSA9PT0gMSAmJiB0aGlzLnBhZ2UgIT09IDApIHtcbiAgICAgICAgICAgIHJvdy5pbmRleCA9IGluZGV4ICsgdGhpcy5wZXJQYWdlICogdGhpcy5wYWdlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3c7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgSWd4R3JpZFJvd2Agb2JqZWN0IGJ5IHRoZSBzcGVjaWZpZWQgcHJpbWFyeSBrZXkuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFJlcXVpcmVzIHRoYXQgdGhlIGBwcmltYXJ5S2V5YCBwcm9wZXJ0eSBpcyBzZXQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgbXlSb3cgPSB0aGlzLmdyaWQxLmdldFJvd0J5S2V5KFwiY2VsbDVcIik7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIGtleVZhbHVlXG4gICAgICovXG4gICAgcHVibGljIGdldFJvd0J5S2V5KGtleTogYW55KTogUm93VHlwZSB7XG4gICAgICAgIGNvbnN0IHJlYyA9IHRoaXMuZmlsdGVyZWRTb3J0ZWREYXRhID8gdGhpcy5wcmltYXJ5S2V5ID9cbiAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRTb3J0ZWREYXRhLmZpbmQocmVjb3JkID0+IHJlY29yZFt0aGlzLnByaW1hcnlLZXldID09PSBrZXkpIDpcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRTb3J0ZWREYXRhLmZpbmQocmVjb3JkID0+IHJlY29yZCA9PT0ga2V5KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmRhdGFWaWV3LmluZGV4T2YocmVjKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRoaXMuZGF0YVZpZXcubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBJZ3hHcmlkUm93KHRoaXMsIGluZGV4LCByZWMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGFsbFJvd3MoKTogUm93VHlwZVtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVZpZXcubWFwKChyZWMsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhZ2luZ01vZGUgPT09IDEgJiYgdGhpcy5wYWdlICE9PSAwID8gaW5kZXggPSBpbmRleCArIHRoaXMucGVyUGFnZSAqIHRoaXMucGFnZSA6IGluZGV4ID0gdGhpcy5kYXRhUm93TGlzdC5maXJzdC5pbmRleCArIGluZGV4O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUm93KGluZGV4KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29sbGVjdGlvbiBvZiBgSWd4R3JpZFJvd2BzIGZvciBjdXJyZW50IHBhZ2UuXG4gICAgICpcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBkYXRhUm93cygpOiBSb3dUeXBlW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGxSb3dzKCkuZmlsdGVyKHJvdyA9PiByb3cgaW5zdGFuY2VvZiBJZ3hHcmlkUm93KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBzZWxlY3RlZCBgSWd4R3JpZENlbGxgcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHNlbGVjdGVkQ2VsbHMgPSB0aGlzLmdyaWQuc2VsZWN0ZWRDZWxscztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHNlbGVjdGVkQ2VsbHMoKTogQ2VsbFR5cGVbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFSb3dzKCkubWFwKChyb3cpID0+IHJvdy5jZWxscy5maWx0ZXIoKGNlbGwpID0+IGNlbGwuc2VsZWN0ZWQpKVxuICAgICAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYENlbGxUeXBlYCBvYmplY3QgdGhhdCBtYXRjaGVzIHRoZSBjb25kaXRpb25zLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgbXlDZWxsID0gdGhpcy5ncmlkMS5nZXRDZWxsQnlDb2x1bW4oMiwgXCJVbml0UHJpY2VcIik7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIHJvd0luZGV4XG4gICAgICogQHBhcmFtIGNvbHVtbkZpZWxkXG4gICAgICovXG4gICAgcHVibGljIGdldENlbGxCeUNvbHVtbihyb3dJbmRleDogbnVtYmVyLCBjb2x1bW5GaWVsZDogc3RyaW5nKTogQ2VsbFR5cGUge1xuICAgICAgICBjb25zdCByb3cgPSB0aGlzLmdldFJvd0J5SW5kZXgocm93SW5kZXgpO1xuICAgICAgICBjb25zdCBjb2x1bW4gPSB0aGlzLl9jb2x1bW5zLmZpbmQoKGNvbCkgPT4gY29sLmZpZWxkID09PSBjb2x1bW5GaWVsZCk7XG4gICAgICAgIGlmIChyb3cgJiYgcm93IGluc3RhbmNlb2YgSWd4R3JpZFJvdyAmJiAhcm93LmRhdGE/LmRldGFpbHNEYXRhICYmIGNvbHVtbikge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFnaW5nTW9kZSA9PT0gMSAmJiB0aGlzLnBhZ2UgIT09IDApIHtcbiAgICAgICAgICAgICAgICByb3cuaW5kZXggPSByb3dJbmRleCArIHRoaXMucGVyUGFnZSAqIHRoaXMucGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgSWd4R3JpZENlbGwodGhpcywgcm93LmluZGV4LCBjb2x1bW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGBDZWxsVHlwZWAgb2JqZWN0IHRoYXQgbWF0Y2hlcyB0aGUgY29uZGl0aW9ucy5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogUmVxdWlyZXMgdGhhdCB0aGUgcHJpbWFyeUtleSBwcm9wZXJ0eSBpcyBzZXQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogZ3JpZC5nZXRDZWxsQnlLZXkoMSwgJ2luZGV4Jyk7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIHJvd1NlbGVjdG9yIG1hdGNoIGFueSByb3dJRFxuICAgICAqIEBwYXJhbSBjb2x1bW5GaWVsZFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRDZWxsQnlLZXkocm93U2VsZWN0b3I6IGFueSwgY29sdW1uRmllbGQ6IHN0cmluZyk6IENlbGxUeXBlIHtcbiAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5nZXRSb3dCeUtleShyb3dTZWxlY3Rvcik7XG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IHRoaXMuX2NvbHVtbnMuZmluZCgoY29sKSA9PiBjb2wuZmllbGQgPT09IGNvbHVtbkZpZWxkKTtcbiAgICAgICAgaWYgKHJvdyAmJiBjb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSWd4R3JpZENlbGwodGhpcywgcm93LmluZGV4LCBjb2x1bW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIHBpblJvdyhyb3dJRDogYW55LCBpbmRleD86IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCByb3cgPSB0aGlzLmdldFJvd0J5S2V5KHJvd0lEKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnBpblJvdyhyb3dJRCwgaW5kZXgsIHJvdyk7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIHVucGluUm93KHJvd0lEOiBhbnkpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5nZXRSb3dCeUtleShyb3dJRCk7XG4gICAgICAgIHJldHVybiBzdXBlci51bnBpblJvdyhyb3dJRCwgcm93KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBjcmVhdGVSb3coaW5kZXg6IG51bWJlciwgZGF0YT86IGFueSk6IFJvd1R5cGUge1xuICAgICAgICBsZXQgcm93OiBSb3dUeXBlO1xuXG4gICAgICAgIGNvbnN0IGRhdGFJbmRleCA9IHRoaXMuX2dldERhdGFWaWV3SW5kZXgoaW5kZXgpO1xuICAgICAgICBjb25zdCByZWMgPSBkYXRhID8/IHRoaXMuZGF0YVZpZXdbZGF0YUluZGV4XTtcblxuICAgICAgICBpZiAocmVjICYmIHRoaXMuaXNHcm91cEJ5UmVjb3JkKHJlYykpIHtcbiAgICAgICAgICAgIHJvdyA9IG5ldyBJZ3hHcm91cEJ5Um93KHRoaXMsIGluZGV4LCByZWMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWMgJiYgdGhpcy5pc1N1bW1hcnlSb3cocmVjKSkge1xuICAgICAgICAgICAgcm93ID0gbmV3IElneFN1bW1hcnlSb3codGhpcywgaW5kZXgsIHJlYy5zdW1tYXJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGZvdW5kIHJlY29yZCBpcyBhIG5vIGEgZ3JvdXBieSBvciBzdW1tYXJ5IHJvdywgcmV0dXJuIElneEdyaWRSb3cgaW5zdGFuY2VcbiAgICAgICAgaWYgKCFyb3cgJiYgcmVjKSB7XG4gICAgICAgICAgICByb3cgPSBuZXcgSWd4R3JpZFJvdyh0aGlzLCBpbmRleCwgcmVjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByb3c7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgZ2V0IGRlZmF1bHRUYXJnZXRCb2R5SGVpZ2h0KCk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGFsbEl0ZW1zID0gdGhpcy50b3RhbEl0ZW1Db3VudCB8fCB0aGlzLmRhdGFMZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVkQWN0dWFsUm93SGVpZ2h0ICogTWF0aC5taW4odGhpcy5fZGVmYXVsdFRhcmdldFJlY29yZE51bWJlcixcbiAgICAgICAgICAgIHRoaXMucGFnaW5hdG9yID8gTWF0aC5taW4oYWxsSXRlbXMsIHRoaXMucGVyUGFnZSkgOiBhbGxJdGVtcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgZ2V0R3JvdXBBcmVhSGVpZ2h0KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyb3VwQXJlYSA/IHRoaXMuZ2V0Q29tcHV0ZWRIZWlnaHQodGhpcy5ncm91cEFyZWEubmF0aXZlRWxlbWVudCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHJvdGVjdGVkIG92ZXJyaWRlIG9uQ29sdW1uc0FkZGVkT3JSZW1vdmVkKCkge1xuICAgICAgICAvLyB1cGRhdGUgZ3JvdXBpbmcgc3RhdGVzXG4gICAgICAgIHRoaXMuZ3JvdXBhYmxlUGlwZVRyaWdnZXIrKztcbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucyAmJiB0aGlzLmhpZGVHcm91cGVkQ29sdW1ucykge1xuICAgICAgICAgICAgdGhpcy5fc2V0R3JvdXBDb2xzVmlzaWJpbGl0eSh0aGlzLmhpZGVHcm91cGVkQ29sdW1ucyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIub25Db2x1bW5zQWRkZWRPclJlbW92ZWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBvdmVycmlkZSBzY3JvbGxUbyhyb3c6IGFueSB8IG51bWJlciwgY29sdW1uOiBhbnkgfCBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucyAmJiB0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMubGVuZ3RoXG4gICAgICAgICAgICAmJiB0eXBlb2YgKHJvdykgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBjb25zdCByb3dJbmRleCA9IHRoaXMuZ3JvdXBpbmdSZXN1bHQuaW5kZXhPZihyb3cpO1xuICAgICAgICAgICAgY29uc3QgZ3JvdXBCeVJlY29yZCA9IHRoaXMuZ3JvdXBpbmdNZXRhZGF0YVtyb3dJbmRleF07XG4gICAgICAgICAgICBpZiAoZ3JvdXBCeVJlY29yZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Z1bGx5RXhwYW5kR3JvdXAoZ3JvdXBCeVJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdXBlci5zY3JvbGxUbyhyb3csIGNvbHVtbiwgdGhpcy5ncm91cGluZ0ZsYXRSZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9nZXRTdGF0ZUZvckdyb3VwUm93KGdyb3VwUm93OiBJR3JvdXBCeVJlY29yZCk6IElHcm91cEJ5RXhwYW5kU3RhdGUge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JpZEFQSS5ncm91cEJ5X2dldF9leHBhbmRlZF9mb3JfZ3JvdXAoZ3JvdXBSb3cpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3RvZ2dsZUdyb3VwKGdyb3VwUm93OiBJR3JvdXBCeVJlY29yZCkge1xuICAgICAgICB0aGlzLl9ncmlkQVBJLmdyb3VwQnlfdG9nZ2xlX2dyb3VwKGdyb3VwUm93KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZnVsbHlFeHBhbmRHcm91cChncm91cFJvdzogSUdyb3VwQnlSZWNvcmQpIHtcbiAgICAgICAgdGhpcy5fZ3JpZEFQSS5ncm91cEJ5X2Z1bGx5X2V4cGFuZF9ncm91cChncm91cFJvdyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2FwcGx5R3JvdXBpbmcoKSB7XG4gICAgICAgIHRoaXMuX2dyaWRBUEkuc29ydF9ncm91cEJ5X211bHRpcGxlKHRoaXMuX2dyb3VwaW5nRXhwcmVzc2lvbnMpO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3NldHVwTmF2aWdhdGlvblNlcnZpY2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbHVtbkxheW91dHMpIHtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvbiA9IG5ldyBJZ3hHcmlkTVJMTmF2aWdhdGlvblNlcnZpY2UodGhpcy5wbGF0Zm9ybSk7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb24uZ3JpZCA9IHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGNoZWNrSWZOb0NvbHVtbkZpZWxkKGV4cHJlc3Npb246IElHcm91cGluZ0V4cHJlc3Npb24gfCBBcnJheTxJR3JvdXBpbmdFeHByZXNzaW9uPiB8IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNpbmdsZUV4cHJlc3Npb24gb2YgZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIGlmICghc2luZ2xlRXhwcmVzc2lvbi5maWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhZXhwcmVzc2lvbi5maWVsZE5hbWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfc2V0R3JvdXBDb2xzVmlzaWJpbGl0eSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fY29sdW1ucy5sZW5ndGggPiAwICYmICF0aGlzLmhhc0NvbHVtbkxheW91dHMpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucy5mb3JFYWNoKChleHByKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5nZXRDb2x1bW5CeU5hbWUoZXhwci5maWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbC5oaWRkZW4gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdHJpbmdpZnlDYWxsYmFjayhrZXk6IHN0cmluZywgdmFsOiBhbnkpIHtcbiAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgQmxhem9yLCBzaW5jZSBpdHMgd3JhcHBlcnMgaW5qZWN0IHRoaXMgZXh0ZXJuYWxPYmplY3QgdGhhdCBjYW5ub3Qgc2VyaWFsaXplLlxuICAgICAgICBpZiAoa2V5ID09PSAnZXh0ZXJuYWxPYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxufVxuIiwiPCEtLSBUb29sYmFyIGFyZWEgLS0+XG48bmctY29udGVudCBzZWxlY3Q9XCJpZ3gtZ3JpZC10b29sYmFyLGlnYy1ncmlkLXRvb2xiYXJcIj48L25nLWNvbnRlbnQ+XG5cbjwhLS0gR3JvdXAtYnkgYXJlYSAtLT5cbjxuZy1jb250YWluZXIgKm5nSWY9XCJzaG93R3JvdXBBcmVhICYmIChncm91cGluZ0V4cHJlc3Npb25zLmxlbmd0aCA+IDAgfHwgaGFzR3JvdXBhYmxlQ29sdW1ucylcIj5cbiAgICA8aWd4LWdyaWQtZ3JvdXAtYnktYXJlYSAjZ3JvdXBBcmVhIFtzdHlsZS5mbGV4LWJhc2lzLnB4XT1cIm91dGVyV2lkdGhcIlxuICAgICAgICBbZ3JpZF09XCJ0aGlzXCJcbiAgICAgICAgW2V4cHJlc3Npb25zXT1cImdyb3VwaW5nRXhwcmVzc2lvbnNcIlxuICAgICAgICBbc29ydGluZ0V4cHJlc3Npb25zXT1cInNvcnRpbmdFeHByZXNzaW9uc1wiXG4gICAgICAgIFtkcm9wQXJlYVRlbXBsYXRlXT1cImRyb3BBcmVhVGVtcGxhdGVcIlxuICAgICAgICBbZHJvcEFyZWFNZXNzYWdlXT1cImRyb3BBcmVhTWVzc2FnZVwiXG4gICAgPlxuICAgIDwvaWd4LWdyaWQtZ3JvdXAtYnktYXJlYT5cbjwvbmctY29udGFpbmVyPlxuXG48IS0tIEdyaWQgdGFibGUgaGVhZCByb3cgYXJlYSAtLT5cbjxpZ3gtZ3JpZC1oZWFkZXItcm93IGNsYXNzPVwiaWd4LWdyaWQtdGhlYWRcIiB0YWJpbmRleD1cIjBcIlxuICAgIFtncmlkXT1cInRoaXNcIlxuICAgIFtoYXNNUkxdPVwiaGFzQ29sdW1uTGF5b3V0c1wiXG4gICAgW2FjdGl2ZURlc2NlbmRhbnRdPVwiYWN0aXZlRGVzY2VuZGFudFwiXG4gICAgW3dpZHRoXT1cImNhbGNXaWR0aFwiXG4gICAgW3Bpbm5lZENvbHVtbkNvbGxlY3Rpb25dPVwicGlubmVkQ29sdW1uc1wiXG4gICAgW3VucGlubmVkQ29sdW1uQ29sbGVjdGlvbl09XCJ1bnBpbm5lZENvbHVtbnNcIlxuICAgIChrZXlkb3duLm1ldGEuYyk9XCJjb3B5SGFuZGxlcigkZXZlbnQpXCJcbiAgICAoa2V5ZG93bi5jb250cm9sLmMpPVwiY29weUhhbmRsZXIoJGV2ZW50KVwiXG4gICAgKGNvcHkpPVwiY29weUhhbmRsZXIoJGV2ZW50KVwiXG4gICAgKGtleWRvd24pPVwibmF2aWdhdGlvbi5oZWFkZXJOYXZpZ2F0aW9uKCRldmVudClcIlxuICAgIChzY3JvbGwpPVwicHJldmVudEhlYWRlclNjcm9sbCgkZXZlbnQpXCJcbiAgICAoZm9jdXMpPVwibmF2aWdhdGlvbi5mb2N1c0ZpcnN0Q2VsbCgpXCJcbj5cbjwvaWd4LWdyaWQtaGVhZGVyLXJvdz5cblxuPGRpdiBpZ3hHcmlkQm9keSAoa2V5ZG93bi5jb250cm9sLmMpPVwiY29weUhhbmRsZXIoJGV2ZW50KVwiIChjb3B5KT1cImNvcHlIYW5kbGVyKCRldmVudClcIiBjbGFzcz1cImlneC1ncmlkX190Ym9keVwiIHJvbGU9XCJyb3dncm91cFwiPlxuICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fdGJvZHktY29udGVudFwiIHRhYmluZGV4PVwiMFwiIFthdHRyLnJvbGVdPVwiZGF0YVZpZXcubGVuZ3RoID8gbnVsbCA6ICdyb3cnXCIgKGtleWRvd24pPVwibmF2aWdhdGlvbi5oYW5kbGVOYXZpZ2F0aW9uKCRldmVudClcIiAoZm9jdXMpPVwibmF2aWdhdGlvbi5mb2N1c1Rib2R5KCRldmVudClcIlxuICAgICAgICAoZHJhZ1N0b3ApPVwic2VsZWN0aW9uU2VydmljZS5kcmFnTW9kZSA9ICRldmVudFwiIChzY3JvbGwpPVwicHJldmVudENvbnRhaW5lclNjcm9sbCgkZXZlbnQpXCJcbiAgICAgICAgKGRyYWdTY3JvbGwpPVwiZHJhZ1Njcm9sbCgkZXZlbnQpXCIgW2lneEdyaWREcmFnU2VsZWN0XT1cInNlbGVjdGlvblNlcnZpY2UuZHJhZ01vZGVcIlxuICAgICAgICBbc3R5bGUuaGVpZ2h0LnB4XT1cInRvdGFsSGVpZ2h0XCIgW3N0eWxlLndpZHRoLnB4XT1cImNhbGNXaWR0aCB8fCBudWxsXCIgI3Rib2R5IFthdHRyLmFyaWEtYWN0aXZlZGVzY2VuZGFudF09XCJhY3RpdmVEZXNjZW5kYW50XCI+XG4gICAgICAgIDxzcGFuICpuZ0lmPVwibW92aW5nICYmIGNvbHVtbkluRHJhZyAmJiBwaW5uZWRDb2x1bW5zLmxlbmd0aCA8PSAwXCJcbiAgICAgICAgICAgIFtpZ3hDb2x1bW5Nb3ZpbmdEcm9wXT1cImhlYWRlckNvbnRhaW5lclwiIFthdHRyLmRyb3BwYWJsZV09XCJ0cnVlXCIgaWQ9XCJsZWZ0XCJcbiAgICAgICAgICAgIGNsYXNzPVwiaWd4LWdyaWRfX3Njcm9sbC1vbi1kcmFnLWxlZnRcIj48L3NwYW4+XG4gICAgICAgIDxzcGFuICpuZ0lmPVwibW92aW5nICYmIGNvbHVtbkluRHJhZyAmJiBwaW5uZWRDb2x1bW5zLmxlbmd0aCA+IDBcIlxuICAgICAgICAgICAgW2lneENvbHVtbk1vdmluZ0Ryb3BdPVwiaGVhZGVyQ29udGFpbmVyXCIgW2F0dHIuZHJvcHBhYmxlXT1cInRydWVcIiBpZD1cImxlZnRcIlxuICAgICAgICAgICAgY2xhc3M9XCJpZ3gtZ3JpZF9fc2Nyb2xsLW9uLWRyYWctcGlubmVkXCIgW3N0eWxlLmxlZnQucHhdPVwicGlubmVkV2lkdGhcIj48L3NwYW4+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImhhc1Bpbm5lZFJlY29yZHMgJiYgaXNSb3dQaW5uaW5nVG9Ub3AgPyBwaW5uZWRSZWNvcmRzVGVtcGxhdGUgOiBudWxsXCI+XG4gICAgPC9uZy1jb250YWluZXI+XG4gICAgPG5nLXRlbXBsYXRlICNwaW5uZWRSZWNvcmRzVGVtcGxhdGU+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJkYXRhXG4gICAgICAgIHwgZ3JpZFRyYW5zYWN0aW9uOmlkOnBpcGVUcmlnZ2VyXG4gICAgICAgIHwgdmlzaWJsZUNvbHVtbnM6aGFzVmlzaWJsZUNvbHVtbnNcbiAgICAgICAgfCBncmlkQWRkUm93OnRydWU6cGlwZVRyaWdnZXJcbiAgICAgICAgfCBncmlkUm93UGlubmluZzppZDp0cnVlOnBpcGVUcmlnZ2VyXG4gICAgICAgIHwgZ3JpZEZpbHRlcmluZzpmaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWU6ZmlsdGVyU3RyYXRlZ3k6YWR2YW5jZWRGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWU6aWQ6cGlwZVRyaWdnZXI6ZmlsdGVyaW5nUGlwZVRyaWdnZXI6dHJ1ZVxuICAgICAgICB8IGdyaWRTb3J0OnNvcnRpbmdFeHByZXNzaW9uczpncm91cGluZ0V4cHJlc3Npb25zOnNvcnRTdHJhdGVneTppZDpwaXBlVHJpZ2dlcjp0cnVlIGFzIHBpbm5lZERhdGFcIj5cbiAgICAgICAgICAgIDxkaXYgI3BpbkNvbnRhaW5lciAqbmdJZj1cInBpbm5lZERhdGEubGVuZ3RoID4gMFwiXG4gICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwie1xuICAgICAgICAgICAgICAgICAgICAnaWd4LWdyaWRfX3RyLS1waW5uZWQtYm90dG9tJzogICFpc1Jvd1Bpbm5pbmdUb1RvcCxcbiAgICAgICAgICAgICAgICAgICAgJ2lneC1ncmlkX190ci0tcGlubmVkLXRvcCc6IGlzUm93UGlubmluZ1RvVG9wXG4gICAgICAgICAgICAgICAgfVwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJpZ3gtZ3JpZF9fdHItLXBpbm5lZFwiIFtzdHlsZS53aWR0aC5weF09XCJjYWxjV2lkdGhcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCByb3dEYXRhIG9mIHBpbm5lZERhdGE7IGxldCByb3dJbmRleCA9IGluZGV4XCI+XG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJwaW5uZWRfcmVjb3JkX3RlbXBsYXRlOyBjb250ZXh0OiBnZXRDb250ZXh0KHJvd0RhdGEsIHJvd0luZGV4LCB0cnVlKVwiPlxuICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8bmctdGVtcGxhdGUgaWd4R3JpZEZvciBsZXQtcm93RGF0YSBbaWd4R3JpZEZvck9mXT1cImRhdGFcbiAgICAgICAgfCBncmlkVHJhbnNhY3Rpb246aWQ6cGlwZVRyaWdnZXJcbiAgICAgICAgfCB2aXNpYmxlQ29sdW1uczpoYXNWaXNpYmxlQ29sdW1uc1xuICAgICAgICB8IGdyaWRGaWx0ZXJpbmc6ZmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlOmZpbHRlclN0cmF0ZWd5OmFkdmFuY2VkRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlOmlkOnBpcGVUcmlnZ2VyOmZpbHRlcmluZ1BpcGVUcmlnZ2VyXG4gICAgICAgIHwgZ3JpZFNvcnQ6c29ydGluZ0V4cHJlc3Npb25zOmdyb3VwaW5nRXhwcmVzc2lvbnM6c29ydFN0cmF0ZWd5OmlkOnBpcGVUcmlnZ2VyXG4gICAgICAgIHwgZ3JpZEdyb3VwQnk6Z3JvdXBpbmdFeHByZXNzaW9uczpncm91cGluZ0V4cGFuc2lvblN0YXRlOmdyb3VwU3RyYXRlZ3k6Z3JvdXBzRXhwYW5kZWQ6aWQ6Z3JvdXBzUmVjb3JkczpwaXBlVHJpZ2dlclxuICAgICAgICB8IGdyaWRQYWdpbmc6ISFwYWdpbmF0b3I6cGFnZTpwZXJQYWdlOnBpcGVUcmlnZ2VyXG4gICAgICAgIHwgZ3JpZFN1bW1hcnk6aGFzU3VtbWFyaXplZENvbHVtbnM6c3VtbWFyeUNhbGN1bGF0aW9uTW9kZTpzdW1tYXJ5UG9zaXRpb246aWQ6c2hvd1N1bW1hcnlPbkNvbGxhcHNlOnBpcGVUcmlnZ2VyOnN1bW1hcnlQaXBlVHJpZ2dlclxuICAgICAgICB8IGdyaWREZXRhaWxzOmhhc0RldGFpbHM6ZXhwYW5zaW9uU3RhdGVzOnBpcGVUcmlnZ2VyXG4gICAgICAgIHwgZ3JpZEFkZFJvdzpmYWxzZTpwaXBlVHJpZ2dlclxuICAgICAgICB8IGdyaWRSb3dQaW5uaW5nOmlkOmZhbHNlOnBpcGVUcmlnZ2VyXCJcbiAgICAgICAgICAgIGxldC1yb3dJbmRleD1cImluZGV4XCIgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIid2ZXJ0aWNhbCdcIiBbaWd4Rm9yU2Nyb2xsQ29udGFpbmVyXT1cInZlcnRpY2FsU2Nyb2xsXCJcbiAgICAgICAgICAgIFtpZ3hGb3JDb250YWluZXJTaXplXT1cImNhbGNIZWlnaHRcIlxuICAgICAgICAgICAgW2lneEZvckl0ZW1TaXplXT1cImhhc0NvbHVtbkxheW91dHMgPyByb3dIZWlnaHQgKiBtdWx0aVJvd0xheW91dFJvd1NpemUgKyAxIDogcmVuZGVyZWRSb3dIZWlnaHRcIlxuICAgICAgICAgICAgW2lneEZvclRyYWNrQnldPVwidHJhY2tDaGFuZ2VzXCJcbiAgICAgICAgICAgICN2ZXJ0aWNhbFNjcm9sbENvbnRhaW5lciAoY2h1bmtQcmVsb2FkKT1cImRhdGFMb2FkaW5nKCRldmVudClcIiAoZGF0YUNoYW5naW5nKT1cImRhdGFSZWJpbmRpbmcoJGV2ZW50KVwiIChkYXRhQ2hhbmdlZCk9XCJkYXRhUmVib3VuZCgkZXZlbnQpXCI+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgICAgICAgICBbaWd4VGVtcGxhdGVPdXRsZXRdPVwiZ2V0Um93VGVtcGxhdGUocm93RGF0YSlcIlxuICAgICAgICAgICAgICAgIFtpZ3hUZW1wbGF0ZU91dGxldENvbnRleHRdPVwiZ2V0Q29udGV4dChyb3dEYXRhLCByb3dJbmRleClcIlxuICAgICAgICAgICAgICAgIChjYWNoZWRWaWV3TG9hZGVkKT1cImNhY2hlZFZpZXdMb2FkZWQoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgKHZpZXdDcmVhdGVkKT1cInZpZXdDcmVhdGVkSGFuZGxlcigkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAodmlld01vdmVkKT1cInZpZXdNb3ZlZEhhbmRsZXIoJGV2ZW50KVwiPlxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImhhc1Bpbm5lZFJlY29yZHMgJiYgIWlzUm93UGlubmluZ1RvVG9wID8gcGlubmVkUmVjb3Jkc1RlbXBsYXRlIDogbnVsbFwiPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPG5nLXRlbXBsYXRlICNyZWNvcmRfdGVtcGxhdGUgbGV0LXJvd0luZGV4PVwiaW5kZXhcIiBsZXQtcm93RGF0YSBsZXQtZGlzYWJsZWRSb3c9XCJkaXNhYmxlZFwiPlxuICAgICAgICAgICAgPGlneC1ncmlkLXJvdyBbZ3JpZElEXT1cImlkXCIgW2luZGV4XT1cInJvd0luZGV4XCIgW2RhdGFdPVwicm93RGF0YVwiIFtkaXNhYmxlZF09XCJkaXNhYmxlZFJvd1wiXG4gICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwicm93Q2xhc3NlcyB8IGlneEdyaWRSb3dDbGFzc2VzOnJvdzpyb3cuaW5FZGl0TW9kZTpyb3cuc2VsZWN0ZWQ6cm93LmRpcnR5OnJvdy5kZWxldGVkOnJvdy5kcmFnZ2luZzpyb3dJbmRleDpoYXNDb2x1bW5MYXlvdXRzOmZhbHNlOnJvd0RhdGE6cGlwZVRyaWdnZXJcIlxuICAgICAgICAgICAgICAgIFtuZ1N0eWxlXT1cInJvd1N0eWxlcyB8IGlneEdyaWRSb3dTdHlsZXM6cm93RGF0YTpyb3dJbmRleDpwaXBlVHJpZ2dlclwiICNyb3c+XG4gICAgICAgICAgICA8L2lneC1ncmlkLXJvdz5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPG5nLXRlbXBsYXRlICNwaW5uZWRfcmVjb3JkX3RlbXBsYXRlIGxldC1yb3dJbmRleD1cImluZGV4XCIgbGV0LXJvd0RhdGE+XG4gICAgICAgICAgICA8aWd4LWdyaWQtcm93IFtncmlkSURdPVwiaWRcIiBbaW5kZXhdPVwicm93SW5kZXhcIiBbZGF0YV09XCJyb3dEYXRhXCJcbiAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJyb3dDbGFzc2VzIHwgaWd4R3JpZFJvd0NsYXNzZXM6cm93OnJvdy5pbkVkaXRNb2RlOnJvdy5zZWxlY3RlZDpyb3cuZGlydHk6cm93LmRlbGV0ZWQ6cm93LmRyYWdnaW5nOnJvd0luZGV4Omhhc0NvbHVtbkxheW91dHM6ZmFsc2U6cm93RGF0YTpwaXBlVHJpZ2dlclwiXG4gICAgICAgICAgICAgICAgW25nU3R5bGVdPVwicm93U3R5bGVzIHwgaWd4R3JpZFJvd1N0eWxlczpyb3dEYXRhOnJvd0luZGV4OnBpcGVUcmlnZ2VyXCIjcm93ICNwaW5uZWRSb3c+XG4gICAgICAgICAgICA8L2lneC1ncmlkLXJvdz5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPG5nLXRlbXBsYXRlICNncm91cF90ZW1wbGF0ZSBsZXQtcm93SW5kZXg9XCJpbmRleFwiIGxldC1yb3dEYXRhPlxuICAgICAgICAgICAgPGlneC1ncmlkLWdyb3VwYnktcm93IFtncmlkSURdPVwiaWRcIiBbaW5kZXhdPVwicm93SW5kZXhcIiBbZ3JvdXBSb3ddPVwicm93RGF0YVwiIFtoaWRlR3JvdXBSb3dTZWxlY3RvcnNdPVwiaGlkZVJvd1NlbGVjdG9yc1wiIFtyb3dEcmFnZ2FibGVdPVwicm93RHJhZ2dhYmxlXCIgI3Jvdz5cbiAgICAgICAgICAgIDwvaWd4LWdyaWQtZ3JvdXBieS1yb3c+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjc3VtbWFyeV90ZW1wbGF0ZSBsZXQtcm93SW5kZXg9XCJpbmRleFwiIGxldC1yb3dEYXRhPlxuICAgICAgICAgICAgPGlneC1ncmlkLXN1bW1hcnktcm93IHJvbGU9XCJyb3dcIiBbZ3JpZElEXT1cImlkXCIgW3N1bW1hcmllc109XCJyb3dEYXRhLnN1bW1hcmllc1wiIFtpbmRleF09XCJyb3dJbmRleFwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJpZ3gtZ3JpZF9fc3VtbWFyaWVzLS1ib2R5XCIgI3N1bW1hcnlSb3c+XG4gICAgICAgICAgICA8L2lneC1ncmlkLXN1bW1hcnktcm93PlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8bmctdGVtcGxhdGUgI2RldGFpbF90ZW1wbGF0ZV9jb250YWluZXIgbGV0LXJvd0luZGV4PVwiaW5kZXhcIiBsZXQtcm93RGF0YT5cbiAgICAgICAgICAgIDxkaXYgZGV0YWlsPVwidHJ1ZVwiIGlkPVwie3tpZH19X3t7cm93SW5kZXh9fVwiIChwb2ludGVyZG93bik9XCJkZXRhaWxzVmlld0ZvY3VzZWQoZGV0YWlsc0NvbnRhaW5lciwgcm93SW5kZXgpXCIgI2RldGFpbHNDb250YWluZXIgW2F0dHIuZGF0YS1yb3dpbmRleF09XCJyb3dJbmRleFwiXG4gICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwie1xuICAgICAgICAgICAgICAgICdpZ3gtZ3JpZF9fdHItY29udGFpbmVyJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnaWd4LWdyaWRfX3RyLWNvbnRhaW5lci0tYWN0aXZlJzogaXNEZXRhaWxBY3RpdmUocm93SW5kZXgpXG4gICAgICAgICAgICB9XCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX19oaWVyYXJjaGljYWwtaW5kZW50XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwidGhpcy5ncm91cGluZ0V4cHJlc3Npb25zLmxlbmd0aCA+IDBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX19yb3ctaW5kZW50YXRpb24gaWd4LWdyaWRfX3Jvdy1pbmRlbnRhdGlvbi0tbGV2ZWwte3tncm91cGluZ0V4cHJlc3Npb25zLmxlbmd0aH19XCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJkZXRhaWxUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJnZXREZXRhaWxzQ29udGV4dChyb3dEYXRhLCByb3dJbmRleClcIj5cbiAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJ0ZW1wbGF0ZTsgY29udGV4dDogeyAkaW1wbGljaXQ6IHRoaXMgfVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Jvdy1lZGl0aW5nLW91dGxldFwiIGlneE92ZXJsYXlPdXRsZXQgI2lneFJvd0VkaXRpbmdPdmVybGF5T3V0bGV0PjwvZGl2PlxuICAgICAgICA8aWdjLXRyaWFsLXdhdGVybWFyaz48L2lnYy10cmlhbC13YXRlcm1hcms+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBpZ3hUb2dnbGUgI2xvYWRpbmdPdmVybGF5PlxuICAgICAgICA8aWd4LWNpcmN1bGFyLWJhciBbaW5kZXRlcm1pbmF0ZV09XCJ0cnVlXCIgKm5nSWY9XCJzaG91bGRPdmVybGF5TG9hZGluZ1wiPlxuICAgICAgICA8L2lneC1jaXJjdWxhci1iYXI+XG4gICAgPC9kaXY+XG4gICAgPHNwYW4gKm5nSWY9XCJtb3ZpbmcgJiYgY29sdW1uSW5EcmFnXCIgW2lneENvbHVtbk1vdmluZ0Ryb3BdPVwiaGVhZGVyQ29udGFpbmVyXCIgW2F0dHIuZHJvcHBhYmxlXT1cInRydWVcIlxuICAgICAgICBpZD1cInJpZ2h0XCIgY2xhc3M9XCJpZ3gtZ3JpZF9fc2Nyb2xsLW9uLWRyYWctcmlnaHRcIj48L3NwYW4+XG4gICAgPGRpdiBbaGlkZGVuXT1cIiFoYXNWZXJ0aWNhbFNjcm9sbCgpXCIgY2xhc3M9XCJpZ3gtZ3JpZF9fdGJvZHktc2Nyb2xsYmFyXCIgW3N0eWxlLndpZHRoLnB4XT1cInNjcm9sbFNpemVcIiAocG9pbnRlcmRvd24pPVwiJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX190Ym9keS1zY3JvbGxiYXItc3RhcnRcIiBbc3R5bGUuaGVpZ2h0LnB4XT1cImlzUm93UGlubmluZ1RvVG9wID8gcGlubmVkUm93SGVpZ2h0IDogMFwiPjwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Rib2R5LXNjcm9sbGJhci1tYWluXCIgW3N0eWxlLmhlaWdodC5weF09XCJjYWxjSGVpZ2h0XCI+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgaWd4R3JpZEZvciBbaWd4R3JpZEZvck9mXT1cIltdXCIgI3ZlcnRpY2FsU2Nyb2xsSG9sZGVyPjwvbmctdGVtcGxhdGU+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Rib2R5LXNjcm9sbGJhci1lbmRcIiBbc3R5bGUuaGVpZ2h0LnB4XT1cIiFpc1Jvd1Bpbm5pbmdUb1RvcCA/IHBpbm5lZFJvd0hlaWdodCA6IDBcIj48L2Rpdj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fYWRkcm93LXNuYWNrYmFyXCI+XG4gICAgICAgIDxpZ3gtc25hY2tiYXIgI2FkZFJvd1NuYWNrYmFyIFtvdXRsZXRdPVwiaWd4Qm9keU92ZXJsYXlPdXRsZXRcIiBbYWN0aW9uVGV4dF09XCJyZXNvdXJjZVN0cmluZ3MuaWd4X2dyaWRfc25hY2tiYXJfYWRkcm93X2FjdGlvbnRleHRcIiBbZGlzcGxheVRpbWVdPVwic25hY2tiYXJEaXNwbGF5VGltZVwiPnt7cmVzb3VyY2VTdHJpbmdzLmlneF9ncmlkX3NuYWNrYmFyX2FkZHJvd19sYWJlbH19PC9pZ3gtc25hY2tiYXI+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2ICNpZ3hCb2R5T3ZlcmxheU91dGxldD1cIm92ZXJsYXktb3V0bGV0XCIgaWd4T3ZlcmxheU91dGxldD48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX2xvYWRpbmctb3V0bGV0XCIgI2lneExvYWRpbmdPdmVybGF5T3V0bGV0IGlneE92ZXJsYXlPdXRsZXQ+PC9kaXY+XG48L2Rpdj5cblxuXG48ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Rmb290XCIgcm9sZT1cInJvd2dyb3VwXCIgW3N0eWxlLmhlaWdodC5weF09XCJzdW1tYXJ5Um93SGVpZ2h0XCIgI3Rmb290PlxuICAgIDxkaXYgdGFiaW5kZXg9XCIwXCIgKGZvY3VzKT1cIm5hdmlnYXRpb24uZm9jdXNGaXJzdENlbGwoZmFsc2UpXCIgKGtleWRvd24pPVwibmF2aWdhdGlvbi5zdW1tYXJ5TmF2KCRldmVudClcIiBbYXR0ci5hcmlhLWFjdGl2ZWRlc2NlbmRhbnRdPVwiYWN0aXZlRGVzY2VuZGFudFwiPlxuICAgICAgICA8aWd4LWdyaWQtc3VtbWFyeS1yb3cgW3N0eWxlLndpZHRoLnB4XT1cImNhbGNXaWR0aFwiICBbc3R5bGUuaGVpZ2h0LnB4XT1cInN1bW1hcnlSb3dIZWlnaHRcIlxuICAgICAgICAgICAgKm5nSWY9XCJoYXNTdW1tYXJpemVkQ29sdW1ucyAmJiByb290U3VtbWFyaWVzRW5hYmxlZFwiIFtncmlkSURdPVwiaWRcIiByb2xlPVwicm93XCJcbiAgICAgICAgICAgIFtzdW1tYXJpZXNdPVwiaWQgfCBpZ3hHcmlkU3VtbWFyeURhdGFQaXBlOnN1bW1hcnlTZXJ2aWNlLnJldHJpZ2dlclJvb3RQaXBlXCIgW2luZGV4XT1cImRhdGFWaWV3Lmxlbmd0aFwiXG4gICAgICAgICAgICBjbGFzcz1cImlneC1ncmlkX19zdW1tYXJpZXNcIiAjc3VtbWFyeVJvdz5cbiAgICAgICAgPC9pZ3gtZ3JpZC1zdW1tYXJ5LXJvdz5cbiAgICAgICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX190Zm9vdC10aHVtYlwiIFtoaWRkZW5dPVwiIWhhc1ZlcnRpY2FsU2Nyb2xsKClcIiBbc3R5bGUuaGVpZ2h0LnB4XT1cInN1bW1hcnlSb3dIZWlnaHRcIlxuICAgICAgICAgICAgW3N0eWxlLndpZHRoLnB4XT1cInNjcm9sbFNpemVcIj48L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuXG48ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Njcm9sbFwiIFtzdHlsZS5oZWlnaHQucHhdPVwic2Nyb2xsU2l6ZVwiICNzY3IgW2hpZGRlbl09XCJpc0hvcml6b250YWxTY3JvbGxIaWRkZW5cIiAocG9pbnRlcmRvd24pPVwiJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIj5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Njcm9sbC1zdGFydFwiIFtzdHlsZS53aWR0aC5weF09XCJpc1Bpbm5pbmdUb1N0YXJ0ID8gcGlubmVkV2lkdGggOiBoZWFkZXJGZWF0dXJlc1dpZHRoXCIgW3N0eWxlLm1pbi13aWR0aC5weF09XCJpc1Bpbm5pbmdUb1N0YXJ0ID8gcGlubmVkV2lkdGggOiBoZWFkZXJGZWF0dXJlc1dpZHRoXCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX19zY3JvbGwtbWFpblwiIFtzdHlsZS53aWR0aC5weF09XCJ1bnBpbm5lZFdpZHRoXCI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBpZ3hHcmlkRm9yIFtpZ3hHcmlkRm9yT2ZdPVwiRU1QVFlfREFUQVwiICNzY3JvbGxDb250YWluZXI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX19zY3JvbGwtZW5kXCIgW3N0eWxlLmZsb2F0XT1cIidyaWdodCdcIiBbc3R5bGUud2lkdGgucHhdPVwicGlubmVkV2lkdGhcIiBbc3R5bGUubWluLXdpZHRoLnB4XT1cInBpbm5lZFdpZHRoXCIgW2hpZGRlbl09XCJwaW5uZWRXaWR0aCA9PT0gMCB8fCBpc1Bpbm5pbmdUb1N0YXJ0XCI+PC9kaXY+XG48L2Rpdj5cblxuPGRpdiBjbGFzcz1cImlneC1ncmlkX19mb290ZXJcIiAjZm9vdGVyPlxuICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImlneC1ncmlkLWZvb3RlcixpZ2MtZ3JpZC1mb290ZXJcIj48L25nLWNvbnRlbnQ+XG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiaWd4LXBhZ2luYXRvcixpZ2MtcGFnaW5hdG9yXCI+PC9uZy1jb250ZW50PlxuPC9kaXY+XG5cbjxuZy10ZW1wbGF0ZSAjZW1wdHlGaWx0ZXJlZEdyaWQ+XG4gICAgPHNwYW4gY2xhc3M9XCJpZ3gtZ3JpZF9fdGJvZHktbWVzc2FnZVwiIHJvbGU9XCJjZWxsXCI+XG4gICAgICAgIDxzcGFuPnt7ZW1wdHlGaWx0ZXJlZEdyaWRNZXNzYWdlfX08L3NwYW4+XG4gICAgICAgIDxzcGFuICpuZ0lmPVwic2hvd0FkZEJ1dHRvblwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImFkZFJvd0VtcHR5VGVtcGxhdGUgfHwgZGVmYXVsdEFkZFJvd0VtcHR5VGVtcGxhdGVcIj48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9zcGFuPlxuICAgIDwvc3Bhbj5cbjwvbmctdGVtcGxhdGU+XG5cbjxuZy10ZW1wbGF0ZSAjZGVmYXVsdEVtcHR5R3JpZD5cbiAgICA8c3BhbiBjbGFzcz1cImlneC1ncmlkX190Ym9keS1tZXNzYWdlXCIgcm9sZT1cImNlbGxcIj5cbiAgICAgICAgPHNwYW4+e3tlbXB0eUdyaWRNZXNzYWdlfX08L3NwYW4+XG4gICAgICAgIDxzcGFuICpuZ0lmPVwic2hvd0FkZEJ1dHRvblwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImFkZFJvd0VtcHR5VGVtcGxhdGUgfHwgZGVmYXVsdEFkZFJvd0VtcHR5VGVtcGxhdGVcIj48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9zcGFuPlxuICAgIDwvc3Bhbj5cbjwvbmctdGVtcGxhdGU+XG5cbjxuZy10ZW1wbGF0ZSAjZGVmYXVsdEFkZFJvd0VtcHR5VGVtcGxhdGU+XG4gICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgaWd4QnV0dG9uPVwiY29udGFpbmVkXCIgaWd4UmlwcGxlIChjbGljayk9XCJ0aGlzLmNydWRTZXJ2aWNlLmVudGVyQWRkUm93TW9kZShudWxsLCBmYWxzZSwgJGV2ZW50KVwiPlxuICAgICAgICB7e3Jlc291cmNlU3RyaW5ncy5pZ3hfZ3JpZF9hZGRfcm93X2xhYmVsfX1cbiAgICA8L2J1dHRvbj5cbjwvbmctdGVtcGxhdGU+XG5cbjxuZy10ZW1wbGF0ZSAjZGVmYXVsdExvYWRpbmdHcmlkPlxuICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fbG9hZGluZ1wiPlxuICAgICAgICA8aWd4LWNpcmN1bGFyLWJhciBbaW5kZXRlcm1pbmF0ZV09XCJ0cnVlXCI+XG4gICAgICAgIDwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICA8L2Rpdj5cbjwvbmctdGVtcGxhdGU+XG5cbjxuZy10ZW1wbGF0ZSAjZGVmYXVsdEV4cGFuZGVkVGVtcGxhdGU+XG4gICAgPGlneC1pY29uXG4gICAgICAgIGZhbWlseT1cImRlZmF1bHRcIlxuICAgICAgICBuYW1lPVwidW5mb2xkX2xlc3NcIlxuICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgW25nQ2xhc3NdPVwie1xuICAgICAgICAgICAgJ2lneC1ncmlkX19ncm91cC1leHBhbmQtYnRuJzogdHJ1ZSxcbiAgICAgICAgICAgICdpZ3gtZ3JpZF9fZ3JvdXAtZXhwYW5kLWJ0bi0tcHVzaCc6IGZpbHRlcmluZ1NlcnZpY2UuaXNGaWx0ZXJSb3dWaXNpYmxlXG4gICAgICAgIH1cIlxuICAgID5cbiAgICA8L2lneC1pY29uPlxuPC9uZy10ZW1wbGF0ZT5cblxuIDxuZy10ZW1wbGF0ZSAjZGVmYXVsdENvbGxhcHNlZFRlbXBsYXRlPlxuICAgIDxpZ3gtaWNvblxuICAgICAgICBmYW1pbHk9XCJkZWZhdWx0XCJcbiAgICAgICAgbmFtZT1cInVuZm9sZF9tb3JlXCJcbiAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgIFtuZ0NsYXNzXT1cIntcbiAgICAgICAgICAgICdpZ3gtZ3JpZF9fZ3JvdXAtZXhwYW5kLWJ0bic6IHRydWUsXG4gICAgICAgICAgICAnaWd4LWdyaWRfX2dyb3VwLWV4cGFuZC1idG4tLXB1c2gnOiBmaWx0ZXJpbmdTZXJ2aWNlLmlzRmlsdGVyUm93VmlzaWJsZVxuICAgICAgICB9XCJcbiAgICA+PC9pZ3gtaWNvbj5cbjwvbmctdGVtcGxhdGU+XG5cbjxkaXYgKm5nSWY9XCJyb3dFZGl0YWJsZVwiIGlneFRvZ2dsZSAjcm93RWRpdGluZ092ZXJsYXk+XG4gICAgPGRpdiBbY2xhc3NOYW1lXT1cImJhbm5lckNsYXNzXCI+XG4gICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgICpuZ1RlbXBsYXRlT3V0bGV0PVwicm93RWRpdENvbnRhaW5lcjsgY29udGV4dDogeyByb3dDaGFuZ2VzQ291bnQ6IHJvd0NoYW5nZXNDb3VudCwgZW5kRWRpdDogdGhpcy5lbmRFZGl0LmJpbmQodGhpcykgfVwiPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuXG48bmctdGVtcGxhdGUgI2RlZmF1bHRSb3dFZGl0VGV4dD5cbiAgICB7eyB0aGlzLnJlc291cmNlU3RyaW5ncy5pZ3hfZ3JpZF9yb3dfZWRpdF90ZXh0IHwgaWd4U3RyaW5nUmVwbGFjZTonezB9Jzpyb3dDaGFuZ2VzQ291bnQudG9TdHJpbmcoKSB8IGlneFN0cmluZ1JlcGxhY2U6J3sxfSc6aGlkZGVuQ29sdW1uc0NvdW50LnRvU3RyaW5nKCkgfX1cbjwvbmctdGVtcGxhdGU+XG5cbjxuZy10ZW1wbGF0ZSAjZGVmYXVsdFJvd0VkaXRBY3Rpb25zPlxuICAgIDxidXR0b24gaWd4QnV0dG9uIGlneFJvd0VkaXRUYWJTdG9wIHR5cGU9XCJidXR0b25cIiAoY2xpY2spPVwidGhpcy5lbmRSb3dFZGl0VGFiU3RvcChmYWxzZSwgJGV2ZW50KVwiPnt7IHRoaXMucmVzb3VyY2VTdHJpbmdzLmlneF9ncmlkX3Jvd19lZGl0X2J0bl9jYW5jZWwgfX08L2J1dHRvbj5cbiAgICA8YnV0dG9uIGlneEJ1dHRvbiBpZ3hSb3dFZGl0VGFiU3RvcCB0eXBlPVwiYnV0dG9uXCIgKGNsaWNrKT1cInRoaXMuZW5kUm93RWRpdFRhYlN0b3AodHJ1ZSwgJGV2ZW50KVwiPnt7IHRoaXMucmVzb3VyY2VTdHJpbmdzLmlneF9ncmlkX3Jvd19lZGl0X2J0bl9kb25lIH19PC9idXR0b24+XG48L25nLXRlbXBsYXRlPlxuXG48bmctdGVtcGxhdGUgI2RlZmF1bHRSb3dFZGl0VGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cImlneC1iYW5uZXJfX21lc3NhZ2VcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJpZ3gtYmFubmVyX190ZXh0XCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAgICAgKm5nVGVtcGxhdGVPdXRsZXQ9XCJ0aGlzLmNydWRTZXJ2aWNlLnJvdz8uZ2V0Q2xhc3NOYW1lKCkgPT09ICdJZ3hBZGRSb3cnID8gcm93QWRkVGV4dFRlbXBsYXRlIDogcm93RWRpdFRleHRUZW1wbGF0ZSA/IHJvd0VkaXRUZXh0VGVtcGxhdGUgOiBkZWZhdWx0Um93RWRpdFRleHQ7XG4gICAgICAgICAgICAgICAgY29udGV4dDogeyAkaW1wbGljaXQ6IHRoaXMuY3J1ZFNlcnZpY2Uucm93Py5nZXRDbGFzc05hbWUoKSAhPT0gJ0lneEFkZFJvdycgPyByb3dDaGFuZ2VzQ291bnQgOiBudWxsIH1cIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L3NwYW4+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImlneC1iYW5uZXJfX2FjdGlvbnNcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImlneC1iYW5uZXJfX3Jvd1wiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICAgICAgICpuZ1RlbXBsYXRlT3V0bGV0PVwicm93RWRpdEFjdGlvbnNUZW1wbGF0ZSA/IHJvd0VkaXRBY3Rpb25zVGVtcGxhdGUgOiBkZWZhdWx0Um93RWRpdEFjdGlvbnM7IGNvbnRleHQ6IHsgJGltcGxpY2l0OiB0aGlzLmVuZEVkaXQuYmluZCh0aGlzKSB9XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L25nLXRlbXBsYXRlPlxuXG48bmctdGVtcGxhdGUgI2RyYWdJbmRpY2F0b3JJY29uQmFzZT5cbiAgICA8aWd4LWljb24gZmFtaWx5PVwiZGVmYXVsdFwiIG5hbWU9XCJkcmFnX2luZGljYXRvclwiPjwvaWd4LWljb24+XG48L25nLXRlbXBsYXRlPlxuXG48aWd4LWdyaWQtY29sdW1uLXJlc2l6ZXIgKm5nSWY9XCJjb2xSZXNpemluZ1NlcnZpY2Uuc2hvd1Jlc2l6ZXJcIj48L2lneC1ncmlkLWNvbHVtbi1yZXNpemVyPlxuPGRpdiBjbGFzcz1cImlneC1ncmlkX19vdXRsZXRcIiAjaWd4RmlsdGVyaW5nT3ZlcmxheU91dGxldCBpZ3hPdmVybGF5T3V0bGV0PjwvZGl2PlxuQGlmIChwbGF0Zm9ybS5pc0VsZW1lbnRzKSB7XG4gICAgPGRpdiAjc2luayBzdHlsZT1cImRpc3BsYXk6IG5vbmU7XCI+XG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImlneC1ncmlkLXN0YXRlLGlnYy1ncmlkLXN0YXRlXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJpZ3gtY29sdW1uLGlnYy1jb2x1bW4saWd4LWNvbHVtbi1ncm91cCxpZ2MtY29sdW1uLWdyb3VwLGlneC1jb2x1bW4tbGF5b3V0LGlnYy1jb2x1bW4tbGF5b3V0LGlneC1hY3Rpb24tc3RyaXAsaWdjLWFjdGlvbi1zdHJpcFwiPjwvbmctY29udGVudD5cbiAgICA8L2Rpdj5cbn1cbiJdfQ==