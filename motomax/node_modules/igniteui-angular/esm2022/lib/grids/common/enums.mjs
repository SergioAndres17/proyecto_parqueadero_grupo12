import { mkenum } from '../../core/utils';
/**
 * Enumeration representing different filter modes for grid filtering.
 * - quickFilter: Default mode with a filter row UI between the column headers and the first row of records.
 * - excelStyleFilter: Filter mode where an Excel-style filter is used.
 */
export const FilterMode = /*@__PURE__*/ mkenum({
    quickFilter: 'quickFilter',
    excelStyleFilter: 'excelStyleFilter'
});
/**
 * Enumeration representing the position of grid summary rows.
 * - top: Default value; Summary rows are displayed at the top of the grid.
 * - bottom: Summary rows are displayed at the bottom of the grid.
 */
export const GridSummaryPosition = /*@__PURE__*/ mkenum({
    top: 'top',
    bottom: 'bottom'
});
/**
 * Enumeration representing different calculation modes for grid summaries.
 * - rootLevelOnly: Summaries are calculated only for the root level.
 * - childLevelsOnly: Summaries are calculated only for child levels.
 * - rootAndChildLevels: Default value; Summaries are calculated for both root and child levels.
 */
export const GridSummaryCalculationMode = /*@__PURE__*/ mkenum({
    rootLevelOnly: 'rootLevelOnly',
    childLevelsOnly: 'childLevelsOnly',
    rootAndChildLevels: 'rootAndChildLevels'
});
/**
 * Enumeration representing different selection modes for the grid elements if can be selected.
 * - 'none': No selection is allowed. Default row and column selection mode.
 * - 'single': Only one element can be selected at a time. Selecting a new one will deselect the previously selected one.
 * - 'multiple': Default cell selection mode. More than one element can be selected at a time.
 * - 'multipleCascade': Similar to multiple selection. It is used in hierarchical or tree grids. Allows selection not only to an individual item but also all its related or nested items in a single action
 */
export const GridSelectionMode = /*@__PURE__*/ mkenum({
    none: 'none',
    single: 'single',
    multiple: 'multiple',
    multipleCascade: 'multipleCascade'
});
/** Enumeration representing different column display order options. */
export const ColumnDisplayOrder = /*@__PURE__*/ mkenum({
    Alphabetical: 'Alphabetical',
    DisplayOrder: 'DisplayOrder'
});
/* mustCoerceToInt */
/**
 * Enumeration representing the possible positions for pinning columns.
 * - Start: Columns are pinned to the start of the grid.
 * - End: Columns are pinned to the end of the grid.
 */
export var ColumnPinningPosition;
(function (ColumnPinningPosition) {
    ColumnPinningPosition[ColumnPinningPosition["Start"] = 0] = "Start";
    ColumnPinningPosition[ColumnPinningPosition["End"] = 1] = "End";
})(ColumnPinningPosition || (ColumnPinningPosition = {}));
/* mustCoerceToInt */
/**
 * Enumeration representing the possible positions for pinning rows.
 * - Top: Rows are pinned to the top of the grid.
 * - Bottom: Rows are pinned to the bottom of the grid.
 */
export var RowPinningPosition;
(function (RowPinningPosition) {
    RowPinningPosition[RowPinningPosition["Top"] = 0] = "Top";
    RowPinningPosition[RowPinningPosition["Bottom"] = 1] = "Bottom";
})(RowPinningPosition || (RowPinningPosition = {}));
/* mustCoerceToInt */
/**
 * Enumeration representing different paging modes for the grid.
 * - Local: The grid will use local data to extract pages during paging.
 * - Remote: The grid will expect pages to be delivered from a remote location and will only raise events during paging interactions.
 */
export var GridPagingMode;
(function (GridPagingMode) {
    GridPagingMode[GridPagingMode["Local"] = 0] = "Local";
    GridPagingMode[GridPagingMode["Remote"] = 1] = "Remote";
})(GridPagingMode || (GridPagingMode = {}));
/**
 * @hidden @internal
 *
 * Enumeration representing the possible predefined size options of the grid.
 * - Small: This is the smallest size with 32px row height. Left and Right paddings are 12px. Minimal column width is 56px.
 * - Medium: This is the middle size with 40px row height. Left and Right paddings are 16px. Minimal column width is 64px.
 * - Large:  this is the default Grid size with the lowest intense and row height equal to 50px. Left and Right paddings are 24px. Minimal column width is 80px.
 */
export const Size = /*@__PURE__*/ mkenum({
    Small: '1',
    Medium: '2',
    Large: '3'
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW51bXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZ3JpZHMvY29tbW9uL2VudW1zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUMxQzs7OztHQUlHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sVUFBVSxHQUFHLGFBQWEsQ0FBQSxNQUFNLENBQUM7SUFDMUMsV0FBVyxFQUFFLGFBQWE7SUFDMUIsZ0JBQWdCLEVBQUUsa0JBQWtCO0NBQ3ZDLENBQUMsQ0FBQztBQUdIOzs7O0dBSUc7QUFDSCxNQUFNLENBQUMsTUFBTSxtQkFBbUIsR0FBRyxhQUFhLENBQUEsTUFBTSxDQUFDO0lBQ25ELEdBQUcsRUFBRSxLQUFLO0lBQ1YsTUFBTSxFQUFFLFFBQVE7Q0FDbkIsQ0FBQyxDQUFDO0FBR0g7Ozs7O0dBS0c7QUFDSCxNQUFNLENBQUMsTUFBTSwwQkFBMEIsR0FBRyxhQUFhLENBQUEsTUFBTSxDQUFDO0lBQzFELGFBQWEsRUFBRSxlQUFlO0lBQzlCLGVBQWUsRUFBRSxpQkFBaUI7SUFDbEMsa0JBQWtCLEVBQUUsb0JBQW9CO0NBQzNDLENBQUMsQ0FBQztBQTJCSDs7Ozs7O0dBTUc7QUFDSCxNQUFNLENBQUMsTUFBTSxpQkFBaUIsR0FBRyxhQUFhLENBQUEsTUFBTSxDQUFDO0lBQ2pELElBQUksRUFBRSxNQUFNO0lBQ1osTUFBTSxFQUFFLFFBQVE7SUFDaEIsUUFBUSxFQUFFLFVBQVU7SUFDcEIsZUFBZSxFQUFFLGlCQUFpQjtDQUNyQyxDQUFDLENBQUM7QUFHSCx1RUFBdUU7QUFDdkUsTUFBTSxDQUFDLE1BQU0sa0JBQWtCLEdBQUcsYUFBYSxDQUFBLE1BQU0sQ0FBQztJQUNsRCxZQUFZLEVBQUUsY0FBYztJQUM1QixZQUFZLEVBQUUsY0FBYztDQUMvQixDQUFDLENBQUM7QUFHSCxxQkFBcUI7QUFDckI7Ozs7R0FJRztBQUNILE1BQU0sQ0FBTixJQUFZLHFCQUdYO0FBSEQsV0FBWSxxQkFBcUI7SUFDN0IsbUVBQUssQ0FBQTtJQUNMLCtEQUFHLENBQUE7QUFDUCxDQUFDLEVBSFcscUJBQXFCLEtBQXJCLHFCQUFxQixRQUdoQztBQUVELHFCQUFxQjtBQUNyQjs7OztHQUlHO0FBQ0gsTUFBTSxDQUFOLElBQVksa0JBR1g7QUFIRCxXQUFZLGtCQUFrQjtJQUMxQix5REFBRyxDQUFBO0lBQ0gsK0RBQU0sQ0FBQTtBQUNWLENBQUMsRUFIVyxrQkFBa0IsS0FBbEIsa0JBQWtCLFFBRzdCO0FBRUQscUJBQXFCO0FBQ3JCOzs7O0dBSUc7QUFDSCxNQUFNLENBQU4sSUFBWSxjQUdYO0FBSEQsV0FBWSxjQUFjO0lBQ3RCLHFEQUFLLENBQUE7SUFDTCx1REFBTSxDQUFBO0FBQ1YsQ0FBQyxFQUhXLGNBQWMsS0FBZCxjQUFjLFFBR3pCO0FBRUQ7Ozs7Ozs7R0FPRztBQUNILE1BQU0sQ0FBQyxNQUFNLElBQUksR0FBRyxhQUFhLENBQUEsTUFBTSxDQUFDO0lBQ3BDLEtBQUssRUFBRSxHQUFHO0lBQ1YsTUFBTSxFQUFFLEdBQUc7SUFDWCxLQUFLLEVBQUUsR0FBRztDQUNiLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgbWtlbnVtIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscyc7XG4vKipcbiAqIEVudW1lcmF0aW9uIHJlcHJlc2VudGluZyBkaWZmZXJlbnQgZmlsdGVyIG1vZGVzIGZvciBncmlkIGZpbHRlcmluZy5cbiAqIC0gcXVpY2tGaWx0ZXI6IERlZmF1bHQgbW9kZSB3aXRoIGEgZmlsdGVyIHJvdyBVSSBiZXR3ZWVuIHRoZSBjb2x1bW4gaGVhZGVycyBhbmQgdGhlIGZpcnN0IHJvdyBvZiByZWNvcmRzLlxuICogLSBleGNlbFN0eWxlRmlsdGVyOiBGaWx0ZXIgbW9kZSB3aGVyZSBhbiBFeGNlbC1zdHlsZSBmaWx0ZXIgaXMgdXNlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IEZpbHRlck1vZGUgPSAvKkBfX1BVUkVfXyovbWtlbnVtKHtcbiAgICBxdWlja0ZpbHRlcjogJ3F1aWNrRmlsdGVyJyxcbiAgICBleGNlbFN0eWxlRmlsdGVyOiAnZXhjZWxTdHlsZUZpbHRlcidcbn0pO1xuZXhwb3J0IHR5cGUgRmlsdGVyTW9kZSA9ICh0eXBlb2YgRmlsdGVyTW9kZSlba2V5b2YgdHlwZW9mIEZpbHRlck1vZGVdO1xuXG4vKipcbiAqIEVudW1lcmF0aW9uIHJlcHJlc2VudGluZyB0aGUgcG9zaXRpb24gb2YgZ3JpZCBzdW1tYXJ5IHJvd3MuXG4gKiAtIHRvcDogRGVmYXVsdCB2YWx1ZTsgU3VtbWFyeSByb3dzIGFyZSBkaXNwbGF5ZWQgYXQgdGhlIHRvcCBvZiB0aGUgZ3JpZC5cbiAqIC0gYm90dG9tOiBTdW1tYXJ5IHJvd3MgYXJlIGRpc3BsYXllZCBhdCB0aGUgYm90dG9tIG9mIHRoZSBncmlkLlxuICovXG5leHBvcnQgY29uc3QgR3JpZFN1bW1hcnlQb3NpdGlvbiA9IC8qQF9fUFVSRV9fKi9ta2VudW0oe1xuICAgIHRvcDogJ3RvcCcsXG4gICAgYm90dG9tOiAnYm90dG9tJ1xufSk7XG5leHBvcnQgdHlwZSBHcmlkU3VtbWFyeVBvc2l0aW9uID0gKHR5cGVvZiBHcmlkU3VtbWFyeVBvc2l0aW9uKVtrZXlvZiB0eXBlb2YgR3JpZFN1bW1hcnlQb3NpdGlvbl07XG5cbi8qKlxuICogRW51bWVyYXRpb24gcmVwcmVzZW50aW5nIGRpZmZlcmVudCBjYWxjdWxhdGlvbiBtb2RlcyBmb3IgZ3JpZCBzdW1tYXJpZXMuXG4gKiAtIHJvb3RMZXZlbE9ubHk6IFN1bW1hcmllcyBhcmUgY2FsY3VsYXRlZCBvbmx5IGZvciB0aGUgcm9vdCBsZXZlbC5cbiAqIC0gY2hpbGRMZXZlbHNPbmx5OiBTdW1tYXJpZXMgYXJlIGNhbGN1bGF0ZWQgb25seSBmb3IgY2hpbGQgbGV2ZWxzLlxuICogLSByb290QW5kQ2hpbGRMZXZlbHM6IERlZmF1bHQgdmFsdWU7IFN1bW1hcmllcyBhcmUgY2FsY3VsYXRlZCBmb3IgYm90aCByb290IGFuZCBjaGlsZCBsZXZlbHMuXG4gKi9cbmV4cG9ydCBjb25zdCBHcmlkU3VtbWFyeUNhbGN1bGF0aW9uTW9kZSA9IC8qQF9fUFVSRV9fKi9ta2VudW0oe1xuICAgIHJvb3RMZXZlbE9ubHk6ICdyb290TGV2ZWxPbmx5JyxcbiAgICBjaGlsZExldmVsc09ubHk6ICdjaGlsZExldmVsc09ubHknLFxuICAgIHJvb3RBbmRDaGlsZExldmVsczogJ3Jvb3RBbmRDaGlsZExldmVscydcbn0pO1xuZXhwb3J0IHR5cGUgR3JpZFN1bW1hcnlDYWxjdWxhdGlvbk1vZGUgPSAodHlwZW9mIEdyaWRTdW1tYXJ5Q2FsY3VsYXRpb25Nb2RlKVtrZXlvZiB0eXBlb2YgR3JpZFN1bW1hcnlDYWxjdWxhdGlvbk1vZGVdO1xuXG4vKipcbiAqIFR5cGUgcmVwcmVzZW50aW5nIHRoZSB0cmlnZ2VycyBmb3IgZ3JpZCBjZWxsIHZhbGlkYXRpb24uXG4gKiAtICdjaGFuZ2UnOiBWYWxpZGF0aW9uIGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBjZWxsIHZhbHVlIGNoYW5nZXMuXG4gKiAtICdibHVyJzogVmFsaWRhdGlvbiBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgY2VsbCBsb3NlcyBmb2N1cy5cbiAqL1xuZXhwb3J0IHR5cGUgR3JpZFZhbGlkYXRpb25UcmlnZ2VyID0gJ2NoYW5nZScgfCAnYmx1cicgO1xuXG4vKipcbiAqIFR5cGUgcmVwcmVzZW50aW5nIHRoZSB0eXBlIG9mIHRoZSB0YXJnZXQgb2JqZWN0IChlbGVtZW50cyBvZiB0aGUgZ3JpZCkgZm9yIGtleWRvd24gKGZpcmVkIHdoZW4gYSBrZXkgaXMgcHJlc3NlZCkgZXZlbnRzIGluIHRoZSBncmlkLlxuICogLSAnZGF0YUNlbGwnOiBSZXByZXNlbnRzIGEgZGF0YSBjZWxsIHdpdGhpbiB0aGUgZ3JpZC4gSXQgY29udGFpbnMgYW5kIGRpc3BsYXlzIGluZGl2aWR1YWwgZGF0YSB2YWx1ZXNcbiAqIC0gJ3N1bW1hcnlDZWxsJzogU3VtbWFyeSBjZWxscyBkaXNwbGF5IGFnZ3JlZ2F0ZWQvc3VtbWFyaXplZCBkYXRhIGF0IHRoZSBib3R0b20gb2YgdGhlIGdyaWQuIFRoZXkgcHJvdmlkZSBpbnNpZ2h0cyBsaWtlIHRvdGFsIHJlY29yZCBjb3VudCwgbWluL21heCB2YWx1ZXMsIGV0Yy5cbiAqIC0gJ2dyb3VwUm93JzogR3JvdXAgcm93IHdpdGhpbiB0aGUgZ3JpZC4gR3JvdXAgcm93cyBhcmUgdXNlZCB0byBncm91cCByZWxhdGVkIGRhdGEgcm93cyBieSBjb2x1bW5zLiBDb250YWlucyB0aGUgcmVsYXRlZCBncm91cCBleHByZXNzaW9uLCBsZXZlbCwgc3ViLXJlY29yZHMgYW5kIGdyb3VwIHZhbHVlLlxuICogLSAnaGllcmFyY2hpY2FsUm93JzogSGllcmFyY2hpY2FsIHJvd3MgYXJlIHNpbWlsYXIgdG8gZ3JvdXAgcm93cywgYnV0IHJlcHJlc2VudCBhIG1vcmUgY29tcGxleCBoaWVyYXJjaGljYWwgc3RydWN0dXJlLCBhbGxvd2luZyBmb3IgbmVzdGVkIGdyb3VwaW5nXG4gKiAtICdoZWFkZXJDZWxsJzogUmVwcmVzZW50cyBhIGhlYWRlciBjZWxsIHdpdGhpbiB0aGUgZ3JpZC4gSGVhZGVyIGNlbGxzIGFyZSB1c2VkIHRvIGRpc3BsYXkgY29sdW1uIGhlYWRlcnMsIHByb3ZpZGluZyBjb250ZXh0IGFuZCBsYWJlbHMgZm9yIHRoZSBjb2x1bW5zLlxuICogLSAnbWFzdGVyRGV0YWlsUm93JzogUmVwcmVzZW50cyBhIGdyaWQgcm93IHRoYXQgY2FuIGJlIGV4cGFuZGVkIGluIG9yZGVyIHRvIHNob3cgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICovXG5leHBvcnQgdHlwZSBHcmlkS2V5ZG93blRhcmdldFR5cGUgPVxuICAgICdkYXRhQ2VsbCcgfFxuICAgICdzdW1tYXJ5Q2VsbCcgfFxuICAgICdncm91cFJvdycgfFxuICAgICdoaWVyYXJjaGljYWxSb3cnIHxcbiAgICAnaGVhZGVyQ2VsbCcgfFxuICAgICdtYXN0ZXJEZXRhaWxSb3cnO1xuXG4vKipcbiAqIEVudW1lcmF0aW9uIHJlcHJlc2VudGluZyBkaWZmZXJlbnQgc2VsZWN0aW9uIG1vZGVzIGZvciB0aGUgZ3JpZCBlbGVtZW50cyBpZiBjYW4gYmUgc2VsZWN0ZWQuXG4gKiAtICdub25lJzogTm8gc2VsZWN0aW9uIGlzIGFsbG93ZWQuIERlZmF1bHQgcm93IGFuZCBjb2x1bW4gc2VsZWN0aW9uIG1vZGUuXG4gKiAtICdzaW5nbGUnOiBPbmx5IG9uZSBlbGVtZW50IGNhbiBiZSBzZWxlY3RlZCBhdCBhIHRpbWUuIFNlbGVjdGluZyBhIG5ldyBvbmUgd2lsbCBkZXNlbGVjdCB0aGUgcHJldmlvdXNseSBzZWxlY3RlZCBvbmUuXG4gKiAtICdtdWx0aXBsZSc6IERlZmF1bHQgY2VsbCBzZWxlY3Rpb24gbW9kZS4gTW9yZSB0aGFuIG9uZSBlbGVtZW50IGNhbiBiZSBzZWxlY3RlZCBhdCBhIHRpbWUuXG4gKiAtICdtdWx0aXBsZUNhc2NhZGUnOiBTaW1pbGFyIHRvIG11bHRpcGxlIHNlbGVjdGlvbi4gSXQgaXMgdXNlZCBpbiBoaWVyYXJjaGljYWwgb3IgdHJlZSBncmlkcy4gQWxsb3dzIHNlbGVjdGlvbiBub3Qgb25seSB0byBhbiBpbmRpdmlkdWFsIGl0ZW0gYnV0IGFsc28gYWxsIGl0cyByZWxhdGVkIG9yIG5lc3RlZCBpdGVtcyBpbiBhIHNpbmdsZSBhY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IEdyaWRTZWxlY3Rpb25Nb2RlID0gLypAX19QVVJFX18qL21rZW51bSh7XG4gICAgbm9uZTogJ25vbmUnLFxuICAgIHNpbmdsZTogJ3NpbmdsZScsXG4gICAgbXVsdGlwbGU6ICdtdWx0aXBsZScsXG4gICAgbXVsdGlwbGVDYXNjYWRlOiAnbXVsdGlwbGVDYXNjYWRlJ1xufSk7XG5leHBvcnQgdHlwZSBHcmlkU2VsZWN0aW9uTW9kZSA9ICh0eXBlb2YgR3JpZFNlbGVjdGlvbk1vZGUpW2tleW9mIHR5cGVvZiBHcmlkU2VsZWN0aW9uTW9kZV07XG5cbi8qKiBFbnVtZXJhdGlvbiByZXByZXNlbnRpbmcgZGlmZmVyZW50IGNvbHVtbiBkaXNwbGF5IG9yZGVyIG9wdGlvbnMuICovXG5leHBvcnQgY29uc3QgQ29sdW1uRGlzcGxheU9yZGVyID0gLypAX19QVVJFX18qL21rZW51bSh7XG4gICAgQWxwaGFiZXRpY2FsOiAnQWxwaGFiZXRpY2FsJyxcbiAgICBEaXNwbGF5T3JkZXI6ICdEaXNwbGF5T3JkZXInXG59KTtcbmV4cG9ydCB0eXBlIENvbHVtbkRpc3BsYXlPcmRlciA9ICh0eXBlb2YgQ29sdW1uRGlzcGxheU9yZGVyKVtrZXlvZiB0eXBlb2YgQ29sdW1uRGlzcGxheU9yZGVyXTtcblxuLyogbXVzdENvZXJjZVRvSW50ICovXG4vKipcbiAqIEVudW1lcmF0aW9uIHJlcHJlc2VudGluZyB0aGUgcG9zc2libGUgcG9zaXRpb25zIGZvciBwaW5uaW5nIGNvbHVtbnMuXG4gKiAtIFN0YXJ0OiBDb2x1bW5zIGFyZSBwaW5uZWQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBncmlkLlxuICogLSBFbmQ6IENvbHVtbnMgYXJlIHBpbm5lZCB0byB0aGUgZW5kIG9mIHRoZSBncmlkLlxuICovXG5leHBvcnQgZW51bSBDb2x1bW5QaW5uaW5nUG9zaXRpb24ge1xuICAgIFN0YXJ0LFxuICAgIEVuZFxufVxuXG4vKiBtdXN0Q29lcmNlVG9JbnQgKi9cbi8qKlxuICogRW51bWVyYXRpb24gcmVwcmVzZW50aW5nIHRoZSBwb3NzaWJsZSBwb3NpdGlvbnMgZm9yIHBpbm5pbmcgcm93cy5cbiAqIC0gVG9wOiBSb3dzIGFyZSBwaW5uZWQgdG8gdGhlIHRvcCBvZiB0aGUgZ3JpZC5cbiAqIC0gQm90dG9tOiBSb3dzIGFyZSBwaW5uZWQgdG8gdGhlIGJvdHRvbSBvZiB0aGUgZ3JpZC5cbiAqL1xuZXhwb3J0IGVudW0gUm93UGlubmluZ1Bvc2l0aW9uIHtcbiAgICBUb3AsXG4gICAgQm90dG9tXG59XG5cbi8qIG11c3RDb2VyY2VUb0ludCAqL1xuLyoqXG4gKiBFbnVtZXJhdGlvbiByZXByZXNlbnRpbmcgZGlmZmVyZW50IHBhZ2luZyBtb2RlcyBmb3IgdGhlIGdyaWQuXG4gKiAtIExvY2FsOiBUaGUgZ3JpZCB3aWxsIHVzZSBsb2NhbCBkYXRhIHRvIGV4dHJhY3QgcGFnZXMgZHVyaW5nIHBhZ2luZy5cbiAqIC0gUmVtb3RlOiBUaGUgZ3JpZCB3aWxsIGV4cGVjdCBwYWdlcyB0byBiZSBkZWxpdmVyZWQgZnJvbSBhIHJlbW90ZSBsb2NhdGlvbiBhbmQgd2lsbCBvbmx5IHJhaXNlIGV2ZW50cyBkdXJpbmcgcGFnaW5nIGludGVyYWN0aW9ucy5cbiAqL1xuZXhwb3J0IGVudW0gR3JpZFBhZ2luZ01vZGUge1xuICAgIExvY2FsLFxuICAgIFJlbW90ZVxufVxuXG4vKipcbiAqIEBoaWRkZW4gQGludGVybmFsXG4gKlxuICogRW51bWVyYXRpb24gcmVwcmVzZW50aW5nIHRoZSBwb3NzaWJsZSBwcmVkZWZpbmVkIHNpemUgb3B0aW9ucyBvZiB0aGUgZ3JpZC5cbiAqIC0gU21hbGw6IFRoaXMgaXMgdGhlIHNtYWxsZXN0IHNpemUgd2l0aCAzMnB4IHJvdyBoZWlnaHQuIExlZnQgYW5kIFJpZ2h0IHBhZGRpbmdzIGFyZSAxMnB4LiBNaW5pbWFsIGNvbHVtbiB3aWR0aCBpcyA1NnB4LlxuICogLSBNZWRpdW06IFRoaXMgaXMgdGhlIG1pZGRsZSBzaXplIHdpdGggNDBweCByb3cgaGVpZ2h0LiBMZWZ0IGFuZCBSaWdodCBwYWRkaW5ncyBhcmUgMTZweC4gTWluaW1hbCBjb2x1bW4gd2lkdGggaXMgNjRweC5cbiAqIC0gTGFyZ2U6ICB0aGlzIGlzIHRoZSBkZWZhdWx0IEdyaWQgc2l6ZSB3aXRoIHRoZSBsb3dlc3QgaW50ZW5zZSBhbmQgcm93IGhlaWdodCBlcXVhbCB0byA1MHB4LiBMZWZ0IGFuZCBSaWdodCBwYWRkaW5ncyBhcmUgMjRweC4gTWluaW1hbCBjb2x1bW4gd2lkdGggaXMgODBweC5cbiAqL1xuZXhwb3J0IGNvbnN0IFNpemUgPSAvKkBfX1BVUkVfXyovbWtlbnVtKHtcbiAgICBTbWFsbDogJzEnLFxuICAgIE1lZGl1bTogJzInLFxuICAgIExhcmdlOiAnMydcbn0pO1xuZXhwb3J0IHR5cGUgU2l6ZSA9ICh0eXBlb2YgU2l6ZSlba2V5b2YgdHlwZW9mIFNpemVdO1xuIl19