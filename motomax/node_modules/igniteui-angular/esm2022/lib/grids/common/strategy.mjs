import { cloneArray, parseDate, resolveNestedPath } from '../../core/utils';
import { getHierarchy, isHierarchyMatch } from '../../data-operations/operations';
import { DefaultSortingStrategy } from '../../data-operations/sorting-strategy';
const DATE_TYPE = 'date';
const TIME_TYPE = 'time';
const DATE_TIME_TYPE = 'dateTime';
const STRING_TYPE = 'string';
/**
 * Represents a class implementing the IGridSortingStrategy interface.
 * It provides sorting functionality for grid data based on sorting expressions.
 */
export class IgxSorting {
    /* blazorSuppress */
    /**
   * Sorts the provided data based on the given sorting expressions.
   * `data`: The array of data to be sorted.
   * `expressions`: An array of sorting expressions that define the sorting rules. The expression contains information like file name, whether the letter case should be taken into account, etc.
   * `grid`: (Optional) The instance of the grid where the sorting is applied.
   * Returns a new array with the data sorted according to the sorting expressions.
   */
    sort(data, expressions, grid) {
        return this.sortDataRecursive(data, expressions, 0, grid);
    }
    /**
   * Recursively groups the provided data based on the given grouping state and returns the grouped result.
   * Returns an array containing the grouped result.
   * @internal
   */
    groupDataRecursive(data, state, level, parent, metadata, grid = null, groupsRecords = [], fullResult = { data: [], metadata: [] }) {
        const expressions = state.expressions;
        const expansion = state.expansion;
        let i = 0;
        let result = [];
        while (i < data.length) {
            const column = grid ? grid.getColumnByName(expressions[level].fieldName) : null;
            const isDate = column?.dataType === DATE_TYPE || column?.dataType === DATE_TIME_TYPE;
            const isTime = column?.dataType === TIME_TYPE || column?.dataType === DATE_TIME_TYPE;
            const isString = column?.dataType === STRING_TYPE;
            const group = this.groupedRecordsByExpression(data, i, expressions[level], isDate, isTime, isString);
            const groupRow = {
                expression: expressions[level],
                level,
                records: cloneArray(group),
                value: this.getFieldValue(group[0], expressions[level].fieldName, isDate, isTime),
                groupParent: parent,
                groups: [],
                height: grid ? grid.renderedRowHeight : null,
                column
            };
            if (parent) {
                parent.groups.push(groupRow);
            }
            else {
                groupsRecords.push(groupRow);
            }
            const hierarchy = getHierarchy(groupRow);
            const expandState = expansion.find((s) => isHierarchyMatch(s.hierarchy || [{ fieldName: groupRow.expression.fieldName, value: groupRow.value }], hierarchy, expressions));
            const expanded = expandState ? expandState.expanded : state.defaultExpanded;
            let recursiveResult;
            result.push(groupRow);
            metadata.push(null);
            fullResult.data.push(groupRow);
            fullResult.metadata.push(null);
            if (level < expressions.length - 1) {
                recursiveResult = this.groupDataRecursive(group, state, level + 1, groupRow, expanded ? metadata : [], grid, groupsRecords, fullResult);
                if (expanded) {
                    result = result.concat(recursiveResult);
                }
            }
            else {
                for (const groupItem of group) {
                    fullResult.metadata.push(groupRow);
                    fullResult.data.push(groupItem);
                }
                if (expanded) {
                    metadata.push(...fullResult.metadata.slice(fullResult.metadata.length - group.length));
                    result.push(...fullResult.data.slice(fullResult.data.length - group.length));
                }
            }
            i += group.length;
        }
        return result;
    }
    /**
   * Retrieves the value of the specified field from the given object, considering date and time data types.
   * `key`: The key of the field to retrieve.
   * `isDate`: (Optional) Indicates if the field is of type Date.
   * `isTime`: (Optional) Indicates if the field is of type Time.
   * Returns the value of the specified field in the data object.
   * @internal
   */
    getFieldValue(obj, key, isDate = false, isTime = false) {
        let resolvedValue = resolveNestedPath(obj, key);
        const date = parseDate(resolvedValue);
        if (date && isDate && isTime) {
            resolvedValue = date;
        }
        else if (date && isDate && !isTime) {
            resolvedValue = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0);
        }
        else if (date && isTime && !isDate) {
            resolvedValue = new Date(new Date().setHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
        }
        return resolvedValue;
    }
    /**
   * Groups the records in the provided data array based on the given grouping expression.
   * `groupingComparer`: (Optional) A custom grouping comparator to determine the members of the group.
   * Returns an array containing the records that belong to the group.
   * @internal
   */
    groupedRecordsByExpression(data, index, expression, isDate = false, isTime = false, isString, groupingComparer) {
        const res = [];
        const key = expression.fieldName;
        const len = data.length;
        const groupRecord = data[index];
        let groupval = this.getFieldValue(groupRecord, key, isDate, isTime);
        res.push(groupRecord);
        index++;
        const comparer = expression.groupingComparer || groupingComparer || DefaultSortingStrategy.instance().compareValues;
        for (let i = index; i < len; i++) {
            const currRec = data[i];
            let fieldValue = this.getFieldValue(currRec, key, isDate, isTime);
            if (expression.ignoreCase && isString) {
                // when column's dataType is string but the value is number
                fieldValue = fieldValue?.toString().toLowerCase();
                groupval = groupval?.toString().toLowerCase();
            }
            if (comparer(fieldValue, groupval, currRec, groupRecord) === 0) {
                res.push(currRec);
            }
            else {
                break;
            }
        }
        return res;
    }
    /**
   * Sorts the provided data array based on the given sorting expressions.
   * The method can be used when multiple sorting is performed, going through each one
   * Returns a new array with the data sorted according to the sorting expressions.
   * @internal
   */
    sortDataRecursive(data, expressions, expressionIndex = 0, grid) {
        let i;
        let j;
        let gbData;
        let gbDataLen;
        const exprsLen = expressions.length;
        const dataLen = data.length;
        expressionIndex = expressionIndex || 0;
        if (expressionIndex >= exprsLen || dataLen <= 1) {
            return data;
        }
        const expr = expressions[expressionIndex];
        if (!expr.strategy) {
            expr.strategy = DefaultSortingStrategy.instance();
        }
        const column = grid?.getColumnByName(expr.fieldName);
        const isDate = column?.dataType === DATE_TYPE || column?.dataType === DATE_TIME_TYPE;
        const isTime = column?.dataType === TIME_TYPE || column?.dataType === DATE_TIME_TYPE;
        const isString = column?.dataType === STRING_TYPE;
        data = expr.strategy.sort(data, expr.fieldName, expr.dir, expr.ignoreCase, this.getFieldValue, isDate, isTime, grid);
        if (expressionIndex === exprsLen - 1) {
            return data;
        }
        // in case of multiple sorting
        for (i = 0; i < dataLen; i++) {
            gbData = this.groupedRecordsByExpression(data, i, expr, isDate, isTime, isString, column?.groupingComparer);
            gbDataLen = gbData.length;
            if (gbDataLen > 1) {
                gbData = this.sortDataRecursive(gbData, expressions, expressionIndex + 1, grid);
            }
            for (j = 0; j < gbDataLen; j++) {
                data[i + j] = gbData[j];
            }
            i += gbDataLen - 1;
        }
        return data;
    }
}
/**
 * Represents a class implementing the IGridGroupingStrategy interface and extending the IgxSorting class.
 * It provides a method to group data based on the given grouping state.
 */
export class IgxGrouping extends IgxSorting {
    /* blazorSuppress */
    /**
     * Groups the provided data based on the given grouping state.
     * Returns an object containing the result of the grouping operation.
     */
    groupBy(data, state, grid, groupsRecords, fullResult = { data: [], metadata: [] }) {
        const metadata = [];
        const grouping = this.groupDataRecursive(data, state, 0, null, metadata, grid, groupsRecords, fullResult);
        grid?.groupingPerformedSubject.next();
        return {
            data: grouping,
            metadata
        };
    }
}
/* csSuppress */
/**
 * Represents a class implementing the IGridSortingStrategy interface with a no-operation sorting strategy.
 * It performs no sorting and returns the data as it is.
 */
export class NoopSortingStrategy {
    static { this._instance = null; }
    constructor() { }
    static instance() {
        return this._instance || (this._instance = new NoopSortingStrategy());
    }
    /* csSuppress */
    sort(data) {
        return data;
    }
}
/**
 * Represents a class extending the IgxSorting class
 * Provides custom data record sorting.
 */
export class IgxDataRecordSorting extends IgxSorting {
    /**
    * Overrides the base method to retrieve the field value from the data object instead of the record object.
    * Returns the value of the specified field in the data object.
    */
    getFieldValue(obj, key, isDate = false, isTime = false) {
        return super.getFieldValue(obj.data, key, isDate, isTime);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RyYXRlZ3kuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZ3JpZHMvY29tbW9uL3N0cmF0ZWd5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFNNUUsT0FBTyxFQUFFLFlBQVksRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQ2xGLE9BQU8sRUFBRSxzQkFBc0IsRUFBc0IsTUFBTSx3Q0FBd0MsQ0FBQztBQUdwRyxNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUM7QUFDekIsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDO0FBQ3pCLE1BQU0sY0FBYyxHQUFHLFVBQVUsQ0FBQztBQUNsQyxNQUFNLFdBQVcsR0FBRyxRQUFRLENBQUM7QUFrQzdCOzs7R0FHRztBQUNILE1BQU0sT0FBTyxVQUFVO0lBQ25CLG9CQUFvQjtJQUNwQjs7Ozs7O0tBTUM7SUFDTSxJQUFJLENBQUMsSUFBVyxFQUFFLFdBQWlDLEVBQUUsSUFBZTtRQUN2RSxPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsV0FBVyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUM5RCxDQUFDO0lBRUQ7Ozs7S0FJQztJQUNTLGtCQUFrQixDQUN4QixJQUFXLEVBQ1gsS0FBcUIsRUFDckIsS0FBYSxFQUNiLE1BQXNCLEVBQ3RCLFFBQTBCLEVBQzFCLE9BQWlCLElBQUksRUFDckIsZ0JBQXVCLEVBQUUsRUFDekIsYUFBNkIsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUU7UUFFdkQsTUFBTSxXQUFXLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQztRQUN0QyxNQUFNLFNBQVMsR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFD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QUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxhQUFhLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFDMUcsSUFBSSxFQUFFLHdCQUF3QixDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3RDLE9BQU87WUFDSCxJQUFJLEVBQUUsUUFBUTtZQUNkLFFBQVE7U0FDWCxDQUFDO0lBQ04sQ0FBQztDQUNKO0FBRUQsZ0JBQWdCO0FBQ2hCOzs7R0FHRztBQUNILE1BQU0sT0FBTyxtQkFBbUI7YUFDYixjQUFTLEdBQXdCLElBQUksQ0FBQztJQUVyRCxnQkFBd0IsQ0FBQztJQUVsQixNQUFNLENBQUMsUUFBUTtRQUNsQixPQUFPLElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksbUJBQW1CLEVBQUUsQ0FBQyxDQUFDO0lBQzFFLENBQUM7SUFFRCxnQkFBZ0I7SUFDVCxJQUFJLENBQUMsSUFBVztRQUNuQixPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDOztBQUdMOzs7R0FHRztBQUNILE1BQU0sT0FBTyxvQkFBcUIsU0FBUSxVQUFVO0lBQ2pEOzs7TUFHRTtJQUNrQixhQUFhLENBQUMsR0FBUSxFQUFFLEdBQVcsRUFBRSxNQUFNLEdBQUcsS0FBSyxFQUFFLE1BQU0sR0FBRyxLQUFLO1FBQ2xGLE9BQU8sS0FBSyxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDOUQsQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY2xvbmVBcnJheSwgcGFyc2VEYXRlLCByZXNvbHZlTmVzdGVkUGF0aCB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgSUdyb3VwQnlFeHBhbmRTdGF0ZSB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9ncm91cGJ5LWV4cGFuZC1zdGF0ZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSUdyb3VwQnlSZWNvcmQgfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZ3JvdXBieS1yZWNvcmQuaW50ZXJmYWNlJztcbmltcG9ydCB7IElHcm91cGluZ1N0YXRlIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2dyb3VwYnktc3RhdGUuaW50ZXJmYWNlJztcbmltcG9ydCB7IElHcm91cGluZ0V4cHJlc3Npb24gfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZ3JvdXBpbmctZXhwcmVzc2lvbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSUdyb3VwQnlSZXN1bHQgfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZ3JvdXBpbmctcmVzdWx0LmludGVyZmFjZSc7XG5pbXBvcnQgeyBnZXRIaWVyYXJjaHksIGlzSGllcmFyY2h5TWF0Y2ggfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvb3BlcmF0aW9ucyc7XG5pbXBvcnQgeyBEZWZhdWx0U29ydGluZ1N0cmF0ZWd5LCBJU29ydGluZ0V4cHJlc3Npb24gfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvc29ydGluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBHcmlkVHlwZSB9IGZyb20gJy4vZ3JpZC5pbnRlcmZhY2UnO1xuXG5jb25zdCBEQVRFX1RZUEUgPSAnZGF0ZSc7XG5jb25zdCBUSU1FX1RZUEUgPSAndGltZSc7XG5jb25zdCBEQVRFX1RJTUVfVFlQRSA9ICdkYXRlVGltZSc7XG5jb25zdCBTVFJJTkdfVFlQRSA9ICdzdHJpbmcnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzb3J0aW5nIHN0cmF0ZWd5IGZvciB0aGUgZ3JpZCBkYXRhXG4gKiBDb250YWlucyBhIHNpbmdsZSBtZXRob2Qgc29ydCB0aGF0IHNvcnRzIHRoZSBwcm92aWRlZCBkYXRhIGJhc2VkIG9uIHRoZSBnaXZlbiBzb3J0aW5nIGV4cHJlc3Npb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUdyaWRTb3J0aW5nU3RyYXRlZ3kge1xuICAgIC8qIGJsYXpvckNTU3VwcHJlc3MgKi9cbiAgIC8qKlxuICAgKiBgZGF0YWA6IFRoZSBhcnJheSBvZiBkYXRhIHRvIGJlIHNvcnRlZC4gQ291bGQgYmUgb2YgYW55IHR5cGUuXG4gICAqIGBleHByZXNzaW9uc2A6IEFuIGFycmF5IG9mIHNvcnRpbmcgZXhwcmVzc2lvbnMgdGhhdCBkZWZpbmUgdGhlIHNvcnRpbmcgcnVsZXMuIFRoZSBleHByZXNzaW9uIGNvbnRhaW5zIGluZm9ybWF0aW9uIGxpa2UgZmlsZSBuYW1lLCB3aGV0aGVyIHRoZSBsZXR0ZXIgY2FzZSBzaG91bGQgYmUgdGFrZW4gaW50byBhY2NvdW50LCBldGMuXG4gICAqIGBncmlkYDogKE9wdGlvbmFsKSBUaGUgaW5zdGFuY2Ugb2YgdGhlIGdyaWQgd2hlcmUgdGhlIHNvcnRpbmcgaXMgYXBwbGllZC5cbiAgICogUmV0dXJucyBhIG5ldyBhcnJheSB3aXRoIHRoZSBkYXRhIHNvcnRlZCBhY2NvcmRpbmcgdG8gdGhlIHNvcnRpbmcgZXhwcmVzc2lvbnMuXG4gICAqL1xuICAgIHNvcnQoZGF0YTogYW55W10sIGV4cHJlc3Npb25zOiBJU29ydGluZ0V4cHJlc3Npb25bXSwgZ3JpZD86IEdyaWRUeXBlKTogYW55W107XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGdyb3VwaW5nIHN0cmF0ZWd5IGZvciB0aGUgZ3JpZCBkYXRhLCBleHRlbmRpbmcgdGhlIFNvcnRpbmcgU3RyYXRlZ3kgaW50ZXJmYWNlIChjb250YWlucyBhIHNvcnRpbmcgbWV0aG9kKS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJR3JpZEdyb3VwaW5nU3RyYXRlZ3kgZXh0ZW5kcyBJR3JpZFNvcnRpbmdTdHJhdGVneSB7XG4gICAgLyogYmxhem9yQ1NTdXBwcmVzcyAqL1xuICAvKipcbiAgICogVGhlIG1ldGhvZCBncm91cHMgdGhlIHByb3ZpZGVkIGRhdGEgYmFzZWQgb24gdGhlIGdpdmVuIGdyb3VwaW5nIHN0YXRlIGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXG4gICAqIGBkYXRhYDogVGhlIGFycmF5IG9mIGRhdGEgdG8gYmUgZ3JvdXBlZC4gQ291bGQgYmUgb2YgYW55IHR5cGUuXG4gICAqIGBzdGF0ZWA6IFRoZSBncm91cGluZyBzdGF0ZSB0aGF0IGRlZmluZXMgdGhlIGdyb3VwaW5nIHNldHRpbmdzIGFuZCBleHByZXNzaW9ucy5cbiAgICogYGdyaWRgOiAoT3B0aW9uYWwpIFRoZSBpbnN0YW5jZSBvZiB0aGUgZ3JpZCB3aGVyZSB0aGUgZ3JvdXBpbmcgaXMgYXBwbGllZC5cbiAgICogYGdyb3Vwc1JlY29yZHNgOiAoT3B0aW9uYWwpIEFuIGFycmF5IHRoYXQgaG9sZHMgdGhlIHJlY29yZHMgZm9yIGVhY2ggZ3JvdXAuXG4gICAqIGBmdWxsUmVzdWx0YDogKE9wdGlvbmFsKSBUaGUgY29tcGxldGUgcmVzdWx0IG9mIGdyb3VwaW5nIGluY2x1ZGluZyBncm91cHMgYW5kIHN1bW1hcnkgZGF0YS5cbiAgICogUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmVzdWx0IG9mIHRoZSBncm91cGluZyBvcGVyYXRpb24uXG4gICAqL1xuICAgIGdyb3VwQnkoZGF0YTogYW55W10sIHN0YXRlOiBJR3JvdXBpbmdTdGF0ZSwgZ3JpZD86IGFueSwgZ3JvdXBzUmVjb3Jkcz86IGFueVtdLCBmdWxsUmVzdWx0PzogSUdyb3VwQnlSZXN1bHQpOiBJR3JvdXBCeVJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2xhc3MgaW1wbGVtZW50aW5nIHRoZSBJR3JpZFNvcnRpbmdTdHJhdGVneSBpbnRlcmZhY2UuXG4gKiBJdCBwcm92aWRlcyBzb3J0aW5nIGZ1bmN0aW9uYWxpdHkgZm9yIGdyaWQgZGF0YSBiYXNlZCBvbiBzb3J0aW5nIGV4cHJlc3Npb25zLlxuICovXG5leHBvcnQgY2xhc3MgSWd4U29ydGluZyBpbXBsZW1lbnRzIElHcmlkU29ydGluZ1N0cmF0ZWd5IHtcbiAgICAvKiBibGF6b3JTdXBwcmVzcyAqL1xuICAgIC8qKlxuICAgKiBTb3J0cyB0aGUgcHJvdmlkZWQgZGF0YSBiYXNlZCBvbiB0aGUgZ2l2ZW4gc29ydGluZyBleHByZXNzaW9ucy5cbiAgICogYGRhdGFgOiBUaGUgYXJyYXkgb2YgZGF0YSB0byBiZSBzb3J0ZWQuXG4gICAqIGBleHByZXNzaW9uc2A6IEFuIGFycmF5IG9mIHNvcnRpbmcgZXhwcmVzc2lvbnMgdGhhdCBkZWZpbmUgdGhlIHNvcnRpbmcgcnVsZXMuIFRoZSBleHByZXNzaW9uIGNvbnRhaW5zIGluZm9ybWF0aW9uIGxpa2UgZmlsZSBuYW1lLCB3aGV0aGVyIHRoZSBsZXR0ZXIgY2FzZSBzaG91bGQgYmUgdGFrZW4gaW50byBhY2NvdW50LCBldGMuXG4gICAqIGBncmlkYDogKE9wdGlvbmFsKSBUaGUgaW5zdGFuY2Ugb2YgdGhlIGdyaWQgd2hlcmUgdGhlIHNvcnRpbmcgaXMgYXBwbGllZC5cbiAgICogUmV0dXJucyBhIG5ldyBhcnJheSB3aXRoIHRoZSBkYXRhIHNvcnRlZCBhY2NvcmRpbmcgdG8gdGhlIHNvcnRpbmcgZXhwcmVzc2lvbnMuXG4gICAqL1xuICAgIHB1YmxpYyBzb3J0KGRhdGE6IGFueVtdLCBleHByZXNzaW9uczogSVNvcnRpbmdFeHByZXNzaW9uW10sIGdyaWQ/OiBHcmlkVHlwZSk6IGFueVtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ydERhdGFSZWN1cnNpdmUoZGF0YSwgZXhwcmVzc2lvbnMsIDAsIGdyaWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgKiBSZWN1cnNpdmVseSBncm91cHMgdGhlIHByb3ZpZGVkIGRhdGEgYmFzZWQgb24gdGhlIGdpdmVuIGdyb3VwaW5nIHN0YXRlIGFuZCByZXR1cm5zIHRoZSBncm91cGVkIHJlc3VsdC5cbiAgICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBncm91cGVkIHJlc3VsdC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICAgIHByb3RlY3RlZCBncm91cERhdGFSZWN1cnNpdmUoXG4gICAgICAgIGRhdGE6IGFueVtdLFxuICAgICAgICBzdGF0ZTogSUdyb3VwaW5nU3RhdGUsXG4gICAgICAgIGxldmVsOiBudW1iZXIsXG4gICAgICAgIHBhcmVudDogSUdyb3VwQnlSZWNvcmQsXG4gICAgICAgIG1ldGFkYXRhOiBJR3JvdXBCeVJlY29yZFtdLFxuICAgICAgICBncmlkOiBHcmlkVHlwZSA9IG51bGwsXG4gICAgICAgIGdyb3Vwc1JlY29yZHM6IGFueVtdID0gW10sXG4gICAgICAgIGZ1bGxSZXN1bHQ6IElHcm91cEJ5UmVzdWx0ID0geyBkYXRhOiBbXSwgbWV0YWRhdGE6IFtdIH1cbiAgICApOiBhbnlbXSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25zID0gc3RhdGUuZXhwcmVzc2lvbnM7XG4gICAgICAgIGNvbnN0IGV4cGFuc2lvbiA9IHN0YXRlLmV4cGFuc2lvbjtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlIChpIDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IGdyaWQgPyBncmlkLmdldENvbHVtbkJ5TmFtZShleHByZXNzaW9uc1tsZXZlbF0uZmllbGROYW1lKSA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCBpc0RhdGUgPSBjb2x1bW4/LmRhdGFUeXBlID09PSBEQVRFX1RZUEUgfHwgY29sdW1uPy5kYXRhVHlwZSA9PT0gREFURV9USU1FX1RZUEU7XG4gICAgICAgICAgICBjb25zdCBpc1RpbWUgPSBjb2x1bW4/LmRhdGFUeXBlID09PSBUSU1FX1RZUEUgfHwgY29sdW1uPy5kYXRhVHlwZSA9PT0gREFURV9USU1FX1RZUEU7XG4gICAgICAgICAgICBjb25zdCBpc1N0cmluZyA9IGNvbHVtbj8uZGF0YVR5cGUgPT09IFNUUklOR19UWVBFO1xuICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSB0aGlzLmdyb3VwZWRSZWNvcmRzQnlFeHByZXNzaW9uKGRhdGEsIGksIGV4cHJlc3Npb25zW2xldmVsXSwgaXNEYXRlLCBpc1RpbWUsIGlzU3RyaW5nKTtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwUm93OiBJR3JvdXBCeVJlY29yZCA9IHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uc1tsZXZlbF0sXG4gICAgICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICAgICAgcmVjb3JkczogY2xvbmVBcnJheShncm91cCksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuZ2V0RmllbGRWYWx1ZShncm91cFswXSwgZXhwcmVzc2lvbnNbbGV2ZWxdLmZpZWxkTmFtZSwgaXNEYXRlLCBpc1RpbWUpLFxuICAgICAgICAgICAgICAgIGdyb3VwUGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgICAgICAgZ3JvdXBzOiBbXSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGdyaWQgPyBncmlkLnJlbmRlcmVkUm93SGVpZ2h0IDogbnVsbCxcbiAgICAgICAgICAgICAgICBjb2x1bW5cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Lmdyb3Vwcy5wdXNoKGdyb3VwUm93KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBzUmVjb3Jkcy5wdXNoKGdyb3VwUm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhpZXJhcmNoeSA9IGdldEhpZXJhcmNoeShncm91cFJvdyk7XG4gICAgICAgICAgICBjb25zdCBleHBhbmRTdGF0ZTogSUdyb3VwQnlFeHBhbmRTdGF0ZSA9IGV4cGFuc2lvbi5maW5kKChzKSA9PlxuICAgICAgICAgICAgICAgIGlzSGllcmFyY2h5TWF0Y2goXG4gICAgICAgICAgICAgICAgICAgIHMuaGllcmFyY2h5IHx8IFt7IGZpZWxkTmFtZTogZ3JvdXBSb3cuZXhwcmVzc2lvbi5maWVsZE5hbWUsIHZhbHVlOiBncm91cFJvdy52YWx1ZSB9XSxcbiAgICAgICAgICAgICAgICAgICAgaGllcmFyY2h5LFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uc1xuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgY29uc3QgZXhwYW5kZWQgPSBleHBhbmRTdGF0ZSA/IGV4cGFuZFN0YXRlLmV4cGFuZGVkIDogc3RhdGUuZGVmYXVsdEV4cGFuZGVkO1xuICAgICAgICAgICAgbGV0IHJlY3Vyc2l2ZVJlc3VsdDtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdyb3VwUm93KTtcbiAgICAgICAgICAgIG1ldGFkYXRhLnB1c2gobnVsbCk7XG4gICAgICAgICAgICBmdWxsUmVzdWx0LmRhdGEucHVzaChncm91cFJvdyk7XG4gICAgICAgICAgICBmdWxsUmVzdWx0Lm1ldGFkYXRhLnB1c2gobnVsbCk7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPCBleHByZXNzaW9ucy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlUmVzdWx0ID0gdGhpcy5ncm91cERhdGFSZWN1cnNpdmUoZ3JvdXAsIHN0YXRlLCBsZXZlbCArIDEsIGdyb3VwUm93LFxuICAgICAgICAgICAgICAgICAgICBleHBhbmRlZCA/IG1ldGFkYXRhIDogW10sIGdyaWQsIGdyb3Vwc1JlY29yZHMsIGZ1bGxSZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmIChleHBhbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHJlY3Vyc2l2ZVJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGdyb3VwSXRlbSBvZiBncm91cCkge1xuICAgICAgICAgICAgICAgICAgICBmdWxsUmVzdWx0Lm1ldGFkYXRhLnB1c2goZ3JvdXBSb3cpO1xuICAgICAgICAgICAgICAgICAgICBmdWxsUmVzdWx0LmRhdGEucHVzaChncm91cEl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEucHVzaCguLi5mdWxsUmVzdWx0Lm1ldGFkYXRhLnNsaWNlKGZ1bGxSZXN1bHQubWV0YWRhdGEubGVuZ3RoIC0gZ3JvdXAubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKC4uLmZ1bGxSZXN1bHQuZGF0YS5zbGljZShmdWxsUmVzdWx0LmRhdGEubGVuZ3RoIC0gZ3JvdXAubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSArPSBncm91cC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICogUmV0cmlldmVzIHRoZSB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIGZpZWxkIGZyb20gdGhlIGdpdmVuIG9iamVjdCwgY29uc2lkZXJpbmcgZGF0ZSBhbmQgdGltZSBkYXRhIHR5cGVzLlxuICAgKiBga2V5YDogVGhlIGtleSBvZiB0aGUgZmllbGQgdG8gcmV0cmlldmUuXG4gICAqIGBpc0RhdGVgOiAoT3B0aW9uYWwpIEluZGljYXRlcyBpZiB0aGUgZmllbGQgaXMgb2YgdHlwZSBEYXRlLlxuICAgKiBgaXNUaW1lYDogKE9wdGlvbmFsKSBJbmRpY2F0ZXMgaWYgdGhlIGZpZWxkIGlzIG9mIHR5cGUgVGltZS5cbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBmaWVsZCBpbiB0aGUgZGF0YSBvYmplY3QuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0RmllbGRWYWx1ZTxUPihvYmo6IFQsIGtleTogc3RyaW5nLCBpc0RhdGUgPSBmYWxzZSwgaXNUaW1lID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHJlc29sdmVkVmFsdWUgPSByZXNvbHZlTmVzdGVkUGF0aChvYmosIGtleSk7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBwYXJzZURhdGUocmVzb2x2ZWRWYWx1ZSk7XG4gICAgICAgIGlmIChkYXRlICYmIGlzRGF0ZSAmJiBpc1RpbWUpIHtcbiAgICAgICAgICAgIHJlc29sdmVkVmFsdWUgPSBkYXRlO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGUgJiYgaXNEYXRlICYmICFpc1RpbWUpIHtcbiAgICAgICAgICAgIHJlc29sdmVkVmFsdWUgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCksIDAsIDAsIDAsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGUgJiYgaXNUaW1lICYmICFpc0RhdGUpIHtcbiAgICAgICAgICAgIHJlc29sdmVkVmFsdWUgPSBuZXcgRGF0ZShuZXcgRGF0ZSgpLnNldEhvdXJzKGRhdGUuZ2V0SG91cnMoKSwgZGF0ZS5nZXRNaW51dGVzKCksIGRhdGUuZ2V0U2Vjb25kcygpLCBkYXRlLmdldE1pbGxpc2Vjb25kcygpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmVkVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAqIEdyb3VwcyB0aGUgcmVjb3JkcyBpbiB0aGUgcHJvdmlkZWQgZGF0YSBhcnJheSBiYXNlZCBvbiB0aGUgZ2l2ZW4gZ3JvdXBpbmcgZXhwcmVzc2lvbi5cbiAgICogYGdyb3VwaW5nQ29tcGFyZXJgOiAoT3B0aW9uYWwpIEEgY3VzdG9tIGdyb3VwaW5nIGNvbXBhcmF0b3IgdG8gZGV0ZXJtaW5lIHRoZSBtZW1iZXJzIG9mIHRoZSBncm91cC5cbiAgICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIHRoZSByZWNvcmRzIHRoYXQgYmVsb25nIHRvIHRoZSBncm91cC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICAgIHByaXZhdGUgZ3JvdXBlZFJlY29yZHNCeUV4cHJlc3Npb248VD4oXG4gICAgICAgIGRhdGE6IFRbXSxcbiAgICAgICAgaW5kZXg6IG51bWJlcixcbiAgICAgICAgZXhwcmVzc2lvbjogSUdyb3VwaW5nRXhwcmVzc2lvbixcbiAgICAgICAgaXNEYXRlID0gZmFsc2UsXG4gICAgICAgIGlzVGltZSA9IGZhbHNlLFxuICAgICAgICBpc1N0cmluZzogYm9vbGVhbixcbiAgICAgICAgZ3JvdXBpbmdDb21wYXJlcj86IChhOiBhbnksIGI6IGFueSwgY3VyclJlYzogYW55LCBncm91cFJlYzogYW55KSA9PiBudW1iZXJcbiAgICApOiBUW10ge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5ID0gZXhwcmVzc2lvbi5maWVsZE5hbWU7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBjb25zdCBncm91cFJlY29yZCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICBsZXQgZ3JvdXB2YWwgPSB0aGlzLmdldEZpZWxkVmFsdWUoZ3JvdXBSZWNvcmQsIGtleSwgaXNEYXRlLCBpc1RpbWUpO1xuICAgICAgICByZXMucHVzaChncm91cFJlY29yZCk7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIGNvbnN0IGNvbXBhcmVyID0gZXhwcmVzc2lvbi5ncm91cGluZ0NvbXBhcmVyIHx8IGdyb3VwaW5nQ29tcGFyZXIgfHwgRGVmYXVsdFNvcnRpbmdTdHJhdGVneS5pbnN0YW5jZSgpLmNvbXBhcmVWYWx1ZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSBpbmRleDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyUmVjID0gZGF0YVtpXTtcbiAgICAgICAgICAgIGxldCBmaWVsZFZhbHVlID0gdGhpcy5nZXRGaWVsZFZhbHVlKGN1cnJSZWMsIGtleSwgaXNEYXRlLCBpc1RpbWUpO1xuICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24uaWdub3JlQ2FzZSAmJiBpc1N0cmluZykge1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gY29sdW1uJ3MgZGF0YVR5cGUgaXMgc3RyaW5nIGJ1dCB0aGUgdmFsdWUgaXMgbnVtYmVyXG4gICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9IGZpZWxkVmFsdWU/LnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBncm91cHZhbCA9IGdyb3VwdmFsPy50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tcGFyZXIoZmllbGRWYWx1ZSwgZ3JvdXB2YWwsIGN1cnJSZWMsIGdyb3VwUmVjb3JkKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGN1cnJSZWMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgKiBTb3J0cyB0aGUgcHJvdmlkZWQgZGF0YSBhcnJheSBiYXNlZCBvbiB0aGUgZ2l2ZW4gc29ydGluZyBleHByZXNzaW9ucy5cbiAgICogVGhlIG1ldGhvZCBjYW4gYmUgdXNlZCB3aGVuIG11bHRpcGxlIHNvcnRpbmcgaXMgcGVyZm9ybWVkLCBnb2luZyB0aHJvdWdoIGVhY2ggb25lXG4gICAqIFJldHVybnMgYSBuZXcgYXJyYXkgd2l0aCB0aGUgZGF0YSBzb3J0ZWQgYWNjb3JkaW5nIHRvIHRoZSBzb3J0aW5nIGV4cHJlc3Npb25zLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gICAgcHJpdmF0ZSBzb3J0RGF0YVJlY3Vyc2l2ZTxUPihcbiAgICAgICAgZGF0YTogVFtdLFxuICAgICAgICBleHByZXNzaW9uczogSVNvcnRpbmdFeHByZXNzaW9uW10sXG4gICAgICAgIGV4cHJlc3Npb25JbmRleCA9IDAsXG4gICAgICAgIGdyaWQ6IEdyaWRUeXBlXG4gICAgKTogVFtdIHtcbiAgICAgICAgbGV0IGk6IG51bWJlcjtcbiAgICAgICAgbGV0IGo6IG51bWJlcjtcbiAgICAgICAgbGV0IGdiRGF0YTogVFtdO1xuICAgICAgICBsZXQgZ2JEYXRhTGVuOiBudW1iZXI7XG4gICAgICAgIGNvbnN0IGV4cHJzTGVuID0gZXhwcmVzc2lvbnMubGVuZ3RoO1xuICAgICAgICBjb25zdCBkYXRhTGVuID0gZGF0YS5sZW5ndGg7XG5cbiAgICAgICAgZXhwcmVzc2lvbkluZGV4ID0gZXhwcmVzc2lvbkluZGV4IHx8IDA7XG4gICAgICAgIGlmIChleHByZXNzaW9uSW5kZXggPj0gZXhwcnNMZW4gfHwgZGF0YUxlbiA8PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHByID0gZXhwcmVzc2lvbnNbZXhwcmVzc2lvbkluZGV4XTtcbiAgICAgICAgaWYgKCFleHByLnN0cmF0ZWd5KSB7XG4gICAgICAgICAgICBleHByLnN0cmF0ZWd5ID0gRGVmYXVsdFNvcnRpbmdTdHJhdGVneS5pbnN0YW5jZSgpIGFzIGFueTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2x1bW4gPSBncmlkPy5nZXRDb2x1bW5CeU5hbWUoZXhwci5maWVsZE5hbWUpO1xuICAgICAgICBjb25zdCBpc0RhdGUgPSBjb2x1bW4/LmRhdGFUeXBlID09PSBEQVRFX1RZUEUgfHwgY29sdW1uPy5kYXRhVHlwZSA9PT0gREFURV9USU1FX1RZUEU7XG4gICAgICAgIGNvbnN0IGlzVGltZSA9IGNvbHVtbj8uZGF0YVR5cGUgPT09IFRJTUVfVFlQRSB8fCBjb2x1bW4/LmRhdGFUeXBlID09PSBEQVRFX1RJTUVfVFlQRTtcbiAgICAgICAgY29uc3QgaXNTdHJpbmcgPSBjb2x1bW4/LmRhdGFUeXBlID09PSBTVFJJTkdfVFlQRTtcbiAgICAgICAgZGF0YSA9IGV4cHIuc3RyYXRlZ3kuc29ydChkYXRhLCBleHByLmZpZWxkTmFtZSwgZXhwci5kaXIsIGV4cHIuaWdub3JlQ2FzZSwgdGhpcy5nZXRGaWVsZFZhbHVlLCBpc0RhdGUsIGlzVGltZSwgZ3JpZCk7XG4gICAgICAgIGlmIChleHByZXNzaW9uSW5kZXggPT09IGV4cHJzTGVuIC0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW4gY2FzZSBvZiBtdWx0aXBsZSBzb3J0aW5nXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuOyBpKyspIHtcbiAgICAgICAgICAgIGdiRGF0YSA9IHRoaXMuZ3JvdXBlZFJlY29yZHNCeUV4cHJlc3Npb24oZGF0YSwgaSwgZXhwciwgaXNEYXRlLCBpc1RpbWUsIGlzU3RyaW5nLCBjb2x1bW4/Lmdyb3VwaW5nQ29tcGFyZXIpO1xuICAgICAgICAgICAgZ2JEYXRhTGVuID0gZ2JEYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChnYkRhdGFMZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgZ2JEYXRhID0gdGhpcy5zb3J0RGF0YVJlY3Vyc2l2ZShnYkRhdGEsIGV4cHJlc3Npb25zLCBleHByZXNzaW9uSW5kZXggKyAxLCBncmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnYkRhdGFMZW47IGorKykge1xuICAgICAgICAgICAgICAgIGRhdGFbaSArIGpdID0gZ2JEYXRhW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSArPSBnYkRhdGFMZW4gLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2xhc3MgaW1wbGVtZW50aW5nIHRoZSBJR3JpZEdyb3VwaW5nU3RyYXRlZ3kgaW50ZXJmYWNlIGFuZCBleHRlbmRpbmcgdGhlIElneFNvcnRpbmcgY2xhc3MuXG4gKiBJdCBwcm92aWRlcyBhIG1ldGhvZCB0byBncm91cCBkYXRhIGJhc2VkIG9uIHRoZSBnaXZlbiBncm91cGluZyBzdGF0ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIElneEdyb3VwaW5nIGV4dGVuZHMgSWd4U29ydGluZyBpbXBsZW1lbnRzIElHcmlkR3JvdXBpbmdTdHJhdGVneSB7XG4gICAgLyogYmxhem9yU3VwcHJlc3MgKi9cbiAgLyoqXG4gICAqIEdyb3VwcyB0aGUgcHJvdmlkZWQgZGF0YSBiYXNlZCBvbiB0aGUgZ2l2ZW4gZ3JvdXBpbmcgc3RhdGUuXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJlc3VsdCBvZiB0aGUgZ3JvdXBpbmcgb3BlcmF0aW9uLlxuICAgKi9cbiAgICBwdWJsaWMgZ3JvdXBCeShkYXRhOiBhbnlbXSwgc3RhdGU6IElHcm91cGluZ1N0YXRlLCBncmlkPzogYW55LFxuICAgICAgICBncm91cHNSZWNvcmRzPzogYW55W10sIGZ1bGxSZXN1bHQ6IElHcm91cEJ5UmVzdWx0ID0geyBkYXRhOiBbXSwgbWV0YWRhdGE6IFtdIH0pOiBJR3JvdXBCeVJlc3VsdCB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhOiBJR3JvdXBCeVJlY29yZFtdID0gW107XG4gICAgICAgIGNvbnN0IGdyb3VwaW5nID0gdGhpcy5ncm91cERhdGFSZWN1cnNpdmUoZGF0YSwgc3RhdGUsIDAsIG51bGwsIG1ldGFkYXRhLCBncmlkLCBncm91cHNSZWNvcmRzLCBmdWxsUmVzdWx0KTtcbiAgICAgICAgZ3JpZD8uZ3JvdXBpbmdQZXJmb3JtZWRTdWJqZWN0Lm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IGdyb3VwaW5nLFxuICAgICAgICAgICAgbWV0YWRhdGFcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8qIGNzU3VwcHJlc3MgKi9cbi8qKlxuICogUmVwcmVzZW50cyBhIGNsYXNzIGltcGxlbWVudGluZyB0aGUgSUdyaWRTb3J0aW5nU3RyYXRlZ3kgaW50ZXJmYWNlIHdpdGggYSBuby1vcGVyYXRpb24gc29ydGluZyBzdHJhdGVneS5cbiAqIEl0IHBlcmZvcm1zIG5vIHNvcnRpbmcgYW5kIHJldHVybnMgdGhlIGRhdGEgYXMgaXQgaXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBOb29wU29ydGluZ1N0cmF0ZWd5IGltcGxlbWVudHMgSUdyaWRTb3J0aW5nU3RyYXRlZ3kge1xuICAgIHByaXZhdGUgc3RhdGljIF9pbnN0YW5jZTogTm9vcFNvcnRpbmdTdHJhdGVneSA9IG51bGw7XG5cbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKCkgeyB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGluc3RhbmNlKCk6IE5vb3BTb3J0aW5nU3RyYXRlZ3kge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFuY2UgfHwgKHRoaXMuX2luc3RhbmNlID0gbmV3IE5vb3BTb3J0aW5nU3RyYXRlZ3koKSk7XG4gICAgfVxuXG4gICAgLyogY3NTdXBwcmVzcyAqL1xuICAgIHB1YmxpYyBzb3J0KGRhdGE6IGFueVtdKTogYW55W10ge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNsYXNzIGV4dGVuZGluZyB0aGUgSWd4U29ydGluZyBjbGFzc1xuICogUHJvdmlkZXMgY3VzdG9tIGRhdGEgcmVjb3JkIHNvcnRpbmcuXG4gKi9cbmV4cG9ydCBjbGFzcyBJZ3hEYXRhUmVjb3JkU29ydGluZyBleHRlbmRzIElneFNvcnRpbmcge1xuICAgLyoqXG4gICAqIE92ZXJyaWRlcyB0aGUgYmFzZSBtZXRob2QgdG8gcmV0cmlldmUgdGhlIGZpZWxkIHZhbHVlIGZyb20gdGhlIGRhdGEgb2JqZWN0IGluc3RlYWQgb2YgdGhlIHJlY29yZCBvYmplY3QuXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQgZmllbGQgaW4gdGhlIGRhdGEgb2JqZWN0LlxuICAgKi9cbiAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgZ2V0RmllbGRWYWx1ZShvYmo6IGFueSwga2V5OiBzdHJpbmcsIGlzRGF0ZSA9IGZhbHNlLCBpc1RpbWUgPSBmYWxzZSk6IGFueSB7XG4gICAgICAgIHJldHVybiBzdXBlci5nZXRGaWVsZFZhbHVlKG9iai5kYXRhLCBrZXksIGlzRGF0ZSwgaXNUaW1lKTtcbiAgICB9XG59XG4iXX0=