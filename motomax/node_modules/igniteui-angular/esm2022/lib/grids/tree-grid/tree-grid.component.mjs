import { ChangeDetectionStrategy, Component, HostBinding, Input, TemplateRef, ContentChild, ViewChild, Inject, Optional, LOCALE_ID, CUSTOM_ELEMENTS_SCHEMA, booleanAttribute } from '@angular/core';
import { DOCUMENT, NgIf, NgClass, NgFor, NgTemplateOutlet, NgStyle } from '@angular/common';
import { IgxTreeGridAPIService } from './tree-grid-api.service';
import { IgxGridBaseDirective } from '../grid-base.directive';
import { TransactionType, TransactionEventOrigin } from '../../services/transaction/transaction';
import { IgxFilteringService } from '../filtering/grid-filtering.service';
import { IgxGridSummaryService } from '../summaries/grid-summary.service';
import { IgxGridSelectionService } from '../selection/selection.service';
import { mergeObjects } from '../../core/utils';
import { first, takeUntil } from 'rxjs/operators';
import { IgxRowLoadingIndicatorTemplateDirective } from './tree-grid.directives';
import { IgxForOfSyncService, IgxForOfScrollSyncService } from '../../directives/for-of/for_of.sync.service';
import { IgxGridNavigationService } from '../grid-navigation.service';
import { IGX_GRID_BASE, IGX_GRID_SERVICE_BASE } from '../common/grid.interface';
import { IgxTreeGridSelectionService } from './tree-grid-selection.service';
import { GridSelectionMode } from '../common/enums';
import { IgxSummaryRow, IgxTreeGridRow } from '../grid-public-row';
import { IgxGridCRUDService } from '../common/crud.service';
import { IgxTreeGridGroupByAreaComponent } from '../grouping/tree-grid-group-by-area.component';
import { IgxGridCell } from '../grid-public-cell';
import { IgxColumnResizingService } from '../resizing/resizing.service';
import { IgxOverlayService } from '../../services/overlay/overlay';
import { IgxGridTransaction } from '../common/types';
import { TreeGridFilteringStrategy } from './tree-grid.filtering.strategy';
import { IgxGridValidationService } from '../grid/grid-validation.service';
import { IgxTreeGridSummaryPipe } from './tree-grid.summary.pipe';
import { IgxTreeGridFilteringPipe } from './tree-grid.filtering.pipe';
import { IgxTreeGridHierarchizingPipe, IgxTreeGridFlatteningPipe, IgxTreeGridSortingPipe, IgxTreeGridPagingPipe, IgxTreeGridTransactionPipe, IgxTreeGridNormalizeRecordsPipe, IgxTreeGridAddRowPipe } from './tree-grid.pipes';
import { IgxSummaryDataPipe } from '../summaries/grid-root-summary.pipe';
import { IgxHasVisibleColumnsPipe, IgxGridRowPinningPipe, IgxGridRowClassesPipe, IgxGridRowStylesPipe, IgxStringReplacePipe } from '../common/pipes';
import { IgxGridColumnResizerComponent } from '../resizing/resizer.component';
import { IgxIconComponent } from '../../icon/icon.component';
import { IgxRowEditTabStopDirective } from '../grid.rowEdit.directive';
import { IgxRippleDirective } from '../../directives/ripple/ripple.directive';
import { IgxButtonDirective } from '../../directives/button/button.directive';
import { IgxSnackbarComponent } from '../../snackbar/snackbar.component';
import { IgxCircularProgressBarComponent } from '../../progressbar/progressbar.component';
import { IgxOverlayOutletDirective, IgxToggleDirective } from '../../directives/toggle/toggle.directive';
import { IgxSummaryRowComponent } from '../summaries/summary-row.component';
import { IgxTreeGridRowComponent } from './tree-grid-row.component';
import { IgxTemplateOutletDirective } from '../../directives/template-outlet/template_outlet.directive';
import { IgxGridForOfDirective } from '../../directives/for-of/for_of.directive';
import { IgxColumnMovingDropDirective } from '../moving/moving.drop.directive';
import { IgxGridDragSelectDirective } from '../selection/drag-select.directive';
import { IgxGridBodyDirective } from '../grid.common';
import { IgxGridHeaderRowComponent } from '../headers/grid-header-row.component';
import * as i0 from "@angular/core";
import * as i1 from "../grid/grid-validation.service";
import * as i2 from "../selection/selection.service";
import * as i3 from "../resizing/resizing.service";
import * as i4 from "../../services/transaction/transaction-factory.service";
import * as i5 from "../grid-navigation.service";
import * as i6 from "../filtering/grid-filtering.service";
import * as i7 from "../../directives/text-highlight/text-highlight.service";
import * as i8 from "../summaries/grid-summary.service";
import * as i9 from "../../core/utils";
import * as i10 from "../../services/overlay/overlay";
let NEXT_ID = 0;
/* blazorAdditionalDependency: Column */
/* blazorAdditionalDependency: ColumnGroup */
/* blazorAdditionalDependency: ColumnLayout */
/* blazorAdditionalDependency: GridToolbar */
/* blazorAdditionalDependency: GridToolbarActions */
/* blazorAdditionalDependency: GridToolbarTitle */
/* blazorAdditionalDependency: GridToolbarAdvancedFiltering */
/* blazorAdditionalDependency: GridToolbarExporter */
/* blazorAdditionalDependency: GridToolbarHiding */
/* blazorAdditionalDependency: GridToolbarPinning */
/* blazorAdditionalDependency: ActionStrip */
/* blazorAdditionalDependency: GridActionsBaseDirective */
/* blazorAdditionalDependency: GridEditingActions */
/* blazorAdditionalDependency: GridPinningActions */
/* blazorIndirectRender */
/**
 * **Ignite UI for Angular Tree Grid** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid/grid)
 *
 * The Ignite UI Tree Grid displays and manipulates hierarchical data with consistent schema formatted as a table and
 * provides features such as sorting, filtering, editing, column pinning, paging, column moving and hiding.
 *
 * Example:
 * ```html
 * <igx-tree-grid [data]="employeeData" primaryKey="employeeID" foreignKey="PID" [autoGenerate]="false">
 *   <igx-column field="first" header="First Name"></igx-column>
 *   <igx-column field="last" header="Last Name"></igx-column>
 *   <igx-column field="role" header="Role"></igx-column>
 * </igx-tree-grid>
 * ```
 */
export class IgxTreeGridComponent extends IgxGridBaseDirective {
    /* treatAsRef */
    /**
     * Gets/Sets the array of data that populates the component.
     * ```html
     * <igx-tree-grid [data]="Data" [autoGenerate]="true"></igx-tree-grid>
     * ```
     *
     * @memberof IgxTreeGridComponent
     */
    get data() {
        return this._data;
    }
    /* treatAsRef */
    set data(value) {
        const oldData = this._data;
        this._data = value || [];
        this.summaryService.clearSummaryCache();
        if (!this._init) {
            this.validation.updateAll(this._data);
        }
        if (this.autoGenerate && this._data.length > 0 && this.shouldRecreateColumns(oldData, this._data)) {
            this.setupColumns();
        }
        this.cdr.markForCheck();
    }
    /** @hidden @internal */
    get type() {
        return 'tree';
    }
    /**
     * Get transactions service for the grid.
     *
     * @experimental @hidden
     */
    get transactions() {
        if (this._diTransactions && !this.batchEditing) {
            return this._diTransactions;
        }
        return this._transactions;
    }
    /**
     * Sets the count of levels to be expanded in the `IgxTreeGridComponent`. By default it is
     * set to `Infinity` which means all levels would be expanded.
     * ```html
     * <igx-tree-grid #grid [data]="employeeData" [childDataKey]="'employees'" expansionDepth="1" [autoGenerate]="true"></igx-tree-grid>
     * ```
     *
     * @memberof IgxTreeGridComponent
     */
    get expansionDepth() {
        return this._expansionDepth;
    }
    set expansionDepth(value) {
        this._expansionDepth = value;
        this.notifyChanges();
    }
    /**
     * Template for the row loading indicator when load on demand is enabled.
     * ```html
     * <ng-template #rowLoadingTemplate>
     *     <igx-icon>loop</igx-icon>
     * </ng-template>
     *
     * <igx-tree-grid #grid [data]="employeeData" [primaryKey]="'ID'" [foreignKey]="'parentID'"
     *                [loadChildrenOnDemand]="loadChildren"
     *                [rowLoadingIndicatorTemplate]="rowLoadingTemplate">
     * </igx-tree-grid>
     * ```
     *
     * @memberof IgxTreeGridComponent
     */
    get rowLoadingIndicatorTemplate() {
        return this._rowLoadingIndicatorTemplate;
    }
    set rowLoadingIndicatorTemplate(value) {
        this._rowLoadingIndicatorTemplate = value;
        this.notifyChanges();
    }
    // Kind of stupid
    // private get _gridAPI(): IgxTreeGridAPIService {
    //     return this.gridAPI as IgxTreeGridAPIService;
    // }
    constructor(validationService, selectionService, colResizingService, gridAPI, 
    // public gridAPI: GridBaseAPIService<IgxGridBaseDirective & GridType>,
    transactionFactory, _elementRef, _zone, document, cdr, differs, viewRef, injector, envInjector, navigation, filteringService, textHighlightService, overlayService, summaryService, localeId, platform, _diTransactions) {
        super(validationService, selectionService, colResizingService, gridAPI, transactionFactory, _elementRef, _zone, document, cdr, differs, viewRef, injector, envInjector, navigation, filteringService, textHighlightService, overlayService, summaryService, localeId, platform, _diTransactions);
        this._diTransactions = _diTransactions;
        /**
         * Sets whether child records should be deleted when their parent gets deleted.
         * By default it is set to true and deletes all children along with the parent.
         * ```html
         * <igx-tree-grid [data]="employeeData" [primaryKey]="'employeeID'" [foreignKey]="'parentID'" cascadeOnDelete="false">
         * </igx-tree-grid>
         * ```
         *
         * @memberof IgxTreeGridComponent
         */
        this.cascadeOnDelete = true;
        /**
         * @hidden @internal
         */
        this.role = 'treegrid';
        /**
         * Sets the value of the `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-tree-grid [id]="'igx-tree-grid-1'"></igx-tree-grid>
         * ```
         *
         * @memberof IgxTreeGridComponent
         */
        this.id = `igx-tree-grid-${NEXT_ID++}`;
        /* blazorSuppress */
        /**
         * Returns a map of all `ITreeGridRecord`s.
         * ```typescript
         * // gets the record with primaryKey=2
         * const states = this.grid.records.get(2);
         * ```
         *
         * @memberof IgxTreeGridComponent
         */
        this.records = new Map();
        /* blazorSuppress */
        /**
         * Returns a map of all processed (filtered and sorted) `ITreeGridRecord`s.
         * ```typescript
         * // gets the processed record with primaryKey=2
         * const states = this.grid.processedRecords.get(2);
         * ```
         *
         * @memberof IgxTreeGridComponent
         */
        this.processedRecords = new Map();
        /**
         * @hidden
         */
        this.loadingRows = new Set();
        this._filterStrategy = new TreeGridFilteringStrategy();
        this._expansionDepth = Infinity;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        super.ngOnInit();
        this.rowToggle.pipe(takeUntil(this.destroy$)).subscribe((args) => {
            this.loadChildrenOnRowExpansion(args);
        });
        // TODO: cascade selection logic should be refactor to be handled in the already existing subs
        this.rowAddedNotifier.pipe(takeUntil(this.destroy$)).subscribe(args => {
            if (this.rowSelection === GridSelectionMode.multipleCascade) {
                let rec = this.gridAPI.get_rec_by_id(this.primaryKey ? args.data[this.primaryKey] : args.data);
                if (rec && rec.parent) {
                    this.gridAPI.grid.selectionService.updateCascadeSelectionOnFilterAndCRUD(new Set([rec.parent]), rec.parent.key);
                }
                else {
                    // The record is still not available
                    // Wait for the change detection to update records through pipes
                    requestAnimationFrame(() => {
                        rec = this.gridAPI.get_rec_by_id(this.primaryKey ?
                            args.data[this.primaryKey] : args.data);
                        if (rec && rec.parent) {
                            this.gridAPI.grid.selectionService.updateCascadeSelectionOnFilterAndCRUD(new Set([rec.parent]), rec.parent.key);
                        }
                        this.notifyChanges();
                    });
                }
            }
        });
        this.rowDeletedNotifier.pipe(takeUntil(this.destroy$)).subscribe(args => {
            if (this.rowSelection === GridSelectionMode.multipleCascade) {
                if (args.data) {
                    const rec = this.gridAPI.get_rec_by_id(this.primaryKey ? args.data[this.primaryKey] : args.data);
                    this.handleCascadeSelection(args, rec);
                }
                else {
                    // if a row has been added and before commiting the transaction deleted
                    const leafRowsDirectParents = new Set();
                    this.records.forEach(record => {
                        if (record && (!record.children || record.children.length === 0) && record.parent) {
                            leafRowsDirectParents.add(record.parent);
                        }
                    });
                    // Wait for the change detection to update records through pipes
                    requestAnimationFrame(() => {
                        this.gridAPI.grid.selectionService.updateCascadeSelectionOnFilterAndCRUD(leafRowsDirectParents);
                        this.notifyChanges();
                    });
                }
            }
        });
        this.filteringDone.pipe(takeUntil(this.destroy$)).subscribe(() => {
            if (this.rowSelection === GridSelectionMode.multipleCascade) {
                const leafRowsDirectParents = new Set();
                this.records.forEach(record => {
                    if (record && (!record.children || record.children.length === 0) && record.parent) {
                        leafRowsDirectParents.add(record.parent);
                    }
                });
                this.gridAPI.grid.selectionService.updateCascadeSelectionOnFilterAndCRUD(leafRowsDirectParents);
                this.notifyChanges();
            }
        });
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        super.ngAfterViewInit();
        // TODO: pipesExectured event
        // run after change detection in super triggers pipes for records structure
        if (this.rowSelection === GridSelectionMode.multipleCascade && this.selectedRows.length) {
            const selRows = this.selectedRows;
            this.selectionService.clearRowSelection();
            this.selectRows(selRows, true);
            this.cdr.detectChanges();
        }
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (this.rowLoadingTemplate) {
            this._rowLoadingIndicatorTemplate = this.rowLoadingTemplate.template;
        }
        super.ngAfterContentInit();
    }
    getDefaultExpandState(record) {
        return record.children && record.children.length && record.level < this.expansionDepth;
    }
    /**
     * Expands all rows.
     * ```typescript
     * this.grid.expandAll();
     * ```
     *
     * @memberof IgxTreeGridComponent
     */
    expandAll() {
        this._expansionDepth = Infinity;
        this.expansionStates = new Map();
    }
    /**
     * Collapses all rows.
     *
     * ```typescript
     * this.grid.collapseAll();
     *  ```
     *
     * @memberof IgxTreeGridComponent
     */
    collapseAll() {
        this._expansionDepth = 0;
        this.expansionStates = new Map();
    }
    /**
     * @hidden
     */
    refreshGridState(args) {
        super.refreshGridState();
        if (this.primaryKey && this.foreignKey && args) {
            const rowID = args.data[this.foreignKey];
            this.summaryService.clearSummaryCache({ rowID });
            this.pipeTrigger++;
            this.cdr.detectChanges();
        }
    }
    /* blazorCSSuppress */
    /**
     * Creates a new `IgxTreeGridRowComponent` with the given data. If a parentRowID is not specified, the newly created
     * row would be added at the root level. Otherwise, it would be added as a child of the row whose primaryKey matches
     * the specified parentRowID. If the parentRowID does not exist, an error would be thrown.
     * ```typescript
     * const record = {
     *     ID: this.grid.data[this.grid1.data.length - 1].ID + 1,
     *     Name: this.newRecord
     * };
     * this.grid.addRow(record, 1); // Adds a new child row to the row with ID=1.
     * ```
     *
     * @param data
     * @param parentRowID
     * @memberof IgxTreeGridComponent
     */
    // TODO: remove evt emission
    addRow(data, parentRowID) {
        this.crudService.endEdit(true);
        this.gridAPI.addRowToData(data, parentRowID);
        this.rowAddedNotifier.next({
            data: data,
            rowData: data, owner: this,
            primaryKey: data[this.primaryKey],
            rowKey: data[this.primaryKey]
        });
        this.pipeTrigger++;
        this.notifyChanges();
    }
    /**
     * Enters add mode by spawning the UI with the context of the specified row by index.
     *
     * @remarks
     * Accepted values for index are integers from 0 to this.grid.dataView.length
     * @remarks
     * When adding the row as a child, the parent row is the specified row.
     * @remarks
     * To spawn the UI on top, call the function with index = null or a negative number.
     * In this case trying to add this row as a child will result in error.
     * @example
     * ```typescript
     * this.grid.beginAddRowByIndex(10);
     * this.grid.beginAddRowByIndex(10, true);
     * this.grid.beginAddRowByIndex(null);
     * ```
     * @param index - The index to spawn the UI at. Accepts integers from 0 to this.grid.dataView.length
     * @param asChild - Whether the record should be added as a child. Only applicable to igxTreeGrid.
     */
    beginAddRowByIndex(index, asChild) {
        if (index === null || index < 0) {
            return this.beginAddRowById(null, asChild);
        }
        return this._addRowForIndex(index - 1, asChild);
    }
    /**
     * @hidden
     */
    getContext(rowData, rowIndex, pinned) {
        return {
            $implicit: this.isGhostRecord(rowData) ? rowData.recordRef : rowData,
            index: this.getDataViewIndex(rowIndex, pinned),
            templateID: {
                type: this.isSummaryRow(rowData) ? 'summaryRow' : 'dataRow',
                id: null
            },
            disabled: this.isGhostRecord(rowData) ? rowData.recordRef.isFilteredOutParent === undefined : false
        };
    }
    /**
     * @hidden
     * @internal
     */
    getInitialPinnedIndex(rec) {
        const id = this.gridAPI.get_row_id(rec);
        return this._pinnedRecordIDs.indexOf(id);
    }
    /**
     * @hidden
     * @internal
     */
    isRecordPinned(rec) {
        return this.getInitialPinnedIndex(rec.data) !== -1;
    }
    /**
     *
     * Returns an array of the current cell selection in the form of `[{ column.field: cell.value }, ...]`.
     *
     * @remarks
     * If `formatters` is enabled, the cell value will be formatted by its respective column formatter (if any).
     * If `headers` is enabled, it will use the column header (if any) instead of the column field.
     */
    getSelectedData(formatters = false, headers = false) {
        let source = [];
        const process = (record) => {
            if (record.summaries) {
                source.push(null);
                return;
            }
            source.push(record.data);
        };
        this.unpinnedDataView.forEach(process);
        source = this.isRowPinningToTop ? [...this.pinnedDataView, ...source] : [...source, ...this.pinnedDataView];
        return this.extractDataFromSelection(source, formatters, headers);
    }
    /**
     * @hidden @internal
     */
    getEmptyRecordObjectFor(inTreeRow) {
        const treeRowRec = inTreeRow?.treeRow || null;
        const row = { ...treeRowRec };
        const data = treeRowRec?.data || {};
        row.data = { ...data };
        Object.keys(row.data).forEach(key => {
            // persist foreign key if one is set.
            if (this.foreignKey && key === this.foreignKey) {
                row.data[key] = treeRowRec.data[this.crudService.addRowParent?.asChild ? this.primaryKey : key];
            }
            else {
                row.data[key] = undefined;
            }
        });
        let id = this.generateRowID();
        const rootRecPK = this.foreignKey && this.rootRecords && this.rootRecords.length > 0 ?
            this.rootRecords[0].data[this.foreignKey] : null;
        if (id === rootRecPK) {
            // safeguard in case generated id matches the root foreign key.
            id = this.generateRowID();
        }
        row.key = id;
        row.data[this.primaryKey] = id;
        return { rowID: id, data: row.data, recordRef: row };
    }
    /** @hidden */
    deleteRowById(rowId) {
        //  if this is flat self-referencing data, and CascadeOnDelete is set to true
        //  and if we have transactions we should start pending transaction. This allows
        //  us in case of delete action to delete all child rows as single undo action
        const args = {
            rowID: rowId,
            primaryKey: rowId,
            rowKey: rowId,
            cancel: false,
            rowData: this.getRowData(rowId),
            data: this.getRowData(rowId),
            oldValue: null,
            owner: this
        };
        this.rowDelete.emit(args);
        if (args.cancel) {
            return;
        }
        const record = this.gridAPI.deleteRowById(rowId);
        const key = record[this.primaryKey];
        if (record !== null && record !== undefined) {
            const rowDeletedEventArgs = {
                data: record,
                rowData: record,
                owner: this,
                primaryKey: key,
                rowKey: key
            };
            this.rowDeleted.emit(rowDeletedEventArgs);
        }
        return record;
    }
    /**
     * Returns the `IgxTreeGridRow` by index.
     *
     * @example
     * ```typescript
     * const myRow = treeGrid.getRowByIndex(1);
     * ```
     * @param index
     */
    getRowByIndex(index) {
        if (index < 0 || index >= this.dataView.length) {
            return undefined;
        }
        return this.createRow(index);
    }
    /**
     * Returns the `RowType` object by the specified primary key.
     *
     * @example
     * ```typescript
     * const myRow = this.treeGrid.getRowByIndex(1);
     * ```
     * @param index
     */
    getRowByKey(key) {
        const rec = this.filteredSortedData ? this.primaryKey ? this.filteredSortedData.find(r => r[this.primaryKey] === key) :
            this.filteredSortedData.find(r => r === key) : undefined;
        const index = this.dataView.findIndex(r => r.data && r.data === rec);
        if (index < 0 || index >= this.filteredSortedData.length) {
            return undefined;
        }
        return new IgxTreeGridRow(this, index, rec);
    }
    /**
     * Returns the collection of all RowType for current page.
     *
     * @hidden @internal
     */
    allRows() {
        return this.dataView.map((rec, index) => this.createRow(index));
    }
    /**
     * Returns the collection of `IgxTreeGridRow`s for current page.
     *
     * @hidden @internal
     */
    dataRows() {
        return this.allRows().filter(row => row instanceof IgxTreeGridRow);
    }
    /**
     * Returns an array of the selected `IgxGridCell`s.
     *
     * @example
     * ```typescript
     * const selectedCells = this.grid.selectedCells;
     * ```
     */
    get selectedCells() {
        return this.dataRows().map((row) => row.cells.filter((cell) => cell.selected))
            .reduce((a, b) => a.concat(b), []);
    }
    /**
     * Returns a `CellType` object that matches the conditions.
     *
     * @example
     * ```typescript
     * const myCell = this.grid1.getCellByColumn(2, "UnitPrice");
     * ```
     * @param rowIndex
     * @param columnField
     */
    getCellByColumn(rowIndex, columnField) {
        const row = this.getRowByIndex(rowIndex);
        const column = this.columns.find((col) => col.field === columnField);
        if (row && row instanceof IgxTreeGridRow && column) {
            return new IgxGridCell(this, rowIndex, column);
        }
    }
    /**
     * Returns a `CellType` object that matches the conditions.
     *
     * @remarks
     * Requires that the primaryKey property is set.
     * @example
     * ```typescript
     * grid.getCellByKey(1, 'index');
     * ```
     * @param rowSelector match any rowID
     * @param columnField
     */
    getCellByKey(rowSelector, columnField) {
        const row = this.getRowByKey(rowSelector);
        const column = this.columns.find((col) => col.field === columnField);
        if (row && column) {
            return new IgxGridCell(this, row.index, column);
        }
    }
    pinRow(rowID, index) {
        const row = this.getRowByKey(rowID);
        return super.pinRow(rowID, index, row);
    }
    unpinRow(rowID) {
        const row = this.getRowByKey(rowID);
        return super.unpinRow(rowID, row);
    }
    /** @hidden */
    generateRowPath(rowId) {
        const path = [];
        let record = this.records.get(rowId);
        while (record.parent) {
            path.push(record.parent.key);
            record = record.parent;
        }
        return path.reverse();
    }
    /** @hidden */
    isTreeRow(record) {
        return record.key !== undefined && record.data;
    }
    /** @hidden */
    getUnpinnedIndexById(id) {
        return this.unpinnedRecords.findIndex(x => x.data[this.primaryKey] === id);
    }
    /**
     * @hidden
     */
    createRow(index, data) {
        let row;
        const dataIndex = this._getDataViewIndex(index);
        const rec = data ?? this.dataView[dataIndex];
        if (this.isSummaryRow(rec)) {
            row = new IgxSummaryRow(this, index, rec.summaries);
        }
        if (!row && rec) {
            const isTreeRow = this.isTreeRow(rec);
            const dataRec = isTreeRow ? rec.data : rec;
            const treeRow = isTreeRow ? rec : undefined;
            row = new IgxTreeGridRow(this, index, dataRec, treeRow);
        }
        return row;
    }
    generateDataFields(data) {
        return super.generateDataFields(data).filter(field => field !== this.childDataKey);
    }
    transactionStatusUpdate(event) {
        let actions = [];
        if (event.origin === TransactionEventOrigin.REDO) {
            actions = event.actions ? event.actions.filter(x => x.transaction.type === TransactionType.DELETE) : [];
            if (this.rowSelection === GridSelectionMode.multipleCascade) {
                this.handleCascadeSelection(event);
            }
        }
        else if (event.origin === TransactionEventOrigin.UNDO) {
            actions = event.actions ? event.actions.filter(x => x.transaction.type === TransactionType.ADD) : [];
            if (this.rowSelection === GridSelectionMode.multipleCascade) {
                if (event.actions[0].transaction.type === 'add') {
                    const rec = this.gridAPI.get_rec_by_id(event.actions[0].transaction.id);
                    this.handleCascadeSelection(event, rec);
                }
                else {
                    this.handleCascadeSelection(event);
                }
            }
        }
        if (actions.length) {
            for (const action of actions) {
                this.deselectChildren(action.transaction.id);
            }
        }
        super.transactionStatusUpdate(event);
    }
    findRecordIndexInView(rec) {
        return this.dataView.findIndex(x => x.data[this.primaryKey] === rec[this.primaryKey]);
    }
    /**
     * @hidden @internal
     */
    getDataBasedBodyHeight() {
        return !this.flatData || (this.flatData.length < this._defaultTargetRecordNumber) ?
            0 : this.defaultTargetBodyHeight;
    }
    /**
     * @hidden
     */
    scrollTo(row, column) {
        let delayScrolling = false;
        let record;
        if (typeof (row) !== 'number') {
            const rowData = row;
            const rowID = this.gridAPI.get_row_id(rowData);
            record = this.processedRecords.get(rowID);
            this.gridAPI.expand_path_to_record(record);
            if (this.paginator) {
                const rowIndex = this.processedExpandedFlatData.indexOf(rowData);
                const page = Math.floor(rowIndex / this.perPage);
                if (this.page !== page) {
                    delayScrolling = true;
                    this.page = page;
                }
            }
        }
        if (delayScrolling) {
            this.verticalScrollContainer.dataChanged.pipe(first()).subscribe(() => {
                this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.unpinnedDataView.indexOf(record));
            });
        }
        else {
            this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.unpinnedDataView.indexOf(record));
        }
        this.scrollToHorizontally(column);
    }
    writeToData(rowIndex, value) {
        mergeObjects(this.flatData[rowIndex], value);
    }
    /**
     * @hidden
     */
    initColumns(collection, cb = null) {
        if (this.hasColumnLayouts) {
            // invalid configuration - tree grid should not allow column layouts
            // remove column layouts
            const nonColumnLayoutColumns = this.columns.filter((col) => !col.columnLayout && !col.columnLayoutChild);
            this.updateColumns(nonColumnLayoutColumns);
        }
        super.initColumns(collection, cb);
    }
    /**
     * @hidden @internal
     */
    getGroupAreaHeight() {
        return this.treeGroupArea ? this.getComputedHeight(this.treeGroupArea.nativeElement) : 0;
    }
    /**
     * @description A recursive way to deselect all selected children of a given record
     * @param recordID ID of the record whose children to deselect
     * @hidden
     * @internal
     */
    deselectChildren(recordID) {
        const selectedChildren = [];
        // G.E. Apr 28, 2021 #9465 Records which are not in view can also be selected so we need to
        // deselect them as well, hence using 'records' map instead of getRowByKey() method which will
        // return only row components (i.e. records in view).
        const rowToDeselect = this.records.get(recordID);
        this.selectionService.deselectRowsWithNoEvent([recordID]);
        this.gridAPI.get_selected_children(rowToDeselect, selectedChildren);
        if (selectedChildren.length > 0) {
            selectedChildren.forEach(x => this.deselectChildren(x));
        }
    }
    addChildRows(children, parentID) {
        if (this.primaryKey && this.foreignKey) {
            for (const child of children) {
                child[this.foreignKey] = parentID;
            }
            this.data.push(...children);
        }
        else if (this.childDataKey) {
            let parent = this.records.get(parentID);
            let parentData = parent.data;
            if (this.transactions.enabled && this.transactions.getAggregatedChanges(true).length) {
                const path = [];
                while (parent) {
                    path.push(parent.key);
                    parent = parent.parent;
                }
                let collection = this.data;
                let record;
                for (let i = path.length - 1; i >= 0; i--) {
                    const pid = path[i];
                    record = collection.find(r => r[this.primaryKey] === pid);
                    if (!record) {
                        break;
                    }
                    collection = record[this.childDataKey];
                }
                if (record) {
                    parentData = record;
                }
            }
            parentData[this.childDataKey] = children;
        }
        this.selectionService.clearHeaderCBState();
        this.pipeTrigger++;
        if (this.rowSelection === GridSelectionMode.multipleCascade) {
            // Force pipe triggering for building the data structure
            this.cdr.detectChanges();
            if (this.selectionService.isRowSelected(parentID)) {
                this.selectionService.rowSelection.delete(parentID);
                this.selectionService.selectRowsWithNoEvent([parentID]);
            }
        }
    }
    loadChildrenOnRowExpansion(args) {
        if (this.loadChildrenOnDemand) {
            const parentID = args.rowID;
            if (args.expanded && !this._expansionStates.has(parentID)) {
                this.loadingRows.add(parentID);
                this.loadChildrenOnDemand(parentID, children => {
                    this.loadingRows.delete(parentID);
                    this.addChildRows(children, parentID);
                    this.notifyChanges();
                });
            }
        }
    }
    handleCascadeSelection(event, rec = null) {
        // Wait for the change detection to update records through the pipes
        requestAnimationFrame(() => {
            if (rec === null) {
                rec = this.gridAPI.get_rec_by_id(event.actions[0].transaction.id);
            }
            if (rec && rec.parent) {
                this.gridAPI.grid.selectionService.updateCascadeSelectionOnFilterAndCRUD(new Set([rec.parent]), rec.parent.key);
                this.notifyChanges();
            }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxTreeGridComponent, deps: [{ token: i1.IgxGridValidationService }, { token: i2.IgxGridSelectionService }, { token: i3.IgxColumnResizingService }, { token: IGX_GRID_SERVICE_BASE }, { token: i4.IgxHierarchicalTransactionFactory }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: DOCUMENT }, { token: i0.ChangeDetectorRef }, { token: i0.IterableDiffers }, { token: i0.ViewContainerRef }, { token: i0.Injector }, { token: i0.EnvironmentInjector }, { token: i5.IgxGridNavigationService }, { token: i6.IgxFilteringService }, { token: i7.IgxTextHighlightService }, { token: IgxOverlayService }, { token: i8.IgxGridSummaryService }, { token: LOCALE_ID }, { token: i9.PlatformUtil }, { token: IgxGridTransaction, optional: true }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "18.2.4", type: IgxTreeGridComponent, isStandalone: true, selector: "igx-tree-grid", inputs: { childDataKey: "childDataKey", foreignKey: "foreignKey", hasChildrenKey: "hasChildrenKey", cascadeOnDelete: ["cascadeOnDelete", "cascadeOnDelete", booleanAttribute], loadChildrenOnDemand: "loadChildrenOnDemand", id: "id", data: "data", expansionDepth: "expansionDepth", rowLoadingIndicatorTemplate: "rowLoadingIndicatorTemplate" }, host: { properties: { "attr.role": "this.role", "attr.id": "this.id" } }, providers: [
            IgxGridCRUDService,
            IgxGridValidationService,
            IgxGridSummaryService,
            IgxGridNavigationService,
            { provide: IgxGridSelectionService, useClass: IgxTreeGridSelectionService },
            { provide: IGX_GRID_SERVICE_BASE, useClass: IgxTreeGridAPIService },
            { provide: IGX_GRID_BASE, useExisting: IgxTreeGridComponent },
            IgxFilteringService,
            IgxColumnResizingService,
            IgxForOfSyncService,
            IgxForOfScrollSyncService
        ], queries: [{ propertyName: "treeGroupArea", first: true, predicate: IgxTreeGridGroupByAreaComponent, descendants: true, read: IgxTreeGridGroupByAreaComponent }, { propertyName: "rowLoadingTemplate", first: true, predicate: IgxRowLoadingIndicatorTemplateDirective, descendants: true, read: IgxRowLoadingIndicatorTemplateDirective }], viewQueries: [{ propertyName: "recordTemplate", first: true, predicate: ["record_template"], descendants: true, read: TemplateRef, static: true }, { propertyName: "summaryTemplate", first: true, predicate: ["summary_template"], descendants: true, read: TemplateRef, static: true }], usesInheritance: true, ngImport: i0, template: "<ng-content select=\"igx-grid-toolbar,igc-grid-toolbar\"></ng-content>\n<ng-content select=\"igx-tree-grid-group-by-area,igc-tree-grid-group-by-area\"></ng-content>\n<igx-grid-header-row class=\"igx-grid-thead\" tabindex=\"0\"\n    [grid]=\"this\"\n    [hasMRL]=\"hasColumnLayouts\"\n    [activeDescendant]=\"activeDescendant\"\n    [width]=\"calcWidth\"\n    [pinnedColumnCollection]=\"pinnedColumns\"\n    [unpinnedColumnCollection]=\"unpinnedColumns\"\n    (keydown.meta.c)=\"copyHandler($event)\"\n    (keydown.control.c)=\"copyHandler($event)\"\n    (copy)=\"copyHandler($event)\"\n    (keydown)=\"navigation.headerNavigation($event)\"\n    (focus)=\"navigation.focusFirstCell()\"\n>\n</igx-grid-header-row>\n\n<div igxGridBody (keydown.control.c)=\"copyHandler($event)\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\" role=\"rowgroup\">\n    <div class=\"igx-grid__tbody-content\"  tabindex=\"0\" (focus)=\"navigation.focusTbody($event)\" (keydown)=\"navigation.handleNavigation($event)\"\n    (dragStop)=\"selectionService.dragMode = $event\" [attr.aria-activedescendant]=\"activeDescendant\" [attr.role]=\"dataView.length ? null : 'row'\"\n        (dragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\"\n        [style.height.px]='totalHeight' [style.width.px]='calcWidth' #tbody (scroll)='preventContainerScroll($event)'>\n        <span *ngIf=\"moving && columnInDrag && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"moving && columnInDrag && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template #pinnedRecordsTemplate>\n            <ng-container *ngIf=\"data\n            | treeGridTransaction:pipeTrigger\n            | visibleColumns:hasVisibleColumns\n            | treeGridNormalizeRecord:pipeTrigger\n            | treeGridAddRow:true:pipeTrigger\n            | gridRowPinning:id:true:pipeTrigger\n            | treeGridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:pipeTrigger:filteringPipeTrigger:true\n            | treeGridSorting:sortingExpressions:treeGroupArea?.expressions:sortStrategy:pipeTrigger:true as pinnedData\">\n                <div #pinContainer *ngIf=\"pinnedData.length > 0\"\n                    [ngClass]=\"{\n                        'igx-grid__tr--pinned-bottom':  !isRowPinningToTop,\n                        'igx-grid__tr--pinned-top': isRowPinningToTop\n                    }\"\n                    class=\"igx-grid__tr--pinned\" [style.width.px]=\"calcWidth\">\n                    <ng-container *ngFor=\"let rowData of pinnedData;let rowIndex = index;\">\n                        <ng-container *ngTemplateOutlet=\"pinned_record_template; context: getContext(rowData, rowIndex, true)\">\n                        </ng-container>\n                    </ng-container>\n                </div>\n            </ng-container>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && isRowPinningToTop ? pinnedRecordsTemplate : null\"></ng-container>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | treeGridTransaction:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | treeGridHierarchizing:primaryKey:foreignKey:childDataKey:pipeTrigger\n        | treeGridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:pipeTrigger:filteringPipeTrigger\n        | treeGridSorting:sortingExpressions:treeGroupArea?.expressions:sortStrategy:pipeTrigger\n        | treeGridFlattening:expansionDepth:expansionStates:pipeTrigger\n        | treeGridPaging:!!paginator:page:perPage:pipeTrigger\n        | treeGridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:showSummaryOnCollapse:pipeTrigger:summaryPipeTrigger\n        | treeGridAddRow:false:pipeTrigger\n        | gridRowPinning:id:false:pipeTrigger\"\n            let-rowIndex=\"index\" [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight' [igxForItemSize]=\"renderedRowHeight\" #verticalScrollContainer\n            (dataChanging)=\"dataRebinding($event)\" (dataChanged)=\"dataRebound($event)\">\n            <ng-template [igxTemplateOutlet]='isSummaryRow(rowData) ? summary_template : record_template'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex, false)'\n                (cachedViewLoaded)='cachedViewLoaded($event)'>\n            </ng-template>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && !isRowPinningToTop ? pinnedRecordsTemplate : null\"></ng-container>\n        <ng-template #record_template let-rowIndex=\"index\" let-disabledRow=\"disabled\" let-rowData>\n            <igx-tree-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [treeRow]=\"rowData\" [disabled]=\"disabledRow\"\n                [ngClass]=\"rowClasses | igxGridRowClasses:row:row.inEditMode:row.selected:row.dirty:row.deleted:row.dragging:rowIndex:hasColumnLayouts:row.treeRow.isFilteredOutParent:rowData:pipeTrigger\"\n                [ngStyle]=\"rowStyles | igxGridRowStyles:rowData:rowIndex:pipeTrigger\" #row>\n            </igx-tree-grid-row>\n        </ng-template>\n        <ng-template #pinned_record_template let-rowIndex=\"index\" let-rowData>\n            <igx-tree-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [treeRow]=\"rowData\"\n                [ngClass]=\"rowClasses | igxGridRowClasses:row:row.inEditMode:row.selected:row.dirty:row.deleted:row.dragging:rowIndex:hasColumnLayouts:row.treeRow.isFilteredOutParent:rowData:pipeTrigger\"\n                [ngStyle]=\"rowStyles | igxGridRowStyles:rowData:rowIndex:pipeTrigger\"#row #pinnedRow>\n            </igx-tree-grid-row>\n        </ng-template>\n        <ng-template #summary_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-summary-row [gridID]=\"id\" [summaries]=\"rowData.summaries\"\n                [firstCellIndentation]=\"rowData.cellIndentation\" [index]=\"rowIndex\"\n                class=\"igx-grid__summaries--body\" role=\"row\" #summaryRow>\n            </igx-grid-summary-row>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"template; context: { $implicit: this }\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n        <igc-trial-watermark></igc-trial-watermark>\n    </div>\n    <div igxToggle #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\" *ngIf='shouldOverlayLoading'>\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"moving && columnInDrag\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n        <div [hidden]='!hasVerticalScroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollSize\"  (pointerdown)=\"$event.preventDefault()\"\n            [style.height.px]='calcHeight'>\n        <div class=\"igx-grid__tbody-scrollbar-start\" [style.height.px]=' isRowPinningToTop ? pinnedRowHeight : 0'></div>\n        <div class=\"igx-grid__tbody-scrollbar-main\" [style.height.px]='calcHeight'>\n            <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n        </div>\n        <div class=\"igx-grid__tbody-scrollbar-end\" [style.height.px]='!isRowPinningToTop ? pinnedRowHeight : 0'></div>\n    </div>\n    <div class=\"igx-grid__addrow-snackbar\">\n        <igx-snackbar #addRowSnackbar [outlet]=\"igxBodyOverlayOutlet\" [actionText]=\"resourceStrings.igx_grid_snackbar_addrow_actiontext\" [displayTime]='snackbarDisplayTime'>{{resourceStrings.igx_grid_snackbar_addrow_label}}</igx-snackbar>\n    </div>\n\n    <div igxOverlayOutlet #igxBodyOverlayOutlet=\"overlay-outlet\"></div>\n</div>\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summaryRowHeight' #tfoot>\n    <div tabindex=\"0\" (focus)=\"navigation.focusFirstCell(false)\"\n    (keydown)=\"navigation.summaryNav($event)\" [attr.aria-activedescendant]=\"activeDescendant\">\n        <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summaryRowHeight'\n            *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\" role=\"row\"\n            [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"dataView.length\"\n            class=\"igx-grid__summaries\" #summaryRow>\n        </igx-grid-summary-row>\n        <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalScroll()' [style.height.px]='summaryRowHeight'\n            [style.width.px]=\"scrollSize\"></div>\n    </div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height.px]=\"scrollSize\" #scr [hidden]=\"isHorizontalScrollHidden\" (pointerdown)=\"$event.preventDefault()\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth' [style.min-width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth'></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n    <div class=\"igx-grid__scroll-end\" [style.width.px]='pinnedWidth' [style.min-width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0 || isPinningToStart\"></div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer,igc-grid-footer\"></ng-content>\n    <ng-content select=\"igx-paginator,igc-paginator\"></ng-content>\n</div>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\" role=\"cell\">\n        <span>{{emptyFilteredGridMessage}}</span>\n        <span *ngIf='showAddButton'>\n            <ng-container *ngTemplateOutlet='addRowEmptyTemplate || defaultAddRowEmptyTemplate'></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\" role=\"cell\">\n        <span>{{emptyGridMessage}}</span>\n        <span *ngIf='showAddButton'>\n            <ng-container *ngTemplateOutlet='addRowEmptyTemplate || defaultAddRowEmptyTemplate'></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultAddRowEmptyTemplate>\n    <button type=\"button\" igxButton=\"contained\" igxRipple (click)=\"this.crudService.enterAddRowMode(null, false, $event)\">\n        {{resourceStrings.igx_grid_add_row_label}}\n    </button>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle #rowEditingOverlay>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: this.crudService.endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditText>\n    {{ this.resourceStrings.igx_grid_row_edit_text | igxStringReplace:'{0}':rowChangesCount.toString() | igxStringReplace:'{1}':hiddenColumnsCount.toString() }}\n</ng-template>\n\n<ng-template #defaultRowEditActions>\n    <button type=\"button\" igxButton igxRowEditTabStop (click)=\"this.endRowEditTabStop(false, $event)\">{{ this.resourceStrings.igx_grid_row_edit_btn_cancel }}</button>\n    <button type=\"button\" igxButton igxRowEditTabStop (click)=\"this.endRowEditTabStop(true, $event)\">{{ this.resourceStrings.igx_grid_row_edit_btn_done }}</button>\n</ng-template>\n\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"this.crudService.row?.getClassName() === 'IgxAddRow' ? rowAddTextTemplate : rowEditTextTemplate ? rowEditTextTemplate : defaultRowEditText;\n                context: { $implicit: this.crudService.row?.getClassName() !== 'IgxAddRow' ? rowChangesCount : null }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActionsTemplate ? rowEditActionsTemplate : defaultRowEditActions; context: { $implicit: this.endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon family=\"default\" name=\"drag_indicator\"></igx-icon>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet></div>\n@if (platform.isElements) {\n    <div #sink style=\"display: none;\">\n        <ng-content select=\"igx-grid-state,igc-grid-state\"></ng-content>\n        <ng-content select=\"igx-column,igc-column,igx-column-group,igc-column-group,igx-action-strip,igc-action-strip\"></ng-content>\n    </div>\n}\n", dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: IgxGridHeaderRowComponent, selector: "igx-grid-header-row", inputs: ["grid", "pinnedColumnCollection", "unpinnedColumnCollection", "activeDescendant", "hasMRL", "width"] }, { kind: "directive", type: IgxGridBodyDirective, selector: "[igxGridBody]" }, { kind: "directive", type: IgxGridDragSelectDirective, selector: "[igxGridDragSelect]", inputs: ["igxGridDragSelect"], outputs: ["dragStop", "dragScroll"] }, { kind: "directive", type: IgxColumnMovingDropDirective, selector: "[igxColumnMovingDrop]", inputs: ["igxColumnMovingDrop"] }, { kind: "directive", type: IgxGridForOfDirective, selector: "[igxGridFor][igxGridForOf]", inputs: ["igxGridForOf", "igxGridForOfUniqueSizeCache", "igxGridForOfVariableSizes"], outputs: ["dataChanging"] }, { kind: "directive", type: IgxTemplateOutletDirective, selector: "[igxTemplateOutlet]", inputs: ["igxTemplateOutletContext", "igxTemplateOutlet"], outputs: ["viewCreated", "viewMoved", "cachedViewLoaded", "beforeViewDetach"] }, { kind: "component", type: IgxTreeGridRowComponent, selector: "igx-tree-grid-row", inputs: ["treeRow"] }, { kind: "component", type: IgxSummaryRowComponent, selector: "igx-grid-summary-row", inputs: ["summaries", "gridID", "index", "firstCellIndentation"] }, { kind: "directive", type: IgxOverlayOutletDirective, selector: "[igxOverlayOutlet]", exportAs: ["overlay-outlet"] }, { kind: "directive", type: IgxToggleDirective, selector: "[igxToggle]", inputs: ["id"], outputs: ["opened", "opening", "closed", "closing", "appended"], exportAs: ["toggle"] }, { kind: "component", type: IgxCircularProgressBarComponent, selector: "igx-circular-bar", inputs: ["id", "isIndeterminate", "textVisibility", "text"] }, { kind: "component", type: IgxSnackbarComponent, selector: "igx-snackbar", inputs: ["id", "actionText", "positionSettings"], outputs: ["clicked", "animationStarted", "animationDone"] }, { kind: "directive", type: IgxButtonDirective, selector: "[igxButton]", inputs: ["selected", "igxButton", "igxLabel"], outputs: ["buttonSelected"] }, { kind: "directive", type: IgxRippleDirective, selector: "[igxRipple]", inputs: ["igxRippleTarget", "igxRipple", "igxRippleDuration", "igxRippleCentered", "igxRippleDisabled"] }, { kind: "directive", type: IgxRowEditTabStopDirective, selector: "[igxRowEditTabStop]" }, { kind: "component", type: IgxIconComponent, selector: "igx-icon", inputs: ["family", "name", "active"] }, { kind: "component", type: IgxGridColumnResizerComponent, selector: "igx-grid-column-resizer", inputs: ["restrictResizerTop"] }, { kind: "pipe", type: IgxHasVisibleColumnsPipe, name: "visibleColumns" }, { kind: "pipe", type: IgxGridRowPinningPipe, name: "gridRowPinning" }, { kind: "pipe", type: IgxGridRowClassesPipe, name: "igxGridRowClasses" }, { kind: "pipe", type: IgxGridRowStylesPipe, name: "igxGridRowStyles" }, { kind: "pipe", type: IgxSummaryDataPipe, name: "igxGridSummaryDataPipe" }, { kind: "pipe", type: IgxTreeGridHierarchizingPipe, name: "treeGridHierarchizing" }, { kind: "pipe", type: IgxTreeGridFlatteningPipe, name: "treeGridFlattening" }, { kind: "pipe", type: IgxTreeGridSortingPipe, name: "treeGridSorting" }, { kind: "pipe", type: IgxTreeGridFilteringPipe, name: "treeGridFiltering" }, { kind: "pipe", type: IgxTreeGridPagingPipe, name: "treeGridPaging" }, { kind: "pipe", type: IgxTreeGridTransactionPipe, name: "treeGridTransaction" }, { kind: "pipe", type: IgxTreeGridSummaryPipe, name: "treeGridSummary" }, { kind: "pipe", type: IgxTreeGridNormalizeRecordsPipe, name: "treeGridNormalizeRecord" }, { kind: "pipe", type: IgxTreeGridAddRowPipe, name: "treeGridAddRow" }, { kind: "pipe", type: IgxStringReplacePipe, name: "igxStringReplace" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxTreeGridComponent, decorators: [{
            type: Component,
            args: [{ changeDetection: ChangeDetectionStrategy.OnPush, selector: 'igx-tree-grid', providers: [
                        IgxGridCRUDService,
                        IgxGridValidationService,
                        IgxGridSummaryService,
                        IgxGridNavigationService,
                        { provide: IgxGridSelectionService, useClass: IgxTreeGridSelectionService },
                        { provide: IGX_GRID_SERVICE_BASE, useClass: IgxTreeGridAPIService },
                        { provide: IGX_GRID_BASE, useExisting: IgxTreeGridComponent },
                        IgxFilteringService,
                        IgxColumnResizingService,
                        IgxForOfSyncService,
                        IgxForOfScrollSyncService
                    ], standalone: true, imports: [
                        NgIf,
                        NgFor,
                        NgClass,
                        NgStyle,
                        NgTemplateOutlet,
                        IgxGridHeaderRowComponent,
                        IgxGridBodyDirective,
                        IgxGridDragSelectDirective,
                        IgxColumnMovingDropDirective,
                        IgxGridForOfDirective,
                        IgxTemplateOutletDirective,
                        IgxTreeGridRowComponent,
                        IgxSummaryRowComponent,
                        IgxOverlayOutletDirective,
                        IgxToggleDirective,
                        IgxCircularProgressBarComponent,
                        IgxSnackbarComponent,
                        IgxButtonDirective,
                        IgxRippleDirective,
                        IgxRowEditTabStopDirective,
                        IgxIconComponent,
                        IgxGridColumnResizerComponent,
                        IgxHasVisibleColumnsPipe,
                        IgxGridRowPinningPipe,
                        IgxGridRowClassesPipe,
                        IgxGridRowStylesPipe,
                        IgxSummaryDataPipe,
                        IgxTreeGridHierarchizingPipe,
                        IgxTreeGridFlatteningPipe,
                        IgxTreeGridSortingPipe,
                        IgxTreeGridFilteringPipe,
                        IgxTreeGridPagingPipe,
                        IgxTreeGridTransactionPipe,
                        IgxTreeGridSummaryPipe,
                        IgxTreeGridNormalizeRecordsPipe,
                        IgxTreeGridAddRowPipe,
                        IgxStringReplacePipe
                    ], schemas: [CUSTOM_ELEMENTS_SCHEMA], template: "<ng-content select=\"igx-grid-toolbar,igc-grid-toolbar\"></ng-content>\n<ng-content select=\"igx-tree-grid-group-by-area,igc-tree-grid-group-by-area\"></ng-content>\n<igx-grid-header-row class=\"igx-grid-thead\" tabindex=\"0\"\n    [grid]=\"this\"\n    [hasMRL]=\"hasColumnLayouts\"\n    [activeDescendant]=\"activeDescendant\"\n    [width]=\"calcWidth\"\n    [pinnedColumnCollection]=\"pinnedColumns\"\n    [unpinnedColumnCollection]=\"unpinnedColumns\"\n    (keydown.meta.c)=\"copyHandler($event)\"\n    (keydown.control.c)=\"copyHandler($event)\"\n    (copy)=\"copyHandler($event)\"\n    (keydown)=\"navigation.headerNavigation($event)\"\n    (focus)=\"navigation.focusFirstCell()\"\n>\n</igx-grid-header-row>\n\n<div igxGridBody (keydown.control.c)=\"copyHandler($event)\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\" role=\"rowgroup\">\n    <div class=\"igx-grid__tbody-content\"  tabindex=\"0\" (focus)=\"navigation.focusTbody($event)\" (keydown)=\"navigation.handleNavigation($event)\"\n    (dragStop)=\"selectionService.dragMode = $event\" [attr.aria-activedescendant]=\"activeDescendant\" [attr.role]=\"dataView.length ? null : 'row'\"\n        (dragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\"\n        [style.height.px]='totalHeight' [style.width.px]='calcWidth' #tbody (scroll)='preventContainerScroll($event)'>\n        <span *ngIf=\"moving && columnInDrag && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"moving && columnInDrag && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template #pinnedRecordsTemplate>\n            <ng-container *ngIf=\"data\n            | treeGridTransaction:pipeTrigger\n            | visibleColumns:hasVisibleColumns\n            | treeGridNormalizeRecord:pipeTrigger\n            | treeGridAddRow:true:pipeTrigger\n            | gridRowPinning:id:true:pipeTrigger\n            | treeGridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:pipeTrigger:filteringPipeTrigger:true\n            | treeGridSorting:sortingExpressions:treeGroupArea?.expressions:sortStrategy:pipeTrigger:true as pinnedData\">\n                <div #pinContainer *ngIf=\"pinnedData.length > 0\"\n                    [ngClass]=\"{\n                        'igx-grid__tr--pinned-bottom':  !isRowPinningToTop,\n                        'igx-grid__tr--pinned-top': isRowPinningToTop\n                    }\"\n                    class=\"igx-grid__tr--pinned\" [style.width.px]=\"calcWidth\">\n                    <ng-container *ngFor=\"let rowData of pinnedData;let rowIndex = index;\">\n                        <ng-container *ngTemplateOutlet=\"pinned_record_template; context: getContext(rowData, rowIndex, true)\">\n                        </ng-container>\n                    </ng-container>\n                </div>\n            </ng-container>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && isRowPinningToTop ? pinnedRecordsTemplate : null\"></ng-container>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | treeGridTransaction:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | treeGridHierarchizing:primaryKey:foreignKey:childDataKey:pipeTrigger\n        | treeGridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:pipeTrigger:filteringPipeTrigger\n        | treeGridSorting:sortingExpressions:treeGroupArea?.expressions:sortStrategy:pipeTrigger\n        | treeGridFlattening:expansionDepth:expansionStates:pipeTrigger\n        | treeGridPaging:!!paginator:page:perPage:pipeTrigger\n        | treeGridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:showSummaryOnCollapse:pipeTrigger:summaryPipeTrigger\n        | treeGridAddRow:false:pipeTrigger\n        | gridRowPinning:id:false:pipeTrigger\"\n            let-rowIndex=\"index\" [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight' [igxForItemSize]=\"renderedRowHeight\" #verticalScrollContainer\n            (dataChanging)=\"dataRebinding($event)\" (dataChanged)=\"dataRebound($event)\">\n            <ng-template [igxTemplateOutlet]='isSummaryRow(rowData) ? summary_template : record_template'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex, false)'\n                (cachedViewLoaded)='cachedViewLoaded($event)'>\n            </ng-template>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && !isRowPinningToTop ? pinnedRecordsTemplate : null\"></ng-container>\n        <ng-template #record_template let-rowIndex=\"index\" let-disabledRow=\"disabled\" let-rowData>\n            <igx-tree-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [treeRow]=\"rowData\" [disabled]=\"disabledRow\"\n                [ngClass]=\"rowClasses | igxGridRowClasses:row:row.inEditMode:row.selected:row.dirty:row.deleted:row.dragging:rowIndex:hasColumnLayouts:row.treeRow.isFilteredOutParent:rowData:pipeTrigger\"\n                [ngStyle]=\"rowStyles | igxGridRowStyles:rowData:rowIndex:pipeTrigger\" #row>\n            </igx-tree-grid-row>\n        </ng-template>\n        <ng-template #pinned_record_template let-rowIndex=\"index\" let-rowData>\n            <igx-tree-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [treeRow]=\"rowData\"\n                [ngClass]=\"rowClasses | igxGridRowClasses:row:row.inEditMode:row.selected:row.dirty:row.deleted:row.dragging:rowIndex:hasColumnLayouts:row.treeRow.isFilteredOutParent:rowData:pipeTrigger\"\n                [ngStyle]=\"rowStyles | igxGridRowStyles:rowData:rowIndex:pipeTrigger\"#row #pinnedRow>\n            </igx-tree-grid-row>\n        </ng-template>\n        <ng-template #summary_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-summary-row [gridID]=\"id\" [summaries]=\"rowData.summaries\"\n                [firstCellIndentation]=\"rowData.cellIndentation\" [index]=\"rowIndex\"\n                class=\"igx-grid__summaries--body\" role=\"row\" #summaryRow>\n            </igx-grid-summary-row>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"template; context: { $implicit: this }\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n        <igc-trial-watermark></igc-trial-watermark>\n    </div>\n    <div igxToggle #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\" *ngIf='shouldOverlayLoading'>\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"moving && columnInDrag\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n        <div [hidden]='!hasVerticalScroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollSize\"  (pointerdown)=\"$event.preventDefault()\"\n            [style.height.px]='calcHeight'>\n        <div class=\"igx-grid__tbody-scrollbar-start\" [style.height.px]=' isRowPinningToTop ? pinnedRowHeight : 0'></div>\n        <div class=\"igx-grid__tbody-scrollbar-main\" [style.height.px]='calcHeight'>\n            <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n        </div>\n        <div class=\"igx-grid__tbody-scrollbar-end\" [style.height.px]='!isRowPinningToTop ? pinnedRowHeight : 0'></div>\n    </div>\n    <div class=\"igx-grid__addrow-snackbar\">\n        <igx-snackbar #addRowSnackbar [outlet]=\"igxBodyOverlayOutlet\" [actionText]=\"resourceStrings.igx_grid_snackbar_addrow_actiontext\" [displayTime]='snackbarDisplayTime'>{{resourceStrings.igx_grid_snackbar_addrow_label}}</igx-snackbar>\n    </div>\n\n    <div igxOverlayOutlet #igxBodyOverlayOutlet=\"overlay-outlet\"></div>\n</div>\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summaryRowHeight' #tfoot>\n    <div tabindex=\"0\" (focus)=\"navigation.focusFirstCell(false)\"\n    (keydown)=\"navigation.summaryNav($event)\" [attr.aria-activedescendant]=\"activeDescendant\">\n        <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summaryRowHeight'\n            *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\" role=\"row\"\n            [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"dataView.length\"\n            class=\"igx-grid__summaries\" #summaryRow>\n        </igx-grid-summary-row>\n        <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalScroll()' [style.height.px]='summaryRowHeight'\n            [style.width.px]=\"scrollSize\"></div>\n    </div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height.px]=\"scrollSize\" #scr [hidden]=\"isHorizontalScrollHidden\" (pointerdown)=\"$event.preventDefault()\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth' [style.min-width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth'></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n    <div class=\"igx-grid__scroll-end\" [style.width.px]='pinnedWidth' [style.min-width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0 || isPinningToStart\"></div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer,igc-grid-footer\"></ng-content>\n    <ng-content select=\"igx-paginator,igc-paginator\"></ng-content>\n</div>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\" role=\"cell\">\n        <span>{{emptyFilteredGridMessage}}</span>\n        <span *ngIf='showAddButton'>\n            <ng-container *ngTemplateOutlet='addRowEmptyTemplate || defaultAddRowEmptyTemplate'></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\" role=\"cell\">\n        <span>{{emptyGridMessage}}</span>\n        <span *ngIf='showAddButton'>\n            <ng-container *ngTemplateOutlet='addRowEmptyTemplate || defaultAddRowEmptyTemplate'></ng-container>\n        </span>\n    </span>\n</ng-template>\n\n<ng-template #defaultAddRowEmptyTemplate>\n    <button type=\"button\" igxButton=\"contained\" igxRipple (click)=\"this.crudService.enterAddRowMode(null, false, $event)\">\n        {{resourceStrings.igx_grid_add_row_label}}\n    </button>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle #rowEditingOverlay>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: this.crudService.endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditText>\n    {{ this.resourceStrings.igx_grid_row_edit_text | igxStringReplace:'{0}':rowChangesCount.toString() | igxStringReplace:'{1}':hiddenColumnsCount.toString() }}\n</ng-template>\n\n<ng-template #defaultRowEditActions>\n    <button type=\"button\" igxButton igxRowEditTabStop (click)=\"this.endRowEditTabStop(false, $event)\">{{ this.resourceStrings.igx_grid_row_edit_btn_cancel }}</button>\n    <button type=\"button\" igxButton igxRowEditTabStop (click)=\"this.endRowEditTabStop(true, $event)\">{{ this.resourceStrings.igx_grid_row_edit_btn_done }}</button>\n</ng-template>\n\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"this.crudService.row?.getClassName() === 'IgxAddRow' ? rowAddTextTemplate : rowEditTextTemplate ? rowEditTextTemplate : defaultRowEditText;\n                context: { $implicit: this.crudService.row?.getClassName() !== 'IgxAddRow' ? rowChangesCount : null }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActionsTemplate ? rowEditActionsTemplate : defaultRowEditActions; context: { $implicit: this.endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon family=\"default\" name=\"drag_indicator\"></igx-icon>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet></div>\n@if (platform.isElements) {\n    <div #sink style=\"display: none;\">\n        <ng-content select=\"igx-grid-state,igc-grid-state\"></ng-content>\n        <ng-content select=\"igx-column,igc-column,igx-column-group,igc-column-group,igx-action-strip,igc-action-strip\"></ng-content>\n    </div>\n}\n" }]
        }], ctorParameters: () => [{ type: i1.IgxGridValidationService }, { type: i2.IgxGridSelectionService }, { type: i3.IgxColumnResizingService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_SERVICE_BASE]
                }] }, { type: i4.IgxHierarchicalTransactionFactory }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i0.ChangeDetectorRef }, { type: i0.IterableDiffers }, { type: i0.ViewContainerRef }, { type: i0.Injector }, { type: i0.EnvironmentInjector }, { type: i5.IgxGridNavigationService }, { type: i6.IgxFilteringService }, { type: i7.IgxTextHighlightService }, { type: i10.IgxOverlayService, decorators: [{
                    type: Inject,
                    args: [IgxOverlayService]
                }] }, { type: i8.IgxGridSummaryService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }, { type: i9.PlatformUtil }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [IgxGridTransaction]
                }] }], propDecorators: { childDataKey: [{
                type: Input
            }], foreignKey: [{
                type: Input
            }], hasChildrenKey: [{
                type: Input
            }], cascadeOnDelete: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], loadChildrenOnDemand: [{
                type: Input
            }], role: [{
                type: HostBinding,
                args: ['attr.role']
            }], id: [{
                type: HostBinding,
                args: ['attr.id']
            }, {
                type: Input
            }], treeGroupArea: [{
                type: ContentChild,
                args: [IgxTreeGridGroupByAreaComponent, { read: IgxTreeGridGroupByAreaComponent }]
            }], recordTemplate: [{
                type: ViewChild,
                args: ['record_template', { read: TemplateRef, static: true }]
            }], summaryTemplate: [{
                type: ViewChild,
                args: ['summary_template', { read: TemplateRef, static: true }]
            }], rowLoadingTemplate: [{
                type: ContentChild,
                args: [IgxRowLoadingIndicatorTemplateDirective, { read: IgxRowLoadingIndicatorTemplateDirective }]
            }], data: [{
                type: Input
            }], expansionDepth: [{
                type: Input
            }], rowLoadingIndicatorTemplate: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1ncmlkLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy90cmVlLWdyaWQvdHJlZS1ncmlkLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy90cmVlLWdyaWQvdHJlZS1ncmlkLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDSCx1QkFBdUIsRUFDdkIsU0FBUyxFQUNULFdBQVcsRUFDWCxLQUFLLEVBRUwsV0FBVyxFQUNYLFlBQVksRUFFWixTQUFTLEVBS1QsTUFBTSxFQUlOLFFBQVEsRUFDUixTQUFTLEVBR1Qsc0JBQXNCLEVBQ3RCLGdCQUFnQixFQUNuQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLGdCQUFnQixFQUFFLE9BQU8sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRTVGLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBRzlELE9BQU8sRUFHSCxlQUFlLEVBQ2Ysc0JBQXNCLEVBRXpCLE1BQU0sd0NBQXdDLENBQUM7QUFDaEQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFDMUUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFDMUUsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFDekUsT0FBTyxFQUFFLFlBQVksRUFBZ0IsTUFBTSxrQkFBa0IsQ0FBQztBQUM5RCxPQUFPLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxN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O2dCQVFDLGFBQWE7c0JBRG5CLFlBQVk7dUJBQUMsK0JBQStCLEVBQUUsRUFBRSxJQUFJLEVBQUUsK0JBQStCLEVBQUU7Z0JBTzlFLGNBQWM7c0JBRHZCLFNBQVM7dUJBQUMsaUJBQWlCLEVBQUUsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7Z0JBT3ZELGVBQWU7c0JBRHhCLFNBQVM7dUJBQUMsa0JBQWtCLEVBQUUsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7Z0JBT3hELGtCQUFrQjtzQkFEM0IsWUFBWTt1QkFBQyx1Q0FBdUMsRUFBRSxFQUFFLElBQUksRUFBRSx1Q0FBdUMsRUFBRTtnQkFnRjdGLElBQUk7c0JBRGQsS0FBSztnQkE4Q0ssY0FBYztzQkFEeEIsS0FBSztnQkEwQkssMkJBQTJCO3NCQURyQyxLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICBDb21wb25lbnQsXG4gICAgSG9zdEJpbmRpbmcsXG4gICAgSW5wdXQsXG4gICAgT25Jbml0LFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIFZpZXdDaGlsZCxcbiAgICBEb0NoZWNrLFxuICAgIEFmdGVyVmlld0luaXQsXG4gICAgRWxlbWVudFJlZixcbiAgICBOZ1pvbmUsXG4gICAgSW5qZWN0LFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIEl0ZXJhYmxlRGlmZmVycyxcbiAgICBWaWV3Q29udGFpbmVyUmVmLFxuICAgIE9wdGlvbmFsLFxuICAgIExPQ0FMRV9JRCxcbiAgICBJbmplY3RvcixcbiAgICBFbnZpcm9ubWVudEluamVjdG9yLFxuICAgIENVU1RPTV9FTEVNRU5UU19TQ0hFTUEsXG4gICAgYm9vbGVhbkF0dHJpYnV0ZVxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERPQ1VNRU5ULCBOZ0lmLCBOZ0NsYXNzLCBOZ0ZvciwgTmdUZW1wbGF0ZU91dGxldCwgTmdTdHlsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbmltcG9ydCB7IElneFRyZWVHcmlkQVBJU2VydmljZSB9IGZyb20gJy4vdHJlZS1ncmlkLWFwaS5zZXJ2aWNlJztcbmltcG9ydCB7IElneEdyaWRCYXNlRGlyZWN0aXZlIH0gZnJvbSAnLi4vZ3JpZC1iYXNlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJVHJlZUdyaWRSZWNvcmQgfSBmcm9tICcuL3RyZWUtZ3JpZC5pbnRlcmZhY2VzJztcbmltcG9ydCB7IElSb3dEYXRhQ2FuY2VsYWJsZUV2ZW50QXJncywgSVJvd0RhdGFFdmVudEFyZ3MsIElSb3dUb2dnbGVFdmVudEFyZ3MgfSBmcm9tICcuLi9jb21tb24vZXZlbnRzJztcbmltcG9ydCB7XG4gICAgSGllcmFyY2hpY2FsVHJhbnNhY3Rpb24sXG4gICAgSGllcmFyY2hpY2FsU3RhdGUsXG4gICAgVHJhbnNhY3Rpb25UeXBlLFxuICAgIFRyYW5zYWN0aW9uRXZlbnRPcmlnaW4sXG4gICAgU3RhdGVVcGRhdGVFdmVudFxufSBmcm9tICcuLi8uLi9zZXJ2aWNlcy90cmFuc2FjdGlvbi90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBJZ3hGaWx0ZXJpbmdTZXJ2aWNlIH0gZnJvbSAnLi4vZmlsdGVyaW5nL2dyaWQtZmlsdGVyaW5nLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4R3JpZFN1bW1hcnlTZXJ2aWNlIH0gZnJvbSAnLi4vc3VtbWFyaWVzL2dyaWQtc3VtbWFyeS5zZXJ2aWNlJztcbmltcG9ydCB7IElneEdyaWRTZWxlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi4vc2VsZWN0aW9uL3NlbGVjdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IG1lcmdlT2JqZWN0cywgUGxhdGZvcm1VdGlsIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBmaXJzdCwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgSWd4Um93TG9hZGluZ0luZGljYXRvclRlbXBsYXRlRGlyZWN0aXZlIH0gZnJvbSAnLi90cmVlLWdyaWQuZGlyZWN0aXZlcyc7XG5pbXBvcnQgeyBJZ3hGb3JPZlN5bmNTZXJ2aWNlLCBJZ3hGb3JPZlNjcm9sbFN5bmNTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9mb3Itb2YvZm9yX29mLnN5bmMuc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hHcmlkTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuLi9ncmlkLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBDZWxsVHlwZSwgR3JpZFNlcnZpY2VUeXBlLCBHcmlkVHlwZSwgSUdYX0dSSURfQkFTRSwgSUdYX0dSSURfU0VSVklDRV9CQVNFLCBSb3dUeXBlIH0gZnJvbSAnLi4vY29tbW9uL2dyaWQuaW50ZXJmYWNlJztcbmltcG9ydCB7IElneENvbHVtbkNvbXBvbmVudCB9IGZyb20gJy4uL2NvbHVtbnMvY29sdW1uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hUcmVlR3JpZFNlbGVjdGlvblNlcnZpY2UgfSBmcm9tICcuL3RyZWUtZ3JpZC1zZWxlY3Rpb24uc2VydmljZSc7XG5pbXBvcnQgeyBHcmlkU2VsZWN0aW9uTW9kZSB9IGZyb20gJy4uL2NvbW1vbi9lbnVtcyc7XG5pbXBvcnQgeyBJZ3hTdW1tYXJ5Um93LCBJZ3hUcmVlR3JpZFJvdyB9IGZyb20gJy4uL2dyaWQtcHVibGljLXJvdyc7XG5pbXBvcnQgeyBJZ3hHcmlkQ1JVRFNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vY3J1ZC5zZXJ2aWNlJztcbmltcG9ydCB7IElneFRyZWVHcmlkR3JvdXBCeUFyZWFDb21wb25lbnQgfSBmcm9tICcuLi9ncm91cGluZy90cmVlLWdyaWQtZ3JvdXAtYnktYXJlYS5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4R3JpZENlbGwgfSBmcm9tICcuLi9ncmlkLXB1YmxpYy1jZWxsJztcbmltcG9ydCB7IElneEhpZXJhcmNoaWNhbFRyYW5zYWN0aW9uRmFjdG9yeSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL3RyYW5zYWN0aW9uL3RyYW5zYWN0aW9uLWZhY3Rvcnkuc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hDb2x1bW5SZXNpemluZ1NlcnZpY2UgfSBmcm9tICcuLi9yZXNpemluZy9yZXNpemluZy5zZXJ2aWNlJztcbmltcG9ydCB7IEhpZXJhcmNoaWNhbFRyYW5zYWN0aW9uU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL3RyYW5zYWN0aW9uL2hpZXJhcmNoaWNhbC10cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBJZ3hPdmVybGF5U2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL292ZXJsYXkvb3ZlcmxheSc7XG5pbXBvcnQgeyBJZ3hHcmlkVHJhbnNhY3Rpb24gfSBmcm9tICcuLi9jb21tb24vdHlwZXMnO1xuaW1wb3J0IHsgVHJlZUdyaWRGaWx0ZXJpbmdTdHJhdGVneSB9IGZyb20gJy4vdHJlZS1ncmlkLmZpbHRlcmluZy5zdHJhdGVneSc7XG5pbXBvcnQgeyBJZ3hHcmlkVmFsaWRhdGlvblNlcnZpY2UgfSBmcm9tICcuLi9ncmlkL2dyaWQtdmFsaWRhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IElneFRyZWVHcmlkU3VtbWFyeVBpcGUgfSBmcm9tICcuL3RyZWUtZ3JpZC5zdW1tYXJ5LnBpcGUnO1xuaW1wb3J0IHsgSWd4VHJlZUdyaWRGaWx0ZXJpbmdQaXBlIH0gZnJvbSAnLi90cmVlLWdyaWQuZmlsdGVyaW5nLnBpcGUnO1xuaW1wb3J0IHsgSWd4VHJlZUdyaWRIaWVyYXJjaGl6aW5nUGlwZSwgSWd4VHJlZUdyaWRGbGF0dGVuaW5nUGlwZSwgSWd4VHJlZUdyaWRTb3J0aW5nUGlwZSwgSWd4VHJlZUdyaWRQYWdpbmdQaXBlLCBJZ3hUcmVlR3JpZFRyYW5zYWN0aW9uUGlwZSwgSWd4VHJlZUdyaWROb3JtYWxpemVSZWNvcmRzUGlwZSwgSWd4VHJlZUdyaWRBZGRSb3dQaXBlIH0gZnJvbSAnLi90cmVlLWdyaWQucGlwZXMnO1xuaW1wb3J0IHsgSWd4U3VtbWFyeURhdGFQaXBlIH0gZnJvbSAnLi4vc3VtbWFyaWVzL2dyaWQtcm9vdC1zdW1tYXJ5LnBpcGUnO1xuaW1wb3J0IHsgSWd4SGFzVmlzaWJsZUNvbHVtbnNQaXBlLCBJZ3hHcmlkUm93UGlubmluZ1BpcGUsIElneEdyaWRSb3dDbGFzc2VzUGlwZSwgSWd4R3JpZFJvd1N0eWxlc1BpcGUsIElneFN0cmluZ1JlcGxhY2VQaXBlIH0gZnJvbSAnLi4vY29tbW9uL3BpcGVzJztcbmltcG9ydCB7IElneEdyaWRDb2x1bW5SZXNpemVyQ29tcG9uZW50IH0gZnJvbSAnLi4vcmVzaXppbmcvcmVzaXplci5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4SWNvbkNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4Um93RWRpdFRhYlN0b3BEaXJlY3RpdmUgfSBmcm9tICcuLi9ncmlkLnJvd0VkaXQuZGlyZWN0aXZlJztcbmltcG9ydCB7IElneFJpcHBsZURpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvcmlwcGxlL3JpcHBsZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSWd4QnV0dG9uRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9idXR0b24vYnV0dG9uLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJZ3hTbmFja2JhckNvbXBvbmVudCB9IGZyb20gJy4uLy4uL3NuYWNrYmFyL3NuYWNrYmFyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3NiYXIuY29tcG9uZW50JztcbmltcG9ydCB7IElneE92ZXJsYXlPdXRsZXREaXJlY3RpdmUsIElneFRvZ2dsZURpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvdG9nZ2xlL3RvZ2dsZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSWd4U3VtbWFyeVJvd0NvbXBvbmVudCB9IGZyb20gJy4uL3N1bW1hcmllcy9zdW1tYXJ5LXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4VHJlZUdyaWRSb3dDb21wb25lbnQgfSBmcm9tICcuL3RyZWUtZ3JpZC1yb3cuY29tcG9uZW50JztcbmltcG9ydCB7IElneFRlbXBsYXRlT3V0bGV0RGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy90ZW1wbGF0ZS1vdXRsZXQvdGVtcGxhdGVfb3V0bGV0LmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJZ3hHcmlkRm9yT2ZEaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2Zvci1vZi9mb3Jfb2YuZGlyZWN0aXZlJztcbmltcG9ydCB7IElneENvbHVtbk1vdmluZ0Ryb3BEaXJlY3RpdmUgfSBmcm9tICcuLi9tb3ZpbmcvbW92aW5nLmRyb3AuZGlyZWN0aXZlJztcbmltcG9ydCB7IElneEdyaWREcmFnU2VsZWN0RGlyZWN0aXZlIH0gZnJvbSAnLi4vc2VsZWN0aW9uL2RyYWctc2VsZWN0LmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJZ3hHcmlkQm9keURpcmVjdGl2ZSB9IGZyb20gJy4uL2dyaWQuY29tbW9uJztcbmltcG9ydCB7IElneEdyaWRIZWFkZXJSb3dDb21wb25lbnQgfSBmcm9tICcuLi9oZWFkZXJzL2dyaWQtaGVhZGVyLXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4VGV4dEhpZ2hsaWdodFNlcnZpY2UgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL3RleHQtaGlnaGxpZ2h0L3RleHQtaGlnaGxpZ2h0LnNlcnZpY2UnO1xuXG5sZXQgTkVYVF9JRCA9IDA7XG5cbi8qIGJsYXpvckFkZGl0aW9uYWxEZXBlbmRlbmN5OiBDb2x1bW4gKi9cbi8qIGJsYXpvckFkZGl0aW9uYWxEZXBlbmRlbmN5OiBDb2x1bW5Hcm91cCAqL1xuLyogYmxhem9yQWRkaXRpb25hbERlcGVuZGVuY3k6IENvbHVtbkxheW91dCAqL1xuLyogYmxhem9yQWRkaXRpb25hbERlcGVuZGVuY3k6IEdyaWRUb29sYmFyICovXG4vKiBibGF6b3JBZGRpdGlvbmFsRGVwZW5kZW5jeTogR3JpZFRvb2xiYXJBY3Rpb25zICovXG4vKiBibGF6b3JBZGRpdGlvbmFsRGVwZW5kZW5jeTogR3JpZFRvb2xiYXJUaXRsZSAqL1xuLyogYmxhem9yQWRkaXRpb25hbERlcGVuZGVuY3k6IEdyaWRUb29sYmFyQWR2YW5jZWRGaWx0ZXJpbmcgKi9cbi8qIGJsYXpvckFkZGl0aW9uYWxEZXBlbmRlbmN5OiBHcmlkVG9vbGJhckV4cG9ydGVyICovXG4vKiBibGF6b3JBZGRpdGlvbmFsRGVwZW5kZW5jeTogR3JpZFRvb2xiYXJIaWRpbmcgKi9cbi8qIGJsYXpvckFkZGl0aW9uYWxEZXBlbmRlbmN5OiBHcmlkVG9vbGJhclBpbm5pbmcgKi9cbi8qIGJsYXpvckFkZGl0aW9uYWxEZXBlbmRlbmN5OiBBY3Rpb25TdHJpcCAqL1xuLyogYmxhem9yQWRkaXRpb25hbERlcGVuZGVuY3k6IEdyaWRBY3Rpb25zQmFzZURpcmVjdGl2ZSAqL1xuLyogYmxhem9yQWRkaXRpb25hbERlcGVuZGVuY3k6IEdyaWRFZGl0aW5nQWN0aW9ucyAqL1xuLyogYmxhem9yQWRkaXRpb25hbERlcGVuZGVuY3k6IEdyaWRQaW5uaW5nQWN0aW9ucyAqL1xuLyogYmxhem9ySW5kaXJlY3RSZW5kZXIgKi9cbi8qKlxuICogKipJZ25pdGUgVUkgZm9yIEFuZ3VsYXIgVHJlZSBHcmlkKiogLVxuICogW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vd3d3LmluZnJhZ2lzdGljcy5jb20vcHJvZHVjdHMvaWduaXRlLXVpLWFuZ3VsYXIvYW5ndWxhci9jb21wb25lbnRzL2dyaWQvZ3JpZClcbiAqXG4gKiBUaGUgSWduaXRlIFVJIFRyZWUgR3JpZCBkaXNwbGF5cyBhbmQgbWFuaXB1bGF0ZXMgaGllcmFyY2hpY2FsIGRhdGEgd2l0aCBjb25zaXN0ZW50IHNjaGVtYSBmb3JtYXR0ZWQgYXMgYSB0YWJsZSBhbmRcbiAqIHByb3ZpZGVzIGZlYXR1cmVzIHN1Y2ggYXMgc29ydGluZywgZmlsdGVyaW5nLCBlZGl0aW5nLCBjb2x1bW4gcGlubmluZywgcGFnaW5nLCBjb2x1bW4gbW92aW5nIGFuZCBoaWRpbmcuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYGh0bWxcbiAqIDxpZ3gtdHJlZS1ncmlkIFtkYXRhXT1cImVtcGxveWVlRGF0YVwiIHByaW1hcnlLZXk9XCJlbXBsb3llZUlEXCIgZm9yZWlnbktleT1cIlBJRFwiIFthdXRvR2VuZXJhdGVdPVwiZmFsc2VcIj5cbiAqICAgPGlneC1jb2x1bW4gZmllbGQ9XCJmaXJzdFwiIGhlYWRlcj1cIkZpcnN0IE5hbWVcIj48L2lneC1jb2x1bW4+XG4gKiAgIDxpZ3gtY29sdW1uIGZpZWxkPVwibGFzdFwiIGhlYWRlcj1cIkxhc3QgTmFtZVwiPjwvaWd4LWNvbHVtbj5cbiAqICAgPGlneC1jb2x1bW4gZmllbGQ9XCJyb2xlXCIgaGVhZGVyPVwiUm9sZVwiPjwvaWd4LWNvbHVtbj5cbiAqIDwvaWd4LXRyZWUtZ3JpZD5cbiAqIGBgYFxuICovXG5AQ29tcG9uZW50KHtcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBzZWxlY3RvcjogJ2lneC10cmVlLWdyaWQnLFxuICAgIHRlbXBsYXRlVXJsOiAndHJlZS1ncmlkLmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgSWd4R3JpZENSVURTZXJ2aWNlLFxuICAgICAgICBJZ3hHcmlkVmFsaWRhdGlvblNlcnZpY2UsXG4gICAgICAgIElneEdyaWRTdW1tYXJ5U2VydmljZSxcbiAgICAgICAgSWd4R3JpZE5hdmlnYXRpb25TZXJ2aWNlLFxuICAgICAgICB7IHByb3ZpZGU6IElneEdyaWRTZWxlY3Rpb25TZXJ2aWNlLCB1c2VDbGFzczogSWd4VHJlZUdyaWRTZWxlY3Rpb25TZXJ2aWNlIH0sXG4gICAgICAgIHsgcHJvdmlkZTogSUdYX0dSSURfU0VSVklDRV9CQVNFLCB1c2VDbGFzczogSWd4VHJlZUdyaWRBUElTZXJ2aWNlIH0sXG4gICAgICAgIHsgcHJvdmlkZTogSUdYX0dSSURfQkFTRSwgdXNlRXhpc3Rpbmc6IElneFRyZWVHcmlkQ29tcG9uZW50IH0sXG4gICAgICAgIElneEZpbHRlcmluZ1NlcnZpY2UsXG4gICAgICAgIElneENvbHVtblJlc2l6aW5nU2VydmljZSxcbiAgICAgICAgSWd4Rm9yT2ZTeW5jU2VydmljZSxcbiAgICAgICAgSWd4Rm9yT2ZTY3JvbGxTeW5jU2VydmljZVxuICAgIF0sXG4gICAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIE5nSWYsXG4gICAgICAgIE5nRm9yLFxuICAgICAgICBOZ0NsYXNzLFxuICAgICAgICBOZ1N0eWxlLFxuICAgICAgICBOZ1RlbXBsYXRlT3V0bGV0LFxuICAgICAgICBJZ3hHcmlkSGVhZGVyUm93Q29tcG9uZW50LFxuICAgICAgICBJZ3hHcmlkQm9keURpcmVjdGl2ZSxcbiAgICAgICAgSWd4R3JpZERyYWdTZWxlY3REaXJlY3RpdmUsXG4gICAgICAgIElneENvbHVtbk1vdmluZ0Ryb3BEaXJlY3RpdmUsXG4gICAgICAgIElneEdyaWRGb3JPZkRpcmVjdGl2ZSxcbiAgICAgICAgSWd4VGVtcGxhdGVPdXRsZXREaXJlY3RpdmUsXG4gICAgICAgIElneFRyZWVHcmlkUm93Q29tcG9uZW50LFxuICAgICAgICBJZ3hTdW1tYXJ5Um93Q29tcG9uZW50LFxuICAgICAgICBJZ3hPdmVybGF5T3V0bGV0RGlyZWN0aXZlLFxuICAgICAgICBJZ3hUb2dnbGVEaXJlY3RpdmUsXG4gICAgICAgIElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnQsXG4gICAgICAgIElneFNuYWNrYmFyQ29tcG9uZW50LFxuICAgICAgICBJZ3hCdXR0b25EaXJlY3RpdmUsXG4gICAgICAgIElneFJpcHBsZURpcmVjdGl2ZSxcbiAgICAgICAgSWd4Um93RWRpdFRhYlN0b3BEaXJlY3RpdmUsXG4gICAgICAgIElneEljb25Db21wb25lbnQsXG4gICAgICAgIElneEdyaWRDb2x1bW5SZXNpemVyQ29tcG9uZW50LFxuICAgICAgICBJZ3hIYXNWaXNpYmxlQ29sdW1uc1BpcGUsXG4gICAgICAgIElneEdyaWRSb3dQaW5uaW5nUGlwZSxcbiAgICAgICAgSWd4R3JpZFJvd0NsYXNzZXNQaXBlLFxuICAgICAgICBJZ3hHcmlkUm93U3R5bGVzUGlwZSxcbiAgICAgICAgSWd4U3VtbWFyeURhdGFQaXBlLFxuICAgICAgICBJZ3hUcmVlR3JpZEhpZXJhcmNoaXppbmdQaXBlLFxuICAgICAgICBJZ3hUcmVlR3JpZEZsYXR0ZW5pbmdQaXBlLFxuICAgICAgICBJZ3hUcmVlR3JpZFNvcnRpbmdQaXBlLFxuICAgICAgICBJZ3hUcmVlR3JpZEZpbHRlcmluZ1BpcGUsXG4gICAgICAgIElneFRyZWVHcmlkUGFnaW5nUGlwZSxcbiAgICAgICAgSWd4VHJlZUdyaWRUcmFuc2FjdGlvblBpcGUsXG4gICAgICAgIElneFRyZWVHcmlkU3VtbWFyeVBpcGUsXG4gICAgICAgIElneFRyZWVHcmlkTm9ybWFsaXplUmVjb3Jkc1BpcGUsXG4gICAgICAgIElneFRyZWVHcmlkQWRkUm93UGlwZSxcbiAgICAgICAgSWd4U3RyaW5nUmVwbGFjZVBpcGVcbl0sXG4gICAgc2NoZW1hczogW0NVU1RPTV9FTEVNRU5UU19TQ0hFTUFdXG59KVxuZXhwb3J0IGNsYXNzIElneFRyZWVHcmlkQ29tcG9uZW50IGV4dGVuZHMgSWd4R3JpZEJhc2VEaXJlY3RpdmUgaW1wbGVtZW50cyBHcmlkVHlwZSwgT25Jbml0LCBBZnRlclZpZXdJbml0LCBEb0NoZWNrLCBBZnRlckNvbnRlbnRJbml0IHtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjaGlsZCBkYXRhIGtleSBvZiB0aGUgYElneFRyZWVHcmlkQ29tcG9uZW50YC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlLWdyaWQgI2dyaWQgW2RhdGFdPVwiZW1wbG95ZWVEYXRhXCIgW2NoaWxkRGF0YUtleV09XCInZW1wbG95ZWVzJ1wiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPjwvaWd4LXRyZWUtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGNoaWxkRGF0YUtleTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZm9yZWlnbiBrZXkgb2YgdGhlIGBJZ3hUcmVlR3JpZENvbXBvbmVudGAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZS1ncmlkICNncmlkIFtkYXRhXT1cImVtcGxveWVlRGF0YVwiIFtwcmltYXJ5S2V5XT1cIidlbXBsb3llZUlEJ1wiIFtmb3JlaWduS2V5XT1cIidwYXJlbnRJRCdcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj5cbiAgICAgKiA8L2lneC10cmVlLWdyaWQ+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBmb3JlaWduS2V5OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBrZXkgaW5kaWNhdGluZyB3aGV0aGVyIGEgcm93IGhhcyBjaGlsZHJlbi5cbiAgICAgKiBUaGlzIHByb3BlcnR5IGlzIG9ubHkgdXNlZCBmb3IgbG9hZCBvbiBkZW1hbmQgc2NlbmFyaW9zLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUtZ3JpZCAjZ3JpZCBbZGF0YV09XCJlbXBsb3llZURhdGFcIiBbcHJpbWFyeUtleV09XCInZW1wbG95ZWVJRCdcIiBbZm9yZWlnbktleV09XCIncGFyZW50SUQnXCJcbiAgICAgKiAgICAgICAgICAgICAgICBbbG9hZENoaWxkcmVuT25EZW1hbmRdPVwibG9hZENoaWxkcmVuXCJcbiAgICAgKiAgICAgICAgICAgICAgICBbaGFzQ2hpbGRyZW5LZXldPVwiJ2hhc0VtcGxveWVlcydcIj5cbiAgICAgKiA8L2lneC10cmVlLWdyaWQ+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBoYXNDaGlsZHJlbktleTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIGNoaWxkIHJlY29yZHMgc2hvdWxkIGJlIGRlbGV0ZWQgd2hlbiB0aGVpciBwYXJlbnQgZ2V0cyBkZWxldGVkLlxuICAgICAqIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIHRydWUgYW5kIGRlbGV0ZXMgYWxsIGNoaWxkcmVuIGFsb25nIHdpdGggdGhlIHBhcmVudC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlLWdyaWQgW2RhdGFdPVwiZW1wbG95ZWVEYXRhXCIgW3ByaW1hcnlLZXldPVwiJ2VtcGxveWVlSUQnXCIgW2ZvcmVpZ25LZXldPVwiJ3BhcmVudElEJ1wiIGNhc2NhZGVPbkRlbGV0ZT1cImZhbHNlXCI+XG4gICAgICogPC9pZ3gtdHJlZS1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KHsgdHJhbnNmb3JtOiBib29sZWFuQXR0cmlidXRlIH0pXG4gICAgcHVibGljIGNhc2NhZGVPbkRlbGV0ZSA9IHRydWU7XG5cbiAgICAvKiBjc1N1cHByZXNzICovXG4gICAgLyoqXG4gICAgICogU2V0cyBhIGNhbGxiYWNrIGZvciBsb2FkaW5nIGNoaWxkIHJvd3Mgb24gZGVtYW5kLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUtZ3JpZCBbZGF0YV09XCJlbXBsb3llZURhdGFcIiBbcHJpbWFyeUtleV09XCInZW1wbG95ZWVJRCdcIiBbZm9yZWlnbktleV09XCIncGFyZW50SUQnXCIgW2xvYWRDaGlsZHJlbk9uRGVtYW5kXT1cImxvYWRDaGlsZHJlblwiPlxuICAgICAqIDwvaWd4LXRyZWUtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGxvYWRDaGlsZHJlbiA9IChwYXJlbnRJRDogYW55LCBkb25lOiAoY2hpbGRyZW46IGFueVtdKSA9PiB2b2lkKSA9PiB7XG4gICAgICogICAgIHRoaXMuZGF0YVNlcnZpY2UuZ2V0RGF0YShwYXJlbnRJRCwgY2hpbGRyZW4gPT4gZG9uZShjaGlsZHJlbikpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGxvYWRDaGlsZHJlbk9uRGVtYW5kOiAocGFyZW50SUQ6IGFueSwgZG9uZTogKGNoaWxkcmVuOiBhbnlbXSkgPT4gdm9pZCkgPT4gdm9pZDtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLnJvbGUnKVxuICAgIHB1YmxpYyByb2xlID0gJ3RyZWVncmlkJztcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBgaWRgIGF0dHJpYnV0ZS4gSWYgbm90IHByb3ZpZGVkIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZS1ncmlkIFtpZF09XCInaWd4LXRyZWUtZ3JpZC0xJ1wiPjwvaWd4LXRyZWUtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5pZCcpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaWQgPSBgaWd4LXRyZWUtZ3JpZC0ke05FWFRfSUQrK31gO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoSWd4VHJlZUdyaWRHcm91cEJ5QXJlYUNvbXBvbmVudCwgeyByZWFkOiBJZ3hUcmVlR3JpZEdyb3VwQnlBcmVhQ29tcG9uZW50IH0pXG4gICAgcHVibGljIHRyZWVHcm91cEFyZWE6IElneFRyZWVHcmlkR3JvdXBCeUFyZWFDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ3JlY29yZF90ZW1wbGF0ZScsIHsgcmVhZDogVGVtcGxhdGVSZWYsIHN0YXRpYzogdHJ1ZSB9KVxuICAgIHByb3RlY3RlZCByZWNvcmRUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnc3VtbWFyeV90ZW1wbGF0ZScsIHsgcmVhZDogVGVtcGxhdGVSZWYsIHN0YXRpYzogdHJ1ZSB9KVxuICAgIHByb3RlY3RlZCBzdW1tYXJ5VGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hSb3dMb2FkaW5nSW5kaWNhdG9yVGVtcGxhdGVEaXJlY3RpdmUsIHsgcmVhZDogSWd4Um93TG9hZGluZ0luZGljYXRvclRlbXBsYXRlRGlyZWN0aXZlIH0pXG4gICAgcHJvdGVjdGVkIHJvd0xvYWRpbmdUZW1wbGF0ZTogSWd4Um93TG9hZGluZ0luZGljYXRvclRlbXBsYXRlRGlyZWN0aXZlO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBmbGF0RGF0YTogYW55W10gfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBwcm9jZXNzZWRFeHBhbmRlZEZsYXREYXRhOiBhbnlbXSB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSByb290IGxldmVsIGBJVHJlZUdyaWRSZWNvcmRgcy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0cyB0aGUgcm9vdCByZWNvcmQgd2l0aCBpbmRleD0yXG4gICAgICogY29uc3Qgc3RhdGVzID0gdGhpcy5ncmlkLnJvb3RSZWNvcmRzWzJdO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHJvb3RSZWNvcmRzOiBJVHJlZUdyaWRSZWNvcmRbXTtcblxuICAgIC8qIGJsYXpvclN1cHByZXNzICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG1hcCBvZiBhbGwgYElUcmVlR3JpZFJlY29yZGBzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRzIHRoZSByZWNvcmQgd2l0aCBwcmltYXJ5S2V5PTJcbiAgICAgKiBjb25zdCBzdGF0ZXMgPSB0aGlzLmdyaWQucmVjb3Jkcy5nZXQoMik7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgcmVjb3JkczogTWFwPGFueSwgSVRyZWVHcmlkUmVjb3JkPiA9IG5ldyBNYXA8YW55LCBJVHJlZUdyaWRSZWNvcmQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHByb2Nlc3NlZCAoZmlsdGVyZWQgYW5kIHNvcnRlZCkgcm9vdCBgSVRyZWVHcmlkUmVjb3JkYHMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldHMgdGhlIHByb2Nlc3NlZCByb290IHJlY29yZCB3aXRoIGluZGV4PTJcbiAgICAgKiBjb25zdCBzdGF0ZXMgPSB0aGlzLmdyaWQucHJvY2Vzc2VkUm9vdFJlY29yZHNbMl07XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgcHJvY2Vzc2VkUm9vdFJlY29yZHM6IElUcmVlR3JpZFJlY29yZFtdO1xuXG4gICAgLyogYmxhem9yU3VwcHJlc3MgKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbWFwIG9mIGFsbCBwcm9jZXNzZWQgKGZpbHRlcmVkIGFuZCBzb3J0ZWQpIGBJVHJlZUdyaWRSZWNvcmRgcy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0cyB0aGUgcHJvY2Vzc2VkIHJlY29yZCB3aXRoIHByaW1hcnlLZXk9MlxuICAgICAqIGNvbnN0IHN0YXRlcyA9IHRoaXMuZ3JpZC5wcm9jZXNzZWRSZWNvcmRzLmdldCgyKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBwcm9jZXNzZWRSZWNvcmRzOiBNYXA8YW55LCBJVHJlZUdyaWRSZWNvcmQ+ID0gbmV3IE1hcDxhbnksIElUcmVlR3JpZFJlY29yZD4oKTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbG9hZGluZ1Jvd3MgPSBuZXcgU2V0PGFueT4oKTtcblxuICAgIHByb3RlY3RlZCBvdmVycmlkZSBfZmlsdGVyU3RyYXRlZ3kgPSBuZXcgVHJlZUdyaWRGaWx0ZXJpbmdTdHJhdGVneSgpO1xuICAgIHByb3RlY3RlZCBvdmVycmlkZSBfdHJhbnNhY3Rpb25zOiBIaWVyYXJjaGljYWxUcmFuc2FjdGlvblNlcnZpY2U8SGllcmFyY2hpY2FsVHJhbnNhY3Rpb24sIEhpZXJhcmNoaWNhbFN0YXRlPjtcbiAgICBwcml2YXRlIF9kYXRhO1xuICAgIHByaXZhdGUgX3Jvd0xvYWRpbmdJbmRpY2F0b3JUZW1wbGF0ZTogVGVtcGxhdGVSZWY8dm9pZD47XG4gICAgcHJpdmF0ZSBfZXhwYW5zaW9uRGVwdGggPSBJbmZpbml0eTtcblxuICAgICAvKiB0cmVhdEFzUmVmICovXG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSBhcnJheSBvZiBkYXRhIHRoYXQgcG9wdWxhdGVzIHRoZSBjb21wb25lbnQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZS1ncmlkIFtkYXRhXT1cIkRhdGFcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC10cmVlLWdyaWQ+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgZGF0YSgpOiBhbnlbXSB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9XG5cbiAgICAgLyogdHJlYXRBc1JlZiAqL1xuICAgIHB1YmxpYyBzZXQgZGF0YSh2YWx1ZTogYW55W10gfCBudWxsKSB7XG4gICAgICAgIGNvbnN0IG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICB0aGlzLl9kYXRhID0gdmFsdWUgfHwgW107XG4gICAgICAgIHRoaXMuc3VtbWFyeVNlcnZpY2UuY2xlYXJTdW1tYXJ5Q2FjaGUoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9pbml0KSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRpb24udXBkYXRlQWxsKHRoaXMuX2RhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF1dG9HZW5lcmF0ZSAmJiB0aGlzLl9kYXRhLmxlbmd0aCA+IDAgJiYgdGhpcy5zaG91bGRSZWNyZWF0ZUNvbHVtbnMob2xkRGF0YSwgdGhpcy5fZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dXBDb2x1bW5zKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIG92ZXJyaWRlIGdldCB0eXBlKCk6IEdyaWRUeXBlW1widHlwZVwiXSB7XG4gICAgICAgIHJldHVybiAndHJlZSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRyYW5zYWN0aW9ucyBzZXJ2aWNlIGZvciB0aGUgZ3JpZC5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBnZXQgdHJhbnNhY3Rpb25zKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlUcmFuc2FjdGlvbnMgJiYgIXRoaXMuYmF0Y2hFZGl0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlUcmFuc2FjdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb3VudCBvZiBsZXZlbHMgdG8gYmUgZXhwYW5kZWQgaW4gdGhlIGBJZ3hUcmVlR3JpZENvbXBvbmVudGAuIEJ5IGRlZmF1bHQgaXQgaXNcbiAgICAgKiBzZXQgdG8gYEluZmluaXR5YCB3aGljaCBtZWFucyBhbGwgbGV2ZWxzIHdvdWxkIGJlIGV4cGFuZGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUtZ3JpZCAjZ3JpZCBbZGF0YV09XCJlbXBsb3llZURhdGFcIiBbY2hpbGREYXRhS2V5XT1cIidlbXBsb3llZXMnXCIgZXhwYW5zaW9uRGVwdGg9XCIxXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCI+PC9pZ3gtdHJlZS1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGV4cGFuc2lvbkRlcHRoKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHBhbnNpb25EZXB0aDtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IGV4cGFuc2lvbkRlcHRoKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fZXhwYW5zaW9uRGVwdGggPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVtcGxhdGUgZm9yIHRoZSByb3cgbG9hZGluZyBpbmRpY2F0b3Igd2hlbiBsb2FkIG9uIGRlbWFuZCBpcyBlbmFibGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgI3Jvd0xvYWRpbmdUZW1wbGF0ZT5cbiAgICAgKiAgICAgPGlneC1pY29uPmxvb3A8L2lneC1pY29uPlxuICAgICAqIDwvbmctdGVtcGxhdGU+XG4gICAgICpcbiAgICAgKiA8aWd4LXRyZWUtZ3JpZCAjZ3JpZCBbZGF0YV09XCJlbXBsb3llZURhdGFcIiBbcHJpbWFyeUtleV09XCInSUQnXCIgW2ZvcmVpZ25LZXldPVwiJ3BhcmVudElEJ1wiXG4gICAgICogICAgICAgICAgICAgICAgW2xvYWRDaGlsZHJlbk9uRGVtYW5kXT1cImxvYWRDaGlsZHJlblwiXG4gICAgICogICAgICAgICAgICAgICAgW3Jvd0xvYWRpbmdJbmRpY2F0b3JUZW1wbGF0ZV09XCJyb3dMb2FkaW5nVGVtcGxhdGVcIj5cbiAgICAgKiA8L2lneC10cmVlLWdyaWQ+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgcm93TG9hZGluZ0luZGljYXRvclRlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvd0xvYWRpbmdJbmRpY2F0b3JUZW1wbGF0ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IHJvd0xvYWRpbmdJbmRpY2F0b3JUZW1wbGF0ZSh2YWx1ZTogVGVtcGxhdGVSZWY8dm9pZD4pIHtcbiAgICAgICAgdGhpcy5fcm93TG9hZGluZ0luZGljYXRvclRlbXBsYXRlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIC8vIEtpbmQgb2Ygc3R1cGlkXG4gICAgLy8gcHJpdmF0ZSBnZXQgX2dyaWRBUEkoKTogSWd4VHJlZUdyaWRBUElTZXJ2aWNlIHtcbiAgICAvLyAgICAgcmV0dXJuIHRoaXMuZ3JpZEFQSSBhcyBJZ3hUcmVlR3JpZEFQSVNlcnZpY2U7XG4gICAgLy8gfVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHZhbGlkYXRpb25TZXJ2aWNlOiBJZ3hHcmlkVmFsaWRhdGlvblNlcnZpY2UsXG4gICAgICAgIHNlbGVjdGlvblNlcnZpY2U6IElneEdyaWRTZWxlY3Rpb25TZXJ2aWNlLFxuICAgICAgICBjb2xSZXNpemluZ1NlcnZpY2U6IElneENvbHVtblJlc2l6aW5nU2VydmljZSxcbiAgICAgICAgQEluamVjdChJR1hfR1JJRF9TRVJWSUNFX0JBU0UpIGdyaWRBUEk6IEdyaWRTZXJ2aWNlVHlwZSxcbiAgICAgICAgLy8gcHVibGljIGdyaWRBUEk6IEdyaWRCYXNlQVBJU2VydmljZTxJZ3hHcmlkQmFzZURpcmVjdGl2ZSAmIEdyaWRUeXBlPixcbiAgICAgICAgdHJhbnNhY3Rpb25GYWN0b3J5OiBJZ3hIaWVyYXJjaGljYWxUcmFuc2FjdGlvbkZhY3RvcnksXG4gICAgICAgIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PixcbiAgICAgICAgX3pvbmU6IE5nWm9uZSxcbiAgICAgICAgQEluamVjdChET0NVTUVOVCkgZG9jdW1lbnQ6IGFueSxcbiAgICAgICAgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgZGlmZmVyczogSXRlcmFibGVEaWZmZXJzLFxuICAgICAgICB2aWV3UmVmOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgICAgIGVudkluamVjdG9yOiBFbnZpcm9ubWVudEluamVjdG9yLFxuICAgICAgICBuYXZpZ2F0aW9uOiBJZ3hHcmlkTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgICAgIGZpbHRlcmluZ1NlcnZpY2U6IElneEZpbHRlcmluZ1NlcnZpY2UsXG4gICAgICAgIHRleHRIaWdobGlnaHRTZXJ2aWNlOiBJZ3hUZXh0SGlnaGxpZ2h0U2VydmljZSxcbiAgICAgICAgQEluamVjdChJZ3hPdmVybGF5U2VydmljZSkgb3ZlcmxheVNlcnZpY2U6IElneE92ZXJsYXlTZXJ2aWNlLFxuICAgICAgICBzdW1tYXJ5U2VydmljZTogSWd4R3JpZFN1bW1hcnlTZXJ2aWNlLFxuICAgICAgICBASW5qZWN0KExPQ0FMRV9JRCkgbG9jYWxlSWQ6IHN0cmluZyxcbiAgICAgICAgcGxhdGZvcm06IFBsYXRmb3JtVXRpbCxcbiAgICAgICAgQE9wdGlvbmFsKCkgQEluamVjdChJZ3hHcmlkVHJhbnNhY3Rpb24pIHByb3RlY3RlZCBvdmVycmlkZSBfZGlUcmFuc2FjdGlvbnM/OlxuICAgICAgICAgICAgSGllcmFyY2hpY2FsVHJhbnNhY3Rpb25TZXJ2aWNlPEhpZXJhcmNoaWNhbFRyYW5zYWN0aW9uLCBIaWVyYXJjaGljYWxTdGF0ZT4sXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKFxuICAgICAgICAgICAgdmFsaWRhdGlvblNlcnZpY2UsXG4gICAgICAgICAgICBzZWxlY3Rpb25TZXJ2aWNlLFxuICAgICAgICAgICAgY29sUmVzaXppbmdTZXJ2aWNlLFxuICAgICAgICAgICAgZ3JpZEFQSSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uRmFjdG9yeSxcbiAgICAgICAgICAgIF9lbGVtZW50UmVmLFxuICAgICAgICAgICAgX3pvbmUsXG4gICAgICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgICAgIGNkcixcbiAgICAgICAgICAgIGRpZmZlcnMsXG4gICAgICAgICAgICB2aWV3UmVmLFxuICAgICAgICAgICAgaW5qZWN0b3IsXG4gICAgICAgICAgICBlbnZJbmplY3RvcixcbiAgICAgICAgICAgIG5hdmlnYXRpb24sXG4gICAgICAgICAgICBmaWx0ZXJpbmdTZXJ2aWNlLFxuICAgICAgICAgICAgdGV4dEhpZ2hsaWdodFNlcnZpY2UsXG4gICAgICAgICAgICBvdmVybGF5U2VydmljZSxcbiAgICAgICAgICAgIHN1bW1hcnlTZXJ2aWNlLFxuICAgICAgICAgICAgbG9jYWxlSWQsXG4gICAgICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgICAgIF9kaVRyYW5zYWN0aW9ucyxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG92ZXJyaWRlIG5nT25Jbml0KCkge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgICAgIHRoaXMucm93VG9nZ2xlLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoKGFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9hZENoaWxkcmVuT25Sb3dFeHBhbnNpb24oYXJncyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRPRE86IGNhc2NhZGUgc2VsZWN0aW9uIGxvZ2ljIHNob3VsZCBiZSByZWZhY3RvciB0byBiZSBoYW5kbGVkIGluIHRoZSBhbHJlYWR5IGV4aXN0aW5nIHN1YnNcbiAgICAgICAgdGhpcy5yb3dBZGRlZE5vdGlmaWVyLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoYXJncyA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5yb3dTZWxlY3Rpb24gPT09IEdyaWRTZWxlY3Rpb25Nb2RlLm11bHRpcGxlQ2FzY2FkZSkge1xuICAgICAgICAgICAgICAgIGxldCByZWMgPSB0aGlzLmdyaWRBUEkuZ2V0X3JlY19ieV9pZCh0aGlzLnByaW1hcnlLZXkgPyBhcmdzLmRhdGFbdGhpcy5wcmltYXJ5S2V5XSA6IGFyZ3MuZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlYyAmJiByZWMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JpZEFQSS5ncmlkLnNlbGVjdGlvblNlcnZpY2UudXBkYXRlQ2FzY2FkZVNlbGVjdGlvbk9uRmlsdGVyQW5kQ1JVRChcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBTZXQoW3JlYy5wYXJlbnRdKSwgcmVjLnBhcmVudC5rZXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZWNvcmQgaXMgc3RpbGwgbm90IGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgY2hhbmdlIGRldGVjdGlvbiB0byB1cGRhdGUgcmVjb3JkcyB0aHJvdWdoIHBpcGVzXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWMgPSB0aGlzLmdyaWRBUEkuZ2V0X3JlY19ieV9pZCh0aGlzLnByaW1hcnlLZXkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MuZGF0YVt0aGlzLnByaW1hcnlLZXldIDogYXJncy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWMgJiYgcmVjLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JpZEFQSS5ncmlkLnNlbGVjdGlvblNlcnZpY2UudXBkYXRlQ2FzY2FkZVNlbGVjdGlvbk9uRmlsdGVyQW5kQ1JVRChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFNldChbcmVjLnBhcmVudF0pLCByZWMucGFyZW50LmtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUNoYW5nZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnJvd0RlbGV0ZWROb3RpZmllci5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKGFyZ3MgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucm93U2VsZWN0aW9uID09PSBHcmlkU2VsZWN0aW9uTW9kZS5tdWx0aXBsZUNhc2NhZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYyA9IHRoaXMuZ3JpZEFQSS5nZXRfcmVjX2J5X2lkKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmltYXJ5S2V5ID8gYXJncy5kYXRhW3RoaXMucHJpbWFyeUtleV0gOiBhcmdzLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNhc2NhZGVTZWxlY3Rpb24oYXJncywgcmVjKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBhIHJvdyBoYXMgYmVlbiBhZGRlZCBhbmQgYmVmb3JlIGNvbW1pdGluZyB0aGUgdHJhbnNhY3Rpb24gZGVsZXRlZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWFmUm93c0RpcmVjdFBhcmVudHMgPSBuZXcgU2V0PGFueT4oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvcmRzLmZvckVhY2gocmVjb3JkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQgJiYgKCFyZWNvcmQuY2hpbGRyZW4gfHwgcmVjb3JkLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgJiYgcmVjb3JkLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlYWZSb3dzRGlyZWN0UGFyZW50cy5hZGQocmVjb3JkLnBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgY2hhbmdlIGRldGVjdGlvbiB0byB1cGRhdGUgcmVjb3JkcyB0aHJvdWdoIHBpcGVzXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyaWRBUEkuZ3JpZC5zZWxlY3Rpb25TZXJ2aWNlLnVwZGF0ZUNhc2NhZGVTZWxlY3Rpb25PbkZpbHRlckFuZENSVUQobGVhZlJvd3NEaXJlY3RQYXJlbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZmlsdGVyaW5nRG9uZS5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJvd1NlbGVjdGlvbiA9PT0gR3JpZFNlbGVjdGlvbk1vZGUubXVsdGlwbGVDYXNjYWRlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVhZlJvd3NEaXJlY3RQYXJlbnRzID0gbmV3IFNldDxhbnk+KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvcmRzLmZvckVhY2gocmVjb3JkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZCAmJiAoIXJlY29yZC5jaGlsZHJlbiB8fCByZWNvcmQuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSAmJiByZWNvcmQucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWFmUm93c0RpcmVjdFBhcmVudHMuYWRkKHJlY29yZC5wYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkQVBJLmdyaWQuc2VsZWN0aW9uU2VydmljZS51cGRhdGVDYXNjYWRlU2VsZWN0aW9uT25GaWx0ZXJBbmRDUlVEKGxlYWZSb3dzRGlyZWN0UGFyZW50cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICBzdXBlci5uZ0FmdGVyVmlld0luaXQoKTtcbiAgICAgICAgLy8gVE9ETzogcGlwZXNFeGVjdHVyZWQgZXZlbnRcbiAgICAgICAgLy8gcnVuIGFmdGVyIGNoYW5nZSBkZXRlY3Rpb24gaW4gc3VwZXIgdHJpZ2dlcnMgcGlwZXMgZm9yIHJlY29yZHMgc3RydWN0dXJlXG4gICAgICAgIGlmICh0aGlzLnJvd1NlbGVjdGlvbiA9PT0gR3JpZFNlbGVjdGlvbk1vZGUubXVsdGlwbGVDYXNjYWRlICYmIHRoaXMuc2VsZWN0ZWRSb3dzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgc2VsUm93cyA9IHRoaXMuc2VsZWN0ZWRSb3dzO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmNsZWFyUm93U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdFJvd3Moc2VsUm93cywgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG92ZXJyaWRlIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMucm93TG9hZGluZ1RlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9yb3dMb2FkaW5nSW5kaWNhdG9yVGVtcGxhdGUgPSB0aGlzLnJvd0xvYWRpbmdUZW1wbGF0ZS50ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5uZ0FmdGVyQ29udGVudEluaXQoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgZ2V0RGVmYXVsdEV4cGFuZFN0YXRlKHJlY29yZDogSVRyZWVHcmlkUmVjb3JkKSB7XG4gICAgICAgIHJldHVybiByZWNvcmQuY2hpbGRyZW4gJiYgcmVjb3JkLmNoaWxkcmVuLmxlbmd0aCAmJiByZWNvcmQubGV2ZWwgPCB0aGlzLmV4cGFuc2lvbkRlcHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgYWxsIHJvd3MuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC5leHBhbmRBbGwoKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBleHBhbmRBbGwoKSB7XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvbkRlcHRoID0gSW5maW5pdHk7XG4gICAgICAgIHRoaXMuZXhwYW5zaW9uU3RhdGVzID0gbmV3IE1hcDxhbnksIGJvb2xlYW4+KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29sbGFwc2VzIGFsbCByb3dzLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC5jb2xsYXBzZUFsbCgpO1xuICAgICAqICBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBjb2xsYXBzZUFsbCgpIHtcbiAgICAgICAgdGhpcy5fZXhwYW5zaW9uRGVwdGggPSAwO1xuICAgICAgICB0aGlzLmV4cGFuc2lvblN0YXRlcyA9IG5ldyBNYXA8YW55LCBib29sZWFuPigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgcmVmcmVzaEdyaWRTdGF0ZShhcmdzPzogSVJvd0RhdGFFdmVudEFyZ3MpIHtcbiAgICAgICAgc3VwZXIucmVmcmVzaEdyaWRTdGF0ZSgpO1xuICAgICAgICBpZiAodGhpcy5wcmltYXJ5S2V5ICYmIHRoaXMuZm9yZWlnbktleSAmJiBhcmdzKSB7XG4gICAgICAgICAgICBjb25zdCByb3dJRCA9IGFyZ3MuZGF0YVt0aGlzLmZvcmVpZ25LZXldO1xuICAgICAgICAgICAgdGhpcy5zdW1tYXJ5U2VydmljZS5jbGVhclN1bW1hcnlDYWNoZSh7IHJvd0lEIH0pO1xuICAgICAgICAgICAgdGhpcy5waXBlVHJpZ2dlcisrO1xuICAgICAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogYmxhem9yQ1NTdXBwcmVzcyAqL1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYElneFRyZWVHcmlkUm93Q29tcG9uZW50YCB3aXRoIHRoZSBnaXZlbiBkYXRhLiBJZiBhIHBhcmVudFJvd0lEIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBuZXdseSBjcmVhdGVkXG4gICAgICogcm93IHdvdWxkIGJlIGFkZGVkIGF0IHRoZSByb290IGxldmVsLiBPdGhlcndpc2UsIGl0IHdvdWxkIGJlIGFkZGVkIGFzIGEgY2hpbGQgb2YgdGhlIHJvdyB3aG9zZSBwcmltYXJ5S2V5IG1hdGNoZXNcbiAgICAgKiB0aGUgc3BlY2lmaWVkIHBhcmVudFJvd0lELiBJZiB0aGUgcGFyZW50Um93SUQgZG9lcyBub3QgZXhpc3QsIGFuIGVycm9yIHdvdWxkIGJlIHRocm93bi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgcmVjb3JkID0ge1xuICAgICAqICAgICBJRDogdGhpcy5ncmlkLmRhdGFbdGhpcy5ncmlkMS5kYXRhLmxlbmd0aCAtIDFdLklEICsgMSxcbiAgICAgKiAgICAgTmFtZTogdGhpcy5uZXdSZWNvcmRcbiAgICAgKiB9O1xuICAgICAqIHRoaXMuZ3JpZC5hZGRSb3cocmVjb3JkLCAxKTsgLy8gQWRkcyBhIG5ldyBjaGlsZCByb3cgdG8gdGhlIHJvdyB3aXRoIElEPTEuXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqIEBwYXJhbSBwYXJlbnRSb3dJRFxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIC8vIFRPRE86IHJlbW92ZSBldnQgZW1pc3Npb25cbiAgICBwdWJsaWMgb3ZlcnJpZGUgYWRkUm93KGRhdGE6IGFueSwgcGFyZW50Um93SUQ/OiBhbnkpIHtcbiAgICAgICAgdGhpcy5jcnVkU2VydmljZS5lbmRFZGl0KHRydWUpO1xuICAgICAgICB0aGlzLmdyaWRBUEkuYWRkUm93VG9EYXRhKGRhdGEsIHBhcmVudFJvd0lEKTtcblxuICAgICAgICB0aGlzLnJvd0FkZGVkTm90aWZpZXIubmV4dCh7XG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgcm93RGF0YTogZGF0YSwgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICBwcmltYXJ5S2V5OiBkYXRhW3RoaXMucHJpbWFyeUtleV0sXG4gICAgICAgICAgICByb3dLZXk6IGRhdGFbdGhpcy5wcmltYXJ5S2V5XVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5waXBlVHJpZ2dlcisrO1xuICAgICAgICB0aGlzLm5vdGlmeUNoYW5nZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnRlcnMgYWRkIG1vZGUgYnkgc3Bhd25pbmcgdGhlIFVJIHdpdGggdGhlIGNvbnRleHQgb2YgdGhlIHNwZWNpZmllZCByb3cgYnkgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEFjY2VwdGVkIHZhbHVlcyBmb3IgaW5kZXggYXJlIGludGVnZXJzIGZyb20gMCB0byB0aGlzLmdyaWQuZGF0YVZpZXcubGVuZ3RoXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBXaGVuIGFkZGluZyB0aGUgcm93IGFzIGEgY2hpbGQsIHRoZSBwYXJlbnQgcm93IGlzIHRoZSBzcGVjaWZpZWQgcm93LlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVG8gc3Bhd24gdGhlIFVJIG9uIHRvcCwgY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBpbmRleCA9IG51bGwgb3IgYSBuZWdhdGl2ZSBudW1iZXIuXG4gICAgICogSW4gdGhpcyBjYXNlIHRyeWluZyB0byBhZGQgdGhpcyByb3cgYXMgYSBjaGlsZCB3aWxsIHJlc3VsdCBpbiBlcnJvci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQuYmVnaW5BZGRSb3dCeUluZGV4KDEwKTtcbiAgICAgKiB0aGlzLmdyaWQuYmVnaW5BZGRSb3dCeUluZGV4KDEwLCB0cnVlKTtcbiAgICAgKiB0aGlzLmdyaWQuYmVnaW5BZGRSb3dCeUluZGV4KG51bGwpO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCB0byBzcGF3biB0aGUgVUkgYXQuIEFjY2VwdHMgaW50ZWdlcnMgZnJvbSAwIHRvIHRoaXMuZ3JpZC5kYXRhVmlldy5sZW5ndGhcbiAgICAgKiBAcGFyYW0gYXNDaGlsZCAtIFdoZXRoZXIgdGhlIHJlY29yZCBzaG91bGQgYmUgYWRkZWQgYXMgYSBjaGlsZC4gT25seSBhcHBsaWNhYmxlIHRvIGlneFRyZWVHcmlkLlxuICAgICAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBiZWdpbkFkZFJvd0J5SW5kZXgoaW5kZXg6IG51bWJlciwgYXNDaGlsZD86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSBudWxsIHx8IGluZGV4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmVnaW5BZGRSb3dCeUlkKG51bGwsIGFzQ2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRSb3dGb3JJbmRleChpbmRleCAtIDEsIGFzQ2hpbGQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Q29udGV4dChyb3dEYXRhOiBhbnksIHJvd0luZGV4OiBudW1iZXIsIHBpbm5lZD86IGJvb2xlYW4pOiBhbnkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJGltcGxpY2l0OiB0aGlzLmlzR2hvc3RSZWNvcmQocm93RGF0YSkgPyByb3dEYXRhLnJlY29yZFJlZiA6IHJvd0RhdGEsXG4gICAgICAgICAgICBpbmRleDogdGhpcy5nZXREYXRhVmlld0luZGV4KHJvd0luZGV4LCBwaW5uZWQpLFxuICAgICAgICAgICAgdGVtcGxhdGVJRDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMuaXNTdW1tYXJ5Um93KHJvd0RhdGEpID8gJ3N1bW1hcnlSb3cnIDogJ2RhdGFSb3cnLFxuICAgICAgICAgICAgICAgIGlkOiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlzYWJsZWQ6IHRoaXMuaXNHaG9zdFJlY29yZChyb3dEYXRhKSA/IHJvd0RhdGEucmVjb3JkUmVmLmlzRmlsdGVyZWRPdXRQYXJlbnQgPT09IHVuZGVmaW5lZCA6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBnZXRJbml0aWFsUGlubmVkSW5kZXgocmVjKSB7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5ncmlkQVBJLmdldF9yb3dfaWQocmVjKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bpbm5lZFJlY29yZElEcy5pbmRleE9mKGlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG92ZXJyaWRlIGlzUmVjb3JkUGlubmVkKHJlYykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRJbml0aWFsUGlubmVkSW5kZXgocmVjLmRhdGEpICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGN1cnJlbnQgY2VsbCBzZWxlY3Rpb24gaW4gdGhlIGZvcm0gb2YgYFt7IGNvbHVtbi5maWVsZDogY2VsbC52YWx1ZSB9LCAuLi5dYC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgYGZvcm1hdHRlcnNgIGlzIGVuYWJsZWQsIHRoZSBjZWxsIHZhbHVlIHdpbGwgYmUgZm9ybWF0dGVkIGJ5IGl0cyByZXNwZWN0aXZlIGNvbHVtbiBmb3JtYXR0ZXIgKGlmIGFueSkuXG4gICAgICogSWYgYGhlYWRlcnNgIGlzIGVuYWJsZWQsIGl0IHdpbGwgdXNlIHRoZSBjb2x1bW4gaGVhZGVyIChpZiBhbnkpIGluc3RlYWQgb2YgdGhlIGNvbHVtbiBmaWVsZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgZ2V0U2VsZWN0ZWREYXRhKGZvcm1hdHRlcnMgPSBmYWxzZSwgaGVhZGVycyA9IGZhbHNlKTogYW55W10ge1xuICAgICAgICBsZXQgc291cmNlID0gW107XG5cbiAgICAgICAgY29uc3QgcHJvY2VzcyA9IChyZWNvcmQpID0+IHtcbiAgICAgICAgICAgIGlmIChyZWNvcmQuc3VtbWFyaWVzKSB7XG4gICAgICAgICAgICAgICAgc291cmNlLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc291cmNlLnB1c2gocmVjb3JkLmRhdGEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMudW5waW5uZWREYXRhVmlldy5mb3JFYWNoKHByb2Nlc3MpO1xuICAgICAgICBzb3VyY2UgPSB0aGlzLmlzUm93UGlubmluZ1RvVG9wID8gWy4uLnRoaXMucGlubmVkRGF0YVZpZXcsIC4uLnNvdXJjZV0gOiBbLi4uc291cmNlLCAuLi50aGlzLnBpbm5lZERhdGFWaWV3XTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdERhdGFGcm9tU2VsZWN0aW9uKHNvdXJjZSwgZm9ybWF0dGVycywgaGVhZGVycyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgZ2V0RW1wdHlSZWNvcmRPYmplY3RGb3IoaW5UcmVlUm93OiBSb3dUeXBlKSB7XG4gICAgICAgIGNvbnN0IHRyZWVSb3dSZWMgPSBpblRyZWVSb3c/LnRyZWVSb3cgfHwgbnVsbDtcbiAgICAgICAgY29uc3Qgcm93ID0geyAuLi50cmVlUm93UmVjIH07XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0cmVlUm93UmVjPy5kYXRhIHx8IHt9O1xuICAgICAgICByb3cuZGF0YSA9IHsgLi4uZGF0YSB9O1xuICAgICAgICBPYmplY3Qua2V5cyhyb3cuZGF0YSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgLy8gcGVyc2lzdCBmb3JlaWduIGtleSBpZiBvbmUgaXMgc2V0LlxuICAgICAgICAgICAgaWYgKHRoaXMuZm9yZWlnbktleSAmJiBrZXkgPT09IHRoaXMuZm9yZWlnbktleSkge1xuICAgICAgICAgICAgICAgIHJvdy5kYXRhW2tleV0gPSB0cmVlUm93UmVjLmRhdGFbdGhpcy5jcnVkU2VydmljZS5hZGRSb3dQYXJlbnQ/LmFzQ2hpbGQgPyB0aGlzLnByaW1hcnlLZXkgOiBrZXldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByb3cuZGF0YVtrZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5nZW5lcmF0ZVJvd0lEKCk7XG4gICAgICAgIGNvbnN0IHJvb3RSZWNQSyA9IHRoaXMuZm9yZWlnbktleSAmJiB0aGlzLnJvb3RSZWNvcmRzICYmIHRoaXMucm9vdFJlY29yZHMubGVuZ3RoID4gMCA/XG4gICAgICAgICAgICB0aGlzLnJvb3RSZWNvcmRzWzBdLmRhdGFbdGhpcy5mb3JlaWduS2V5XSA6IG51bGw7XG4gICAgICAgIGlmIChpZCA9PT0gcm9vdFJlY1BLKSB7XG4gICAgICAgICAgICAvLyBzYWZlZ3VhcmQgaW4gY2FzZSBnZW5lcmF0ZWQgaWQgbWF0Y2hlcyB0aGUgcm9vdCBmb3JlaWduIGtleS5cbiAgICAgICAgICAgIGlkID0gdGhpcy5nZW5lcmF0ZVJvd0lEKCk7XG4gICAgICAgIH1cbiAgICAgICAgcm93LmtleSA9IGlkO1xuICAgICAgICByb3cuZGF0YVt0aGlzLnByaW1hcnlLZXldID0gaWQ7XG4gICAgICAgIHJldHVybiB7IHJvd0lEOiBpZCwgZGF0YTogcm93LmRhdGEsIHJlY29yZFJlZjogcm93IH07XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgZGVsZXRlUm93QnlJZChyb3dJZDogYW55KTogYW55IHtcbiAgICAgICAgLy8gIGlmIHRoaXMgaXMgZmxhdCBzZWxmLXJlZmVyZW5jaW5nIGRhdGEsIGFuZCBDYXNjYWRlT25EZWxldGUgaXMgc2V0IHRvIHRydWVcbiAgICAgICAgLy8gIGFuZCBpZiB3ZSBoYXZlIHRyYW5zYWN0aW9ucyB3ZSBzaG91bGQgc3RhcnQgcGVuZGluZyB0cmFuc2FjdGlvbi4gVGhpcyBhbGxvd3NcbiAgICAgICAgLy8gIHVzIGluIGNhc2Ugb2YgZGVsZXRlIGFjdGlvbiB0byBkZWxldGUgYWxsIGNoaWxkIHJvd3MgYXMgc2luZ2xlIHVuZG8gYWN0aW9uXG4gICAgICAgIGNvbnN0IGFyZ3M6IElSb3dEYXRhQ2FuY2VsYWJsZUV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgIHJvd0lEOiByb3dJZCxcbiAgICAgICAgICAgIHByaW1hcnlLZXk6IHJvd0lkLFxuICAgICAgICAgICAgcm93S2V5OiByb3dJZCxcbiAgICAgICAgICAgIGNhbmNlbDogZmFsc2UsXG4gICAgICAgICAgICByb3dEYXRhOiB0aGlzLmdldFJvd0RhdGEocm93SWQpLFxuICAgICAgICAgICAgZGF0YTogdGhpcy5nZXRSb3dEYXRhKHJvd0lkKSxcbiAgICAgICAgICAgIG9sZFZhbHVlOiBudWxsLFxuICAgICAgICAgICAgb3duZXI6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yb3dEZWxldGUuZW1pdChhcmdzKTtcbiAgICAgICAgaWYgKGFyZ3MuY2FuY2VsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZWNvcmQgPSB0aGlzLmdyaWRBUEkuZGVsZXRlUm93QnlJZChyb3dJZCk7XG4gICAgICAgIGNvbnN0IGtleSA9IHJlY29yZFt0aGlzLnByaW1hcnlLZXldO1xuICAgICAgICBpZiAocmVjb3JkICE9PSBudWxsICYmIHJlY29yZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCByb3dEZWxldGVkRXZlbnRBcmdzOiBJUm93RGF0YUV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiByZWNvcmQsXG4gICAgICAgICAgICAgICAgcm93RGF0YTogcmVjb3JkLFxuICAgICAgICAgICAgICAgIG93bmVyOiB0aGlzLFxuICAgICAgICAgICAgICAgIHByaW1hcnlLZXk6IGtleSxcbiAgICAgICAgICAgICAgICByb3dLZXk6IGtleVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucm93RGVsZXRlZC5lbWl0KHJvd0RlbGV0ZWRFdmVudEFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYElneFRyZWVHcmlkUm93YCBieSBpbmRleC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IG15Um93ID0gdHJlZUdyaWQuZ2V0Um93QnlJbmRleCgxKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Um93QnlJbmRleChpbmRleDogbnVtYmVyKTogUm93VHlwZSB7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5kYXRhVmlldy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUm93KGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBgUm93VHlwZWAgb2JqZWN0IGJ5IHRoZSBzcGVjaWZpZWQgcHJpbWFyeSBrZXkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBteVJvdyA9IHRoaXMudHJlZUdyaWQuZ2V0Um93QnlJbmRleCgxKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Um93QnlLZXkoa2V5OiBhbnkpOiBSb3dUeXBlIHtcbiAgICAgICAgY29uc3QgcmVjID0gdGhpcy5maWx0ZXJlZFNvcnRlZERhdGEgPyB0aGlzLnByaW1hcnlLZXkgPyB0aGlzLmZpbHRlcmVkU29ydGVkRGF0YS5maW5kKHIgPT4gclt0aGlzLnByaW1hcnlLZXldID09PSBrZXkpIDpcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRTb3J0ZWREYXRhLmZpbmQociA9PiByID09PSBrZXkpIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZGF0YVZpZXcuZmluZEluZGV4KHIgPT4gci5kYXRhICYmIHIuZGF0YSA9PT0gcmVjKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmZpbHRlcmVkU29ydGVkRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBJZ3hUcmVlR3JpZFJvdyh0aGlzIGFzIGFueSwgaW5kZXgsIHJlYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29sbGVjdGlvbiBvZiBhbGwgUm93VHlwZSBmb3IgY3VycmVudCBwYWdlLlxuICAgICAqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgYWxsUm93cygpOiBSb3dUeXBlW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhVmlldy5tYXAoKHJlYywgaW5kZXgpID0+IHRoaXMuY3JlYXRlUm93KGluZGV4KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29sbGVjdGlvbiBvZiBgSWd4VHJlZUdyaWRSb3dgcyBmb3IgY3VycmVudCBwYWdlLlxuICAgICAqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZGF0YVJvd3MoKTogUm93VHlwZVtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsUm93cygpLmZpbHRlcihyb3cgPT4gcm93IGluc3RhbmNlb2YgSWd4VHJlZUdyaWRSb3cpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHNlbGVjdGVkIGBJZ3hHcmlkQ2VsbGBzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3Qgc2VsZWN0ZWRDZWxscyA9IHRoaXMuZ3JpZC5zZWxlY3RlZENlbGxzO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgc2VsZWN0ZWRDZWxscygpOiBDZWxsVHlwZVtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVJvd3MoKS5tYXAoKHJvdykgPT4gcm93LmNlbGxzLmZpbHRlcigoY2VsbCkgPT4gY2VsbC5zZWxlY3RlZCkpXG4gICAgICAgICAgICAucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBgQ2VsbFR5cGVgIG9iamVjdCB0aGF0IG1hdGNoZXMgdGhlIGNvbmRpdGlvbnMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBteUNlbGwgPSB0aGlzLmdyaWQxLmdldENlbGxCeUNvbHVtbigyLCBcIlVuaXRQcmljZVwiKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gcm93SW5kZXhcbiAgICAgKiBAcGFyYW0gY29sdW1uRmllbGRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Q2VsbEJ5Q29sdW1uKHJvd0luZGV4OiBudW1iZXIsIGNvbHVtbkZpZWxkOiBzdHJpbmcpOiBDZWxsVHlwZSB7XG4gICAgICAgIGNvbnN0IHJvdyA9IHRoaXMuZ2V0Um93QnlJbmRleChyb3dJbmRleCk7XG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IHRoaXMuY29sdW1ucy5maW5kKChjb2wpID0+IGNvbC5maWVsZCA9PT0gY29sdW1uRmllbGQpO1xuICAgICAgICBpZiAocm93ICYmIHJvdyBpbnN0YW5jZW9mIElneFRyZWVHcmlkUm93ICYmIGNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJZ3hHcmlkQ2VsbCh0aGlzIGFzIGFueSwgcm93SW5kZXgsIGNvbHVtbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYENlbGxUeXBlYCBvYmplY3QgdGhhdCBtYXRjaGVzIHRoZSBjb25kaXRpb25zLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBSZXF1aXJlcyB0aGF0IHRoZSBwcmltYXJ5S2V5IHByb3BlcnR5IGlzIHNldC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBncmlkLmdldENlbGxCeUtleSgxLCAnaW5kZXgnKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gcm93U2VsZWN0b3IgbWF0Y2ggYW55IHJvd0lEXG4gICAgICogQHBhcmFtIGNvbHVtbkZpZWxkXG4gICAgICovXG4gICAgcHVibGljIGdldENlbGxCeUtleShyb3dTZWxlY3RvcjogYW55LCBjb2x1bW5GaWVsZDogc3RyaW5nKTogQ2VsbFR5cGUge1xuICAgICAgICBjb25zdCByb3cgPSB0aGlzLmdldFJvd0J5S2V5KHJvd1NlbGVjdG9yKTtcbiAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5jb2x1bW5zLmZpbmQoKGNvbCkgPT4gY29sLmZpZWxkID09PSBjb2x1bW5GaWVsZCk7XG4gICAgICAgIGlmIChyb3cgJiYgY29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IElneEdyaWRDZWxsKHRoaXMgYXMgYW55LCByb3cuaW5kZXgsIGNvbHVtbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgcGluUm93KHJvd0lEOiBhbnksIGluZGV4PzogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IHJvdyA9IHRoaXMuZ2V0Um93QnlLZXkocm93SUQpO1xuICAgICAgICByZXR1cm4gc3VwZXIucGluUm93KHJvd0lELCBpbmRleCwgcm93KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgdW5waW5Sb3cocm93SUQ6IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCByb3cgPSB0aGlzLmdldFJvd0J5S2V5KHJvd0lEKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnVucGluUm93KHJvd0lELCByb3cpO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIGdlbmVyYXRlUm93UGF0aChyb3dJZDogYW55KTogYW55W10ge1xuICAgICAgICBjb25zdCBwYXRoOiBhbnlbXSA9IFtdO1xuICAgICAgICBsZXQgcmVjb3JkID0gdGhpcy5yZWNvcmRzLmdldChyb3dJZCk7XG5cbiAgICAgICAgd2hpbGUgKHJlY29yZC5wYXJlbnQpIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChyZWNvcmQucGFyZW50LmtleSk7XG4gICAgICAgICAgICByZWNvcmQgPSByZWNvcmQucGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdGgucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIGlzVHJlZVJvdyhyZWNvcmQ6IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gcmVjb3JkLmtleSAhPT0gdW5kZWZpbmVkICYmIHJlY29yZC5kYXRhO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIG92ZXJyaWRlIGdldFVucGlubmVkSW5kZXhCeUlkKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVucGlubmVkUmVjb3Jkcy5maW5kSW5kZXgoeCA9PiB4LmRhdGFbdGhpcy5wcmltYXJ5S2V5XSA9PT0gaWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgY3JlYXRlUm93KGluZGV4OiBudW1iZXIsIGRhdGE/OiBhbnkpOiBSb3dUeXBlIHtcbiAgICAgICAgbGV0IHJvdzogUm93VHlwZTtcbiAgICAgICAgY29uc3QgZGF0YUluZGV4ID0gdGhpcy5fZ2V0RGF0YVZpZXdJbmRleChpbmRleCk7XG4gICAgICAgIGNvbnN0IHJlYzogYW55ID0gZGF0YSA/PyB0aGlzLmRhdGFWaWV3W2RhdGFJbmRleF07XG5cbiAgICAgICAgaWYgKHRoaXMuaXNTdW1tYXJ5Um93KHJlYykpIHtcbiAgICAgICAgICAgIHJvdyA9IG5ldyBJZ3hTdW1tYXJ5Um93KHRoaXMgYXMgYW55LCBpbmRleCwgcmVjLnN1bW1hcmllcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJvdyAmJiByZWMpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzVHJlZVJvdyA9IHRoaXMuaXNUcmVlUm93KHJlYyk7XG4gICAgICAgICAgICBjb25zdCBkYXRhUmVjID0gaXNUcmVlUm93ID8gcmVjLmRhdGEgOiByZWM7XG4gICAgICAgICAgICBjb25zdCB0cmVlUm93ID0gaXNUcmVlUm93ID8gcmVjIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgcm93ID0gbmV3IElneFRyZWVHcmlkUm93KHRoaXMgYXMgYW55LCBpbmRleCwgZGF0YVJlYywgdHJlZVJvdyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcm93O1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBvdmVycmlkZSBnZW5lcmF0ZURhdGFGaWVsZHMoZGF0YTogYW55W10pOiBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiBzdXBlci5nZW5lcmF0ZURhdGFGaWVsZHMoZGF0YSkuZmlsdGVyKGZpZWxkID0+IGZpZWxkICE9PSB0aGlzLmNoaWxkRGF0YUtleSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIG92ZXJyaWRlIHRyYW5zYWN0aW9uU3RhdHVzVXBkYXRlKGV2ZW50OiBTdGF0ZVVwZGF0ZUV2ZW50KSB7XG4gICAgICAgIGxldCBhY3Rpb25zID0gW107XG4gICAgICAgIGlmIChldmVudC5vcmlnaW4gPT09IFRyYW5zYWN0aW9uRXZlbnRPcmlnaW4uUkVETykge1xuICAgICAgICAgICAgYWN0aW9ucyA9IGV2ZW50LmFjdGlvbnMgPyBldmVudC5hY3Rpb25zLmZpbHRlcih4ID0+IHgudHJhbnNhY3Rpb24udHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkRFTEVURSkgOiBbXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJvd1NlbGVjdGlvbiA9PT0gR3JpZFNlbGVjdGlvbk1vZGUubXVsdGlwbGVDYXNjYWRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDYXNjYWRlU2VsZWN0aW9uKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5vcmlnaW4gPT09IFRyYW5zYWN0aW9uRXZlbnRPcmlnaW4uVU5ETykge1xuICAgICAgICAgICAgYWN0aW9ucyA9IGV2ZW50LmFjdGlvbnMgPyBldmVudC5hY3Rpb25zLmZpbHRlcih4ID0+IHgudHJhbnNhY3Rpb24udHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkFERCkgOiBbXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJvd1NlbGVjdGlvbiA9PT0gR3JpZFNlbGVjdGlvbk1vZGUubXVsdGlwbGVDYXNjYWRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmFjdGlvbnNbMF0udHJhbnNhY3Rpb24udHlwZSA9PT0gJ2FkZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjID0gdGhpcy5ncmlkQVBJLmdldF9yZWNfYnlfaWQoZXZlbnQuYWN0aW9uc1swXS50cmFuc2FjdGlvbi5pZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2FzY2FkZVNlbGVjdGlvbihldmVudCwgcmVjKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNhc2NhZGVTZWxlY3Rpb24oZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYWN0aW9uIG9mIGFjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc2VsZWN0Q2hpbGRyZW4oYWN0aW9uLnRyYW5zYWN0aW9uLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlci50cmFuc2FjdGlvblN0YXR1c1VwZGF0ZShldmVudCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGZpbmRSZWNvcmRJbmRleEluVmlldyhyZWMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVZpZXcuZmluZEluZGV4KHggPT4geC5kYXRhW3RoaXMucHJpbWFyeUtleV0gPT09IHJlY1t0aGlzLnByaW1hcnlLZXldKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBvdmVycmlkZSBnZXREYXRhQmFzZWRCb2R5SGVpZ2h0KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiAhdGhpcy5mbGF0RGF0YSB8fCAodGhpcy5mbGF0RGF0YS5sZW5ndGggPCB0aGlzLl9kZWZhdWx0VGFyZ2V0UmVjb3JkTnVtYmVyKSA/XG4gICAgICAgICAgICAwIDogdGhpcy5kZWZhdWx0VGFyZ2V0Qm9keUhlaWdodDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIG92ZXJyaWRlIHNjcm9sbFRvKHJvdzogYW55IHwgbnVtYmVyLCBjb2x1bW46IGFueSB8IG51bWJlcik6IHZvaWQge1xuICAgICAgICBsZXQgZGVsYXlTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlY29yZDogSVRyZWVHcmlkUmVjb3JkO1xuXG4gICAgICAgIGlmICh0eXBlb2YgKHJvdykgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBjb25zdCByb3dEYXRhID0gcm93O1xuICAgICAgICAgICAgY29uc3Qgcm93SUQgPSB0aGlzLmdyaWRBUEkuZ2V0X3Jvd19pZChyb3dEYXRhKTtcbiAgICAgICAgICAgIHJlY29yZCA9IHRoaXMucHJvY2Vzc2VkUmVjb3Jkcy5nZXQocm93SUQpO1xuICAgICAgICAgICAgdGhpcy5ncmlkQVBJLmV4cGFuZF9wYXRoX3RvX3JlY29yZChyZWNvcmQpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5wYWdpbmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByb3dJbmRleCA9IHRoaXMucHJvY2Vzc2VkRXhwYW5kZWRGbGF0RGF0YS5pbmRleE9mKHJvd0RhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2UgPSBNYXRoLmZsb29yKHJvd0luZGV4IC8gdGhpcy5wZXJQYWdlKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhZ2UgIT09IHBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXlTY3JvbGxpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhZ2UgPSBwYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWxheVNjcm9sbGluZykge1xuICAgICAgICAgICAgdGhpcy52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5kYXRhQ2hhbmdlZC5waXBlKGZpcnN0KCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxEaXJlY3RpdmUodGhpcy52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lcixcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIChyb3cpID09PSAnbnVtYmVyJyA/IHJvdyA6IHRoaXMudW5waW5uZWREYXRhVmlldy5pbmRleE9mKHJlY29yZCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbERpcmVjdGl2ZSh0aGlzLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgIHR5cGVvZiAocm93KSA9PT0gJ251bWJlcicgPyByb3cgOiB0aGlzLnVucGlubmVkRGF0YVZpZXcuaW5kZXhPZihyZWNvcmQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2Nyb2xsVG9Ib3Jpem9udGFsbHkoY29sdW1uKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgd3JpdGVUb0RhdGEocm93SW5kZXg6IG51bWJlciwgdmFsdWU6IGFueSkge1xuICAgICAgICBtZXJnZU9iamVjdHModGhpcy5mbGF0RGF0YVtyb3dJbmRleF0sIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIG92ZXJyaWRlIGluaXRDb2x1bW5zKGNvbGxlY3Rpb246IElneENvbHVtbkNvbXBvbmVudFtdLCBjYjogKGFyZ3M6IGFueSkgPT4gdm9pZCA9IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29sdW1uTGF5b3V0cykge1xuICAgICAgICAgICAgLy8gaW52YWxpZCBjb25maWd1cmF0aW9uIC0gdHJlZSBncmlkIHNob3VsZCBub3QgYWxsb3cgY29sdW1uIGxheW91dHNcbiAgICAgICAgICAgIC8vIHJlbW92ZSBjb2x1bW4gbGF5b3V0c1xuICAgICAgICAgICAgY29uc3Qgbm9uQ29sdW1uTGF5b3V0Q29sdW1ucyA9IHRoaXMuY29sdW1ucy5maWx0ZXIoKGNvbCkgPT4gIWNvbC5jb2x1bW5MYXlvdXQgJiYgIWNvbC5jb2x1bW5MYXlvdXRDaGlsZCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbHVtbnMobm9uQ29sdW1uTGF5b3V0Q29sdW1ucyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuaW5pdENvbHVtbnMoY29sbGVjdGlvbiwgY2IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHJvdGVjdGVkIG92ZXJyaWRlIGdldEdyb3VwQXJlYUhlaWdodCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlR3JvdXBBcmVhID8gdGhpcy5nZXRDb21wdXRlZEhlaWdodCh0aGlzLnRyZWVHcm91cEFyZWEubmF0aXZlRWxlbWVudCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBBIHJlY3Vyc2l2ZSB3YXkgdG8gZGVzZWxlY3QgYWxsIHNlbGVjdGVkIGNoaWxkcmVuIG9mIGEgZ2l2ZW4gcmVjb3JkXG4gICAgICogQHBhcmFtIHJlY29yZElEIElEIG9mIHRoZSByZWNvcmQgd2hvc2UgY2hpbGRyZW4gdG8gZGVzZWxlY3RcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHJpdmF0ZSBkZXNlbGVjdENoaWxkcmVuKHJlY29yZElEKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkQ2hpbGRyZW4gPSBbXTtcbiAgICAgICAgLy8gRy5FLiBBcHIgMjgsIDIwMjEgIzk0NjUgUmVjb3JkcyB3aGljaCBhcmUgbm90IGluIHZpZXcgY2FuIGFsc28gYmUgc2VsZWN0ZWQgc28gd2UgbmVlZCB0b1xuICAgICAgICAvLyBkZXNlbGVjdCB0aGVtIGFzIHdlbGwsIGhlbmNlIHVzaW5nICdyZWNvcmRzJyBtYXAgaW5zdGVhZCBvZiBnZXRSb3dCeUtleSgpIG1ldGhvZCB3aGljaCB3aWxsXG4gICAgICAgIC8vIHJldHVybiBvbmx5IHJvdyBjb21wb25lbnRzIChpLmUuIHJlY29yZHMgaW4gdmlldykuXG4gICAgICAgIGNvbnN0IHJvd1RvRGVzZWxlY3QgPSB0aGlzLnJlY29yZHMuZ2V0KHJlY29yZElEKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmRlc2VsZWN0Um93c1dpdGhOb0V2ZW50KFtyZWNvcmRJRF0pO1xuICAgICAgICB0aGlzLmdyaWRBUEkuZ2V0X3NlbGVjdGVkX2NoaWxkcmVuKHJvd1RvRGVzZWxlY3QsIHNlbGVjdGVkQ2hpbGRyZW4pO1xuICAgICAgICBpZiAoc2VsZWN0ZWRDaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzZWxlY3RlZENoaWxkcmVuLmZvckVhY2goeCA9PiB0aGlzLmRlc2VsZWN0Q2hpbGRyZW4oeCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhZGRDaGlsZFJvd3MoY2hpbGRyZW46IGFueVtdLCBwYXJlbnRJRDogYW55KSB7XG4gICAgICAgIGlmICh0aGlzLnByaW1hcnlLZXkgJiYgdGhpcy5mb3JlaWduS2V5KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRbdGhpcy5mb3JlaWduS2V5XSA9IHBhcmVudElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kYXRhLnB1c2goLi4uY2hpbGRyZW4pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2hpbGREYXRhS2V5KSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5yZWNvcmRzLmdldChwYXJlbnRJRCk7XG4gICAgICAgICAgICBsZXQgcGFyZW50RGF0YSA9IHBhcmVudC5kYXRhO1xuXG4gICAgICAgICAgICBpZiAodGhpcy50cmFuc2FjdGlvbnMuZW5hYmxlZCAmJiB0aGlzLnRyYW5zYWN0aW9ucy5nZXRBZ2dyZWdhdGVkQ2hhbmdlcyh0cnVlKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gW107XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2gocGFyZW50LmtleSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGNvbGxlY3Rpb24gPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICAgICAgbGV0IHJlY29yZDogYW55O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpZCA9IHBhdGhbaV07XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IGNvbGxlY3Rpb24uZmluZChyID0+IHJbdGhpcy5wcmltYXJ5S2V5XSA9PT0gcGlkKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbiA9IHJlY29yZFt0aGlzLmNoaWxkRGF0YUtleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RGF0YSA9IHJlY29yZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcmVudERhdGFbdGhpcy5jaGlsZERhdGFLZXldID0gY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmNsZWFySGVhZGVyQ0JTdGF0ZSgpO1xuICAgICAgICB0aGlzLnBpcGVUcmlnZ2VyKys7XG4gICAgICAgIGlmICh0aGlzLnJvd1NlbGVjdGlvbiA9PT0gR3JpZFNlbGVjdGlvbk1vZGUubXVsdGlwbGVDYXNjYWRlKSB7XG4gICAgICAgICAgICAvLyBGb3JjZSBwaXBlIHRyaWdnZXJpbmcgZm9yIGJ1aWxkaW5nIHRoZSBkYXRhIHN0cnVjdHVyZVxuICAgICAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU2VydmljZS5pc1Jvd1NlbGVjdGVkKHBhcmVudElEKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5yb3dTZWxlY3Rpb24uZGVsZXRlKHBhcmVudElEKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0Um93c1dpdGhOb0V2ZW50KFtwYXJlbnRJRF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBsb2FkQ2hpbGRyZW5PblJvd0V4cGFuc2lvbihhcmdzOiBJUm93VG9nZ2xlRXZlbnRBcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLmxvYWRDaGlsZHJlbk9uRGVtYW5kKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRJRCA9IGFyZ3Mucm93SUQ7XG5cbiAgICAgICAgICAgIGlmIChhcmdzLmV4cGFuZGVkICYmICF0aGlzLl9leHBhbnNpb25TdGF0ZXMuaGFzKHBhcmVudElEKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZ1Jvd3MuYWRkKHBhcmVudElEKTtcblxuICAgICAgICAgICAgICAgIHRoaXMubG9hZENoaWxkcmVuT25EZW1hbmQocGFyZW50SUQsIGNoaWxkcmVuID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nUm93cy5kZWxldGUocGFyZW50SUQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZENoaWxkUm93cyhjaGlsZHJlbiwgcGFyZW50SUQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUNoYW5nZXMoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlQ2FzY2FkZVNlbGVjdGlvbihldmVudDogSVJvd0RhdGFFdmVudEFyZ3MgfCBTdGF0ZVVwZGF0ZUV2ZW50LCByZWM6IElUcmVlR3JpZFJlY29yZCA9IG51bGwpIHtcbiAgICAgICAgLy8gV2FpdCBmb3IgdGhlIGNoYW5nZSBkZXRlY3Rpb24gdG8gdXBkYXRlIHJlY29yZHMgdGhyb3VnaCB0aGUgcGlwZXNcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChyZWMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWMgPSB0aGlzLmdyaWRBUEkuZ2V0X3JlY19ieV9pZCgoZXZlbnQgYXMgU3RhdGVVcGRhdGVFdmVudCkuYWN0aW9uc1swXS50cmFuc2FjdGlvbi5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVjICYmIHJlYy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWRBUEkuZ3JpZC5zZWxlY3Rpb25TZXJ2aWNlLnVwZGF0ZUNhc2NhZGVTZWxlY3Rpb25PbkZpbHRlckFuZENSVUQoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBTZXQoW3JlYy5wYXJlbnRdKSwgcmVjLnBhcmVudC5rZXlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCI8bmctY29udGVudCBzZWxlY3Q9XCJpZ3gtZ3JpZC10b29sYmFyLGlnYy1ncmlkLXRvb2xiYXJcIj48L25nLWNvbnRlbnQ+XG48bmctY29udGVudCBzZWxlY3Q9XCJpZ3gtdHJlZS1ncmlkLWdyb3VwLWJ5LWFyZWEsaWdjLXRyZWUtZ3JpZC1ncm91cC1ieS1hcmVhXCI+PC9uZy1jb250ZW50PlxuPGlneC1ncmlkLWhlYWRlci1yb3cgY2xhc3M9XCJpZ3gtZ3JpZC10aGVhZFwiIHRhYmluZGV4PVwiMFwiXG4gICAgW2dyaWRdPVwidGhpc1wiXG4gICAgW2hhc01STF09XCJoYXNDb2x1bW5MYXlvdXRzXCJcbiAgICBbYWN0aXZlRGVzY2VuZGFudF09XCJhY3RpdmVEZXNjZW5kYW50XCJcbiAgICBbd2lkdGhdPVwiY2FsY1dpZHRoXCJcbiAgICBbcGlubmVkQ29sdW1uQ29sbGVjdGlvbl09XCJwaW5uZWRDb2x1bW5zXCJcbiAgICBbdW5waW5uZWRDb2x1bW5Db2xsZWN0aW9uXT1cInVucGlubmVkQ29sdW1uc1wiXG4gICAgKGtleWRvd24ubWV0YS5jKT1cImNvcHlIYW5kbGVyKCRldmVudClcIlxuICAgIChrZXlkb3duLmNvbnRyb2wuYyk9XCJjb3B5SGFuZGxlcigkZXZlbnQpXCJcbiAgICAoY29weSk9XCJjb3B5SGFuZGxlcigkZXZlbnQpXCJcbiAgICAoa2V5ZG93bik9XCJuYXZpZ2F0aW9uLmhlYWRlck5hdmlnYXRpb24oJGV2ZW50KVwiXG4gICAgKGZvY3VzKT1cIm5hdmlnYXRpb24uZm9jdXNGaXJzdENlbGwoKVwiXG4+XG48L2lneC1ncmlkLWhlYWRlci1yb3c+XG5cbjxkaXYgaWd4R3JpZEJvZHkgKGtleWRvd24uY29udHJvbC5jKT1cImNvcHlIYW5kbGVyKCRldmVudClcIiAoY29weSk9XCJjb3B5SGFuZGxlcigkZXZlbnQpXCIgY2xhc3M9XCJpZ3gtZ3JpZF9fdGJvZHlcIiByb2xlPVwicm93Z3JvdXBcIj5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Rib2R5LWNvbnRlbnRcIiAgdGFiaW5kZXg9XCIwXCIgKGZvY3VzKT1cIm5hdmlnYXRpb24uZm9jdXNUYm9keSgkZXZlbnQpXCIgKGtleWRvd24pPVwibmF2aWdhdGlvbi5oYW5kbGVOYXZpZ2F0aW9uKCRldmVudClcIlxuICAgIChkcmFnU3RvcCk9XCJzZWxlY3Rpb25TZXJ2aWNlLmRyYWdNb2RlID0gJGV2ZW50XCIgW2F0dHIuYXJpYS1hY3RpdmVkZXNjZW5kYW50XT1cImFjdGl2ZURlc2NlbmRhbnRcIiBbYXR0ci5yb2xlXT1cImRhdGFWaWV3Lmxlbmd0aCA/IG51bGwgOiAncm93J1wiXG4gICAgICAgIChkcmFnU2Nyb2xsKT1cImRyYWdTY3JvbGwoJGV2ZW50KVwiIFtpZ3hHcmlkRHJhZ1NlbGVjdF09XCJzZWxlY3Rpb25TZXJ2aWNlLmRyYWdNb2RlXCJcbiAgICAgICAgW3N0eWxlLmhlaWdodC5weF09J3RvdGFsSGVpZ2h0JyBbc3R5bGUud2lkdGgucHhdPSdjYWxjV2lkdGgnICN0Ym9keSAoc2Nyb2xsKT0ncHJldmVudENvbnRhaW5lclNjcm9sbCgkZXZlbnQpJz5cbiAgICAgICAgPHNwYW4gKm5nSWY9XCJtb3ZpbmcgJiYgY29sdW1uSW5EcmFnICYmIHBpbm5lZENvbHVtbnMubGVuZ3RoIDw9IDBcIlxuICAgICAgICAgICAgW2lneENvbHVtbk1vdmluZ0Ryb3BdPVwiaGVhZGVyQ29udGFpbmVyXCIgW2F0dHIuZHJvcHBhYmxlXT1cInRydWVcIiBpZD1cImxlZnRcIlxuICAgICAgICAgICAgY2xhc3M9XCJpZ3gtZ3JpZF9fc2Nyb2xsLW9uLWRyYWctbGVmdFwiPjwvc3Bhbj5cbiAgICAgICAgPHNwYW4gKm5nSWY9XCJtb3ZpbmcgJiYgY29sdW1uSW5EcmFnICYmIHBpbm5lZENvbHVtbnMubGVuZ3RoID4gMFwiXG4gICAgICAgICAgICBbaWd4Q29sdW1uTW92aW5nRHJvcF09XCJoZWFkZXJDb250YWluZXJcIiBbYXR0ci5kcm9wcGFibGVdPVwidHJ1ZVwiIGlkPVwibGVmdFwiXG4gICAgICAgICAgICBjbGFzcz1cImlneC1ncmlkX19zY3JvbGwtb24tZHJhZy1waW5uZWRcIiBbc3R5bGUubGVmdC5weF09XCJwaW5uZWRXaWR0aFwiPjwvc3Bhbj5cbiAgICAgICAgPG5nLXRlbXBsYXRlICNwaW5uZWRSZWNvcmRzVGVtcGxhdGU+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiZGF0YVxuICAgICAgICAgICAgfCB0cmVlR3JpZFRyYW5zYWN0aW9uOnBpcGVUcmlnZ2VyXG4gICAgICAgICAgICB8IHZpc2libGVDb2x1bW5zOmhhc1Zpc2libGVDb2x1bW5zXG4gICAgICAgICAgICB8IHRyZWVHcmlkTm9ybWFsaXplUmVjb3JkOnBpcGVUcmlnZ2VyXG4gICAgICAgICAgICB8IHRyZWVHcmlkQWRkUm93OnRydWU6cGlwZVRyaWdnZXJcbiAgICAgICAgICAgIHwgZ3JpZFJvd1Bpbm5pbmc6aWQ6dHJ1ZTpwaXBlVHJpZ2dlclxuICAgICAgICAgICAgfCB0cmVlR3JpZEZpbHRlcmluZzpmaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWU6ZmlsdGVyU3RyYXRlZ3k6YWR2YW5jZWRGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWU6cGlwZVRyaWdnZXI6ZmlsdGVyaW5nUGlwZVRyaWdnZXI6dHJ1ZVxuICAgICAgICAgICAgfCB0cmVlR3JpZFNvcnRpbmc6c29ydGluZ0V4cHJlc3Npb25zOnRyZWVHcm91cEFyZWE/LmV4cHJlc3Npb25zOnNvcnRTdHJhdGVneTpwaXBlVHJpZ2dlcjp0cnVlIGFzIHBpbm5lZERhdGFcIj5cbiAgICAgICAgICAgICAgICA8ZGl2ICNwaW5Db250YWluZXIgKm5nSWY9XCJwaW5uZWREYXRhLmxlbmd0aCA+IDBcIlxuICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJ7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaWd4LWdyaWRfX3RyLS1waW5uZWQtYm90dG9tJzogICFpc1Jvd1Bpbm5pbmdUb1RvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpZ3gtZ3JpZF9fdHItLXBpbm5lZC10b3AnOiBpc1Jvd1Bpbm5pbmdUb1RvcFxuICAgICAgICAgICAgICAgICAgICB9XCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJpZ3gtZ3JpZF9fdHItLXBpbm5lZFwiIFtzdHlsZS53aWR0aC5weF09XCJjYWxjV2lkdGhcIj5cbiAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgcm93RGF0YSBvZiBwaW5uZWREYXRhO2xldCByb3dJbmRleCA9IGluZGV4O1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInBpbm5lZF9yZWNvcmRfdGVtcGxhdGU7IGNvbnRleHQ6IGdldENvbnRleHQocm93RGF0YSwgcm93SW5kZXgsIHRydWUpXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImhhc1Bpbm5lZFJlY29yZHMgJiYgaXNSb3dQaW5uaW5nVG9Ub3AgPyBwaW5uZWRSZWNvcmRzVGVtcGxhdGUgOiBudWxsXCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBpZ3hHcmlkRm9yIGxldC1yb3dEYXRhIFtpZ3hHcmlkRm9yT2ZdPVwiZGF0YVxuICAgICAgICB8IHRyZWVHcmlkVHJhbnNhY3Rpb246cGlwZVRyaWdnZXJcbiAgICAgICAgfCB2aXNpYmxlQ29sdW1uczpoYXNWaXNpYmxlQ29sdW1uc1xuICAgICAgICB8IHRyZWVHcmlkSGllcmFyY2hpemluZzpwcmltYXJ5S2V5OmZvcmVpZ25LZXk6Y2hpbGREYXRhS2V5OnBpcGVUcmlnZ2VyXG4gICAgICAgIHwgdHJlZUdyaWRGaWx0ZXJpbmc6ZmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlOmZpbHRlclN0cmF0ZWd5OmFkdmFuY2VkRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlOnBpcGVUcmlnZ2VyOmZpbHRlcmluZ1BpcGVUcmlnZ2VyXG4gICAgICAgIHwgdHJlZUdyaWRTb3J0aW5nOnNvcnRpbmdFeHByZXNzaW9uczp0cmVlR3JvdXBBcmVhPy5leHByZXNzaW9uczpzb3J0U3RyYXRlZ3k6cGlwZVRyaWdnZXJcbiAgICAgICAgfCB0cmVlR3JpZEZsYXR0ZW5pbmc6ZXhwYW5zaW9uRGVwdGg6ZXhwYW5zaW9uU3RhdGVzOnBpcGVUcmlnZ2VyXG4gICAgICAgIHwgdHJlZUdyaWRQYWdpbmc6ISFwYWdpbmF0b3I6cGFnZTpwZXJQYWdlOnBpcGVUcmlnZ2VyXG4gICAgICAgIHwgdHJlZUdyaWRTdW1tYXJ5Omhhc1N1bW1hcml6ZWRDb2x1bW5zOnN1bW1hcnlDYWxjdWxhdGlvbk1vZGU6c3VtbWFyeVBvc2l0aW9uOnNob3dTdW1tYXJ5T25Db2xsYXBzZTpwaXBlVHJpZ2dlcjpzdW1tYXJ5UGlwZVRyaWdnZXJcbiAgICAgICAgfCB0cmVlR3JpZEFkZFJvdzpmYWxzZTpwaXBlVHJpZ2dlclxuICAgICAgICB8IGdyaWRSb3dQaW5uaW5nOmlkOmZhbHNlOnBpcGVUcmlnZ2VyXCJcbiAgICAgICAgICAgIGxldC1yb3dJbmRleD1cImluZGV4XCIgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIid2ZXJ0aWNhbCdcIiBbaWd4Rm9yU2Nyb2xsQ29udGFpbmVyXT0ndmVydGljYWxTY3JvbGwnXG4gICAgICAgICAgICBbaWd4Rm9yQ29udGFpbmVyU2l6ZV09J2NhbGNIZWlnaHQnIFtpZ3hGb3JJdGVtU2l6ZV09XCJyZW5kZXJlZFJvd0hlaWdodFwiICN2ZXJ0aWNhbFNjcm9sbENvbnRhaW5lclxuICAgICAgICAgICAgKGRhdGFDaGFuZ2luZyk9XCJkYXRhUmViaW5kaW5nKCRldmVudClcIiAoZGF0YUNoYW5nZWQpPVwiZGF0YVJlYm91bmQoJGV2ZW50KVwiPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtpZ3hUZW1wbGF0ZU91dGxldF09J2lzU3VtbWFyeVJvdyhyb3dEYXRhKSA/IHN1bW1hcnlfdGVtcGxhdGUgOiByZWNvcmRfdGVtcGxhdGUnXG4gICAgICAgICAgICAgICAgW2lneFRlbXBsYXRlT3V0bGV0Q29udGV4dF09J2dldENvbnRleHQocm93RGF0YSwgcm93SW5kZXgsIGZhbHNlKSdcbiAgICAgICAgICAgICAgICAoY2FjaGVkVmlld0xvYWRlZCk9J2NhY2hlZFZpZXdMb2FkZWQoJGV2ZW50KSc+XG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiaGFzUGlubmVkUmVjb3JkcyAmJiAhaXNSb3dQaW5uaW5nVG9Ub3AgPyBwaW5uZWRSZWNvcmRzVGVtcGxhdGUgOiBudWxsXCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjcmVjb3JkX3RlbXBsYXRlIGxldC1yb3dJbmRleD1cImluZGV4XCIgbGV0LWRpc2FibGVkUm93PVwiZGlzYWJsZWRcIiBsZXQtcm93RGF0YT5cbiAgICAgICAgICAgIDxpZ3gtdHJlZS1ncmlkLXJvdyBbZ3JpZElEXT1cImlkXCIgW2luZGV4XT1cInJvd0luZGV4XCIgW3RyZWVSb3ddPVwicm93RGF0YVwiIFtkaXNhYmxlZF09XCJkaXNhYmxlZFJvd1wiXG4gICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwicm93Q2xhc3NlcyB8IGlneEdyaWRSb3dDbGFzc2VzOnJvdzpyb3cuaW5FZGl0TW9kZTpyb3cuc2VsZWN0ZWQ6cm93LmRpcnR5OnJvdy5kZWxldGVkOnJvdy5kcmFnZ2luZzpyb3dJbmRleDpoYXNDb2x1bW5MYXlvdXRzOnJvdy50cmVlUm93LmlzRmlsdGVyZWRPdXRQYXJlbnQ6cm93RGF0YTpwaXBlVHJpZ2dlclwiXG4gICAgICAgICAgICAgICAgW25nU3R5bGVdPVwicm93U3R5bGVzIHwgaWd4R3JpZFJvd1N0eWxlczpyb3dEYXRhOnJvd0luZGV4OnBpcGVUcmlnZ2VyXCIgI3Jvdz5cbiAgICAgICAgICAgIDwvaWd4LXRyZWUtZ3JpZC1yb3c+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjcGlubmVkX3JlY29yZF90ZW1wbGF0ZSBsZXQtcm93SW5kZXg9XCJpbmRleFwiIGxldC1yb3dEYXRhPlxuICAgICAgICAgICAgPGlneC10cmVlLWdyaWQtcm93IFtncmlkSURdPVwiaWRcIiBbaW5kZXhdPVwicm93SW5kZXhcIiBbdHJlZVJvd109XCJyb3dEYXRhXCJcbiAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJyb3dDbGFzc2VzIHwgaWd4R3JpZFJvd0NsYXNzZXM6cm93OnJvdy5pbkVkaXRNb2RlOnJvdy5zZWxlY3RlZDpyb3cuZGlydHk6cm93LmRlbGV0ZWQ6cm93LmRyYWdnaW5nOnJvd0luZGV4Omhhc0NvbHVtbkxheW91dHM6cm93LnRyZWVSb3cuaXNGaWx0ZXJlZE91dFBhcmVudDpyb3dEYXRhOnBpcGVUcmlnZ2VyXCJcbiAgICAgICAgICAgICAgICBbbmdTdHlsZV09XCJyb3dTdHlsZXMgfCBpZ3hHcmlkUm93U3R5bGVzOnJvd0RhdGE6cm93SW5kZXg6cGlwZVRyaWdnZXJcIiNyb3cgI3Bpbm5lZFJvdz5cbiAgICAgICAgICAgIDwvaWd4LXRyZWUtZ3JpZC1yb3c+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjc3VtbWFyeV90ZW1wbGF0ZSBsZXQtcm93SW5kZXg9XCJpbmRleFwiIGxldC1yb3dEYXRhPlxuICAgICAgICAgICAgPGlneC1ncmlkLXN1bW1hcnktcm93IFtncmlkSURdPVwiaWRcIiBbc3VtbWFyaWVzXT1cInJvd0RhdGEuc3VtbWFyaWVzXCJcbiAgICAgICAgICAgICAgICBbZmlyc3RDZWxsSW5kZW50YXRpb25dPVwicm93RGF0YS5jZWxsSW5kZW50YXRpb25cIiBbaW5kZXhdPVwicm93SW5kZXhcIlxuICAgICAgICAgICAgICAgIGNsYXNzPVwiaWd4LWdyaWRfX3N1bW1hcmllcy0tYm9keVwiIHJvbGU9XCJyb3dcIiAjc3VtbWFyeVJvdz5cbiAgICAgICAgICAgIDwvaWd4LWdyaWQtc3VtbWFyeS1yb3c+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJ0ZW1wbGF0ZTsgY29udGV4dDogeyAkaW1wbGljaXQ6IHRoaXMgfVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Jvdy1lZGl0aW5nLW91dGxldFwiIGlneE92ZXJsYXlPdXRsZXQgI2lneFJvd0VkaXRpbmdPdmVybGF5T3V0bGV0PjwvZGl2PlxuICAgICAgICA8aWdjLXRyaWFsLXdhdGVybWFyaz48L2lnYy10cmlhbC13YXRlcm1hcms+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBpZ3hUb2dnbGUgI2xvYWRpbmdPdmVybGF5PlxuICAgICAgICA8aWd4LWNpcmN1bGFyLWJhciBbaW5kZXRlcm1pbmF0ZV09XCJ0cnVlXCIgKm5nSWY9J3Nob3VsZE92ZXJsYXlMb2FkaW5nJz5cbiAgICAgICAgPC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgIDwvZGl2PlxuICAgIDxzcGFuICpuZ0lmPVwibW92aW5nICYmIGNvbHVtbkluRHJhZ1wiIFtpZ3hDb2x1bW5Nb3ZpbmdEcm9wXT1cImhlYWRlckNvbnRhaW5lclwiIFthdHRyLmRyb3BwYWJsZV09XCJ0cnVlXCJcbiAgICAgICAgaWQ9XCJyaWdodFwiIGNsYXNzPVwiaWd4LWdyaWRfX3Njcm9sbC1vbi1kcmFnLXJpZ2h0XCI+PC9zcGFuPlxuICAgICAgICA8ZGl2IFtoaWRkZW5dPSchaGFzVmVydGljYWxTY3JvbGwoKScgY2xhc3M9XCJpZ3gtZ3JpZF9fdGJvZHktc2Nyb2xsYmFyXCIgW3N0eWxlLndpZHRoLnB4XT1cInNjcm9sbFNpemVcIiAgKHBvaW50ZXJkb3duKT1cIiRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgICAgIFtzdHlsZS5oZWlnaHQucHhdPSdjYWxjSGVpZ2h0Jz5cbiAgICAgICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX190Ym9keS1zY3JvbGxiYXItc3RhcnRcIiBbc3R5bGUuaGVpZ2h0LnB4XT0nIGlzUm93UGlubmluZ1RvVG9wID8gcGlubmVkUm93SGVpZ2h0IDogMCc+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fdGJvZHktc2Nyb2xsYmFyLW1haW5cIiBbc3R5bGUuaGVpZ2h0LnB4XT0nY2FsY0hlaWdodCc+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgaWd4R3JpZEZvciBbaWd4R3JpZEZvck9mXT0nW10nICN2ZXJ0aWNhbFNjcm9sbEhvbGRlcj48L25nLXRlbXBsYXRlPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX190Ym9keS1zY3JvbGxiYXItZW5kXCIgW3N0eWxlLmhlaWdodC5weF09JyFpc1Jvd1Bpbm5pbmdUb1RvcCA/IHBpbm5lZFJvd0hlaWdodCA6IDAnPjwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fYWRkcm93LXNuYWNrYmFyXCI+XG4gICAgICAgIDxpZ3gtc25hY2tiYXIgI2FkZFJvd1NuYWNrYmFyIFtvdXRsZXRdPVwiaWd4Qm9keU92ZXJsYXlPdXRsZXRcIiBbYWN0aW9uVGV4dF09XCJyZXNvdXJjZVN0cmluZ3MuaWd4X2dyaWRfc25hY2tiYXJfYWRkcm93X2FjdGlvbnRleHRcIiBbZGlzcGxheVRpbWVdPSdzbmFja2JhckRpc3BsYXlUaW1lJz57e3Jlc291cmNlU3RyaW5ncy5pZ3hfZ3JpZF9zbmFja2Jhcl9hZGRyb3dfbGFiZWx9fTwvaWd4LXNuYWNrYmFyPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBpZ3hPdmVybGF5T3V0bGV0ICNpZ3hCb2R5T3ZlcmxheU91dGxldD1cIm92ZXJsYXktb3V0bGV0XCI+PC9kaXY+XG48L2Rpdj5cblxuPGRpdiBjbGFzcz1cImlneC1ncmlkX190Zm9vdFwiIHJvbGU9XCJyb3dncm91cFwiIFtzdHlsZS5oZWlnaHQucHhdPSdzdW1tYXJ5Um93SGVpZ2h0JyAjdGZvb3Q+XG4gICAgPGRpdiB0YWJpbmRleD1cIjBcIiAoZm9jdXMpPVwibmF2aWdhdGlvbi5mb2N1c0ZpcnN0Q2VsbChmYWxzZSlcIlxuICAgIChrZXlkb3duKT1cIm5hdmlnYXRpb24uc3VtbWFyeU5hdigkZXZlbnQpXCIgW2F0dHIuYXJpYS1hY3RpdmVkZXNjZW5kYW50XT1cImFjdGl2ZURlc2NlbmRhbnRcIj5cbiAgICAgICAgPGlneC1ncmlkLXN1bW1hcnktcm93IFtzdHlsZS53aWR0aC5weF09J2NhbGNXaWR0aCcgW3N0eWxlLmhlaWdodC5weF09J3N1bW1hcnlSb3dIZWlnaHQnXG4gICAgICAgICAgICAqbmdJZj1cImhhc1N1bW1hcml6ZWRDb2x1bW5zICYmIHJvb3RTdW1tYXJpZXNFbmFibGVkXCIgW2dyaWRJRF09XCJpZFwiIHJvbGU9XCJyb3dcIlxuICAgICAgICAgICAgW3N1bW1hcmllc109XCJpZCB8IGlneEdyaWRTdW1tYXJ5RGF0YVBpcGU6c3VtbWFyeVNlcnZpY2UucmV0cmlnZ2VyUm9vdFBpcGVcIiBbaW5kZXhdPVwiZGF0YVZpZXcubGVuZ3RoXCJcbiAgICAgICAgICAgIGNsYXNzPVwiaWd4LWdyaWRfX3N1bW1hcmllc1wiICNzdW1tYXJ5Um93PlxuICAgICAgICA8L2lneC1ncmlkLXN1bW1hcnktcm93PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX3Rmb290LXRodW1iXCIgW2hpZGRlbl09JyFoYXNWZXJ0aWNhbFNjcm9sbCgpJyBbc3R5bGUuaGVpZ2h0LnB4XT0nc3VtbWFyeVJvd0hlaWdodCdcbiAgICAgICAgICAgIFtzdHlsZS53aWR0aC5weF09XCJzY3JvbGxTaXplXCI+PC9kaXY+XG4gICAgPC9kaXY+XG48L2Rpdj5cblxuPGRpdiBjbGFzcz1cImlneC1ncmlkX19zY3JvbGxcIiBbc3R5bGUuaGVpZ2h0LnB4XT1cInNjcm9sbFNpemVcIiAjc2NyIFtoaWRkZW5dPVwiaXNIb3Jpem9udGFsU2Nyb2xsSGlkZGVuXCIgKHBvaW50ZXJkb3duKT1cIiRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCI+XG4gICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX19zY3JvbGwtc3RhcnRcIiBbc3R5bGUud2lkdGgucHhdPSdpc1Bpbm5pbmdUb1N0YXJ0ID8gcGlubmVkV2lkdGggOiBoZWFkZXJGZWF0dXJlc1dpZHRoJyBbc3R5bGUubWluLXdpZHRoLnB4XT0naXNQaW5uaW5nVG9TdGFydCA/IHBpbm5lZFdpZHRoIDogaGVhZGVyRmVhdHVyZXNXaWR0aCc+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX19zY3JvbGwtbWFpblwiIFtzdHlsZS53aWR0aC5weF09J3VucGlubmVkV2lkdGgnPlxuICAgICAgICA8bmctdGVtcGxhdGUgaWd4R3JpZEZvciBbaWd4R3JpZEZvck9mXT0nW10nICNzY3JvbGxDb250YWluZXI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImlneC1ncmlkX19zY3JvbGwtZW5kXCIgW3N0eWxlLndpZHRoLnB4XT0ncGlubmVkV2lkdGgnIFtzdHlsZS5taW4td2lkdGgucHhdPSdwaW5uZWRXaWR0aCcgW2hpZGRlbl09XCJwaW5uZWRXaWR0aCA9PT0gMCB8fCBpc1Bpbm5pbmdUb1N0YXJ0XCI+PC9kaXY+XG48L2Rpdj5cblxuPGRpdiBjbGFzcz1cImlneC1ncmlkX19mb290ZXJcIiAjZm9vdGVyPlxuICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImlneC1ncmlkLWZvb3RlcixpZ2MtZ3JpZC1mb290ZXJcIj48L25nLWNvbnRlbnQ+XG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiaWd4LXBhZ2luYXRvcixpZ2MtcGFnaW5hdG9yXCI+PC9uZy1jb250ZW50PlxuPC9kaXY+XG5cbjxuZy10ZW1wbGF0ZSAjZW1wdHlGaWx0ZXJlZEdyaWQ+XG4gICAgPHNwYW4gY2xhc3M9XCJpZ3gtZ3JpZF9fdGJvZHktbWVzc2FnZVwiIHJvbGU9XCJjZWxsXCI+XG4gICAgICAgIDxzcGFuPnt7ZW1wdHlGaWx0ZXJlZEdyaWRNZXNzYWdlfX08L3NwYW4+XG4gICAgICAgIDxzcGFuICpuZ0lmPSdzaG93QWRkQnV0dG9uJz5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9J2FkZFJvd0VtcHR5VGVtcGxhdGUgfHwgZGVmYXVsdEFkZFJvd0VtcHR5VGVtcGxhdGUnPjwvbmctY29udGFpbmVyPlxuICAgICAgICA8L3NwYW4+XG4gICAgPC9zcGFuPlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLXRlbXBsYXRlICNkZWZhdWx0RW1wdHlHcmlkPlxuICAgIDxzcGFuIGNsYXNzPVwiaWd4LWdyaWRfX3Rib2R5LW1lc3NhZ2VcIiByb2xlPVwiY2VsbFwiPlxuICAgICAgICA8c3Bhbj57e2VtcHR5R3JpZE1lc3NhZ2V9fTwvc3Bhbj5cbiAgICAgICAgPHNwYW4gKm5nSWY9J3Nob3dBZGRCdXR0b24nPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD0nYWRkUm93RW1wdHlUZW1wbGF0ZSB8fCBkZWZhdWx0QWRkUm93RW1wdHlUZW1wbGF0ZSc+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvc3Bhbj5cbiAgICA8L3NwYW4+XG48L25nLXRlbXBsYXRlPlxuXG48bmctdGVtcGxhdGUgI2RlZmF1bHRBZGRSb3dFbXB0eVRlbXBsYXRlPlxuICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGlneEJ1dHRvbj1cImNvbnRhaW5lZFwiIGlneFJpcHBsZSAoY2xpY2spPVwidGhpcy5jcnVkU2VydmljZS5lbnRlckFkZFJvd01vZGUobnVsbCwgZmFsc2UsICRldmVudClcIj5cbiAgICAgICAge3tyZXNvdXJjZVN0cmluZ3MuaWd4X2dyaWRfYWRkX3Jvd19sYWJlbH19XG4gICAgPC9idXR0b24+XG48L25nLXRlbXBsYXRlPlxuXG48bmctdGVtcGxhdGUgI2RlZmF1bHRMb2FkaW5nR3JpZD5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWRfX2xvYWRpbmdcIj5cbiAgICAgICAgPGlneC1jaXJjdWxhci1iYXIgW2luZGV0ZXJtaW5hdGVdPVwidHJ1ZVwiPlxuICAgICAgICA8L2lneC1jaXJjdWxhci1iYXI+XG4gICAgPC9kaXY+XG48L25nLXRlbXBsYXRlPlxuXG48ZGl2ICpuZ0lmPVwicm93RWRpdGFibGVcIiBpZ3hUb2dnbGUgI3Jvd0VkaXRpbmdPdmVybGF5PlxuICAgIDxkaXYgW2NsYXNzTmFtZV09XCJiYW5uZXJDbGFzc1wiPlxuICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAqbmdUZW1wbGF0ZU91dGxldD1cInJvd0VkaXRDb250YWluZXI7IGNvbnRleHQ6IHsgcm93Q2hhbmdlc0NvdW50OiByb3dDaGFuZ2VzQ291bnQsIGVuZEVkaXQ6IHRoaXMuY3J1ZFNlcnZpY2UuZW5kRWRpdC5iaW5kKHRoaXMpIH1cIj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC9kaXY+XG48L2Rpdj5cblxuPG5nLXRlbXBsYXRlICNkZWZhdWx0Um93RWRpdFRleHQ+XG4gICAge3sgdGhpcy5yZXNvdXJjZVN0cmluZ3MuaWd4X2dyaWRfcm93X2VkaXRfdGV4dCB8IGlneFN0cmluZ1JlcGxhY2U6J3swfSc6cm93Q2hhbmdlc0NvdW50LnRvU3RyaW5nKCkgfCBpZ3hTdHJpbmdSZXBsYWNlOid7MX0nOmhpZGRlbkNvbHVtbnNDb3VudC50b1N0cmluZygpIH19XG48L25nLXRlbXBsYXRlPlxuXG48bmctdGVtcGxhdGUgI2RlZmF1bHRSb3dFZGl0QWN0aW9ucz5cbiAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBpZ3hCdXR0b24gaWd4Um93RWRpdFRhYlN0b3AgKGNsaWNrKT1cInRoaXMuZW5kUm93RWRpdFRhYlN0b3AoZmFsc2UsICRldmVudClcIj57eyB0aGlzLnJlc291cmNlU3RyaW5ncy5pZ3hfZ3JpZF9yb3dfZWRpdF9idG5fY2FuY2VsIH19PC9idXR0b24+XG4gICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgaWd4QnV0dG9uIGlneFJvd0VkaXRUYWJTdG9wIChjbGljayk9XCJ0aGlzLmVuZFJvd0VkaXRUYWJTdG9wKHRydWUsICRldmVudClcIj57eyB0aGlzLnJlc291cmNlU3RyaW5ncy5pZ3hfZ3JpZF9yb3dfZWRpdF9idG5fZG9uZSB9fTwvYnV0dG9uPlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLXRlbXBsYXRlICNkZWZhdWx0Um93RWRpdFRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJpZ3gtYmFubmVyX19tZXNzYWdlXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaWd4LWJhbm5lcl9fdGV4dFwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICAgICAgICpuZ1RlbXBsYXRlT3V0bGV0PVwidGhpcy5jcnVkU2VydmljZS5yb3c/LmdldENsYXNzTmFtZSgpID09PSAnSWd4QWRkUm93JyA/IHJvd0FkZFRleHRUZW1wbGF0ZSA6IHJvd0VkaXRUZXh0VGVtcGxhdGUgPyByb3dFZGl0VGV4dFRlbXBsYXRlIDogZGVmYXVsdFJvd0VkaXRUZXh0O1xuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHsgJGltcGxpY2l0OiB0aGlzLmNydWRTZXJ2aWNlLnJvdz8uZ2V0Q2xhc3NOYW1lKCkgIT09ICdJZ3hBZGRSb3cnID8gcm93Q2hhbmdlc0NvdW50IDogbnVsbCB9XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9zcGFuPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJpZ3gtYmFubmVyX19hY3Rpb25zXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJpZ3gtYmFubmVyX19yb3dcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgICAgICAqbmdUZW1wbGF0ZU91dGxldD1cInJvd0VkaXRBY3Rpb25zVGVtcGxhdGUgPyByb3dFZGl0QWN0aW9uc1RlbXBsYXRlIDogZGVmYXVsdFJvd0VkaXRBY3Rpb25zOyBjb250ZXh0OiB7ICRpbXBsaWNpdDogdGhpcy5lbmRFZGl0LmJpbmQodGhpcykgfVwiPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLXRlbXBsYXRlICNkcmFnSW5kaWNhdG9ySWNvbkJhc2U+XG4gICAgPGlneC1pY29uIGZhbWlseT1cImRlZmF1bHRcIiBuYW1lPVwiZHJhZ19pbmRpY2F0b3JcIj48L2lneC1pY29uPlxuPC9uZy10ZW1wbGF0ZT5cblxuPGlneC1ncmlkLWNvbHVtbi1yZXNpemVyICpuZ0lmPVwiY29sUmVzaXppbmdTZXJ2aWNlLnNob3dSZXNpemVyXCI+PC9pZ3gtZ3JpZC1jb2x1bW4tcmVzaXplcj5cbjxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fbG9hZGluZy1vdXRsZXRcIiAjaWd4TG9hZGluZ092ZXJsYXlPdXRsZXQgaWd4T3ZlcmxheU91dGxldD48L2Rpdj5cbjxkaXYgY2xhc3M9XCJpZ3gtZ3JpZF9fb3V0bGV0XCIgI2lneEZpbHRlcmluZ092ZXJsYXlPdXRsZXQgaWd4T3ZlcmxheU91dGxldD48L2Rpdj5cbkBpZiAocGxhdGZvcm0uaXNFbGVtZW50cykge1xuICAgIDxkaXYgI3Npbmsgc3R5bGU9XCJkaXNwbGF5OiBub25lO1wiPlxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJpZ3gtZ3JpZC1zdGF0ZSxpZ2MtZ3JpZC1zdGF0ZVwiPjwvbmctY29udGVudD5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiaWd4LWNvbHVtbixpZ2MtY29sdW1uLGlneC1jb2x1bW4tZ3JvdXAsaWdjLWNvbHVtbi1ncm91cCxpZ3gtYWN0aW9uLXN0cmlwLGlnYy1hY3Rpb24tc3RyaXBcIj48L25nLWNvbnRlbnQ+XG4gICAgPC9kaXY+XG59XG4iXX0=