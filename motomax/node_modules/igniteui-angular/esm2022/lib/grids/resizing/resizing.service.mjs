import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
/**
 * @hidden
 * @internal
 */
export class IgxColumnResizingService {
    constructor(zone) {
        this.zone = zone;
        /**
         * @hidden
         */
        this.resizeCursor = 'col-resize';
        /**
         * @hidden
         */
        this.showResizer = false;
    }
    /**
     * @hidden
     */
    getColumnHeaderRenderedWidth() {
        return this.column.headerCell.nativeElement.getBoundingClientRect().width;
    }
    /**
     * @hidden
     */
    get resizerHeight() {
        let height = this.column.grid.getVisibleContentHeight();
        // Column height multiplier in case there are Column Layouts. The resizer height need to take into account rowStart.
        let columnHeightMultiplier = 1;
        if (this.column.columnLayoutChild) {
            columnHeightMultiplier = this.column.grid.multiRowLayoutRowSize - this.column.rowStart + 1;
        }
        if (this.column.level !== 0) {
            height -= this.column.topLevelParent.headerGroup.height - this.column.headerGroup.height * columnHeightMultiplier;
        }
        return height;
    }
    /**
     * Returns the minimal possible width to which the column can be resized.
     */
    get restrictResizeMin() {
        const actualWidth = this.getColumnHeaderRenderedWidth();
        const minWidth = this.column.minWidthPx < actualWidth ? this.column.minWidthPx : actualWidth;
        return actualWidth - minWidth;
    }
    /**
     * Returns the maximal possible width to which the column can be resized.
     */
    get restrictResizeMax() {
        const actualWidth = this.getColumnHeaderRenderedWidth();
        const maxWidth = this.column.maxWidthPx;
        if (this.column.maxWidth) {
            return maxWidth - actualWidth;
        }
        else {
            return Number.MAX_SAFE_INTEGER;
        }
    }
    /**
     * Autosizes the column to the longest currently visible cell value, including the header cell.
     * If the column has a predifined maxWidth and the autosized column width will become bigger than it,
     * then the column is sized to its maxWidth.
     */
    autosizeColumnOnDblClick() {
        const currentColWidth = this.getColumnHeaderRenderedWidth();
        this.column.width = this.column.getAutoSize();
        this.zone.run(() => { });
        this.column.grid.columnResized.emit({
            column: this.column,
            prevWidth: currentColWidth.toString(),
            newWidth: this.column.width
        });
    }
    /**
     * Resizes the column regaridng to the column minWidth and maxWidth.
     */
    resizeColumn(event) {
        this.showResizer = false;
        const diff = event.clientX - this.startResizePos;
        const colWidth = this.column.width;
        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        let currentColWidth = parseFloat(colWidth);
        const actualWidth = this.getColumnHeaderRenderedWidth();
        currentColWidth = Number.isNaN(currentColWidth) ? parseFloat(actualWidth) : currentColWidth;
        if (this.column.grid.hasColumnLayouts) {
            this.resizeColumnLayoutFor(this.column, diff);
        }
        else if (isPercentageWidth) {
            this._handlePercentageResize(diff, this.column);
        }
        else {
            this._handlePixelResize(diff, this.column);
        }
        this.zone.run(() => { });
        if (currentColWidth !== parseFloat(this.column.width)) {
            this.column.grid.columnResized.emit({
                column: this.column,
                prevWidth: isPercentageWidth ? currentColWidth + '%' : currentColWidth + 'px',
                newWidth: this.column.width
            });
        }
        this.isColumnResizing = false;
    }
    _handlePixelResize(diff, column) {
        const currentColWidth = parseFloat(column.width);
        const colMinWidth = column.minWidthPx;
        const colMaxWidth = column.maxWidthPx;
        if (currentColWidth + diff < colMinWidth) {
            column.width = colMinWidth + 'px';
        }
        else if (colMaxWidth && (currentColWidth + diff > colMaxWidth)) {
            column.width = colMaxWidth + 'px';
        }
        else {
            column.width = (currentColWidth + diff) + 'px';
        }
    }
    _handlePercentageResize(diff, column) {
        const currentPercentWidth = parseFloat(column.width);
        const gridAvailableSize = column.grid.calcWidth;
        const diffPercentage = (diff / gridAvailableSize) * 100;
        const colMinWidth = column.minWidthPercent;
        const colMaxWidth = column.maxWidthPercent;
        if (currentPercentWidth + diffPercentage < colMinWidth) {
            column.width = colMinWidth + '%';
        }
        else if (colMaxWidth && (currentPercentWidth + diffPercentage > colMaxWidth)) {
            column.width = colMaxWidth + '%';
        }
        else {
            column.width = (currentPercentWidth + diffPercentage) + '%';
        }
    }
    getColMinWidth(column) {
        let currentColWidth = parseFloat(column.width);
        const actualWidth = column.headerCell.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) || (currentColWidth < actualWidth) ? actualWidth : currentColWidth;
        const actualMinWidth = parseFloat(column.minWidth);
        return actualMinWidth < currentColWidth ? actualMinWidth : currentColWidth;
    }
    resizeColumnLayoutFor(column, diff) {
        const relativeColumns = column.getResizableColUnderEnd();
        const combinedSpan = relativeColumns.reduce((acc, col) => acc + col.spanUsed, 0);
        // Resize first those who might reach min/max width
        let columnsToResize = [...relativeColumns];
        let updatedDiff = diff;
        let updatedCombinedSpan = combinedSpan;
        let setMinMaxCols = false;
        do {
            // Cycle them until there are not ones that reach min/max size, because the diff accumulates after each cycle.
            // This is because we can have at first 2 cols reaching min width and then after
            // recalculating the diff there might be 1 more that reaches min width.
            setMinMaxCols = false;
            let newCombinedSpan = updatedCombinedSpan;
            const newColsToResize = [];
            columnsToResize.forEach((col) => {
                const currentResizeWidth = parseFloat(col.target.calcWidth);
                const resizeScaled = (diff / updatedCombinedSpan) * col.target.gridColumnSpan;
                const colWidth = col.target.width;
                const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
                const minWidth = col.target.minWidthPx;
                const maxWidth = col.target.maxWidthPx;
                if (currentResizeWidth + resizeScaled < minWidth) {
                    col.target.width = isPercentageWidth ? col.target.minWidthPercent + '%' : minWidth + 'px';
                    updatedDiff += (currentResizeWidth - minWidth);
                    newCombinedSpan -= col.spanUsed;
                    setMinMaxCols = true;
                }
                else if (maxWidth && (currentResizeWidth + resizeScaled > maxWidth)) {
                    col.target.width = isPercentageWidth ? col.target.maxWidthPercent + '%' : col.target.maxWidthPx + 'px';
                    updatedDiff -= (maxWidth - currentResizeWidth);
                    newCombinedSpan -= col.spanUsed;
                    setMinMaxCols = true;
                }
                else {
                    // Save new ones that can be resized
                    newColsToResize.push(col);
                }
            });
            updatedCombinedSpan = newCombinedSpan;
            columnsToResize = newColsToResize;
        } while (setMinMaxCols);
        // Those left that don't reach min/max size resize them normally.
        columnsToResize.forEach((col) => {
            const resizeScaled = (updatedDiff / updatedCombinedSpan) * col.target.gridColumnSpan;
            const colWidth = col.target.width;
            const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
            if (isPercentageWidth) {
                this._handlePercentageResize(resizeScaled, col.target);
            }
            else {
                this._handlePixelResize(resizeScaled, col.target);
            }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxColumnResizingService, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxColumnResizingService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxColumnResizingService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i0.NgZone }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzaXppbmcuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy9yZXNpemluZy9yZXNpemluZy5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQVUsTUFBTSxlQUFlLENBQUM7O0FBR25EOzs7R0FHRztBQUVILE1BQU0sT0FBTyx3QkFBd0I7SUF1QmpDLFlBQW9CLElBQVk7UUFBWixTQUFJLEdBQUosSUFBSSxDQUFRO1FBYmhDOztXQUVHO1FBQ0ksaUJBQVksR0FBRyxZQUFZLENBQUM7UUFDbkM7O1dBRUc7UUFDSyxnQkFBVyxHQUFHLEtBQUssQ0FBQztJQU1RLENBQUM7SUFFckM7O09BRUc7SUFDSSw0QkFBNEI7UUFDL0IsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxLQUFLLENBQUM7SUFDOUUsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBVyxhQUFhO1FBQ3BCLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLHVCQUF1QixFQUFFLENBQUM7UUFFeEQsb0hBQW9IO1FBQ3BILElBQUksc0JBQXNCLEdBQUcsQ0FBQyxDQUFDO1FBQy9CLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1lBQ2hDLHNCQUFzQixHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLHFCQUFxQixHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQztRQUMvRixDQUFDO1FBRUQsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssS0FBSyxDQUFDLEVBQUUsQ0FBQztZQUMxQixNQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMs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QztvQkFDSixvQ0FBb0M7b0JBQ3BDLGVBQWUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQzlCLENBQUM7WUFDTCxDQUFDLENBQUMsQ0FBQztZQUVILG1CQUFtQixHQUFHLGVBQWUsQ0FBQztZQUN0QyxlQUFlLEdBQUcsZUFBZSxDQUFDO1FBQ3RDLENBQUMsUUFBUSxhQUFhLEVBQUU7UUFFeEIsaUVBQWlFO1FBQ2pFLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtZQUM1QixNQUFNLFlBQVksR0FBRyxDQUFDLFdBQVcsR0FBRyxtQkFBbUIsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDO1lBQ3JGLE1BQU0sUUFBUSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDO1lBQ2xDLE1BQU0saUJBQWlCLEdBQUcsUUFBUSxJQUFJLE9BQU8sUUFBUSxLQUFLLFFBQVEsSUFBSSxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQ25HLElBQUksaUJBQWlCLEVBQUUsQ0FBQztnQkFDcEIsSUFBSSxDQUFDLHVCQUF1QixDQUFDLFlBQVksRUFBRSxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDM0QsQ0FBQztpQkFBTSxDQUFDO2dCQUNKLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxZQUFZLEVBQUUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3RELENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7OEdBN05RLHdCQUF3QjtrSEFBeEIsd0JBQXdCOzsyRkFBeEIsd0JBQXdCO2tCQURwQyxVQUFVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb2x1bW5UeXBlIH0gZnJvbSAnLi4vY29tbW9uL2dyaWQuaW50ZXJmYWNlJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKiBAaW50ZXJuYWxcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIElneENvbHVtblJlc2l6aW5nU2VydmljZSB7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHN0YXJ0UmVzaXplUG9zOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgYSBjb2x1bW4gaXMgY3VycmVudGx5IGJlaW5nIHJlc2l6ZWQuXG4gICAgICovXG4gICAgcHVibGljIGlzQ29sdW1uUmVzaXppbmc6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyByZXNpemVDdXJzb3IgPSAnY29sLXJlc2l6ZSc7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgICBwdWJsaWMgc2hvd1Jlc2l6ZXIgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBUaGUgY29sdW1uIGJlaW5nIHJlc2l6ZWQuXG4gICAgICovXG4gICAgcHVibGljIGNvbHVtbjogQ29sdW1uVHlwZTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgem9uZTogTmdab25lKSB7IH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Q29sdW1uSGVhZGVyUmVuZGVyZWRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uLmhlYWRlckNlbGwubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCByZXNpemVySGVpZ2h0KCk6IG51bWJlciB7XG4gICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLmNvbHVtbi5ncmlkLmdldFZpc2libGVDb250ZW50SGVpZ2h0KCk7XG5cbiAgICAgICAgLy8gQ29sdW1uIGhlaWdodCBtdWx0aXBsaWVyIGluIGNhc2UgdGhlcmUgYXJlIENvbHVtbiBMYXlvdXRzLiBUaGUgcmVzaXplciBoZWlnaHQgbmVlZCB0byB0YWtlIGludG8gYWNjb3VudCByb3dTdGFydC5cbiAgICAgICAgbGV0IGNvbHVtbkhlaWdodE11bHRpcGxpZXIgPSAxO1xuICAgICAgICBpZiAodGhpcy5jb2x1bW4uY29sdW1uTGF5b3V0Q2hpbGQpIHtcbiAgICAgICAgICAgIGNvbHVtbkhlaWdodE11bHRpcGxpZXIgPSB0aGlzLmNvbHVtbi5ncmlkLm11bHRpUm93TGF5b3V0Um93U2l6ZSAtIHRoaXMuY29sdW1uLnJvd1N0YXJ0ICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNvbHVtbi5sZXZlbCAhPT0gMCkge1xuICAgICAgICAgICAgaGVpZ2h0IC09IHRoaXMuY29sdW1uLnRvcExldmVsUGFyZW50LmhlYWRlckdyb3VwLmhlaWdodCAtIHRoaXMuY29sdW1uLmhlYWRlckdyb3VwLmhlaWdodCAqIGNvbHVtbkhlaWdodE11bHRpcGxpZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1pbmltYWwgcG9zc2libGUgd2lkdGggdG8gd2hpY2ggdGhlIGNvbHVtbiBjYW4gYmUgcmVzaXplZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHJlc3RyaWN0UmVzaXplTWluKCk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGFjdHVhbFdpZHRoID0gdGhpcy5nZXRDb2x1bW5IZWFkZXJSZW5kZXJlZFdpZHRoKCk7XG4gICAgICAgIGNvbnN0IG1pbldpZHRoID0gdGhpcy5jb2x1bW4ubWluV2lkdGhQeCA8IGFjdHVhbFdpZHRoID8gdGhpcy5jb2x1bW4ubWluV2lkdGhQeCA6IGFjdHVhbFdpZHRoO1xuXG4gICAgICAgIHJldHVybiBhY3R1YWxXaWR0aCAtIG1pbldpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1heGltYWwgcG9zc2libGUgd2lkdGggdG8gd2hpY2ggdGhlIGNvbHVtbiBjYW4gYmUgcmVzaXplZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHJlc3RyaWN0UmVzaXplTWF4KCk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGFjdHVhbFdpZHRoID0gdGhpcy5nZXRDb2x1bW5IZWFkZXJSZW5kZXJlZFdpZHRoKCk7XG4gICAgICAgIGNvbnN0IG1heFdpZHRoID0gdGhpcy5jb2x1bW4ubWF4V2lkdGhQeDtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uLm1heFdpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF4V2lkdGggLSBhY3R1YWxXaWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF1dG9zaXplcyB0aGUgY29sdW1uIHRvIHRoZSBsb25nZXN0IGN1cnJlbnRseSB2aXNpYmxlIGNlbGwgdmFsdWUsIGluY2x1ZGluZyB0aGUgaGVhZGVyIGNlbGwuXG4gICAgICogSWYgdGhlIGNvbHVtbiBoYXMgYSBwcmVkaWZpbmVkIG1heFdpZHRoIGFuZCB0aGUgYXV0b3NpemVkIGNvbHVtbiB3aWR0aCB3aWxsIGJlY29tZSBiaWdnZXIgdGhhbiBpdCxcbiAgICAgKiB0aGVuIHRoZSBjb2x1bW4gaXMgc2l6ZWQgdG8gaXRzIG1heFdpZHRoLlxuICAgICAqL1xuICAgIHB1YmxpYyBhdXRvc2l6ZUNvbHVtbk9uRGJsQ2xpY2soKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb2xXaWR0aCA9IHRoaXMuZ2V0Q29sdW1uSGVhZGVyUmVuZGVyZWRXaWR0aCgpO1xuICAgICAgICB0aGlzLmNvbHVtbi53aWR0aCA9IHRoaXMuY29sdW1uLmdldEF1dG9TaXplKCk7XG5cbiAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7IH0pO1xuXG4gICAgICAgIHRoaXMuY29sdW1uLmdyaWQuY29sdW1uUmVzaXplZC5lbWl0KHtcbiAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICBwcmV2V2lkdGg6IGN1cnJlbnRDb2xXaWR0aC50b1N0cmluZygpLFxuICAgICAgICAgICAgbmV3V2lkdGg6IHRoaXMuY29sdW1uLndpZHRoXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgdGhlIGNvbHVtbiByZWdhcmlkbmcgdG8gdGhlIGNvbHVtbiBtaW5XaWR0aCBhbmQgbWF4V2lkdGguXG4gICAgICovXG4gICAgcHVibGljIHJlc2l6ZUNvbHVtbihldmVudDogTW91c2VFdmVudCkge1xuICAgICAgICB0aGlzLnNob3dSZXNpemVyID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGRpZmYgPSBldmVudC5jbGllbnRYIC0gdGhpcy5zdGFydFJlc2l6ZVBvcztcblxuICAgICAgICBjb25zdCBjb2xXaWR0aCA9IHRoaXMuY29sdW1uLndpZHRoO1xuICAgICAgICBjb25zdCBpc1BlcmNlbnRhZ2VXaWR0aCA9IGNvbFdpZHRoICYmIHR5cGVvZiBjb2xXaWR0aCA9PT0gJ3N0cmluZycgJiYgY29sV2lkdGguaW5kZXhPZignJScpICE9PSAtMTtcbiAgICAgICAgbGV0IGN1cnJlbnRDb2xXaWR0aCA9IHBhcnNlRmxvYXQoY29sV2lkdGgpO1xuICAgICAgICBjb25zdCBhY3R1YWxXaWR0aCA9IHRoaXMuZ2V0Q29sdW1uSGVhZGVyUmVuZGVyZWRXaWR0aCgpO1xuICAgICAgICBjdXJyZW50Q29sV2lkdGggPSBOdW1iZXIuaXNOYU4oY3VycmVudENvbFdpZHRoKSA/IHBhcnNlRmxvYXQoYWN0dWFsV2lkdGggYXMgYW55KSA6IGN1cnJlbnRDb2xXaWR0aDtcblxuICAgICAgICBpZiAodGhpcy5jb2x1bW4uZ3JpZC5oYXNDb2x1bW5MYXlvdXRzKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZUNvbHVtbkxheW91dEZvcih0aGlzLmNvbHVtbiwgZGlmZik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNQZXJjZW50YWdlV2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZVBlcmNlbnRhZ2VSZXNpemUoZGlmZiwgdGhpcy5jb2x1bW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlUGl4ZWxSZXNpemUoZGlmZiwgdGhpcy5jb2x1bW4pO1xuICAgICAgICB9XG5cblxuICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHsgfSk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRDb2xXaWR0aCAhPT0gcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi53aWR0aCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uLmdyaWQuY29sdW1uUmVzaXplZC5lbWl0KHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgICAgIHByZXZXaWR0aDogaXNQZXJjZW50YWdlV2lkdGggPyBjdXJyZW50Q29sV2lkdGggKyAnJScgOiBjdXJyZW50Q29sV2lkdGggKyAncHgnLFxuICAgICAgICAgICAgICAgIG5ld1dpZHRoOiB0aGlzLmNvbHVtbi53aWR0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzQ29sdW1uUmVzaXppbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2hhbmRsZVBpeGVsUmVzaXplKGRpZmY6IG51bWJlciwgY29sdW1uOiBDb2x1bW5UeXBlKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb2xXaWR0aCA9IHBhcnNlRmxvYXQoY29sdW1uLndpZHRoKTtcbiAgICAgICAgY29uc3QgY29sTWluV2lkdGggPSBjb2x1bW4ubWluV2lkdGhQeDtcbiAgICAgICAgY29uc3QgY29sTWF4V2lkdGggPSBjb2x1bW4ubWF4V2lkdGhQeDtcbiAgICAgICAgaWYgKGN1cnJlbnRDb2xXaWR0aCArIGRpZmYgPCBjb2xNaW5XaWR0aCkge1xuICAgICAgICAgICAgY29sdW1uLndpZHRoID0gY29sTWluV2lkdGggKyAncHgnO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbE1heFdpZHRoICYmIChjdXJyZW50Q29sV2lkdGggKyBkaWZmID4gY29sTWF4V2lkdGgpKSB7XG4gICAgICAgICAgICBjb2x1bW4ud2lkdGggPSBjb2xNYXhXaWR0aCArICdweCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2x1bW4ud2lkdGggPSAoY3VycmVudENvbFdpZHRoICsgZGlmZikgKyAncHgnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9oYW5kbGVQZXJjZW50YWdlUmVzaXplKGRpZmY6IG51bWJlciwgY29sdW1uOiBDb2x1bW5UeXBlKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQZXJjZW50V2lkdGggPSBwYXJzZUZsb2F0KGNvbHVtbi53aWR0aCk7XG4gICAgICAgIGNvbnN0IGdyaWRBdmFpbGFibGVTaXplID0gY29sdW1uLmdyaWQuY2FsY1dpZHRoO1xuXG4gICAgICAgIGNvbnN0IGRpZmZQZXJjZW50YWdlID0gKGRpZmYgLyBncmlkQXZhaWxhYmxlU2l6ZSkgKiAxMDA7XG4gICAgICAgIGNvbnN0IGNvbE1pbldpZHRoID0gY29sdW1uLm1pbldpZHRoUGVyY2VudDtcbiAgICAgICAgY29uc3QgY29sTWF4V2lkdGggPSBjb2x1bW4ubWF4V2lkdGhQZXJjZW50O1xuXG4gICAgICAgIGlmIChjdXJyZW50UGVyY2VudFdpZHRoICsgZGlmZlBlcmNlbnRhZ2UgPCBjb2xNaW5XaWR0aCkge1xuICAgICAgICAgICAgY29sdW1uLndpZHRoID0gY29sTWluV2lkdGggKyAnJSc7XG4gICAgICAgIH0gZWxzZSBpZiAoY29sTWF4V2lkdGggJiYgKGN1cnJlbnRQZXJjZW50V2lkdGggKyBkaWZmUGVyY2VudGFnZSA+IGNvbE1heFdpZHRoKSkge1xuICAgICAgICAgICAgY29sdW1uLndpZHRoID0gY29sTWF4V2lkdGggKyAnJSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2x1bW4ud2lkdGggPSAoY3VycmVudFBlcmNlbnRXaWR0aCArIGRpZmZQZXJjZW50YWdlKSArICclJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXRDb2xNaW5XaWR0aChjb2x1bW46IENvbHVtblR5cGUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRDb2xXaWR0aCA9IHBhcnNlRmxvYXQoY29sdW1uLndpZHRoKTtcbiAgICAgICAgY29uc3QgYWN0dWFsV2lkdGggPSBjb2x1bW4uaGVhZGVyQ2VsbC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICBjdXJyZW50Q29sV2lkdGggPSBOdW1iZXIuaXNOYU4oY3VycmVudENvbFdpZHRoKSB8fCAoY3VycmVudENvbFdpZHRoIDwgYWN0dWFsV2lkdGgpID8gYWN0dWFsV2lkdGggOiBjdXJyZW50Q29sV2lkdGg7XG5cbiAgICAgICAgY29uc3QgYWN0dWFsTWluV2lkdGggPSBwYXJzZUZsb2F0KGNvbHVtbi5taW5XaWR0aCk7XG4gICAgICAgIHJldHVybiBhY3R1YWxNaW5XaWR0aCA8IGN1cnJlbnRDb2xXaWR0aCA/IGFjdHVhbE1pbldpZHRoIDogY3VycmVudENvbFdpZHRoO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCByZXNpemVDb2x1bW5MYXlvdXRGb3IoY29sdW1uOiBDb2x1bW5UeXBlLCBkaWZmOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgcmVsYXRpdmVDb2x1bW5zID0gY29sdW1uLmdldFJlc2l6YWJsZUNvbFVuZGVyRW5kKCk7XG4gICAgICAgIGNvbnN0IGNvbWJpbmVkU3BhbiA9IHJlbGF0aXZlQ29sdW1ucy5yZWR1Y2UoKGFjYywgY29sKSA9PiBhY2MgKyBjb2wuc3BhblVzZWQsIDApO1xuXG4gICAgICAgIC8vIFJlc2l6ZSBmaXJzdCB0aG9zZSB3aG8gbWlnaHQgcmVhY2ggbWluL21heCB3aWR0aFxuICAgICAgICBsZXQgY29sdW1uc1RvUmVzaXplID0gWy4uLnJlbGF0aXZlQ29sdW1uc107XG4gICAgICAgIGxldCB1cGRhdGVkRGlmZiA9IGRpZmY7XG4gICAgICAgIGxldCB1cGRhdGVkQ29tYmluZWRTcGFuID0gY29tYmluZWRTcGFuO1xuICAgICAgICBsZXQgc2V0TWluTWF4Q29scyA9IGZhbHNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBDeWNsZSB0aGVtIHVudGlsIHRoZXJlIGFyZSBub3Qgb25lcyB0aGF0IHJlYWNoIG1pbi9tYXggc2l6ZSwgYmVjYXVzZSB0aGUgZGlmZiBhY2N1bXVsYXRlcyBhZnRlciBlYWNoIGN5Y2xlLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHdlIGNhbiBoYXZlIGF0IGZpcnN0IDIgY29scyByZWFjaGluZyBtaW4gd2lkdGggYW5kIHRoZW4gYWZ0ZXJcbiAgICAgICAgICAgIC8vIHJlY2FsY3VsYXRpbmcgdGhlIGRpZmYgdGhlcmUgbWlnaHQgYmUgMSBtb3JlIHRoYXQgcmVhY2hlcyBtaW4gd2lkdGguXG4gICAgICAgICAgICBzZXRNaW5NYXhDb2xzID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbmV3Q29tYmluZWRTcGFuID0gdXBkYXRlZENvbWJpbmVkU3BhbjtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbHNUb1Jlc2l6ZSA9IFtdO1xuICAgICAgICAgICAgY29sdW1uc1RvUmVzaXplLmZvckVhY2goKGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRSZXNpemVXaWR0aCA9IHBhcnNlRmxvYXQoY29sLnRhcmdldC5jYWxjV2lkdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc2l6ZVNjYWxlZCA9IChkaWZmIC8gdXBkYXRlZENvbWJpbmVkU3BhbikgKiBjb2wudGFyZ2V0LmdyaWRDb2x1bW5TcGFuO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbFdpZHRoID0gY29sLnRhcmdldC53aWR0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1BlcmNlbnRhZ2VXaWR0aCA9IGNvbFdpZHRoICYmIHR5cGVvZiBjb2xXaWR0aCA9PT0gJ3N0cmluZycgJiYgY29sV2lkdGguaW5kZXhPZignJScpICE9PSAtMTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG1pbldpZHRoID0gY29sLnRhcmdldC5taW5XaWR0aFB4O1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heFdpZHRoID0gY29sLnRhcmdldC5tYXhXaWR0aFB4O1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UmVzaXplV2lkdGggKyByZXNpemVTY2FsZWQgPCBtaW5XaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb2wudGFyZ2V0LndpZHRoID0gaXNQZXJjZW50YWdlV2lkdGggPyBjb2wudGFyZ2V0Lm1pbldpZHRoUGVyY2VudCArICclJyA6IG1pbldpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZERpZmYgKz0gKGN1cnJlbnRSZXNpemVXaWR0aCAtIG1pbldpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29tYmluZWRTcGFuIC09IGNvbC5zcGFuVXNlZDtcbiAgICAgICAgICAgICAgICAgICAgc2V0TWluTWF4Q29scyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXhXaWR0aCAmJiAoY3VycmVudFJlc2l6ZVdpZHRoICsgcmVzaXplU2NhbGVkID4gbWF4V2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbC50YXJnZXQud2lkdGggPSBpc1BlcmNlbnRhZ2VXaWR0aCA/IGNvbC50YXJnZXQubWF4V2lkdGhQZXJjZW50ICsgJyUnIDogY29sLnRhcmdldC5tYXhXaWR0aFB4ICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZERpZmYgLT0gKG1heFdpZHRoIC0gY3VycmVudFJlc2l6ZVdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29tYmluZWRTcGFuIC09IGNvbC5zcGFuVXNlZDtcbiAgICAgICAgICAgICAgICAgICAgc2V0TWluTWF4Q29scyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSBuZXcgb25lcyB0aGF0IGNhbiBiZSByZXNpemVkXG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbHNUb1Jlc2l6ZS5wdXNoKGNvbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHVwZGF0ZWRDb21iaW5lZFNwYW4gPSBuZXdDb21iaW5lZFNwYW47XG4gICAgICAgICAgICBjb2x1bW5zVG9SZXNpemUgPSBuZXdDb2xzVG9SZXNpemU7XG4gICAgICAgIH0gd2hpbGUgKHNldE1pbk1heENvbHMpO1xuXG4gICAgICAgIC8vIFRob3NlIGxlZnQgdGhhdCBkb24ndCByZWFjaCBtaW4vbWF4IHNpemUgcmVzaXplIHRoZW0gbm9ybWFsbHkuXG4gICAgICAgIGNvbHVtbnNUb1Jlc2l6ZS5mb3JFYWNoKChjb2wpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc2l6ZVNjYWxlZCA9ICh1cGRhdGVkRGlmZiAvIHVwZGF0ZWRDb21iaW5lZFNwYW4pICogY29sLnRhcmdldC5ncmlkQ29sdW1uU3BhbjtcbiAgICAgICAgICAgIGNvbnN0IGNvbFdpZHRoID0gY29sLnRhcmdldC53aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGlzUGVyY2VudGFnZVdpZHRoID0gY29sV2lkdGggJiYgdHlwZW9mIGNvbFdpZHRoID09PSAnc3RyaW5nJyAmJiBjb2xXaWR0aC5pbmRleE9mKCclJykgIT09IC0xO1xuICAgICAgICAgICAgaWYgKGlzUGVyY2VudGFnZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlUGVyY2VudGFnZVJlc2l6ZShyZXNpemVTY2FsZWQsIGNvbC50YXJnZXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVQaXhlbFJlc2l6ZShyZXNpemVTY2FsZWQsIGNvbC50YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4iXX0=