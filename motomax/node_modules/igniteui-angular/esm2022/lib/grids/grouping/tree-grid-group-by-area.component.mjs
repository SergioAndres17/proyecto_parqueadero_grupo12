import { Component, Input, booleanAttribute, } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { IgxGroupByAreaDirective, IgxGroupByMetaPipe } from './group-by-area.directive';
import { IgxDropDirective } from '../../directives/drag-drop/drag-drop.directive';
import { IgxGroupAreaDropDirective } from '../grid.directives';
import { IgxSuffixDirective } from '../../directives/suffix/suffix.directive';
import { IgxIconComponent } from '../../icon/icon.component';
import { IgxChipComponent } from '../../chips/chip.component';
import { NgFor, NgTemplateOutlet } from '@angular/common';
import { IgxChipsAreaComponent } from '../../chips/chips-area.component';
import * as i0 from "@angular/core";
import * as i1 from "../../core/utils";
/**
 * An internal component representing the group-by drop area for the igx-grid component.
 *
 * @hidden @internal
 */
export class IgxTreeGridGroupByAreaComponent extends IgxGroupByAreaDirective {
    get hideGroupedColumns() {
        return this._hideGroupedColumns;
    }
    set hideGroupedColumns(value) {
        if (this.grid?.columns && this.expressions) {
            this.setColumnsVisibility(value);
        }
        this._hideGroupedColumns = value;
    }
    constructor(differs, ref, platform) {
        super(ref, platform);
        this.differs = differs;
        this._hideGroupedColumns = false;
        this.destroy$ = new Subject();
    }
    ngAfterContentInit() {
        if (this.grid.columns && this.expressions) {
            this.groupingDiffer = this.differs.find(this.expressions).create();
            this.updateColumnsVisibility();
        }
        this.grid.sortingExpressionsChange.pipe(takeUntil(this.destroy$)).subscribe((sortingExpressions) => {
            if (!this.expressions || !this.expressions.length) {
                return;
            }
            let changed = false;
            sortingExpressions.forEach((sortExpr) => {
                const fieldName = sortExpr.fieldName;
                const groupingExpr = this.expressions.find(ex => ex.fieldName === fieldName);
                if (groupingExpr && groupingExpr.dir !== sortExpr.dir) {
                    groupingExpr.dir = sortExpr.dir;
                    changed = true;
                }
            });
            if (changed) {
                this.expressions = [...this.expressions];
            }
        });
    }
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    handleReorder(event) {
        const { chipsArray, originalEvent } = event;
        const newExpressions = this.getReorderedExpressions(chipsArray);
        this.chipExpressions = newExpressions;
        // When reordered using keyboard navigation, we don't have `onMoveEnd` event.
        if (originalEvent instanceof KeyboardEvent) {
            this.expressions = newExpressions;
        }
    }
    handleMoveEnd() {
        this.expressions = this.chipExpressions;
    }
    groupBy(expression) {
        this.expressions.push(expression);
        this.expressions = [...this.expressions];
    }
    clearGrouping(name) {
        this.expressions = this.expressions.filter(item => item.fieldName !== name);
        this.grid.sortingExpressions = this.grid.sortingExpressions.filter(item => item.fieldName !== name);
        this.grid.notifyChanges(true);
    }
    expressionsChanged() {
        this.updateColumnsVisibility();
    }
    updateColumnsVisibility() {
        if (this.groupingDiffer && this.grid.columns && !this.grid.hasColumnLayouts) {
            const changes = this.groupingDiffer.diff(this.expressions);
            if (changes && this.grid.columns.length > 0) {
                changes.forEachAddedItem((rec) => {
                    const col = this.grid.getColumnByName(rec.item.fieldName);
                    col.hidden = this.hideGroupedColumns;
                });
                changes.forEachRemovedItem((rec) => {
                    const col = this.grid.getColumnByName(rec.item.fieldName);
                    col.hidden = false;
                });
            }
        }
    }
    setColumnsVisibility(value) {
        if (this.grid.columns.length > 0 && !this.grid.hasColumnLayouts) {
            this.expressions.forEach((expr) => {
                const col = this.grid.getColumnByName(expr.fieldName);
                col.hidden = value;
            });
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxTreeGridGroupByAreaComponent, deps: [{ token: i0.IterableDiffers }, { token: i0.ElementRef }, { token: i1.PlatformUtil }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "18.2.4", type: IgxTreeGridGroupByAreaComponent, isStandalone: true, selector: "igx-tree-grid-group-by-area", inputs: { hideGroupedColumns: ["hideGroupedColumns", "hideGroupedColumns", booleanAttribute] }, providers: [{ provide: IgxGroupByAreaDirective, useExisting: IgxTreeGridGroupByAreaComponent }], usesInheritance: true, ngImport: i0, template: "<igx-chips-area (reorder)=\"handleReorder($event)\" (moveEnd)=\"handleMoveEnd()\">\n    <ng-container *ngFor=\"let expression of chipExpressions; let last = last;\">\n        <igx-chip\n            [id]=\"expression.fieldName\"\n            [title]=\"(expression.fieldName | igxGroupByMeta:grid:grid.groupablePipeTrigger).title\"\n            [removable]=\"(expression.fieldName | igxGroupByMeta:grid:grid.groupablePipeTrigger).groupable\"\n            [draggable]=\"(expression.fieldName | igxGroupByMeta:grid:grid.groupablePipeTrigger).groupable\"\n            [disabled]=\"!(expression.fieldName | igxGroupByMeta:grid:grid.groupablePipeTrigger).groupable\"\n            (keyDown)=\"handleKeyDown($event.owner.id, $event.originalEvent)\"\n            (remove)=\"clearGrouping($event.owner.id)\"\n            (chipClick)=\"handleClick(expression.fieldName)\"\n        >\n            <span>{{ (expression.fieldName | igxGroupByMeta:grid:grid.groupablePipeTrigger).title }}</span>\n            <igx-icon\n                family=\"default\"\n                [name]=\"expression.dir === 1 ? 'sort_asc' : 'sort_desc'\"\n                igxSuffix>\n            </igx-icon>\n        </igx-chip>\n\n        <span class=\"igx-grid-grouparea__connector\">\n            <igx-icon\n                family=\"default\"\n                name=\"arrow_forward\"\n                [hidden]=\"(last && !dropAreaVisible)\">\n            </igx-icon>\n        </span>\n    </ng-container>\n    <div igxGroupAreaDrop\n        class=\"igx-drop-area\"\n        [attr.gridId]=\"grid.id\"\n        [hidden]=\"!dropAreaVisible\"\n        (igxDrop)=\"onDragDrop($event)\"\n    >\n        <ng-container *ngTemplateOutlet=\"dropAreaTemplate || default\"></ng-container>\n    </div>\n</igx-chips-area>\n\n<ng-template #default>\n    <igx-icon\n        family=\"default\"\n        name=\"group_work\"\n        class=\"igx-drop-area__icon\">\n    </igx-icon>\n    <span class=\"igx-drop-area__text\">{{ dropAreaMessage }}</span>\n</ng-template>\n", dependencies: [{ kind: "component", type: IgxChipsAreaComponent, selector: "igx-chips-area", inputs: ["width", "height"], outputs: ["reorder", "selectionChange", "moveStart", "moveEnd"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: IgxChipComponent, selector: "igx-chip", inputs: ["variant", "id", "tabIndex", "data", "draggable", "animateOnRelease", "hideBaseOnDrag", "removable", "removeIcon", "selectable", "selectIcon", "class", "disabled", "selected", "color", "resourceStrings"], outputs: ["selectedChange", "moveStart", "moveEnd", "remove", "chipClick", "selectedChanging", "selectedChanged", "keyDown", "dragEnter", "dragLeave", "dragOver", "dragDrop"] }, { kind: "component", type: IgxIconComponent, selector: "igx-icon", inputs: ["family", "name", "active"] }, { kind: "directive", type: IgxSuffixDirective, selector: "igx-suffix,[igxSuffix],[igxEnd]" }, { kind: "directive", type: IgxGroupAreaDropDirective, selector: "[igxGroupAreaDrop]" }, { kind: "directive", type: IgxDropDirective, selector: "[igxDrop]", inputs: ["igxDrop", "dropChannel", "dropStrategy"], outputs: ["enter", "over", "leave", "dropped"], exportAs: ["drop"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "pipe", type: IgxGroupByMetaPipe, name: "igxGroupByMeta" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxTreeGridGroupByAreaComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-tree-grid-group-by-area', providers: [{ provide: IgxGroupByAreaDirective, useExisting: IgxTreeGridGroupByAreaComponent }], standalone: true, imports: [IgxChipsAreaComponent, NgFor, IgxChipComponent, IgxIconComponent, IgxSuffixDirective, IgxGroupAreaDropDirective, IgxDropDirective, NgTemplateOutlet, IgxGroupByMetaPipe], template: "<igx-chips-area (reorder)=\"handleReorder($event)\" (moveEnd)=\"handleMoveEnd()\">\n    <ng-container *ngFor=\"let expression of chipExpressions; let last = last;\">\n        <igx-chip\n            [id]=\"expression.fieldName\"\n            [title]=\"(expression.fieldName | igxGroupByMeta:grid:grid.groupablePipeTrigger).title\"\n            [removable]=\"(expression.fieldName | igxGroupByMeta:grid:grid.groupablePipeTrigger).groupable\"\n            [draggable]=\"(expression.fieldName | igxGroupByMeta:grid:grid.groupablePipeTrigger).groupable\"\n            [disabled]=\"!(expression.fieldName | igxGroupByMeta:grid:grid.groupablePipeTrigger).groupable\"\n            (keyDown)=\"handleKeyDown($event.owner.id, $event.originalEvent)\"\n            (remove)=\"clearGrouping($event.owner.id)\"\n            (chipClick)=\"handleClick(expression.fieldName)\"\n        >\n            <span>{{ (expression.fieldName | igxGroupByMeta:grid:grid.groupablePipeTrigger).title }}</span>\n            <igx-icon\n                family=\"default\"\n                [name]=\"expression.dir === 1 ? 'sort_asc' : 'sort_desc'\"\n                igxSuffix>\n            </igx-icon>\n        </igx-chip>\n\n        <span class=\"igx-grid-grouparea__connector\">\n            <igx-icon\n                family=\"default\"\n                name=\"arrow_forward\"\n                [hidden]=\"(last && !dropAreaVisible)\">\n            </igx-icon>\n        </span>\n    </ng-container>\n    <div igxGroupAreaDrop\n        class=\"igx-drop-area\"\n        [attr.gridId]=\"grid.id\"\n        [hidden]=\"!dropAreaVisible\"\n        (igxDrop)=\"onDragDrop($event)\"\n    >\n        <ng-container *ngTemplateOutlet=\"dropAreaTemplate || default\"></ng-container>\n    </div>\n</igx-chips-area>\n\n<ng-template #default>\n    <igx-icon\n        family=\"default\"\n        name=\"group_work\"\n        class=\"igx-drop-area__icon\">\n    </igx-icon>\n    <span class=\"igx-drop-area__text\">{{ dropAreaMessage }}</span>\n</ng-template>\n" }]
        }], ctorParameters: () => [{ type: i0.IterableDiffers }, { type: i0.ElementRef }, { type: i1.PlatformUtil }], propDecorators: { hideGroupedColumns: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1ncmlkLWdyb3VwLWJ5LWFyZWEuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL2dyaWRzL2dyb3VwaW5nL3RyZWUtZ3JpZC1ncm91cC1ieS1hcmVhLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy9ncm91cGluZy9ncm91cC1ieS1hcmVhLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFFSCxTQUFTLEVBRVQsS0FBSyxFQUlMLGdCQUFnQixHQUNuQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQy9CLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUszQyxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUN4RixPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxnREFBZ0QsQ0FBQztBQUNsRixPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUMvRCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSwwQ0FBMEMsQ0FBQztBQUM5RSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUM3RCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUM5RCxPQUFPLEVBQUUsS0FBSyxFQUFFLGdCQUFnQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDMUQsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sa0NBQWtDLENBQUM7OztBQUV6RTs7OztHQUlHO0FBUUgsTUFBTSxPQUFPLCtCQUFnQyxTQUFRLHVCQUF1QjtJQUN4RSxJ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LHlCQUF5QiwrREFBRSxnQkFBZ0IsOEtBQUUsZ0JBQWdCLCtJQUFFLGtCQUFrQjs7MkZBRXhLLCtCQUErQjtrQkFQM0MsU0FBUzsrQkFDSSw2QkFBNkIsYUFFNUIsQ0FBQyxFQUFFLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxXQUFXLGlDQUFpQyxFQUFFLENBQUMsY0FDbkYsSUFBSSxXQUNQLENBQUMscUJBQXFCLEVBQUUsS0FBSyxFQUFFLGdCQUFnQixFQUFFLGdCQUFnQixFQUFFLGtCQUFrQixFQUFFLHlCQUF5QixFQUFFLGdCQUFnQixFQUFFLGdCQUFnQixFQUFFLGtCQUFrQixDQUFDO3dJQUl2SyxrQkFBa0I7c0JBRDVCLEtBQUs7dUJBQUMsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgQ29tcG9uZW50LFxuICAgIEVsZW1lbnRSZWYsXG4gICAgSW5wdXQsXG4gICAgSXRlcmFibGVEaWZmZXIsXG4gICAgSXRlcmFibGVEaWZmZXJzLFxuICAgIE9uRGVzdHJveSxcbiAgICBib29sZWFuQXR0cmlidXRlLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IElDaGlwc0FyZWFSZW9yZGVyRXZlbnRBcmdzIH0gZnJvbSAnLi4vLi4vY2hpcHMvcHVibGljX2FwaSc7XG5pbXBvcnQgeyBQbGF0Zm9ybVV0aWwgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IElHcm91cGluZ0V4cHJlc3Npb24gfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZ3JvdXBpbmctZXhwcmVzc2lvbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSVNvcnRpbmdFeHByZXNzaW9uIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL3NvcnRpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgSWd4R3JvdXBCeUFyZWFEaXJlY3RpdmUsIElneEdyb3VwQnlNZXRhUGlwZSB9IGZyb20gJy4vZ3JvdXAtYnktYXJlYS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSWd4RHJvcERpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvZHJhZy1kcm9wL2RyYWctZHJvcC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSWd4R3JvdXBBcmVhRHJvcERpcmVjdGl2ZSB9IGZyb20gJy4uL2dyaWQuZGlyZWN0aXZlcyc7XG5pbXBvcnQgeyBJZ3hTdWZmaXhEaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL3N1ZmZpeC9zdWZmaXguZGlyZWN0aXZlJztcbmltcG9ydCB7IElneEljb25Db21wb25lbnQgfSBmcm9tICcuLi8uLi9pY29uL2ljb24uY29tcG9uZW50JztcbmltcG9ydCB7IElneENoaXBDb21wb25lbnQgfSBmcm9tICcuLi8uLi9jaGlwcy9jaGlwLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBOZ0ZvciwgTmdUZW1wbGF0ZU91dGxldCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBJZ3hDaGlwc0FyZWFDb21wb25lbnQgfSBmcm9tICcuLi8uLi9jaGlwcy9jaGlwcy1hcmVhLmNvbXBvbmVudCc7XG5cbi8qKlxuICogQW4gaW50ZXJuYWwgY29tcG9uZW50IHJlcHJlc2VudGluZyB0aGUgZ3JvdXAtYnkgZHJvcCBhcmVhIGZvciB0aGUgaWd4LWdyaWQgY29tcG9uZW50LlxuICpcbiAqIEBoaWRkZW4gQGludGVybmFsXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnaWd4LXRyZWUtZ3JpZC1ncm91cC1ieS1hcmVhJyxcbiAgICB0ZW1wbGF0ZVVybDogJ2dyb3VwLWJ5LWFyZWEuY29tcG9uZW50Lmh0bWwnLFxuICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogSWd4R3JvdXBCeUFyZWFEaXJlY3RpdmUsIHVzZUV4aXN0aW5nOiBJZ3hUcmVlR3JpZEdyb3VwQnlBcmVhQ29tcG9uZW50IH1dLFxuICAgIHN0YW5kYWxvbmU6IHRydWUsXG4gICAgaW1wb3J0czogW0lneENoaXBzQXJlYUNvbXBvbmVudCwgTmdGb3IsIElneENoaXBDb21wb25lbnQsIElneEljb25Db21wb25lbnQsIElneFN1ZmZpeERpcmVjdGl2ZSwgSWd4R3JvdXBBcmVhRHJvcERpcmVjdGl2ZSwgSWd4RHJvcERpcmVjdGl2ZSwgTmdUZW1wbGF0ZU91dGxldCwgSWd4R3JvdXBCeU1ldGFQaXBlXVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hUcmVlR3JpZEdyb3VwQnlBcmVhQ29tcG9uZW50IGV4dGVuZHMgSWd4R3JvdXBCeUFyZWFEaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuICAgIEBJbnB1dCh7IHRyYW5zZm9ybTogYm9vbGVhbkF0dHJpYnV0ZSB9KVxuICAgIHB1YmxpYyBnZXQgaGlkZUdyb3VwZWRDb2x1bW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGlkZUdyb3VwZWRDb2x1bW5zO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgaGlkZUdyb3VwZWRDb2x1bW5zKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIGlmICh0aGlzLmdyaWQ/LmNvbHVtbnMgJiYgdGhpcy5leHByZXNzaW9ucykge1xuICAgICAgICAgICAgdGhpcy5zZXRDb2x1bW5zVmlzaWJpbGl0eSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9oaWRlR3JvdXBlZENvbHVtbnMgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9oaWRlR3JvdXBlZENvbHVtbnMgPSBmYWxzZTtcbiAgICBwcml2YXRlIGdyb3VwaW5nRGlmZmVyOiBJdGVyYWJsZURpZmZlcjxJR3JvdXBpbmdFeHByZXNzaW9uPjtcbiAgICBwcml2YXRlIGRlc3Ryb3kkID0gbmV3IFN1YmplY3Q8YW55PigpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBkaWZmZXJzOiBJdGVyYWJsZURpZmZlcnMsIHJlZjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sIHBsYXRmb3JtOiBQbGF0Zm9ybVV0aWwpIHtcbiAgICAgICAgc3VwZXIocmVmLCBwbGF0Zm9ybSk7XG4gICAgfVxuXG4gICAgcHVibGljIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZC5jb2x1bW5zICYmIHRoaXMuZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBpbmdEaWZmZXIgPSB0aGlzLmRpZmZlcnMuZmluZCh0aGlzLmV4cHJlc3Npb25zKS5jcmVhdGUoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29sdW1uc1Zpc2liaWxpdHkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ3JpZC5zb3J0aW5nRXhwcmVzc2lvbnNDaGFuZ2UucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZSgoc29ydGluZ0V4cHJlc3Npb25zOiBJU29ydGluZ0V4cHJlc3Npb25bXSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmV4cHJlc3Npb25zIHx8ICF0aGlzLmV4cHJlc3Npb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgc29ydGluZ0V4cHJlc3Npb25zLmZvckVhY2goKHNvcnRFeHByOiBJU29ydGluZ0V4cHJlc3Npb24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBzb3J0RXhwci5maWVsZE5hbWU7XG4gICAgICAgICAgICAgICAgY29uc3QgZ3JvdXBpbmdFeHByID0gdGhpcy5leHByZXNzaW9ucy5maW5kKGV4ID0+IGV4LmZpZWxkTmFtZSA9PT0gZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBpbmdFeHByICYmIGdyb3VwaW5nRXhwci5kaXIgIT09IHNvcnRFeHByLmRpcikge1xuICAgICAgICAgICAgICAgICAgICBncm91cGluZ0V4cHIuZGlyID0gc29ydEV4cHIuZGlyO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gWy4uLnRoaXMuZXhwcmVzc2lvbnNdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGVzdHJveSQubmV4dCh0cnVlKTtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBoYW5kbGVSZW9yZGVyKGV2ZW50OiBJQ2hpcHNBcmVhUmVvcmRlckV2ZW50QXJncykge1xuICAgICAgICBjb25zdCB7IGNoaXBzQXJyYXksIG9yaWdpbmFsRXZlbnQgfSA9IGV2ZW50O1xuICAgICAgICBjb25zdCBuZXdFeHByZXNzaW9ucyA9IHRoaXMuZ2V0UmVvcmRlcmVkRXhwcmVzc2lvbnMoY2hpcHNBcnJheSk7XG5cbiAgICAgICAgdGhpcy5jaGlwRXhwcmVzc2lvbnMgPSBuZXdFeHByZXNzaW9ucztcblxuICAgICAgICAvLyBXaGVuIHJlb3JkZXJlZCB1c2luZyBrZXlib2FyZCBuYXZpZ2F0aW9uLCB3ZSBkb24ndCBoYXZlIGBvbk1vdmVFbmRgIGV2ZW50LlxuICAgICAgICBpZiAob3JpZ2luYWxFdmVudCBpbnN0YW5jZW9mIEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBuZXdFeHByZXNzaW9ucztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBoYW5kbGVNb3ZlRW5kKCkge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gdGhpcy5jaGlwRXhwcmVzc2lvbnM7XG4gICAgfVxuXG4gICAgcHVibGljIGdyb3VwQnkoZXhwcmVzc2lvbjogSUdyb3VwaW5nRXhwcmVzc2lvbikge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbik7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBbLi4udGhpcy5leHByZXNzaW9uc107XG4gICAgfVxuXG4gICAgcHVibGljIGNsZWFyR3JvdXBpbmcobmFtZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSB0aGlzLmV4cHJlc3Npb25zLmZpbHRlcihpdGVtID0+IGl0ZW0uZmllbGROYW1lICE9PSBuYW1lKTtcbiAgICAgICAgdGhpcy5ncmlkLnNvcnRpbmdFeHByZXNzaW9ucyA9IHRoaXMuZ3JpZC5zb3J0aW5nRXhwcmVzc2lvbnMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5maWVsZE5hbWUgIT09IG5hbWUpO1xuICAgICAgICB0aGlzLmdyaWQubm90aWZ5Q2hhbmdlcyh0cnVlKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgZXhwcmVzc2lvbnNDaGFuZ2VkKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUNvbHVtbnNWaXNpYmlsaXR5KCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVDb2x1bW5zVmlzaWJpbGl0eSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBpbmdEaWZmZXIgJiYgdGhpcy5ncmlkLmNvbHVtbnMgJiYgIXRoaXMuZ3JpZC5oYXNDb2x1bW5MYXlvdXRzKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5ncm91cGluZ0RpZmZlci5kaWZmKHRoaXMuZXhwcmVzc2lvbnMpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMgJiYgdGhpcy5ncmlkLmNvbHVtbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMuZm9yRWFjaEFkZGVkSXRlbSgocmVjKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuZ3JpZC5nZXRDb2x1bW5CeU5hbWUocmVjLml0ZW0uZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29sLmhpZGRlbiA9IHRoaXMuaGlkZUdyb3VwZWRDb2x1bW5zO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNoYW5nZXMuZm9yRWFjaFJlbW92ZWRJdGVtKChyZWMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5ncmlkLmdldENvbHVtbkJ5TmFtZShyZWMuaXRlbS5maWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb2wuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHNldENvbHVtbnNWaXNpYmlsaXR5KHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmdyaWQuY29sdW1ucy5sZW5ndGggPiAwICYmICF0aGlzLmdyaWQuaGFzQ29sdW1uTGF5b3V0cykge1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9ucy5mb3JFYWNoKChleHByKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5ncmlkLmdldENvbHVtbkJ5TmFtZShleHByLmZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgY29sLmhpZGRlbiA9IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbiIsIjxpZ3gtY2hpcHMtYXJlYSAocmVvcmRlcik9XCJoYW5kbGVSZW9yZGVyKCRldmVudClcIiAobW92ZUVuZCk9XCJoYW5kbGVNb3ZlRW5kKClcIj5cbiAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBleHByZXNzaW9uIG9mIGNoaXBFeHByZXNzaW9uczsgbGV0IGxhc3QgPSBsYXN0O1wiPlxuICAgICAgICA8aWd4LWNoaXBcbiAgICAgICAgICAgIFtpZF09XCJleHByZXNzaW9uLmZpZWxkTmFtZVwiXG4gICAgICAgICAgICBbdGl0bGVdPVwiKGV4cHJlc3Npb24uZmllbGROYW1lIHwgaWd4R3JvdXBCeU1ldGE6Z3JpZDpncmlkLmdyb3VwYWJsZVBpcGVUcmlnZ2VyKS50aXRsZVwiXG4gICAgICAgICAgICBbcmVtb3ZhYmxlXT1cIihleHByZXNzaW9uLmZpZWxkTmFtZSB8IGlneEdyb3VwQnlNZXRhOmdyaWQ6Z3JpZC5ncm91cGFibGVQaXBlVHJpZ2dlcikuZ3JvdXBhYmxlXCJcbiAgICAgICAgICAgIFtkcmFnZ2FibGVdPVwiKGV4cHJlc3Npb24uZmllbGROYW1lIHwgaWd4R3JvdXBCeU1ldGE6Z3JpZDpncmlkLmdyb3VwYWJsZVBpcGVUcmlnZ2VyKS5ncm91cGFibGVcIlxuICAgICAgICAgICAgW2Rpc2FibGVkXT1cIiEoZXhwcmVzc2lvbi5maWVsZE5hbWUgfCBpZ3hHcm91cEJ5TWV0YTpncmlkOmdyaWQuZ3JvdXBhYmxlUGlwZVRyaWdnZXIpLmdyb3VwYWJsZVwiXG4gICAgICAgICAgICAoa2V5RG93bik9XCJoYW5kbGVLZXlEb3duKCRldmVudC5vd25lci5pZCwgJGV2ZW50Lm9yaWdpbmFsRXZlbnQpXCJcbiAgICAgICAgICAgIChyZW1vdmUpPVwiY2xlYXJHcm91cGluZygkZXZlbnQub3duZXIuaWQpXCJcbiAgICAgICAgICAgIChjaGlwQ2xpY2spPVwiaGFuZGxlQ2xpY2soZXhwcmVzc2lvbi5maWVsZE5hbWUpXCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPHNwYW4+e3sgKGV4cHJlc3Npb24uZmllbGROYW1lIHwgaWd4R3JvdXBCeU1ldGE6Z3JpZDpncmlkLmdyb3VwYWJsZVBpcGVUcmlnZ2VyKS50aXRsZSB9fTwvc3Bhbj5cbiAgICAgICAgICAgIDxpZ3gtaWNvblxuICAgICAgICAgICAgICAgIGZhbWlseT1cImRlZmF1bHRcIlxuICAgICAgICAgICAgICAgIFtuYW1lXT1cImV4cHJlc3Npb24uZGlyID09PSAxID8gJ3NvcnRfYXNjJyA6ICdzb3J0X2Rlc2MnXCJcbiAgICAgICAgICAgICAgICBpZ3hTdWZmaXg+XG4gICAgICAgICAgICA8L2lneC1pY29uPlxuICAgICAgICA8L2lneC1jaGlwPlxuXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaWd4LWdyaWQtZ3JvdXBhcmVhX19jb25uZWN0b3JcIj5cbiAgICAgICAgICAgIDxpZ3gtaWNvblxuICAgICAgICAgICAgICAgIGZhbWlseT1cImRlZmF1bHRcIlxuICAgICAgICAgICAgICAgIG5hbWU9XCJhcnJvd19mb3J3YXJkXCJcbiAgICAgICAgICAgICAgICBbaGlkZGVuXT1cIihsYXN0ICYmICFkcm9wQXJlYVZpc2libGUpXCI+XG4gICAgICAgICAgICA8L2lneC1pY29uPlxuICAgICAgICA8L3NwYW4+XG4gICAgPC9uZy1jb250YWluZXI+XG4gICAgPGRpdiBpZ3hHcm91cEFyZWFEcm9wXG4gICAgICAgIGNsYXNzPVwiaWd4LWRyb3AtYXJlYVwiXG4gICAgICAgIFthdHRyLmdyaWRJZF09XCJncmlkLmlkXCJcbiAgICAgICAgW2hpZGRlbl09XCIhZHJvcEFyZWFWaXNpYmxlXCJcbiAgICAgICAgKGlneERyb3ApPVwib25EcmFnRHJvcCgkZXZlbnQpXCJcbiAgICA+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJkcm9wQXJlYVRlbXBsYXRlIHx8IGRlZmF1bHRcIj48L25nLWNvbnRhaW5lcj5cbiAgICA8L2Rpdj5cbjwvaWd4LWNoaXBzLWFyZWE+XG5cbjxuZy10ZW1wbGF0ZSAjZGVmYXVsdD5cbiAgICA8aWd4LWljb25cbiAgICAgICAgZmFtaWx5PVwiZGVmYXVsdFwiXG4gICAgICAgIG5hbWU9XCJncm91cF93b3JrXCJcbiAgICAgICAgY2xhc3M9XCJpZ3gtZHJvcC1hcmVhX19pY29uXCI+XG4gICAgPC9pZ3gtaWNvbj5cbiAgICA8c3BhbiBjbGFzcz1cImlneC1kcm9wLWFyZWFfX3RleHRcIj57eyBkcm9wQXJlYU1lc3NhZ2UgfX08L3NwYW4+XG48L25nLXRlbXBsYXRlPlxuIl19