import { CurrencyPipe, formatDate as _formatDate, isPlatformBrowser } from '@angular/common';
import { Inject, Injectable, InjectionToken, PLATFORM_ID, inject } from '@angular/core';
import { mergeWith } from 'lodash-es';
import { Observable } from 'rxjs';
import { setImmediate } from './setImmediate';
import { isDevMode } from '@angular/core';
import * as i0 from "@angular/core";
/** @hidden @internal */
export const ELEMENTS_TOKEN = /*@__PURE__*/ new InjectionToken('elements environment');
/**
 * @hidden
 */
export const showMessage = (message, isMessageShown) => {
    if (!isMessageShown && isDevMode()) {
        console.warn(message);
    }
    return true;
};
export const mkenum = (x) => x;
/**
 *
 * @hidden @internal
 */
export const getResizeObserver = () => globalThis.window?.ResizeObserver;
/**
 * @hidden
 */
export const cloneArray = (array, deep) => {
    const arr = [];
    if (!array) {
        return arr;
    }
    let i = array.length;
    while (i--) {
        arr[i] = deep ? cloneValue(array[i]) : array[i];
    }
    return arr;
};
/**
 * Doesn't clone leaf items
 *
 * @hidden
 */
export const cloneHierarchicalArray = (array, childDataKey) => {
    const result = [];
    if (!array) {
        return result;
    }
    for (const item of array) {
        const clonedItem = cloneValue(item);
        if (Array.isArray(item[childDataKey])) {
            clonedItem[childDataKey] = cloneHierarchicalArray(clonedItem[childDataKey], childDataKey);
        }
        result.push(clonedItem);
    }
    return result;
};
/**
 * Creates an object with prototype from provided source and copies
 * all properties descriptors from provided source
 * @param obj Source to copy prototype and descriptors from
 * @returns New object with cloned prototype and property descriptors
 */
export const copyDescriptors = (obj) => {
    if (obj) {
        return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
    }
};
/**
 * Deep clones all first level keys of Obj2 and merges them to Obj1
 *
 * @param obj1 Object to merge into
 * @param obj2 Object to merge from
 * @returns Obj1 with merged cloned keys from Obj2
 * @hidden
 */
export const mergeObjects = (obj1, obj2) => mergeWith(obj1, obj2, (objValue, srcValue) => {
    if (Array.isArray(srcValue)) {
        return objValue = srcValue;
    }
});
/**
 * Creates deep clone of provided value.
 * Supports primitive values, dates and objects.
 * If passed value is array returns shallow copy of the array.
 *
 * @param value value to clone
 * @returns Deep copy of provided value
 * @hidden
 */
export const cloneValue = (value) => {
    if (isDate(value)) {
        return new Date(value.getTime());
    }
    if (Array.isArray(value)) {
        return [...value];
    }
    if (value instanceof Map || value instanceof Set) {
        return value;
    }
    if (isObject(value)) {
        const result = {};
        for (const key of Object.keys(value)) {
            if (key === "externalObject") {
                continue;
            }
            result[key] = cloneValue(value[key]);
        }
        return result;
    }
    return value;
};
/**
 * Creates deep clone of provided value.
 * Supports primitive values, dates and objects.
 * If passed value is array returns shallow copy of the array.
 * For Objects property values and references are cached and reused.
 * This allows for circular references to same objects.
 *
 * @param value value to clone
 * @param cache map of cached values already parsed
 * @returns Deep copy of provided value
 * @hidden
 */
export const cloneValueCached = (value, cache) => {
    if (isDate(value)) {
        return new Date(value.getTime());
    }
    if (Array.isArray(value)) {
        return [...value];
    }
    if (value instanceof Map || value instanceof Set) {
        return value;
    }
    if (isObject(value)) {
        if (cache.has(value)) {
            return cache.get(value);
        }
        const result = {};
        cache.set(value, result);
        for (const key of Object.keys(value)) {
            result[key] = cloneValueCached(value[key], cache);
        }
        return result;
    }
    return value;
};
/**
 * Parse provided input to Date.
 *
 * @param value input to parse
 * @returns Date if parse succeed or null
 * @hidden
 */
export const parseDate = (value) => {
    // if value is Invalid Date return null
    if (isDate(value)) {
        return !isNaN(value.getTime()) ? value : null;
    }
    return value ? new Date(value) : null;
};
/**
 * Returns an array with unique dates only.
 *
 * @param columnValues collection of date values (might be numbers or ISO 8601 strings)
 * @returns collection of unique dates.
 * @hidden
 */
export const uniqueDates = (columnValues) => columnValues.reduce((a, c) => {
    if (!a.cache[c.label]) {
        a.result.push(c);
    }
    a.cache[c.label] = true;
    return a;
}, { result: [], cache: {} }).result;
/**
 * Checks if provided variable is Object
 *
 * @param value Value to check
 * @returns true if provided variable is Object
 * @hidden
 */
export const isObject = (value) => !!(value && value.toString() === '[object Object]');
/**
 * Checks if provided variable is Date
 *
 * @param value Value to check
 * @returns true if provided variable is Date
 * @hidden
 */
export const isDate = (value) => value instanceof Date;
/**
 * Checks if the two passed arguments are equal
 * Currently supports date objects
 *
 * @param obj1
 * @param obj2
 * @returns: `boolean`
 * @hidden
 */
export const isEqual = (obj1, obj2) => {
    if (isDate(obj1) && isDate(obj2)) {
        return obj1.getTime() === obj2.getTime();
    }
    return obj1 === obj2;
};
/**
 * Utility service taking care of various utility functions such as
 * detecting browser features, general cross browser DOM manipulation, etc.
 *
 * @hidden @internal
 */
export class PlatformUtil {
    constructor(platformId) {
        this.platformId = platformId;
        this.isBrowser = isPlatformBrowser(this.platformId);
        this.isIOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window);
        this.isSafari = this.isBrowser && /Safari[\/\s](\d+\.\d+)/.test(navigator.userAgent);
        this.isFirefox = this.isBrowser && /Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent);
        this.isEdge = this.isBrowser && /Edge[\/\s](\d+\.\d+)/.test(navigator.userAgent);
        this.isChromium = this.isBrowser && (/Chrom|e?ium/g.test(navigator.userAgent) ||
            /Google Inc/g.test(navigator.vendor)) && !/Edge/g.test(navigator.userAgent);
        this.browserVersion = this.isBrowser ? parseFloat(navigator.userAgent.match(/Version\/([\d.]+)/)?.at(1)) : 0;
        /** @hidden @internal */
        this.isElements = inject(ELEMENTS_TOKEN, { optional: true });
        this.KEYMAP = mkenum({
            ENTER: 'Enter',
            SPACE: ' ',
            ESCAPE: 'Escape',
            ARROW_DOWN: 'ArrowDown',
            ARROW_UP: 'ArrowUp',
            ARROW_LEFT: 'ArrowLeft',
            ARROW_RIGHT: 'ArrowRight',
            END: 'End',
            HOME: 'Home',
            PAGE_DOWN: 'PageDown',
            PAGE_UP: 'PageUp',
            F2: 'F2',
            TAB: 'Tab',
            SEMICOLON: ';',
            // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values#editing_keys
            DELETE: 'Delete',
            BACKSPACE: 'Backspace',
            CONTROL: 'Control',
            X: 'x',
            Y: 'y',
            Z: 'z'
        });
    }
    /**
     * @hidden @internal
     * Returns the actual size of the node content, using Range
     * ```typescript
     * let range = document.createRange();
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     *
     * let size = getNodeSizeViaRange(range, column.cells[0].nativeElement);
     *
     * @remarks
     * The last parameter is useful when the size of the element to measure is modified by a
     * parent element that has explicit size. In such cases the calculated size is never lower
     * and the function may instead remove the parent size while measuring to get the correct value.
     * ```
     */
    getNodeSizeViaRange(range, node, sizeHoldingNode) {
        let overflow = null;
        let nodeStyles;
        if (!this.isFirefox) {
            overflow = node.style.overflow;
            // we need that hack - otherwise content won't be measured correctly in IE/Edge
            node.style.overflow = 'visible';
        }
        if (sizeHoldingNode) {
            const style = sizeHoldingNode.style;
            nodeStyles = [style.width, style.minWidth, style.flexBasis];
            style.width = '';
            style.minWidth = '';
            style.flexBasis = '';
        }
        range.selectNodeContents(node);
        const scale = node.getBoundingClientRect().width / node.offsetWidth;
        const width = range.getBoundingClientRect().width / scale;
        if (!this.isFirefox) {
            // we need that hack - otherwise content won't be measured correctly in IE/Edge
            node.style.overflow = overflow;
        }
        if (sizeHoldingNode) {
            sizeHoldingNode.style.width = nodeStyles[0];
            sizeHoldingNode.style.minWidth = nodeStyles[1];
            sizeHoldingNode.style.flexBasis = nodeStyles[2];
        }
        return width;
    }
    /**
     * Returns true if the current keyboard event is an activation key (Enter/Space bar)
     *
     * @hidden
     * @internal
     *
     * @memberof PlatformUtil
     */
    isActivationKey(event) {
        return event.key === this.KEYMAP.ENTER || event.key === this.KEYMAP.SPACE;
    }
    /**
     * Returns true if the current keyboard event is a combination that closes the filtering UI of the grid. (Escape/Ctrl+Shift+L)
     *
     * @hidden
     * @internal
     * @param event
     * @memberof PlatformUtil
     */
    isFilteringKeyCombo(event) {
        return event.key === this.KEYMAP.ESCAPE || (event.ctrlKey && event.shiftKey && event.key.toLowerCase() === 'l');
    }
    /**
     * @hidden @internal
     */
    isLeftClick(event) {
        return event.button === 0;
    }
    /**
     * @hidden @internal
     */
    isNavigationKey(key) {
        return [
            this.KEYMAP.HOME, this.KEYMAP.END, this.KEYMAP.SPACE,
            this.KEYMAP.ARROW_DOWN, this.KEYMAP.ARROW_LEFT, this.KEYMAP.ARROW_RIGHT, this.KEYMAP.ARROW_UP
        ].includes(key);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: PlatformUtil, deps: [{ token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: PlatformUtil, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: PlatformUtil, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }] });
/**
 * @hidden
 */
export const flatten = (arr) => {
    let result = [];
    arr.forEach(el => {
        result.push(el);
        if (el.children) {
            const children = Array.isArray(el.children) ? el.children : el.children.toArray();
            result = result.concat(flatten(children));
        }
    });
    return result;
};
export const HORIZONTAL_NAV_KEYS = new Set(['arrowleft', 'left', 'arrowright', 'right', 'home', 'end']);
export const NAVIGATION_KEYS = new Set([
    'down',
    'up',
    'left',
    'right',
    'arrowdown',
    'arrowup',
    'arrowleft',
    'arrowright',
    'home',
    'end',
    'space',
    'spacebar',
    ' '
]);
export const ACCORDION_NAVIGATION_KEYS = new Set('up down arrowup arrowdown home end'.split(' '));
export const ROW_EXPAND_KEYS = new Set('right down arrowright arrowdown'.split(' '));
export const ROW_COLLAPSE_KEYS = new Set('left up arrowleft arrowup'.split(' '));
export const ROW_ADD_KEYS = new Set(['+', 'add', '≠', '±', '=']);
export const SUPPORTED_KEYS = new Set([...Array.from(NAVIGATION_KEYS),
    ...Array.from(ROW_ADD_KEYS), 'enter', 'f2', 'escape', 'esc', 'pagedown', 'pageup']);
export const HEADER_KEYS = new Set([...Array.from(NAVIGATION_KEYS), 'escape', 'esc', 'l',
    /** This symbol corresponds to the Alt + L combination under MAC. */
    '¬']);
/**
 * @hidden
 * @internal
 *
 * Creates a new ResizeObserver on `target` and returns it as an Observable.
 * Run the resizeObservable outside angular zone, because it patches the MutationObserver which causes an infinite loop.
 * Related issue: https://github.com/angular/angular/issues/31712
 */
export const resizeObservable = (target) => new Observable((observer) => {
    const instance = new (getResizeObserver())((entries) => {
        observer.next(entries);
    });
    instance.observe(target);
    const unsubscribe = () => instance.disconnect();
    return unsubscribe;
});
/**
 * @hidden
 * @internal
 *
 * Compares two maps.
 */
export const compareMaps = (map1, map2) => {
    if (!map2) {
        return !map1 ? true : false;
    }
    if (map1.size !== map2.size) {
        return false;
    }
    let match = true;
    const keys = Array.from(map2.keys());
    for (const key of keys) {
        if (map1.has(key)) {
            match = map1.get(key) === map2.get(key);
        }
        else {
            match = false;
        }
        if (!match) {
            break;
        }
    }
    return match;
};
/**
 *
 * Given a property access path in the format `x.y.z` resolves and returns
 * the value of the `z` property in the passed object.
 *
 * @hidden
 * @internal
 */
export const resolveNestedPath = (obj, path) => {
    const parts = path?.split('.') ?? [];
    let current = obj[parts.shift()];
    parts.forEach(prop => {
        if (current) {
            current = current[prop];
        }
    });
    return current;
};
/**
 *
 * Given a property access path in the format `x.y.z` and a value
 * this functions builds and returns an object following the access path.
 *
 * @example
 * ```typescript
 * console.log('x.y.z.', 42);
 * >> { x: { y: { z: 42 } } }
 * ```
 *
 * @hidden
 * @internal
 */
export const reverseMapper = (path, value) => {
    const obj = {};
    const parts = path?.split('.') ?? [];
    let _prop = parts.shift();
    let mapping;
    // Initial binding for first level bindings
    obj[_prop] = value;
    mapping = obj;
    parts.forEach(prop => {
        // Start building the hierarchy
        mapping[_prop] = {};
        // Go down a level
        mapping = mapping[_prop];
        // Bind the value and move the key
        mapping[prop] = value;
        _prop = prop;
    });
    return obj;
};
export const yieldingLoop = (count, chunkSize, callback, done) => {
    let i = 0;
    const chunk = () => {
        const end = Math.min(i + chunkSize, count);
        for (; i < end; ++i) {
            callback(i);
        }
        if (i < count) {
            setImmediate(chunk);
        }
        else {
            done();
        }
    };
    chunk();
};
export const isConstructor = (ref) => typeof ref === 'function' && Boolean(ref.prototype) && Boolean(ref.prototype.constructor);
/**
 * Similar to Angular's formatDate. However it will not throw on `undefined | null | ''` instead
 * coalescing to an empty string.
 */
export const formatDate = (value, format, locale, timezone) => {
    if (value === null || value === undefined || value === '') {
        return '';
    }
    return _formatDate(value, format, locale, timezone);
};
export const formatCurrency = new CurrencyPipe(undefined).transform;
/** Converts pixel values to their rem counterparts for a base value */
export const rem = (value) => {
    const base = parseFloat(globalThis.window?.getComputedStyle(globalThis.document?.documentElement).getPropertyValue('--ig-base-font-size'));
    return Number(value) / base;
};
/** Get the size of the component as derived from the CSS size variable */
export function getComponentSize(el) {
    return globalThis.window?.getComputedStyle(el).getPropertyValue('--component-size');
}
/** Get the first item in an array */
export function first(arr) {
    return arr.at(0);
}
/** Get the last item in an array */
export function last(arr) {
    return arr.at(-1);
}
/** Calculates the modulo of two numbers, ensuring a non-negative result. */
export function modulo(n, d) {
    return ((n % d) + d) % d;
}
/**
 * Splits an array into chunks of length `size` and returns a generator
 * yielding each chunk.
 * The last chunk may contain less than `size` elements.
 *
 * @example
 * ```typescript
 * const arr = [0,1,2,3,4,5,6,7,8,9];
 *
 * Array.from(chunk(arr, 2)) // [[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]
 * Array.from(chunk(arr, 3)) // [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]
 * Array.from(chunk([], 3)) // []
 * Array.from(chunk(arr, -3)) // Error
 * ```
 */
export function* intoChunks(arr, size) {
    if (size < 1) {
        throw new Error('size must be an integer >= 1');
    }
    for (let i = 0; i < arr.length; i += size) {
        yield arr.slice(i, i + size);
    }
}
/**
 * @param size
 * @returns string that represents the --component-size default value
 */
export function getComponentCssSizeVar(size) {
    switch (size) {
        case "1":
            return 'var(--ig-size, var(--ig-size-small))';
        case "2":
            return 'var(--ig-size, var(--ig-size-medium))';
        case "3":
        default:
            return 'var(--ig-size, var(--ig-size-large))';
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvY29yZS91dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsWUFBWSxFQUFFLFVBQVUsSUFBSSxXQUFXLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUM3RixPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxjQUFjLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN4RixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDbEMsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzlDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7O0FBRTFDLHdCQUF3QjtBQUN4QixNQUFNLENBQUMsTUFBTSxjQUFjLEdBQUcsYUFBYSxDQUFBLElBQUksY0FBYyxDQUFVLHNCQUFzQixDQUFDLENBQUM7QUFFL0Y7O0dBRUc7QUFDSCxNQUFNLENBQUMsTUFBTSxXQUFXLEdBQUcsQ0FBQyxPQUFlLEVBQUUsY0FBdUIsRUFBVyxFQUFFO0lBQzdFLElBQUksQ0FBQyxjQUFjLElBQUksU0FBUyxFQUFFLEVBQUUsQ0FBQztRQUNqQyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFFRCxPQUFPLElBQUksQ0FBQztBQUNoQixDQUFDLENBQUM7QUFFRixNQUFNLENBQUMsTUFBTSxNQUFNLEdBQUcsQ0FBcUQsQ0FBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFFdEY7OztHQUdHO0FBQ0gsTUFBTSxDQUFDLE1BQU0saUJBQWlCLEdBQUcsR0FBRyxFQUFFLENBQUMsVUFBVSxDQUFDLE1B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YXRlLCBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBQTEFURk9STV9JRCwgaW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBtZXJnZVdpdGggfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgc2V0SW1tZWRpYXRlIH0gZnJvbSAnLi9zZXRJbW1lZGlhdGUnO1xuaW1wb3J0IHsgaXNEZXZNb2RlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IEVMRU1FTlRTX1RPS0VOID0gLypAX19QVVJFX18qL25ldyBJbmplY3Rpb25Ub2tlbjxib29sZWFuPignZWxlbWVudHMgZW52aXJvbm1lbnQnKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjb25zdCBzaG93TWVzc2FnZSA9IChtZXNzYWdlOiBzdHJpbmcsIGlzTWVzc2FnZVNob3duOiBib29sZWFuKTogYm9vbGVhbiA9PiB7XG4gICAgaWYgKCFpc01lc3NhZ2VTaG93biAmJiBpc0Rldk1vZGUoKSkge1xuICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5leHBvcnQgY29uc3QgbWtlbnVtID0gPFQgZXh0ZW5kcyB7IFtpbmRleDogc3RyaW5nXTogVSB9LCBVIGV4dGVuZHMgc3RyaW5nPih4OiBUKSA9PiB4O1xuXG4vKipcbiAqXG4gKiBAaGlkZGVuIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY29uc3QgZ2V0UmVzaXplT2JzZXJ2ZXIgPSAoKSA9PiBnbG9iYWxUaGlzLndpbmRvdz8uUmVzaXplT2JzZXJ2ZXI7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY29uc3QgY2xvbmVBcnJheSA9IChhcnJheTogYW55W10sIGRlZXA/OiBib29sZWFuKSA9PiB7XG4gICAgY29uc3QgYXJyID0gW107XG4gICAgaWYgKCFhcnJheSkge1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgICBsZXQgaSA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGFycltpXSA9IGRlZXAgPyBjbG9uZVZhbHVlKGFycmF5W2ldKSA6IGFycmF5W2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufTtcblxuLyoqXG4gKiBEb2Vzbid0IGNsb25lIGxlYWYgaXRlbXNcbiAqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjb25zdCBjbG9uZUhpZXJhcmNoaWNhbEFycmF5ID0gKGFycmF5OiBhbnlbXSwgY2hpbGREYXRhS2V5OiBhbnkpOiBhbnlbXSA9PiB7XG4gICAgY29uc3QgcmVzdWx0OiBhbnlbXSA9IFtdO1xuICAgIGlmICghYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyYXkpIHtcbiAgICAgICAgY29uc3QgY2xvbmVkSXRlbSA9IGNsb25lVmFsdWUoaXRlbSk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1bY2hpbGREYXRhS2V5XSkpIHtcbiAgICAgICAgICAgIGNsb25lZEl0ZW1bY2hpbGREYXRhS2V5XSA9IGNsb25lSGllcmFyY2hpY2FsQXJyYXkoY2xvbmVkSXRlbVtjaGlsZERhdGFLZXldLCBjaGlsZERhdGFLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKGNsb25lZEl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHByb3RvdHlwZSBmcm9tIHByb3ZpZGVkIHNvdXJjZSBhbmQgY29waWVzXG4gKiBhbGwgcHJvcGVydGllcyBkZXNjcmlwdG9ycyBmcm9tIHByb3ZpZGVkIHNvdXJjZVxuICogQHBhcmFtIG9iaiBTb3VyY2UgdG8gY29weSBwcm90b3R5cGUgYW5kIGRlc2NyaXB0b3JzIGZyb21cbiAqIEByZXR1cm5zIE5ldyBvYmplY3Qgd2l0aCBjbG9uZWQgcHJvdG90eXBlIGFuZCBwcm9wZXJ0eSBkZXNjcmlwdG9yc1xuICovXG5leHBvcnQgY29uc3QgY29weURlc2NyaXB0b3JzID0gKG9iaikgPT4ge1xuICAgIGlmIChvYmopIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUoXG4gICAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSxcbiAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iailcbiAgICAgICAgKTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBEZWVwIGNsb25lcyBhbGwgZmlyc3QgbGV2ZWwga2V5cyBvZiBPYmoyIGFuZCBtZXJnZXMgdGhlbSB0byBPYmoxXG4gKlxuICogQHBhcmFtIG9iajEgT2JqZWN0IHRvIG1lcmdlIGludG9cbiAqIEBwYXJhbSBvYmoyIE9iamVjdCB0byBtZXJnZSBmcm9tXG4gKiBAcmV0dXJucyBPYmoxIHdpdGggbWVyZ2VkIGNsb25lZCBrZXlzIGZyb20gT2JqMlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY29uc3QgbWVyZ2VPYmplY3RzID0gKG9iajE6IGFueSwgb2JqMjogYW55KTogYW55ID0+IG1lcmdlV2l0aChvYmoxLCBvYmoyLCAob2JqVmFsdWUsIHNyY1ZhbHVlKSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3JjVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBvYmpWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIENyZWF0ZXMgZGVlcCBjbG9uZSBvZiBwcm92aWRlZCB2YWx1ZS5cbiAqIFN1cHBvcnRzIHByaW1pdGl2ZSB2YWx1ZXMsIGRhdGVzIGFuZCBvYmplY3RzLlxuICogSWYgcGFzc2VkIHZhbHVlIGlzIGFycmF5IHJldHVybnMgc2hhbGxvdyBjb3B5IG9mIHRoZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgdmFsdWUgdG8gY2xvbmVcbiAqIEByZXR1cm5zIERlZXAgY29weSBvZiBwcm92aWRlZCB2YWx1ZVxuICogQGhpZGRlblxuICovXG5leHBvcnQgY29uc3QgY2xvbmVWYWx1ZSA9ICh2YWx1ZTogYW55KTogYW55ID0+IHtcbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUuZ2V0VGltZSgpKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBbLi4udmFsdWVdO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fCB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwiZXh0ZXJuYWxPYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBjbG9uZVZhbHVlKHZhbHVlW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBkZWVwIGNsb25lIG9mIHByb3ZpZGVkIHZhbHVlLlxuICogU3VwcG9ydHMgcHJpbWl0aXZlIHZhbHVlcywgZGF0ZXMgYW5kIG9iamVjdHMuXG4gKiBJZiBwYXNzZWQgdmFsdWUgaXMgYXJyYXkgcmV0dXJucyBzaGFsbG93IGNvcHkgb2YgdGhlIGFycmF5LlxuICogRm9yIE9iamVjdHMgcHJvcGVydHkgdmFsdWVzIGFuZCByZWZlcmVuY2VzIGFyZSBjYWNoZWQgYW5kIHJldXNlZC5cbiAqIFRoaXMgYWxsb3dzIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIHRvIHNhbWUgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgdmFsdWUgdG8gY2xvbmVcbiAqIEBwYXJhbSBjYWNoZSBtYXAgb2YgY2FjaGVkIHZhbHVlcyBhbHJlYWR5IHBhcnNlZFxuICogQHJldHVybnMgRGVlcCBjb3B5IG9mIHByb3ZpZGVkIHZhbHVlXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjb25zdCBjbG9uZVZhbHVlQ2FjaGVkID0gKHZhbHVlOiBhbnksIGNhY2hlOiBNYXA8YW55LCBhbnk+KTogYW55ID0+IHtcbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUuZ2V0VGltZSgpKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBbLi4udmFsdWVdO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fCB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBpZiAoY2FjaGUuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlLmdldCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgY2FjaGUuc2V0KHZhbHVlLCByZXN1bHQpO1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHZhbHVlKSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBjbG9uZVZhbHVlQ2FjaGVkKHZhbHVlW2tleV0sIGNhY2hlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFBhcnNlIHByb3ZpZGVkIGlucHV0IHRvIERhdGUuXG4gKlxuICogQHBhcmFtIHZhbHVlIGlucHV0IHRvIHBhcnNlXG4gKiBAcmV0dXJucyBEYXRlIGlmIHBhcnNlIHN1Y2NlZWQgb3IgbnVsbFxuICogQGhpZGRlblxuICovXG5leHBvcnQgY29uc3QgcGFyc2VEYXRlID0gKHZhbHVlOiBhbnkpOiBEYXRlIHwgbnVsbCA9PiB7XG4gICAgLy8gaWYgdmFsdWUgaXMgSW52YWxpZCBEYXRlIHJldHVybiBudWxsXG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICFpc05hTih2YWx1ZS5nZXRUaW1lKCkpID8gdmFsdWUgOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgPyBuZXcgRGF0ZSh2YWx1ZSkgOiBudWxsO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IHdpdGggdW5pcXVlIGRhdGVzIG9ubHkuXG4gKlxuICogQHBhcmFtIGNvbHVtblZhbHVlcyBjb2xsZWN0aW9uIG9mIGRhdGUgdmFsdWVzIChtaWdodCBiZSBudW1iZXJzIG9yIElTTyA4NjAxIHN0cmluZ3MpXG4gKiBAcmV0dXJucyBjb2xsZWN0aW9uIG9mIHVuaXF1ZSBkYXRlcy5cbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNvbnN0IHVuaXF1ZURhdGVzID0gKGNvbHVtblZhbHVlczogYW55W10pID0+IGNvbHVtblZhbHVlcy5yZWR1Y2UoKGEsIGMpID0+IHtcbiAgICBpZiAoIWEuY2FjaGVbYy5sYWJlbF0pIHtcbiAgICAgICAgYS5yZXN1bHQucHVzaChjKTtcbiAgICB9XG4gICAgYS5jYWNoZVtjLmxhYmVsXSA9IHRydWU7XG4gICAgcmV0dXJuIGE7XG59LCB7IHJlc3VsdDogW10sIGNhY2hlOiB7fSB9KS5yZXN1bHQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHByb3ZpZGVkIHZhcmlhYmxlIGlzIE9iamVjdFxuICpcbiAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byBjaGVja1xuICogQHJldHVybnMgdHJ1ZSBpZiBwcm92aWRlZCB2YXJpYWJsZSBpcyBPYmplY3RcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzT2JqZWN0ID0gKHZhbHVlOiBhbnkpOiBib29sZWFuID0+ICEhKHZhbHVlICYmIHZhbHVlLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE9iamVjdF0nKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgcHJvdmlkZWQgdmFyaWFibGUgaXMgRGF0ZVxuICpcbiAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byBjaGVja1xuICogQHJldHVybnMgdHJ1ZSBpZiBwcm92aWRlZCB2YXJpYWJsZSBpcyBEYXRlXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjb25zdCBpc0RhdGUgPSAodmFsdWU6IGFueSk6IHZhbHVlIGlzIERhdGUgPT4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlO1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgdHdvIHBhc3NlZCBhcmd1bWVudHMgYXJlIGVxdWFsXG4gKiBDdXJyZW50bHkgc3VwcG9ydHMgZGF0ZSBvYmplY3RzXG4gKlxuICogQHBhcmFtIG9iajFcbiAqIEBwYXJhbSBvYmoyXG4gKiBAcmV0dXJuczogYGJvb2xlYW5gXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjb25zdCBpc0VxdWFsID0gKG9iajEsIG9iajIpOiBib29sZWFuID0+IHtcbiAgICBpZiAoaXNEYXRlKG9iajEpICYmIGlzRGF0ZShvYmoyKSkge1xuICAgICAgICByZXR1cm4gb2JqMS5nZXRUaW1lKCkgPT09IG9iajIuZ2V0VGltZSgpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqMSA9PT0gb2JqMjtcbn07XG5cbi8qKlxuICogVXRpbGl0eSBzZXJ2aWNlIHRha2luZyBjYXJlIG9mIHZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgc3VjaCBhc1xuICogZGV0ZWN0aW5nIGJyb3dzZXIgZmVhdHVyZXMsIGdlbmVyYWwgY3Jvc3MgYnJvd3NlciBET00gbWFuaXB1bGF0aW9uLCBldGMuXG4gKlxuICogQGhpZGRlbiBAaW50ZXJuYWxcbiAqL1xuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBQbGF0Zm9ybVV0aWwge1xuICAgIHB1YmxpYyBpc0Jyb3dzZXI6IGJvb2xlYW4gPSBpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpO1xuICAgIHB1YmxpYyBpc0lPUyA9IHRoaXMuaXNCcm93c2VyICYmIC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICEoJ01TU3RyZWFtJyBpbiB3aW5kb3cpO1xuICAgIHB1YmxpYyBpc1NhZmFyaSA9IHRoaXMuaXNCcm93c2VyICYmIC9TYWZhcmlbXFwvXFxzXShcXGQrXFwuXFxkKykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgcHVibGljIGlzRmlyZWZveCA9IHRoaXMuaXNCcm93c2VyICYmIC9GaXJlZm94W1xcL1xcc10oXFxkK1xcLlxcZCspLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIHB1YmxpYyBpc0VkZ2UgPSB0aGlzLmlzQnJvd3NlciAmJiAvRWRnZVtcXC9cXHNdKFxcZCtcXC5cXGQrKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICBwdWJsaWMgaXNDaHJvbWl1bSA9IHRoaXMuaXNCcm93c2VyICYmICgvQ2hyb218ZT9pdW0vZy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpIHx8XG4gICAgICAgIC9Hb29nbGUgSW5jL2cudGVzdChuYXZpZ2F0b3IudmVuZG9yKSkgJiYgIS9FZGdlL2cudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICBwdWJsaWMgYnJvd3NlclZlcnNpb24gPSB0aGlzLmlzQnJvd3NlciA/IHBhcnNlRmxvYXQobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVmVyc2lvblxcLyhbXFxkLl0rKS8pPy5hdCgxKSkgOiAwO1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGlzRWxlbWVudHMgPSBpbmplY3QoRUxFTUVOVFNfVE9LRU4sIHsgb3B0aW9uYWw6IHRydWUgfSk7XG5cbiAgICBwdWJsaWMgS0VZTUFQID0gbWtlbnVtKHtcbiAgICAgICAgRU5URVI6ICdFbnRlcicsXG4gICAgICAgIFNQQUNFOiAnICcsXG4gICAgICAgIEVTQ0FQRTogJ0VzY2FwZScsXG4gICAgICAgIEFSUk9XX0RPV046ICdBcnJvd0Rvd24nLFxuICAgICAgICBBUlJPV19VUDogJ0Fycm93VXAnLFxuICAgICAgICBBUlJPV19MRUZUOiAnQXJyb3dMZWZ0JyxcbiAgICAgICAgQVJST1dfUklHSFQ6ICdBcnJvd1JpZ2h0JyxcbiAgICAgICAgRU5EOiAnRW5kJyxcbiAgICAgICAgSE9NRTogJ0hvbWUnLFxuICAgICAgICBQQUdFX0RPV046ICdQYWdlRG93bicsXG4gICAgICAgIFBBR0VfVVA6ICdQYWdlVXAnLFxuICAgICAgICBGMjogJ0YyJyxcbiAgICAgICAgVEFCOiAnVGFiJyxcbiAgICAgICAgU0VNSUNPTE9OOiAnOycsXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L2tleS9LZXlfVmFsdWVzI2VkaXRpbmdfa2V5c1xuICAgICAgICBERUxFVEU6ICdEZWxldGUnLFxuICAgICAgICBCQUNLU1BBQ0U6ICdCYWNrc3BhY2UnLFxuICAgICAgICBDT05UUk9MOiAnQ29udHJvbCcsXG4gICAgICAgIFg6ICd4JyxcbiAgICAgICAgWTogJ3knLFxuICAgICAgICBaOiAneidcbiAgICB9KTtcblxuICAgIGNvbnN0cnVjdG9yKEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgcGxhdGZvcm1JZDogYW55KSB7IH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogUmV0dXJucyB0aGUgYWN0dWFsIHNpemUgb2YgdGhlIG5vZGUgY29udGVudCwgdXNpbmcgUmFuZ2VcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgKiBsZXQgY29sdW1uID0gdGhpcy5ncmlkLmNvbHVtbkxpc3QuZmlsdGVyKGMgPT4gYy5maWVsZCA9PT0gJ0lEJylbMF07XG4gICAgICpcbiAgICAgKiBsZXQgc2l6ZSA9IGdldE5vZGVTaXplVmlhUmFuZ2UocmFuZ2UsIGNvbHVtbi5jZWxsc1swXS5uYXRpdmVFbGVtZW50KTtcbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGxhc3QgcGFyYW1ldGVyIGlzIHVzZWZ1bCB3aGVuIHRoZSBzaXplIG9mIHRoZSBlbGVtZW50IHRvIG1lYXN1cmUgaXMgbW9kaWZpZWQgYnkgYVxuICAgICAqIHBhcmVudCBlbGVtZW50IHRoYXQgaGFzIGV4cGxpY2l0IHNpemUuIEluIHN1Y2ggY2FzZXMgdGhlIGNhbGN1bGF0ZWQgc2l6ZSBpcyBuZXZlciBsb3dlclxuICAgICAqIGFuZCB0aGUgZnVuY3Rpb24gbWF5IGluc3RlYWQgcmVtb3ZlIHRoZSBwYXJlbnQgc2l6ZSB3aGlsZSBtZWFzdXJpbmcgdG8gZ2V0IHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXROb2RlU2l6ZVZpYVJhbmdlKHJhbmdlOiBSYW5nZSwgbm9kZTogSFRNTEVsZW1lbnQsIHNpemVIb2xkaW5nTm9kZT86IEhUTUxFbGVtZW50KSB7XG4gICAgICAgIGxldCBvdmVyZmxvdyA9IG51bGw7XG4gICAgICAgIGxldCBub2RlU3R5bGVzO1xuXG4gICAgICAgIGlmICghdGhpcy5pc0ZpcmVmb3gpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID0gbm9kZS5zdHlsZS5vdmVyZmxvdztcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhhdCBoYWNrIC0gb3RoZXJ3aXNlIGNvbnRlbnQgd29uJ3QgYmUgbWVhc3VyZWQgY29ycmVjdGx5IGluIElFL0VkZ2VcbiAgICAgICAgICAgIG5vZGUuc3R5bGUub3ZlcmZsb3cgPSAndmlzaWJsZSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2l6ZUhvbGRpbmdOb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBzdHlsZSA9IHNpemVIb2xkaW5nTm9kZS5zdHlsZTtcbiAgICAgICAgICAgIG5vZGVTdHlsZXMgPSBbc3R5bGUud2lkdGgsIHN0eWxlLm1pbldpZHRoLCBzdHlsZS5mbGV4QmFzaXNdO1xuICAgICAgICAgICAgc3R5bGUud2lkdGggPSAnJztcbiAgICAgICAgICAgIHN0eWxlLm1pbldpZHRoID0gJyc7XG4gICAgICAgICAgICBzdHlsZS5mbGV4QmFzaXMgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhub2RlKTtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC8gbm9kZS5vZmZzZXRXaWR0aDtcbiAgICAgICAgY29uc3Qgd2lkdGggPSByYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAvIHNjYWxlO1xuXG4gICAgICAgIGlmICghdGhpcy5pc0ZpcmVmb3gpIHtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhhdCBoYWNrIC0gb3RoZXJ3aXNlIGNvbnRlbnQgd29uJ3QgYmUgbWVhc3VyZWQgY29ycmVjdGx5IGluIElFL0VkZ2VcbiAgICAgICAgICAgIG5vZGUuc3R5bGUub3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaXplSG9sZGluZ05vZGUpIHtcbiAgICAgICAgICAgIHNpemVIb2xkaW5nTm9kZS5zdHlsZS53aWR0aCA9IG5vZGVTdHlsZXNbMF07XG4gICAgICAgICAgICBzaXplSG9sZGluZ05vZGUuc3R5bGUubWluV2lkdGggPSBub2RlU3R5bGVzWzFdO1xuICAgICAgICAgICAgc2l6ZUhvbGRpbmdOb2RlLnN0eWxlLmZsZXhCYXNpcyA9IG5vZGVTdHlsZXNbMl07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQga2V5Ym9hcmQgZXZlbnQgaXMgYW4gYWN0aXZhdGlvbiBrZXkgKEVudGVyL1NwYWNlIGJhcilcbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQbGF0Zm9ybVV0aWxcbiAgICAgKi9cbiAgICBwdWJsaWMgaXNBY3RpdmF0aW9uS2V5KGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudC5rZXkgPT09IHRoaXMuS0VZTUFQLkVOVEVSIHx8IGV2ZW50LmtleSA9PT0gdGhpcy5LRVlNQVAuU1BBQ0U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IGtleWJvYXJkIGV2ZW50IGlzIGEgY29tYmluYXRpb24gdGhhdCBjbG9zZXMgdGhlIGZpbHRlcmluZyBVSSBvZiB0aGUgZ3JpZC4gKEVzY2FwZS9DdHJsK1NoaWZ0K0wpXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICogQG1lbWJlcm9mIFBsYXRmb3JtVXRpbFxuICAgICAqL1xuICAgIHB1YmxpYyBpc0ZpbHRlcmluZ0tleUNvbWJvKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudC5rZXkgPT09IHRoaXMuS0VZTUFQLkVTQ0FQRSB8fCAoZXZlbnQuY3RybEtleSAmJiBldmVudC5zaGlmdEtleSAmJiBldmVudC5rZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2wnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBpc0xlZnRDbGljayhldmVudDogUG9pbnRlckV2ZW50IHwgTW91c2VFdmVudCkge1xuICAgICAgICByZXR1cm4gZXZlbnQuYnV0dG9uID09PSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGlzTmF2aWdhdGlvbktleShrZXk6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGhpcy5LRVlNQVAuSE9NRSwgdGhpcy5LRVlNQVAuRU5ELCB0aGlzLktFWU1BUC5TUEFDRSxcbiAgICAgICAgICAgIHRoaXMuS0VZTUFQLkFSUk9XX0RPV04sIHRoaXMuS0VZTUFQLkFSUk9XX0xFRlQsIHRoaXMuS0VZTUFQLkFSUk9XX1JJR0hULCB0aGlzLktFWU1BUC5BUlJPV19VUFxuICAgICAgICBdLmluY2x1ZGVzKGtleSBhcyBhbnkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjb25zdCBmbGF0dGVuID0gKGFycjogYW55W10pID0+IHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG5cbiAgICBhcnIuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGVsKTtcbiAgICAgICAgaWYgKGVsLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IEFycmF5LmlzQXJyYXkoZWwuY2hpbGRyZW4pID8gZWwuY2hpbGRyZW4gOiBlbC5jaGlsZHJlbi50b0FycmF5KCk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGZsYXR0ZW4oY2hpbGRyZW4pKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIENhbmNlbGFibGVFdmVudEFyZ3Mge1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIHRoZSBhYmlsaXR5IHRvIGNhbmNlbCB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgY2FuY2VsOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElCYXNlRXZlbnRBcmdzIHtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyByZWZlcmVuY2UgdG8gdGhlIG93bmVyIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBvd25lcj86IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYW5jZWxhYmxlQnJvd3NlckV2ZW50QXJncyBleHRlbmRzIENhbmNlbGFibGVFdmVudEFyZ3Mge1xuICAgIC8qIGJsYXpvclN1cHByZXNzICovXG4gICAgLyoqIEJyb3dzZXIgZXZlbnQgKi9cbiAgICBldmVudD86IEV2ZW50O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElCYXNlQ2FuY2VsYWJsZUJyb3dzZXJFdmVudEFyZ3MgZXh0ZW5kcyBDYW5jZWxhYmxlQnJvd3NlckV2ZW50QXJncywgSUJhc2VFdmVudEFyZ3MgeyB9XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUJhc2VDYW5jZWxhYmxlRXZlbnRBcmdzIGV4dGVuZHMgQ2FuY2VsYWJsZUV2ZW50QXJncywgSUJhc2VFdmVudEFyZ3MgeyB9XG5cbmV4cG9ydCBjb25zdCBIT1JJWk9OVEFMX05BVl9LRVlTID0gbmV3IFNldChbJ2Fycm93bGVmdCcsICdsZWZ0JywgJ2Fycm93cmlnaHQnLCAncmlnaHQnLCAnaG9tZScsICdlbmQnXSk7XG5cbmV4cG9ydCBjb25zdCBOQVZJR0FUSU9OX0tFWVMgPSBuZXcgU2V0KFtcbiAgICAnZG93bicsXG4gICAgJ3VwJyxcbiAgICAnbGVmdCcsXG4gICAgJ3JpZ2h0JyxcbiAgICAnYXJyb3dkb3duJyxcbiAgICAnYXJyb3d1cCcsXG4gICAgJ2Fycm93bGVmdCcsXG4gICAgJ2Fycm93cmlnaHQnLFxuICAgICdob21lJyxcbiAgICAnZW5kJyxcbiAgICAnc3BhY2UnLFxuICAgICdzcGFjZWJhcicsXG4gICAgJyAnXG5dKTtcbmV4cG9ydCBjb25zdCBBQ0NPUkRJT05fTkFWSUdBVElPTl9LRVlTID0gbmV3IFNldCgndXAgZG93biBhcnJvd3VwIGFycm93ZG93biBob21lIGVuZCcuc3BsaXQoJyAnKSk7XG5leHBvcnQgY29uc3QgUk9XX0VYUEFORF9LRVlTID0gbmV3IFNldCgncmlnaHQgZG93biBhcnJvd3JpZ2h0IGFycm93ZG93bicuc3BsaXQoJyAnKSk7XG5leHBvcnQgY29uc3QgUk9XX0NPTExBUFNFX0tFWVMgPSBuZXcgU2V0KCdsZWZ0IHVwIGFycm93bGVmdCBhcnJvd3VwJy5zcGxpdCgnICcpKTtcbmV4cG9ydCBjb25zdCBST1dfQUREX0tFWVMgPSBuZXcgU2V0KFsnKycsICdhZGQnLCAn4omgJywgJ8KxJywgJz0nXSk7XG5leHBvcnQgY29uc3QgU1VQUE9SVEVEX0tFWVMgPSBuZXcgU2V0KFsuLi5BcnJheS5mcm9tKE5BVklHQVRJT05fS0VZUyksXG4uLi5BcnJheS5mcm9tKFJPV19BRERfS0VZUyksICdlbnRlcicsICdmMicsICdlc2NhcGUnLCAnZXNjJywgJ3BhZ2Vkb3duJywgJ3BhZ2V1cCddKTtcbmV4cG9ydCBjb25zdCBIRUFERVJfS0VZUyA9IG5ldyBTZXQoWy4uLkFycmF5LmZyb20oTkFWSUdBVElPTl9LRVlTKSwgJ2VzY2FwZScsICdlc2MnLCAnbCcsXG4gICAgLyoqIFRoaXMgc3ltYm9sIGNvcnJlc3BvbmRzIHRvIHRoZSBBbHQgKyBMIGNvbWJpbmF0aW9uIHVuZGVyIE1BQy4gKi9cbiAgICAnwqwnXSk7XG5cbi8qKlxuICogQGhpZGRlblxuICogQGludGVybmFsXG4gKlxuICogQ3JlYXRlcyBhIG5ldyBSZXNpemVPYnNlcnZlciBvbiBgdGFyZ2V0YCBhbmQgcmV0dXJucyBpdCBhcyBhbiBPYnNlcnZhYmxlLlxuICogUnVuIHRoZSByZXNpemVPYnNlcnZhYmxlIG91dHNpZGUgYW5ndWxhciB6b25lLCBiZWNhdXNlIGl0IHBhdGNoZXMgdGhlIE11dGF0aW9uT2JzZXJ2ZXIgd2hpY2ggY2F1c2VzIGFuIGluZmluaXRlIGxvb3AuXG4gKiBSZWxhdGVkIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8zMTcxMlxuICovXG5leHBvcnQgY29uc3QgcmVzaXplT2JzZXJ2YWJsZSA9ICh0YXJnZXQ6IEhUTUxFbGVtZW50KTogT2JzZXJ2YWJsZTxSZXNpemVPYnNlcnZlckVudHJ5W10+ID0+IG5ldyBPYnNlcnZhYmxlKChvYnNlcnZlcikgPT4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IChnZXRSZXNpemVPYnNlcnZlcigpKSgoZW50cmllczogUmVzaXplT2JzZXJ2ZXJFbnRyeVtdKSA9PiB7XG4gICAgICAgIG9ic2VydmVyLm5leHQoZW50cmllcyk7XG4gICAgfSk7XG4gICAgaW5zdGFuY2Uub2JzZXJ2ZSh0YXJnZXQpO1xuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gKCkgPT4gaW5zdGFuY2UuZGlzY29ubmVjdCgpO1xuICAgIHJldHVybiB1bnN1YnNjcmliZTtcbn0pO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqIEBpbnRlcm5hbFxuICpcbiAqIENvbXBhcmVzIHR3byBtYXBzLlxuICovXG5leHBvcnQgY29uc3QgY29tcGFyZU1hcHMgPSAobWFwMTogTWFwPGFueSwgYW55PiwgbWFwMjogTWFwPGFueSwgYW55Pik6IGJvb2xlYW4gPT4ge1xuICAgIGlmICghbWFwMikge1xuICAgICAgICByZXR1cm4gIW1hcDEgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuICAgIGlmIChtYXAxLnNpemUgIT09IG1hcDIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBtYXRjaCA9IHRydWU7XG4gICAgY29uc3Qga2V5cyA9IEFycmF5LmZyb20obWFwMi5rZXlzKCkpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgaWYgKG1hcDEuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIG1hdGNoID0gbWFwMS5nZXQoa2V5KSA9PT0gbWFwMi5nZXQoa2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoO1xufTtcblxuLyoqXG4gKlxuICogR2l2ZW4gYSBwcm9wZXJ0eSBhY2Nlc3MgcGF0aCBpbiB0aGUgZm9ybWF0IGB4LnkuemAgcmVzb2x2ZXMgYW5kIHJldHVybnNcbiAqIHRoZSB2YWx1ZSBvZiB0aGUgYHpgIHByb3BlcnR5IGluIHRoZSBwYXNzZWQgb2JqZWN0LlxuICpcbiAqIEBoaWRkZW5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY29uc3QgcmVzb2x2ZU5lc3RlZFBhdGggPSAob2JqOiBhbnksIHBhdGg6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHBhcnRzID0gcGF0aD8uc3BsaXQoJy4nKSA/PyBbXTtcbiAgICBsZXQgY3VycmVudCA9IG9ialtwYXJ0cy5zaGlmdCgpXTtcblxuICAgIHBhcnRzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFtwcm9wXTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGN1cnJlbnQ7XG59O1xuXG4vKipcbiAqXG4gKiBHaXZlbiBhIHByb3BlcnR5IGFjY2VzcyBwYXRoIGluIHRoZSBmb3JtYXQgYHgueS56YCBhbmQgYSB2YWx1ZVxuICogdGhpcyBmdW5jdGlvbnMgYnVpbGRzIGFuZCByZXR1cm5zIGFuIG9iamVjdCBmb2xsb3dpbmcgdGhlIGFjY2VzcyBwYXRoLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zb2xlLmxvZygneC55LnouJywgNDIpO1xuICogPj4geyB4OiB7IHk6IHsgejogNDIgfSB9IH1cbiAqIGBgYFxuICpcbiAqIEBoaWRkZW5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY29uc3QgcmV2ZXJzZU1hcHBlciA9IChwYXRoOiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IHtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBjb25zdCBwYXJ0cyA9IHBhdGg/LnNwbGl0KCcuJykgPz8gW107XG5cbiAgICBsZXQgX3Byb3AgPSBwYXJ0cy5zaGlmdCgpO1xuICAgIGxldCBtYXBwaW5nOiBhbnk7XG5cbiAgICAvLyBJbml0aWFsIGJpbmRpbmcgZm9yIGZpcnN0IGxldmVsIGJpbmRpbmdzXG4gICAgb2JqW19wcm9wXSA9IHZhbHVlO1xuICAgIG1hcHBpbmcgPSBvYmo7XG5cbiAgICBwYXJ0cy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICAvLyBTdGFydCBidWlsZGluZyB0aGUgaGllcmFyY2h5XG4gICAgICAgIG1hcHBpbmdbX3Byb3BdID0ge307XG4gICAgICAgIC8vIEdvIGRvd24gYSBsZXZlbFxuICAgICAgICBtYXBwaW5nID0gbWFwcGluZ1tfcHJvcF07XG4gICAgICAgIC8vIEJpbmQgdGhlIHZhbHVlIGFuZCBtb3ZlIHRoZSBrZXlcbiAgICAgICAgbWFwcGluZ1twcm9wXSA9IHZhbHVlO1xuICAgICAgICBfcHJvcCA9IHByb3A7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxuZXhwb3J0IGNvbnN0IHlpZWxkaW5nTG9vcCA9IChjb3VudDogbnVtYmVyLCBjaHVua1NpemU6IG51bWJlciwgY2FsbGJhY2s6IChpbmRleDogbnVtYmVyKSA9PiB2b2lkLCBkb25lOiAoKSA9PiB2b2lkKSA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IGNodW5rID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihpICsgY2h1bmtTaXplLCBjb3VudCk7XG4gICAgICAgIGZvciAoOyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpIDwgY291bnQpIHtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZShjaHVuayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNodW5rKCk7XG59O1xuXG5leHBvcnQgY29uc3QgaXNDb25zdHJ1Y3RvciA9IChyZWY6IGFueSkgPT4gdHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBCb29sZWFuKHJlZi5wcm90b3R5cGUpICYmIEJvb2xlYW4ocmVmLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcik7XG5cbi8qKlxuICogU2ltaWxhciB0byBBbmd1bGFyJ3MgZm9ybWF0RGF0ZS4gSG93ZXZlciBpdCB3aWxsIG5vdCB0aHJvdyBvbiBgdW5kZWZpbmVkIHwgbnVsbCB8ICcnYCBpbnN0ZWFkXG4gKiBjb2FsZXNjaW5nIHRvIGFuIGVtcHR5IHN0cmluZy5cbiAqL1xuZXhwb3J0IGNvbnN0IGZvcm1hdERhdGUgPSAodmFsdWU6IHN0cmluZyB8IG51bWJlciB8IERhdGUsIGZvcm1hdDogc3RyaW5nLCBsb2NhbGU6IHN0cmluZywgdGltZXpvbmU/OiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAnJykge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBfZm9ybWF0RGF0ZSh2YWx1ZSwgZm9ybWF0LCBsb2NhbGUsIHRpbWV6b25lKTtcbn07XG5cbmV4cG9ydCBjb25zdCBmb3JtYXRDdXJyZW5jeSA9IG5ldyBDdXJyZW5jeVBpcGUodW5kZWZpbmVkKS50cmFuc2Zvcm07XG5cbi8qKiBDb252ZXJ0cyBwaXhlbCB2YWx1ZXMgdG8gdGhlaXIgcmVtIGNvdW50ZXJwYXJ0cyBmb3IgYSBiYXNlIHZhbHVlICovXG5leHBvcnQgY29uc3QgcmVtID0gKHZhbHVlOiBudW1iZXIgfCBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBiYXNlID0gcGFyc2VGbG9hdChnbG9iYWxUaGlzLndpbmRvdz8uZ2V0Q29tcHV0ZWRTdHlsZShnbG9iYWxUaGlzLmRvY3VtZW50Py5kb2N1bWVudEVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJy0taWctYmFzZS1mb250LXNpemUnKSlcbiAgICByZXR1cm4gTnVtYmVyKHZhbHVlKSAvIGJhc2U7XG59XG5cbi8qKiBHZXQgdGhlIHNpemUgb2YgdGhlIGNvbXBvbmVudCBhcyBkZXJpdmVkIGZyb20gdGhlIENTUyBzaXplIHZhcmlhYmxlICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29tcG9uZW50U2l6ZShlbDogRWxlbWVudCkge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLndpbmRvdz8uZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZ2V0UHJvcGVydHlWYWx1ZSgnLS1jb21wb25lbnQtc2l6ZScpO1xufVxuXG4vKiogR2V0IHRoZSBmaXJzdCBpdGVtIGluIGFuIGFycmF5ICovXG5leHBvcnQgZnVuY3Rpb24gZmlyc3Q8VD4oYXJyOiBUW10pIHtcbiAgICByZXR1cm4gYXJyLmF0KDApIGFzIFQ7XG59XG5cbi8qKiBHZXQgdGhlIGxhc3QgaXRlbSBpbiBhbiBhcnJheSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxhc3Q8VD4oYXJyOiBUW10pIHtcbiAgICByZXR1cm4gYXJyLmF0KC0xKSBhcyBUO1xufVxuXG4vKiogQ2FsY3VsYXRlcyB0aGUgbW9kdWxvIG9mIHR3byBudW1iZXJzLCBlbnN1cmluZyBhIG5vbi1uZWdhdGl2ZSByZXN1bHQuICovXG5leHBvcnQgZnVuY3Rpb24gbW9kdWxvKG46IG51bWJlciwgZDogbnVtYmVyKSB7XG4gICAgcmV0dXJuICgobiAlIGQpICsgZCkgJSBkO1xufVxuXG4vKipcbiAqIFNwbGl0cyBhbiBhcnJheSBpbnRvIGNodW5rcyBvZiBsZW5ndGggYHNpemVgIGFuZCByZXR1cm5zIGEgZ2VuZXJhdG9yXG4gKiB5aWVsZGluZyBlYWNoIGNodW5rLlxuICogVGhlIGxhc3QgY2h1bmsgbWF5IGNvbnRhaW4gbGVzcyB0aGFuIGBzaXplYCBlbGVtZW50cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgYXJyID0gWzAsMSwyLDMsNCw1LDYsNyw4LDldO1xuICpcbiAqIEFycmF5LmZyb20oY2h1bmsoYXJyLCAyKSkgLy8gW1swLCAxXSwgWzIsIDNdLCBbNCwgNV0sIFs2LCA3XSwgWzgsIDldXVxuICogQXJyYXkuZnJvbShjaHVuayhhcnIsIDMpKSAvLyBbWzAsIDEsIDJdLCBbMywgNCwgNV0sIFs2LCA3LCA4XSwgWzldXVxuICogQXJyYXkuZnJvbShjaHVuayhbXSwgMykpIC8vIFtdXG4gKiBBcnJheS5mcm9tKGNodW5rKGFyciwgLTMpKSAvLyBFcnJvclxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiogaW50b0NodW5rczxUPihhcnI6IFRbXSwgc2l6ZTogbnVtYmVyKSB7XG4gIGlmIChzaXplIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2l6ZSBtdXN0IGJlIGFuIGludGVnZXIgPj0gMScpO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSBzaXplKSB7XG4gICAgeWllbGQgYXJyLnNsaWNlKGksIGkgKyBzaXplKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSBzaXplXG4gKiBAcmV0dXJucyBzdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSAtLWNvbXBvbmVudC1zaXplIGRlZmF1bHQgdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbXBvbmVudENzc1NpemVWYXIoc2l6ZTogc3RyaW5nKSB7XG4gICAgc3dpdGNoIChzaXplKSB7XG4gICAgICAgIGNhc2UgXCIxXCI6XG4gICAgICAgICAgICByZXR1cm4gJ3ZhcigtLWlnLXNpemUsIHZhcigtLWlnLXNpemUtc21hbGwpKSc7XG4gICAgICAgIGNhc2UgXCIyXCI6XG4gICAgICAgICAgICByZXR1cm4gJ3ZhcigtLWlnLXNpemUsIHZhcigtLWlnLXNpemUtbWVkaXVtKSknO1xuICAgICAgICBjYXNlIFwiM1wiOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICd2YXIoLS1pZy1zaXplLCB2YXIoLS1pZy1zaXplLWxhcmdlKSknO1xuICAgIH1cbn1cbiJdfQ==