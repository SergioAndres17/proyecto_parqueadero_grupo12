import { Component, HostBinding, Inject, Input, ViewChild } from '@angular/core';
import { getResizeObserver, mkenum } from '../../core/utils';
import { IgxAngularAnimationService } from '../../services/animation/angular-animation-service';
import { IgxTabsBase } from '../tabs.base';
import { IgxTabsDirective } from '../tabs.directive';
import { NgClass, NgFor, NgTemplateOutlet, NgIf } from '@angular/common';
import { IgxIconComponent } from '../../icon/icon.component';
import { IgxRippleDirective } from '../../directives/ripple/ripple.directive';
import { IgxIconButtonDirective } from '../../directives/button/icon-button.directive';
import * as i0 from "@angular/core";
import * as i1 from "../../services/direction/directionality";
export const IgxTabsAlignment = /*@__PURE__*/ mkenum({
    start: 'start',
    end: 'end',
    center: 'center',
    justify: 'justify'
});
/** @hidden */
let NEXT_TAB_ID = 0;
/**
 * Tabs component is used to organize or switch between similar data sets.
 *
 * @igxModule IgxTabsModule
 *
 * @igxTheme igx-tabs-theme
 *
 * @igxKeywords tabs
 *
 * @igxGroup Layouts
 *
 * @remarks
 * The Ignite UI for Angular Tabs component places tabs at the top and allows for scrolling when there are multiple tab items on the screen.
 *
 * @example
 * ```html
 * <igx-tabs>
 *     <igx-tab-item>
 *         <igx-tab-header>
 *             <igx-icon igxTabHeaderIcon>folder</igx-icon>
 *             <span igxTabHeaderLabel>Tab 1</span>
 *         </igx-tab-header>
 *         <igx-tab-content>
 *             Content 1
 *         </igx-tab-content>
 *     </igx-tab-item>
 *     ...
 * </igx-tabs>
 * ```
 */
export class IgxTabsComponent extends IgxTabsDirective {
    /**
     * Gets/Sets the tab alignment. Defaults to `start`.
     */
    get tabAlignment() {
        return this._tabAlignment;
    }
    set tabAlignment(value) {
        this._tabAlignment = value;
        requestAnimationFrame(() => {
            this.updateScrollButtons();
            this.realignSelectedIndicator();
        });
    }
    constructor(animationService, cdr, ngZone, dir) {
        super(animationService, cdr, dir);
        this.ngZone = ngZone;
        /**
         * Determines the tab activation.
         * When set to auto, the tab is instantly selected while navigating with the Left/Right Arrows, Home or End keys and the corresponding panel is displayed.
         * When set to manual, the tab is only focused. The selection happens after pressing Space or Enter.
         * Defaults is auto.
         */
        this.activation = 'auto';
        /** @hidden */
        this.defaultClass = true;
        /**  @hidden */
        this.offset = 0;
        /** @hidden */
        this.componentName = 'igx-tabs';
        this._tabAlignment = 'start';
    }
    /** @hidden @internal */
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this.ngZone.runOutsideAngular(() => {
            this._resizeObserver = new (getResizeObserver())(() => {
                this.updateScrollButtons();
                this.realignSelectedIndicator();
            });
            this._resizeObserver.observe(this.headerContainer.nativeElement);
            this._resizeObserver.observe(this.viewPort.nativeElement);
        });
    }
    /** @hidden @internal */
    ngOnDestroy() {
        super.ngOnDestroy();
        this.ngZone.runOutsideAngular(() => {
            this._resizeObserver?.disconnect();
        });
    }
    /** @hidden */
    scrollPrev() {
        this.scroll(false);
    }
    /** @hidden */
    scrollNext() {
        this.scroll(true);
    }
    /** @hidden */
    realignSelectedIndicator() {
        if (this.selectedIndex >= 0 && this.selectedIndex < this.items.length) {
            const header = this.items.get(this.selectedIndex).headerComponent.nativeElement;
            this.alignSelectedIndicator(header, 0);
        }
    }
    /** @hidden */
    resolveHeaderScrollClasses() {
        return {
            'igx-tabs__header-scroll--start': this.tabAlignment === 'start',
            'igx-tabs__header-scroll--end': this.tabAlignment === 'end',
            'igx-tabs__header-scroll--center': this.tabAlignment === 'center',
            'igx-tabs__header-scroll--justify': this.tabAlignment === 'justify',
        };
    }
    /** @hidden */
    scrollTabHeaderIntoView() {
        if (this.selectedIndex >= 0) {
            const tabItems = this.items.toArray();
            const tabHeaderNativeElement = tabItems[this.selectedIndex].headerComponent.nativeElement;
            // Scroll left if there is need
            if (this.getElementOffset(tabHeaderNativeElement) < this.offset) {
                this.scrollElement(tabHeaderNativeElement, false);
            }
            // Scroll right if there is need
            const viewPortOffsetWidth = this.viewPort.nativeElement.offsetWidth;
            const delta = (this.getElementOffset(tabHeaderNativeElement) + tabHeaderNativeElement.offsetWidth) - (viewPortOffsetWidth + this.offset);
            // Fix for IE 11, a difference is accumulated from the widths calculations
            if (delta > 1) {
                this.scrollElement(tabHeaderNativeElement, true);
            }
            this.alignSelectedIndicator(tabHeaderNativeElement);
        }
        else {
            this.hideSelectedIndicator();
        }
    }
    /** @hidden */
    getNextTabId() {
        return NEXT_TAB_ID++;
    }
    /** @hidden */
    onItemChanges() {
        super.onItemChanges();
        Promise.resolve().then(() => {
            this.updateScrollButtons();
        });
    }
    alignSelectedIndicator(element, duration = 0.3) {
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'visible';
            this.selectedIndicator.nativeElement.style.transitionDuration = duration > 0 ? `${duration}s` : 'initial';
            this.selectedIndicator.nativeElement.style.width = `${element.offsetWidth}px`;
            this.selectedIndicator.nativeElement.style.transform = `translate(${element.offsetLeft}px)`;
        }
    }
    hideSelectedIndicator() {
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'hidden';
        }
    }
    scroll(scrollNext) {
        const tabsArray = this.items.toArray();
        for (let index = 0; index < tabsArray.length; index++) {
            const tab = tabsArray[index];
            const element = tab.headerComponent.nativeElement;
            if (scrollNext) {
                if (element.offsetWidth + this.getElementOffset(element) > this.viewPort.nativeElement.offsetWidth + this.offset) {
                    this.scrollElement(element, scrollNext);
                    break;
                }
            }
            else {
                if (this.getElementOffset(element) >= this.offset) {
                    this.scrollElement(tabsArray[index - 1].headerComponent.nativeElement, scrollNext);
                    break;
                }
            }
        }
    }
    scrollElement(element, scrollNext) {
        const viewPortWidth = this.viewPort.nativeElement.offsetWidth;
        this.offset = (scrollNext) ? element.offsetWidth + this.getElementOffset(element) - viewPortWidth : this.getElementOffset(element);
        this.viewPort.nativeElement.scrollLeft = this.getOffset(this.offset);
        this.updateScrollButtons();
    }
    updateScrollButtons() {
        const itemsContainerWidth = this.getTabItemsContainerWidth();
        const scrollPrevButtonStyle = this.resolveLeftScrollButtonStyle(itemsContainerWidth);
        this.setScrollButtonStyle(this.scrollPrevButton.nativeElement, scrollPrevButtonStyle);
        const scrollNextButtonStyle = this.resolveRightScrollButtonStyle(itemsContainerWidth);
        this.setScrollButtonStyle(this.scrollNextButton.nativeElement, scrollNextButtonStyle);
    }
    setScrollButtonStyle(button, buttonStyle) {
        if (buttonStyle === "enabled" /* TabScrollButtonStyle.Enabled */) {
            button.disabled = false;
            button.style.display = '';
        }
        else if (buttonStyle === "disabled" /* TabScrollButtonStyle.Disabled */) {
            button.disabled = true;
            button.style.display = '';
        }
        else if (buttonStyle === "not_displayed" /* TabScrollButtonStyle.NotDisplayed */) {
            button.style.display = 'none';
        }
    }
    resolveLeftScrollButtonStyle(itemsContainerWidth) {
        const headerContainerWidth = this.headerContainer.nativeElement.offsetWidth;
        const offset = this.offset;
        if (offset === 0) {
            // Fix for IE 11, a difference is accumulated from the widths calculations.
            if (itemsContainerWidth - headerContainerWidth <= 1) {
                return "not_displayed" /* TabScrollButtonStyle.NotDisplayed */;
            }
            return "disabled" /* TabScrollButtonStyle.Disabled */;
        }
        else {
            return "enabled" /* TabScrollButtonStyle.Enabled */;
        }
    }
    resolveRightScrollButtonStyle(itemsContainerWidth) {
        const viewPortWidth = this.viewPort.nativeElement.offsetWidth;
        const headerContainerWidth = this.headerContainer.nativeElement.offsetWidth;
        const offset = this.offset;
        const total = offset + viewPortWidth;
        // Fix for IE 11, a difference is accumulated from the widths calculations.
        if (itemsContainerWidth - headerContainerWidth <= 1 && offset === 0) {
            return "not_displayed" /* TabScrollButtonStyle.NotDisplayed */;
        }
        if (itemsContainerWidth > total) {
            return "enabled" /* TabScrollButtonStyle.Enabled */;
        }
        else {
            return "disabled" /* TabScrollButtonStyle.Disabled */;
        }
    }
    getTabItemsContainerWidth() {
        // We use this hacky way to get the width of the itemsContainer,
        // because there is inconsistency in IE we cannot use offsetWidth or scrollOffset.
        const itemsContainerChildrenCount = this.itemsContainer.nativeElement.children.length;
        let itemsContainerWidth = 0;
        if (itemsContainerChildrenCount > 1) {
            const lastTab = this.itemsContainer.nativeElement.children[itemsContainerChildrenCount - 1];
            itemsContainerWidth = this.getElementOffset(lastTab) + lastTab.offsetWidth;
        }
        return itemsContainerWidth;
    }
    getOffset(offset) {
        return this.dir.rtl ? -offset : offset;
    }
    getElementOffset(element) {
        return this.dir.rtl ? this.itemsWrapper.nativeElement.offsetWidth - element.offsetLeft - element.offsetWidth : element.offsetLeft;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxTabsComponent, deps: [{ token: IgxAngularAnimationService }, { token: i0.ChangeDetectorRef }, { token: i0.NgZone }, { token: i1.IgxDirectionality }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.4", type: IgxTabsComponent, isStandalone: true, selector: "igx-tabs", inputs: { tabAlignment: "tabAlignment", activation: "activation" }, host: { properties: { "class.igx-tabs": "this.defaultClass" } }, providers: [{ provide: IgxTabsBase, useExisting: IgxTabsComponent }], viewQueries: [{ propertyName: "headerContainer", first: true, predicate: ["headerContainer"], descendants: true, static: true }, { propertyName: "viewPort", first: true, predicate: ["viewPort"], descendants: true, static: true }, { propertyName: "itemsWrapper", first: true, predicate: ["itemsWrapper"], descendants: true, static: true }, { propertyName: "itemsContainer", first: true, predicate: ["itemsContainer"], descendants: true, static: true }, { propertyName: "selectedIndicator", first: true, predicate: ["selectedIndicator"], descendants: true }, { propertyName: "scrollPrevButton", first: true, predicate: ["scrollPrevButton"], descendants: true }, { propertyName: "scrollNextButton", first: true, predicate: ["scrollNextButton"], descendants: true }], usesInheritance: true, ngImport: i0, template: "<div #headerContainer class=\"igx-tabs__header\">\n    <button #scrollPrevButton type=\"button\" igxIconButton=\"flat\" igxRipple tabindex=\"-1\" class=\"igx-tabs__header-button\" (click)=\"scrollPrev()\">\n        <igx-icon family=\"default\" name=\"prev\"></igx-icon>\n    </button>\n    <div #viewPort class=\"igx-tabs__header-content\">\n        <div #itemsWrapper class=\"igx-tabs__header-wrapper\" role=\"tablist\">\n            <div #itemsContainer class=\"igx-tabs__header-scroll\" [ngClass]=\"resolveHeaderScrollClasses()\">\n                <ng-container *ngFor=\"let tab of items; let i = index\">\n                    <ng-container *ngTemplateOutlet=\"tab.headerTemplate\"></ng-container>\n                </ng-container>\n            </div>\n            <div #selectedIndicator *ngIf=\"items.length > 0\" class=\"igx-tabs__header-active-indicator\">\n            </div>\n        </div>\n    </div>\n    <button #scrollNextButton type=\"button\" igxIconButton=\"flat\" igxRipple tabindex=\"-1\" class=\"igx-tabs__header-button\" (click)=\"scrollNext()\">\n        <igx-icon family=\"default\" name=\"next\"></igx-icon>\n    </button>\n</div>\n<div class=\"igx-tabs__panels\">\n    <ng-container *ngFor=\"let tab of items; let i = index\">\n        <ng-container *ngTemplateOutlet=\"tab.panelTemplate\"></ng-container>\n    </ng-container>\n</div>\n", dependencies: [{ kind: "directive", type: IgxRippleDirective, selector: "[igxRipple]", inputs: ["igxRippleTarget", "igxRipple", "igxRippleDuration", "igxRippleCentered", "igxRippleDisabled"] }, { kind: "component", type: IgxIconComponent, selector: "igx-icon", inputs: ["family", "name", "active"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: IgxIconButtonDirective, selector: "[igxIconButton]", inputs: ["igxIconButton"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxTabsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-tabs', providers: [{ provide: IgxTabsBase, useExisting: IgxTabsComponent }], standalone: true, imports: [IgxRippleDirective, IgxIconComponent, NgClass, NgFor, NgTemplateOutlet, NgIf, IgxIconButtonDirective], template: "<div #headerContainer class=\"igx-tabs__header\">\n    <button #scrollPrevButton type=\"button\" igxIconButton=\"flat\" igxRipple tabindex=\"-1\" class=\"igx-tabs__header-button\" (click)=\"scrollPrev()\">\n        <igx-icon family=\"default\" name=\"prev\"></igx-icon>\n    </button>\n    <div #viewPort class=\"igx-tabs__header-content\">\n        <div #itemsWrapper class=\"igx-tabs__header-wrapper\" role=\"tablist\">\n            <div #itemsContainer class=\"igx-tabs__header-scroll\" [ngClass]=\"resolveHeaderScrollClasses()\">\n                <ng-container *ngFor=\"let tab of items; let i = index\">\n                    <ng-container *ngTemplateOutlet=\"tab.headerTemplate\"></ng-container>\n                </ng-container>\n            </div>\n            <div #selectedIndicator *ngIf=\"items.length > 0\" class=\"igx-tabs__header-active-indicator\">\n            </div>\n        </div>\n    </div>\n    <button #scrollNextButton type=\"button\" igxIconButton=\"flat\" igxRipple tabindex=\"-1\" class=\"igx-tabs__header-button\" (click)=\"scrollNext()\">\n        <igx-icon family=\"default\" name=\"next\"></igx-icon>\n    </button>\n</div>\n<div class=\"igx-tabs__panels\">\n    <ng-container *ngFor=\"let tab of items; let i = index\">\n        <ng-container *ngTemplateOutlet=\"tab.panelTemplate\"></ng-container>\n    </ng-container>\n</div>\n" }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IgxAngularAnimationService]
                }] }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i1.IgxDirectionality }], propDecorators: { tabAlignment: [{
                type: Input
            }], activation: [{
                type: Input
            }], headerContainer: [{
                type: ViewChild,
                args: ['headerContainer', { static: true }]
            }], viewPort: [{
                type: ViewChild,
                args: ['viewPort', { static: true }]
            }], itemsWrapper: [{
                type: ViewChild,
                args: ['itemsWrapper', { static: true }]
            }], itemsContainer: [{
                type: ViewChild,
                args: ['itemsContainer', { static: true }]
            }], selectedIndicator: [{
                type: ViewChild,
                args: ['selectedIndicator']
            }], scrollPrevButton: [{
                type: ViewChild,
                args: ['scrollPrevButton']
            }], scrollNextButton: [{
                type: ViewChild,
                args: ['scrollNextButton']
            }], defaultClass: [{
                type: HostBinding,
                args: ['class.igx-tabs']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFicy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvdGFicy90YWJzL3RhYnMuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL3RhYnMvdGFicy90YWJzLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBb0MsU0FBUyxFQUFjLFdBQVcsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFxQixTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbEosT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQzdELE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLG9EQUFvRCxDQUFDO0FBR2hHLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDM0MsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDckQsT0FBTyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDekUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDN0QsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sMENBQTBDLENBQUM7QUFDOUUsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sK0NBQStDLENBQUM7OztBQUV2RixNQUFNLENBQUMsTUFBTSxnQkFBZ0IsR0FBRyxhQUFhLENBQUEsTUFBTSxDQUFDO0lBQ2hELEtBQUssRUFBRSxPQUFPO0lBQ2QsR0FBRyxFQUFFLEtBQUs7SUFDVixNQUFNLEVBQUUsUUFBUTtJQUNoQixPQUFPLEVBQUUsU0FBUztDQUNyQixDQUFDLENBQUM7QUFXSCxjQUFjO0FB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RSxDQUFDLGNBQ3hELElBQUksV0FDUCxDQUFDLGtCQUFrQixFQUFFLGdCQUFnQixFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFLHNCQUFzQixDQUFDOzswQkF3RTFHLE1BQU07MkJBQUMsMEJBQTBCOzhIQS9EM0IsWUFBWTtzQkFEdEIsS0FBSztnQkFvQkMsVUFBVTtzQkFEaEIsS0FBSztnQkFLQyxlQUFlO3NCQURyQixTQUFTO3VCQUFDLGlCQUFpQixFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTtnQkFLdkMsUUFBUTtzQkFEZCxTQUFTO3VCQUFDLFVBQVUsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7Z0JBS2hDLFlBQVk7c0JBRGxCLFNBQVM7dUJBQUMsY0FBYyxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTtnQkFLcEMsY0FBYztzQkFEcEIsU0FBUzt1QkFBQyxnQkFBZ0IsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7Z0JBS3RDLGlCQUFpQjtzQkFEdkIsU0FBUzt1QkFBQyxtQkFBbUI7Z0JBS3ZCLGdCQUFnQjtzQkFEdEIsU0FBUzt1QkFBQyxrQkFBa0I7Z0JBS3RCLGdCQUFnQjtzQkFEdEIsU0FBUzt1QkFBQyxrQkFBa0I7Z0JBS3RCLFlBQVk7c0JBRGxCLFdBQVc7dUJBQUMsZ0JBQWdCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgQ2hhbmdlRGV0ZWN0b3JSZWYsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgSG9zdEJpbmRpbmcsIEluamVjdCwgSW5wdXQsIE5nWm9uZSwgT25EZXN0cm95LCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGdldFJlc2l6ZU9ic2VydmVyLCBta2VudW0gfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IElneEFuZ3VsYXJBbmltYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvYW5pbWF0aW9uL2FuZ3VsYXItYW5pbWF0aW9uLXNlcnZpY2UnO1xuaW1wb3J0IHsgQW5pbWF0aW9uU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2FuaW1hdGlvbi9hbmltYXRpb24nO1xuaW1wb3J0IHsgSWd4RGlyZWN0aW9uYWxpdHkgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9kaXJlY3Rpb24vZGlyZWN0aW9uYWxpdHknO1xuaW1wb3J0IHsgSWd4VGFic0Jhc2UgfSBmcm9tICcuLi90YWJzLmJhc2UnO1xuaW1wb3J0IHsgSWd4VGFic0RpcmVjdGl2ZSB9IGZyb20gJy4uL3RhYnMuZGlyZWN0aXZlJztcbmltcG9ydCB7IE5nQ2xhc3MsIE5nRm9yLCBOZ1RlbXBsYXRlT3V0bGV0LCBOZ0lmIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IElneEljb25Db21wb25lbnQgfSBmcm9tICcuLi8uLi9pY29uL2ljb24uY29tcG9uZW50JztcbmltcG9ydCB7IElneFJpcHBsZURpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvcmlwcGxlL3JpcHBsZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSWd4SWNvbkJ1dHRvbkRpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvYnV0dG9uL2ljb24tYnV0dG9uLmRpcmVjdGl2ZSc7XG5cbmV4cG9ydCBjb25zdCBJZ3hUYWJzQWxpZ25tZW50ID0gLypAX19QVVJFX18qL21rZW51bSh7XG4gICAgc3RhcnQ6ICdzdGFydCcsXG4gICAgZW5kOiAnZW5kJyxcbiAgICBjZW50ZXI6ICdjZW50ZXInLFxuICAgIGp1c3RpZnk6ICdqdXN0aWZ5J1xufSk7XG5cbi8qKiBAaGlkZGVuICovXG5jb25zdCBlbnVtIFRhYlNjcm9sbEJ1dHRvblN0eWxlIHtcbiAgICBFbmFibGVkID0gJ2VuYWJsZWQnLFxuICAgIERpc2FibGVkID0gJ2Rpc2FibGVkJyxcbiAgICBOb3REaXNwbGF5ZWQgPSAnbm90X2Rpc3BsYXllZCdcbn1cblxuZXhwb3J0IHR5cGUgSWd4VGFic0FsaWdubWVudCA9ICh0eXBlb2YgSWd4VGFic0FsaWdubWVudClba2V5b2YgdHlwZW9mIElneFRhYnNBbGlnbm1lbnRdO1xuXG4vKiogQGhpZGRlbiAqL1xubGV0IE5FWFRfVEFCX0lEID0gMDtcblxuLyoqXG4gKiBUYWJzIGNvbXBvbmVudCBpcyB1c2VkIHRvIG9yZ2FuaXplIG9yIHN3aXRjaCBiZXR3ZWVuIHNpbWlsYXIgZGF0YSBzZXRzLlxuICpcbiAqIEBpZ3hNb2R1bGUgSWd4VGFic01vZHVsZVxuICpcbiAqIEBpZ3hUaGVtZSBpZ3gtdGFicy10aGVtZVxuICpcbiAqIEBpZ3hLZXl3b3JkcyB0YWJzXG4gKlxuICogQGlneEdyb3VwIExheW91dHNcbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIElnbml0ZSBVSSBmb3IgQW5ndWxhciBUYWJzIGNvbXBvbmVudCBwbGFjZXMgdGFicyBhdCB0aGUgdG9wIGFuZCBhbGxvd3MgZm9yIHNjcm9sbGluZyB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSB0YWIgaXRlbXMgb24gdGhlIHNjcmVlbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgaHRtbFxuICogPGlneC10YWJzPlxuICogICAgIDxpZ3gtdGFiLWl0ZW0+XG4gKiAgICAgICAgIDxpZ3gtdGFiLWhlYWRlcj5cbiAqICAgICAgICAgICAgIDxpZ3gtaWNvbiBpZ3hUYWJIZWFkZXJJY29uPmZvbGRlcjwvaWd4LWljb24+XG4gKiAgICAgICAgICAgICA8c3BhbiBpZ3hUYWJIZWFkZXJMYWJlbD5UYWIgMTwvc3Bhbj5cbiAqICAgICAgICAgPC9pZ3gtdGFiLWhlYWRlcj5cbiAqICAgICAgICAgPGlneC10YWItY29udGVudD5cbiAqICAgICAgICAgICAgIENvbnRlbnQgMVxuICogICAgICAgICA8L2lneC10YWItY29udGVudD5cbiAqICAgICA8L2lneC10YWItaXRlbT5cbiAqICAgICAuLi5cbiAqIDwvaWd4LXRhYnM+XG4gKiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtdGFicycsXG4gICAgdGVtcGxhdGVVcmw6ICd0YWJzLmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IElneFRhYnNCYXNlLCB1c2VFeGlzdGluZzogSWd4VGFic0NvbXBvbmVudCB9XSxcbiAgICBzdGFuZGFsb25lOiB0cnVlLFxuICAgIGltcG9ydHM6IFtJZ3hSaXBwbGVEaXJlY3RpdmUsIElneEljb25Db21wb25lbnQsIE5nQ2xhc3MsIE5nRm9yLCBOZ1RlbXBsYXRlT3V0bGV0LCBOZ0lmLCBJZ3hJY29uQnV0dG9uRGlyZWN0aXZlXVxufSlcblxuZXhwb3J0IGNsYXNzIElneFRhYnNDb21wb25lbnQgZXh0ZW5kcyBJZ3hUYWJzRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgdGFiIGFsaWdubWVudC4gRGVmYXVsdHMgdG8gYHN0YXJ0YC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgdGFiQWxpZ25tZW50KCk6IHN0cmluZyB8IElneFRhYnNBbGlnbm1lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFiQWxpZ25tZW50O1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgdGFiQWxpZ25tZW50KHZhbHVlOiBzdHJpbmcgfCBJZ3hUYWJzQWxpZ25tZW50KSB7XG4gICAgICAgIHRoaXMuX3RhYkFsaWdubWVudCA9IHZhbHVlO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTY3JvbGxCdXR0b25zKCk7XG4gICAgICAgICAgICB0aGlzLnJlYWxpZ25TZWxlY3RlZEluZGljYXRvcigpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHRoZSB0YWIgYWN0aXZhdGlvbi5cbiAgICAgKiBXaGVuIHNldCB0byBhdXRvLCB0aGUgdGFiIGlzIGluc3RhbnRseSBzZWxlY3RlZCB3aGlsZSBuYXZpZ2F0aW5nIHdpdGggdGhlIExlZnQvUmlnaHQgQXJyb3dzLCBIb21lIG9yIEVuZCBrZXlzIGFuZCB0aGUgY29ycmVzcG9uZGluZyBwYW5lbCBpcyBkaXNwbGF5ZWQuXG4gICAgICogV2hlbiBzZXQgdG8gbWFudWFsLCB0aGUgdGFiIGlzIG9ubHkgZm9jdXNlZC4gVGhlIHNlbGVjdGlvbiBoYXBwZW5zIGFmdGVyIHByZXNzaW5nIFNwYWNlIG9yIEVudGVyLlxuICAgICAqIERlZmF1bHRzIGlzIGF1dG8uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgYWN0aXZhdGlvbjogJ2F1dG8nIHwgJ21hbnVhbCcgPSAnYXV0byc7XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBWaWV3Q2hpbGQoJ2hlYWRlckNvbnRhaW5lcicsIHsgc3RhdGljOiB0cnVlIH0pXG4gICAgcHVibGljIGhlYWRlckNvbnRhaW5lcjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBWaWV3Q2hpbGQoJ3ZpZXdQb3J0JywgeyBzdGF0aWM6IHRydWUgfSlcbiAgICBwdWJsaWMgdmlld1BvcnQ6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+O1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBAVmlld0NoaWxkKCdpdGVtc1dyYXBwZXInLCB7IHN0YXRpYzogdHJ1ZSB9KVxuICAgIHB1YmxpYyBpdGVtc1dyYXBwZXI6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+O1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBAVmlld0NoaWxkKCdpdGVtc0NvbnRhaW5lcicsIHsgc3RhdGljOiB0cnVlIH0pXG4gICAgcHVibGljIGl0ZW1zQ29udGFpbmVyOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PjtcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgQFZpZXdDaGlsZCgnc2VsZWN0ZWRJbmRpY2F0b3InKVxuICAgIHB1YmxpYyBzZWxlY3RlZEluZGljYXRvcjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBWaWV3Q2hpbGQoJ3Njcm9sbFByZXZCdXR0b24nKVxuICAgIHB1YmxpYyBzY3JvbGxQcmV2QnV0dG9uOiBFbGVtZW50UmVmPEhUTUxCdXR0b25FbGVtZW50PjtcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgQFZpZXdDaGlsZCgnc2Nyb2xsTmV4dEJ1dHRvbicpXG4gICAgcHVibGljIHNjcm9sbE5leHRCdXR0b246IEVsZW1lbnRSZWY8SFRNTEJ1dHRvbkVsZW1lbnQ+O1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC10YWJzJylcbiAgICBwdWJsaWMgZGVmYXVsdENsYXNzID0gdHJ1ZTtcblxuICAgIC8qKiAgQGhpZGRlbiAqL1xuICAgIHB1YmxpYyBvZmZzZXQgPSAwO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgY29tcG9uZW50TmFtZSA9ICdpZ3gtdGFicyc7XG5cbiAgICBwcml2YXRlIF90YWJBbGlnbm1lbnQ6IHN0cmluZyB8IElneFRhYnNBbGlnbm1lbnQgPSAnc3RhcnQnO1xuICAgIHByaXZhdGUgX3Jlc2l6ZU9ic2VydmVyOiBSZXNpemVPYnNlcnZlcjtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBASW5qZWN0KElneEFuZ3VsYXJBbmltYXRpb25TZXJ2aWNlKSBhbmltYXRpb25TZXJ2aWNlOiBBbmltYXRpb25TZXJ2aWNlLFxuICAgICAgICBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBwcml2YXRlIG5nWm9uZTogTmdab25lLFxuICAgICAgICBkaXI6IElneERpcmVjdGlvbmFsaXR5LFxuICAgICkge1xuICAgICAgICBzdXBlcihhbmltYXRpb25TZXJ2aWNlLCBjZHIsIGRpcik7XG4gICAgfVxuXG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICBzdXBlci5uZ0FmdGVyVmlld0luaXQoKTtcblxuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9yZXNpemVPYnNlcnZlciA9IG5ldyAoZ2V0UmVzaXplT2JzZXJ2ZXIoKSkoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2Nyb2xsQnV0dG9ucygpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVhbGlnblNlbGVjdGVkSW5kaWNhdG9yKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5oZWFkZXJDb250YWluZXIubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLl9yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMudmlld1BvcnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgc3VwZXIubmdPbkRlc3Ryb3koKTtcblxuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9yZXNpemVPYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHB1YmxpYyBzY3JvbGxQcmV2KCkge1xuICAgICAgICB0aGlzLnNjcm9sbChmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwdWJsaWMgc2Nyb2xsTmV4dCgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGwodHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwdWJsaWMgcmVhbGlnblNlbGVjdGVkSW5kaWNhdG9yKCkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEluZGV4ID49IDAgJiYgdGhpcy5zZWxlY3RlZEluZGV4IDwgdGhpcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlciA9IHRoaXMuaXRlbXMuZ2V0KHRoaXMuc2VsZWN0ZWRJbmRleCkuaGVhZGVyQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmFsaWduU2VsZWN0ZWRJbmRpY2F0b3IoaGVhZGVyLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIHJlc29sdmVIZWFkZXJTY3JvbGxDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lneC10YWJzX19oZWFkZXItc2Nyb2xsLS1zdGFydCc6IHRoaXMudGFiQWxpZ25tZW50ID09PSAnc3RhcnQnLFxuICAgICAgICAgICAgJ2lneC10YWJzX19oZWFkZXItc2Nyb2xsLS1lbmQnOiB0aGlzLnRhYkFsaWdubWVudCA9PT0gJ2VuZCcsXG4gICAgICAgICAgICAnaWd4LXRhYnNfX2hlYWRlci1zY3JvbGwtLWNlbnRlcic6IHRoaXMudGFiQWxpZ25tZW50ID09PSAnY2VudGVyJyxcbiAgICAgICAgICAgICdpZ3gtdGFic19faGVhZGVyLXNjcm9sbC0tanVzdGlmeSc6IHRoaXMudGFiQWxpZ25tZW50ID09PSAnanVzdGlmeScsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgc2Nyb2xsVGFiSGVhZGVySW50b1ZpZXcoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgdGFiSXRlbXMgPSB0aGlzLml0ZW1zLnRvQXJyYXkoKTtcbiAgICAgICAgICAgIGNvbnN0IHRhYkhlYWRlck5hdGl2ZUVsZW1lbnQgPSB0YWJJdGVtc1t0aGlzLnNlbGVjdGVkSW5kZXhdLmhlYWRlckNvbXBvbmVudC5uYXRpdmVFbGVtZW50O1xuXG4gICAgICAgICAgICAvLyBTY3JvbGwgbGVmdCBpZiB0aGVyZSBpcyBuZWVkXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRFbGVtZW50T2Zmc2V0KHRhYkhlYWRlck5hdGl2ZUVsZW1lbnQpIDwgdGhpcy5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQodGFiSGVhZGVyTmF0aXZlRWxlbWVudCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTY3JvbGwgcmlnaHQgaWYgdGhlcmUgaXMgbmVlZFxuICAgICAgICAgICAgY29uc3Qgdmlld1BvcnRPZmZzZXRXaWR0aCA9IHRoaXMudmlld1BvcnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gKHRoaXMuZ2V0RWxlbWVudE9mZnNldCh0YWJIZWFkZXJOYXRpdmVFbGVtZW50KSArIHRhYkhlYWRlck5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGgpIC0gKHZpZXdQb3J0T2Zmc2V0V2lkdGggKyB0aGlzLm9mZnNldCk7XG5cbiAgICAgICAgICAgIC8vIEZpeCBmb3IgSUUgMTEsIGEgZGlmZmVyZW5jZSBpcyBhY2N1bXVsYXRlZCBmcm9tIHRoZSB3aWR0aHMgY2FsY3VsYXRpb25zXG4gICAgICAgICAgICBpZiAoZGVsdGEgPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50KHRhYkhlYWRlck5hdGl2ZUVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmFsaWduU2VsZWN0ZWRJbmRpY2F0b3IodGFiSGVhZGVyTmF0aXZlRWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhpZGVTZWxlY3RlZEluZGljYXRvcigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwcm90ZWN0ZWQgZ2V0TmV4dFRhYklkKCkge1xuICAgICAgICByZXR1cm4gTkVYVF9UQUJfSUQrKztcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHByb3RlY3RlZCBvdmVycmlkZSBvbkl0ZW1DaGFuZ2VzKCkge1xuICAgICAgICBzdXBlci5vbkl0ZW1DaGFuZ2VzKCk7XG5cbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNjcm9sbEJ1dHRvbnMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhbGlnblNlbGVjdGVkSW5kaWNhdG9yKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBkdXJhdGlvbiA9IDAuMyk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEluZGljYXRvcikge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGljYXRvci5uYXRpdmVFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kaWNhdG9yLm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb24gPiAwID8gYCR7ZHVyYXRpb259c2AgOiAnaW5pdGlhbCc7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kaWNhdG9yLm5hdGl2ZUVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHtlbGVtZW50Lm9mZnNldFdpZHRofXB4YDtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRpY2F0b3IubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7ZWxlbWVudC5vZmZzZXRMZWZ0fXB4KWA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGhpZGVTZWxlY3RlZEluZGljYXRvcigpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRpY2F0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRpY2F0b3IubmF0aXZlRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHNjcm9sbChzY3JvbGxOZXh0OiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRhYnNBcnJheSA9IHRoaXMuaXRlbXMudG9BcnJheSgpO1xuXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0YWJzQXJyYXkubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCB0YWIgPSB0YWJzQXJyYXlbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRhYi5oZWFkZXJDb21wb25lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGlmIChzY3JvbGxOZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQub2Zmc2V0V2lkdGggKyB0aGlzLmdldEVsZW1lbnRPZmZzZXQoZWxlbWVudCkgPiB0aGlzLnZpZXdQb3J0Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGggKyB0aGlzLm9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQoZWxlbWVudCwgc2Nyb2xsTmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0RWxlbWVudE9mZnNldChlbGVtZW50KSA+PSB0aGlzLm9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQodGFic0FycmF5W2luZGV4IC0gMV0uaGVhZGVyQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQsIHNjcm9sbE5leHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHNjcm9sbEVsZW1lbnQoZWxlbWVudDogYW55LCBzY3JvbGxOZXh0OiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHZpZXdQb3J0V2lkdGggPSB0aGlzLnZpZXdQb3J0Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG5cbiAgICAgICAgdGhpcy5vZmZzZXQgPSAoc2Nyb2xsTmV4dCkgPyBlbGVtZW50Lm9mZnNldFdpZHRoICsgdGhpcy5nZXRFbGVtZW50T2Zmc2V0KGVsZW1lbnQpIC0gdmlld1BvcnRXaWR0aCA6IHRoaXMuZ2V0RWxlbWVudE9mZnNldChlbGVtZW50KTtcbiAgICAgICAgdGhpcy52aWV3UG9ydC5uYXRpdmVFbGVtZW50LnNjcm9sbExlZnQgPSB0aGlzLmdldE9mZnNldCh0aGlzLm9mZnNldCk7XG4gICAgICAgIHRoaXMudXBkYXRlU2Nyb2xsQnV0dG9ucygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlU2Nyb2xsQnV0dG9ucygpIHtcbiAgICAgICAgY29uc3QgaXRlbXNDb250YWluZXJXaWR0aCA9IHRoaXMuZ2V0VGFiSXRlbXNDb250YWluZXJXaWR0aCgpO1xuXG4gICAgICAgIGNvbnN0IHNjcm9sbFByZXZCdXR0b25TdHlsZSA9IHRoaXMucmVzb2x2ZUxlZnRTY3JvbGxCdXR0b25TdHlsZShpdGVtc0NvbnRhaW5lcldpZHRoKTtcbiAgICAgICAgdGhpcy5zZXRTY3JvbGxCdXR0b25TdHlsZSh0aGlzLnNjcm9sbFByZXZCdXR0b24ubmF0aXZlRWxlbWVudCwgc2Nyb2xsUHJldkJ1dHRvblN0eWxlKTtcblxuICAgICAgICBjb25zdCBzY3JvbGxOZXh0QnV0dG9uU3R5bGUgPSB0aGlzLnJlc29sdmVSaWdodFNjcm9sbEJ1dHRvblN0eWxlKGl0ZW1zQ29udGFpbmVyV2lkdGgpO1xuICAgICAgICB0aGlzLnNldFNjcm9sbEJ1dHRvblN0eWxlKHRoaXMuc2Nyb2xsTmV4dEJ1dHRvbi5uYXRpdmVFbGVtZW50LCBzY3JvbGxOZXh0QnV0dG9uU3R5bGUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0U2Nyb2xsQnV0dG9uU3R5bGUoYnV0dG9uOiBIVE1MQnV0dG9uRWxlbWVudCwgYnV0dG9uU3R5bGU6IFRhYlNjcm9sbEJ1dHRvblN0eWxlKSB7XG4gICAgICAgIGlmIChidXR0b25TdHlsZSA9PT0gVGFiU2Nyb2xsQnV0dG9uU3R5bGUuRW5hYmxlZCkge1xuICAgICAgICAgICAgYnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICBidXR0b24uc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICB9IGVsc2UgaWYgKGJ1dHRvblN0eWxlID09PSBUYWJTY3JvbGxCdXR0b25TdHlsZS5EaXNhYmxlZCkge1xuICAgICAgICAgICAgYnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAoYnV0dG9uU3R5bGUgPT09IFRhYlNjcm9sbEJ1dHRvblN0eWxlLk5vdERpc3BsYXllZCkge1xuICAgICAgICAgICAgYnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJpdmF0ZSByZXNvbHZlTGVmdFNjcm9sbEJ1dHRvblN0eWxlKGl0ZW1zQ29udGFpbmVyV2lkdGg6IG51bWJlcik6IFRhYlNjcm9sbEJ1dHRvblN0eWxlIHtcbiAgICAgICAgY29uc3QgaGVhZGVyQ29udGFpbmVyV2lkdGggPSB0aGlzLmhlYWRlckNvbnRhaW5lci5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldDtcblxuICAgICAgICBpZiAob2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICAvLyBGaXggZm9yIElFIDExLCBhIGRpZmZlcmVuY2UgaXMgYWNjdW11bGF0ZWQgZnJvbSB0aGUgd2lkdGhzIGNhbGN1bGF0aW9ucy5cbiAgICAgICAgICAgIGlmIChpdGVtc0NvbnRhaW5lcldpZHRoIC0gaGVhZGVyQ29udGFpbmVyV2lkdGggPD0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBUYWJTY3JvbGxCdXR0b25TdHlsZS5Ob3REaXNwbGF5ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVGFiU2Nyb2xsQnV0dG9uU3R5bGUuRGlzYWJsZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gVGFiU2Nyb2xsQnV0dG9uU3R5bGUuRW5hYmxlZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcmVzb2x2ZVJpZ2h0U2Nyb2xsQnV0dG9uU3R5bGUoaXRlbXNDb250YWluZXJXaWR0aDogbnVtYmVyKTogVGFiU2Nyb2xsQnV0dG9uU3R5bGUge1xuICAgICAgICBjb25zdCB2aWV3UG9ydFdpZHRoID0gdGhpcy52aWV3UG9ydC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICBjb25zdCBoZWFkZXJDb250YWluZXJXaWR0aCA9IHRoaXMuaGVhZGVyQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBjb25zdCB0b3RhbCA9IG9mZnNldCArIHZpZXdQb3J0V2lkdGg7XG5cbiAgICAgICAgLy8gRml4IGZvciBJRSAxMSwgYSBkaWZmZXJlbmNlIGlzIGFjY3VtdWxhdGVkIGZyb20gdGhlIHdpZHRocyBjYWxjdWxhdGlvbnMuXG4gICAgICAgIGlmIChpdGVtc0NvbnRhaW5lcldpZHRoIC0gaGVhZGVyQ29udGFpbmVyV2lkdGggPD0gMSAmJiBvZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBUYWJTY3JvbGxCdXR0b25TdHlsZS5Ob3REaXNwbGF5ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbXNDb250YWluZXJXaWR0aCA+IHRvdGFsKSB7XG4gICAgICAgICAgICByZXR1cm4gVGFiU2Nyb2xsQnV0dG9uU3R5bGUuRW5hYmxlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBUYWJTY3JvbGxCdXR0b25TdHlsZS5EaXNhYmxlZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VGFiSXRlbXNDb250YWluZXJXaWR0aCgpIHtcbiAgICAgICAgLy8gV2UgdXNlIHRoaXMgaGFja3kgd2F5IHRvIGdldCB0aGUgd2lkdGggb2YgdGhlIGl0ZW1zQ29udGFpbmVyLFxuICAgICAgICAvLyBiZWNhdXNlIHRoZXJlIGlzIGluY29uc2lzdGVuY3kgaW4gSUUgd2UgY2Fubm90IHVzZSBvZmZzZXRXaWR0aCBvciBzY3JvbGxPZmZzZXQuXG4gICAgICAgIGNvbnN0IGl0ZW1zQ29udGFpbmVyQ2hpbGRyZW5Db3VudCA9IHRoaXMuaXRlbXNDb250YWluZXIubmF0aXZlRWxlbWVudC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGxldCBpdGVtc0NvbnRhaW5lcldpZHRoID0gMDtcblxuICAgICAgICBpZiAoaXRlbXNDb250YWluZXJDaGlsZHJlbkNvdW50ID4gMSkge1xuICAgICAgICAgICAgY29uc3QgbGFzdFRhYiA9IHRoaXMuaXRlbXNDb250YWluZXIubmF0aXZlRWxlbWVudC5jaGlsZHJlbltpdGVtc0NvbnRhaW5lckNoaWxkcmVuQ291bnQgLSAxXSBhcyBIVE1MRWxlbWVudDtcbiAgICAgICAgICAgIGl0ZW1zQ29udGFpbmVyV2lkdGggPSB0aGlzLmdldEVsZW1lbnRPZmZzZXQobGFzdFRhYikgKyBsYXN0VGFiLm9mZnNldFdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1zQ29udGFpbmVyV2lkdGg7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRPZmZzZXQob2Zmc2V0OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXIucnRsID8gLW9mZnNldCA6IG9mZnNldDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEVsZW1lbnRPZmZzZXQoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXIucnRsID8gdGhpcy5pdGVtc1dyYXBwZXIubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aCAtIGVsZW1lbnQub2Zmc2V0TGVmdCAtIGVsZW1lbnQub2Zmc2V0V2lkdGggOiBlbGVtZW50Lm9mZnNldExlZnQ7XG4gICAgfVxufVxuIiwiPGRpdiAjaGVhZGVyQ29udGFpbmVyIGNsYXNzPVwiaWd4LXRhYnNfX2hlYWRlclwiPlxuICAgIDxidXR0b24gI3Njcm9sbFByZXZCdXR0b24gdHlwZT1cImJ1dHRvblwiIGlneEljb25CdXR0b249XCJmbGF0XCIgaWd4UmlwcGxlIHRhYmluZGV4PVwiLTFcIiBjbGFzcz1cImlneC10YWJzX19oZWFkZXItYnV0dG9uXCIgKGNsaWNrKT1cInNjcm9sbFByZXYoKVwiPlxuICAgICAgICA8aWd4LWljb24gZmFtaWx5PVwiZGVmYXVsdFwiIG5hbWU9XCJwcmV2XCI+PC9pZ3gtaWNvbj5cbiAgICA8L2J1dHRvbj5cbiAgICA8ZGl2ICN2aWV3UG9ydCBjbGFzcz1cImlneC10YWJzX19oZWFkZXItY29udGVudFwiPlxuICAgICAgICA8ZGl2ICNpdGVtc1dyYXBwZXIgY2xhc3M9XCJpZ3gtdGFic19faGVhZGVyLXdyYXBwZXJcIiByb2xlPVwidGFibGlzdFwiPlxuICAgICAgICAgICAgPGRpdiAjaXRlbXNDb250YWluZXIgY2xhc3M9XCJpZ3gtdGFic19faGVhZGVyLXNjcm9sbFwiIFtuZ0NsYXNzXT1cInJlc29sdmVIZWFkZXJTY3JvbGxDbGFzc2VzKClcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCB0YWIgb2YgaXRlbXM7IGxldCBpID0gaW5kZXhcIj5cbiAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInRhYi5oZWFkZXJUZW1wbGF0ZVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2ICNzZWxlY3RlZEluZGljYXRvciAqbmdJZj1cIml0ZW1zLmxlbmd0aCA+IDBcIiBjbGFzcz1cImlneC10YWJzX19oZWFkZXItYWN0aXZlLWluZGljYXRvclwiPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxidXR0b24gI3Njcm9sbE5leHRCdXR0b24gdHlwZT1cImJ1dHRvblwiIGlneEljb25CdXR0b249XCJmbGF0XCIgaWd4UmlwcGxlIHRhYmluZGV4PVwiLTFcIiBjbGFzcz1cImlneC10YWJzX19oZWFkZXItYnV0dG9uXCIgKGNsaWNrKT1cInNjcm9sbE5leHQoKVwiPlxuICAgICAgICA8aWd4LWljb24gZmFtaWx5PVwiZGVmYXVsdFwiIG5hbWU9XCJuZXh0XCI+PC9pZ3gtaWNvbj5cbiAgICA8L2J1dHRvbj5cbjwvZGl2PlxuPGRpdiBjbGFzcz1cImlneC10YWJzX19wYW5lbHNcIj5cbiAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCB0YWIgb2YgaXRlbXM7IGxldCBpID0gaW5kZXhcIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInRhYi5wYW5lbFRlbXBsYXRlXCI+PC9uZy1jb250YWluZXI+XG4gICAgPC9uZy1jb250YWluZXI+XG48L2Rpdj5cbiJdfQ==