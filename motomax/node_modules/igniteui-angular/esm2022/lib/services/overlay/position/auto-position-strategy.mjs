import { HorizontalAlignment, VerticalAlignment } from './../utilities';
import { BaseFitPositionStrategy } from './base-fit-position-strategy';
import { AnimationUtil } from 'igniteui-angular/animations';
/**
 * Positions the element as in **Connected** positioning strategy and re-positions the element in
 * the view port (calculating a different start point) in case the element is partially getting out of view
 */
export class AutoPositionStrategy extends BaseFitPositionStrategy {
    /**
     * Fits the element into viewport according to the position settings
     *
     * @param element element to fit in viewport
     * @param connectedFit connectedFit object containing all necessary parameters
     */
    fitInViewport(element, connectedFit) {
        const transformString = [];
        if (connectedFit.fitHorizontal.back < 0 || connectedFit.fitHorizontal.forward < 0) {
            if (this.canFlipHorizontal(connectedFit)) {
                this.flipHorizontal();
                this.flipAnimation(FlipDirection.Horizontal);
            }
            else {
                const horizontalPush = this.horizontalPush(connectedFit);
                transformString.push(`translateX(${horizontalPush}px)`);
            }
        }
        if (connectedFit.fitVertical.back < 0 || connectedFit.fitVertical.forward < 0) {
            if (this.canFlipVertical(connectedFit)) {
                this.flipVertical();
                this.flipAnimation(FlipDirection.Vertical);
            }
            else {
                const verticalPush = this.verticalPush(connectedFit);
                transformString.push(`translateY(${verticalPush}px)`);
            }
        }
        element.style.transform = transformString.join(' ').trim();
    }
    /**
     * Checks if element can be flipped without get off the viewport
     *
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns true if element can be flipped and stain in viewport
     */
    canFlipHorizontal(connectedFit) {
        //  HorizontalAlignment can be Left = -1; Center = -0.5 or Right = 0.
        //  To virtually flip direction and start point (both are HorizontalAlignment) we can do this:
        //  flippedAlignment = (-1) * (HorizontalAlignment + 1)
        //  this way:
        //  (-1) * (Left + 1) = 0 = Right
        //  (-1) * (Center + 1) = -0.5 = Center
        //  (-1) * (Right + 1) = -1 = Left
        const flippedStartPoint = (-1) * (this.settings.horizontalStartPoint + 1);
        const flippedDirection = (-1) * (this.settings.horizontalDirection + 1);
        const leftBorder = this.calculateLeft(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection, 0);
        const rightBorder = leftBorder + connectedFit.contentElementRect.width;
        return 0 < leftBorder && rightBorder < connectedFit.viewPortRect.width;
    }
    /**
     * Checks if element can be flipped without get off the viewport
     *
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns true if element can be flipped and stain in viewport
     */
    canFlipVertical(connectedFit) {
        const flippedStartPoint = (-1) * (this.settings.verticalStartPoint + 1);
        const flippedDirection = (-1) * (this.settings.verticalDirection + 1);
        const topBorder = this.calculateTop(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection, 0);
        const bottomBorder = topBorder + connectedFit.contentElementRect.height;
        return 0 < topBorder && bottomBorder < connectedFit.viewPortRect.height;
    }
    /**
     * Flips direction and start point of the position settings
     */
    flipHorizontal() {
        switch (this.settings.horizontalDirection) {
            case HorizontalAlignment.Left:
                this.settings.horizontalDirection = HorizontalAlignment.Right;
                break;
            case HorizontalAlignment.Right:
                this.settings.horizontalDirection = HorizontalAlignment.Left;
                break;
        }
        switch (this.settings.horizontalStartPoint) {
            case HorizontalAlignment.Left:
                this.settings.horizontalStartPoint = HorizontalAlignment.Right;
                break;
            case HorizontalAlignment.Right:
                this.settings.horizontalStartPoint = HorizontalAlignment.Left;
                break;
        }
    }
    /**
     * Flips direction and start point of the position settings
     */
    flipVertical() {
        switch (this.settings.verticalDirection) {
            case VerticalAlignment.Top:
                this.settings.verticalDirection = VerticalAlignment.Bottom;
                break;
            case VerticalAlignment.Bottom:
                this.settings.verticalDirection = VerticalAlignment.Top;
                break;
        }
        switch (this.settings.verticalStartPoint) {
            case VerticalAlignment.Top:
                this.settings.verticalStartPoint = VerticalAlignment.Bottom;
                break;
            case VerticalAlignment.Bottom:
                this.settings.verticalStartPoint = VerticalAlignment.Top;
                break;
        }
    }
    /**
     * Calculates necessary horizontal push according to provided connectedFit
     *
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns amount of necessary translation which will push the element into viewport
     */
    horizontalPush(connectedFit) {
        const leftExtend = connectedFit.left;
        const rightExtend = connectedFit.right - connectedFit.viewPortRect.width;
        //  if leftExtend < 0 overlay goes beyond left end of the screen. We should push it back with exactly
        //  as much as it is beyond the screen.
        //  if rightExtend > 0 overlay goes beyond right end of the screen. We should push it back with the
        //  extend but with amount not bigger than what left between left border of screen and left border of
        //  overlay, e.g. leftExtend
        if (leftExtend < 0) {
            return Math.abs(leftExtend);
        }
        else if (rightExtend > 0) {
            return -Math.min(rightExtend, leftExtend);
        }
        else {
            return 0;
        }
    }
    /**
     * Calculates necessary vertical push according to provided connectedFit
     *
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns amount of necessary translation which will push the element into viewport
     */
    verticalPush(connectedFit) {
        const topExtend = connectedFit.top;
        const bottomExtend = connectedFit.bottom - connectedFit.viewPortRect.height;
        if (topExtend < 0) {
            return Math.abs(topExtend);
        }
        else if (bottomExtend > 0) {
            return -Math.min(bottomExtend, topExtend);
        }
        else {
            return 0;
        }
    }
    /**
     * Changes open and close animation with reverse animation if one exists
     *
     * @param flipDirection direction for which to change the animations
     */
    flipAnimation(flipDirection) {
        if (this.settings.openAnimation) {
            this.settings.openAnimation = this.updateAnimation(this.settings.openAnimation, flipDirection);
        }
        if (this.settings.closeAnimation) {
            this.settings.closeAnimation = this.updateAnimation(this.settings.closeAnimation, flipDirection);
        }
    }
    /**
     * Tries to find the reverse animation according to provided direction
     *
     * @param animation animation to update
     * @param direction required animation direction
     * @returns reverse animation in given direction if one exists
     */
    updateAnimation(animation, direction) {
        switch (direction) {
            case FlipDirection.Horizontal:
                if (AnimationUtil.instance().isHorizontalAnimation(animation)) {
                    return AnimationUtil.instance().reverseAnimationResolver(animation);
                }
                break;
            case FlipDirection.Vertical:
                if (AnimationUtil.instance().isVerticalAnimation(animation)) {
                    return AnimationUtil.instance().reverseAnimationResolver(animation);
                }
                break;
        }
        return animation;
    }
}
var FlipDirection;
(function (FlipDirection) {
    FlipDirection[FlipDirection["Horizontal"] = 0] = "Horizontal";
    FlipDirection[FlipDirection["Vertical"] = 1] = "Vertical";
})(FlipDirection || (FlipDirection = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0by1wb3NpdGlvbi1zdHJhdGVneS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9zZXJ2aWNlcy9vdmVybGF5L3Bvc2l0aW9uL2F1dG8tcG9zaXRpb24tc3RyYXRlZ3kudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFnQixtQkFBbUIsRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3RGLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBQ3ZFLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUU1RDs7O0dBR0c7QUFDSCxNQUFNLE9BQU8sb0JBQXFCLFNBQVEsdUJBQXVCO0lBRTdEOzs7OztPQUtHO0lBQ08sYUFBYSxDQUFDLE9BQW9CLEVBQUUsWUFBMEI7UUFDcEUsTUFBTSxlQUFlLEdBQWEsRUFBRSxDQUFDO1FBQ3JDLElBQUksWUFBWSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLFlBQVksQ0FBQyxhQUFhLENBQUMsT0FBTyxHQUFHLENBQUMsRUFBRSxDQUFDO1lBQ2hGLElBQUksSUFBSSxDQUFDLGlCQUFpQixDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUM7Z0JBQ3ZDLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztnQkFDdEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDakQsQ0FBQztpQkFBTSxDQUFDO2dCQUNKLE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLENBQUM7Z0JBQ3pELGVBQWUsQ0FBQyxJQUFJLENBQUMsY0FBYyxjQUFjLEtBQUssQ0FBQyxDQUFDO1lBQzVELENBQUM7UUFDTCxDQUFDO1FBRUQsSUFBSSxZQUFZLENBQUMsV0FBVyxDQUFDLElBQUksR0FB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LEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsRUFBRSxhQUFhLENBQUMsQ0FBQztRQUNuRyxDQUFDO1FBQ0QsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLGNBQWMsRUFBRSxDQUFDO1lBQy9CLElBQUksQ0FBQyxRQUFRLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxjQUFjLEVBQUUsYUFBYSxDQUFDLENBQUM7UUFDckcsQ0FBQztJQUNMLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSyxlQUFlLENBQUMsU0FBcUMsRUFBRSxTQUF3QjtRQUNuRixRQUFRLFNBQVMsRUFBRSxDQUFDO1lBQ2hCLEtBQUssYUFBYSxDQUFDLFVBQVU7Z0JBQ3pCLElBQUksYUFBYSxDQUFDLFFBQVEsRUFBRSxDQUFDLHFCQUFxQixDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUM7b0JBQzVELE9BQU8sYUFBYSxDQUFDLFFBQVEsRUFBRSxDQUFDLHdCQUF3QixDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUN4RSxDQUFDO2dCQUNELE1BQU07WUFDVixLQUFLLGFBQWEsQ0FBQyxRQUFRO2dCQUN2QixJQUFJLGFBQWEsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDO29CQUMxRCxPQUFPLGFBQWEsQ0FBQyxRQUFRLEVBQUUsQ0FBQyx3QkFBd0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFDeEUsQ0FBQztnQkFDRCxNQUFNO1FBQ2QsQ0FBQztRQUVELE9BQU8sU0FBUyxDQUFDO0lBQ3JCLENBQUM7Q0FDSjtBQUVELElBQUssYUFHSjtBQUhELFdBQUssYUFBYTtJQUNkLDZEQUFVLENBQUE7SUFDVix5REFBUSxDQUFBO0FBQ1osQ0FBQyxFQUhJLGFBQWEsS0FBYixhQUFhLFFBR2pCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQW5pbWF0aW9uUmVmZXJlbmNlTWV0YWRhdGEgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IENvbm5lY3RlZEZpdCwgSG9yaXpvbnRhbEFsaWdubWVudCwgVmVydGljYWxBbGlnbm1lbnQgfSBmcm9tICcuLy4uL3V0aWxpdGllcyc7XG5pbXBvcnQgeyBCYXNlRml0UG9zaXRpb25TdHJhdGVneSB9IGZyb20gJy4vYmFzZS1maXQtcG9zaXRpb24tc3RyYXRlZ3knO1xuaW1wb3J0IHsgQW5pbWF0aW9uVXRpbCB9IGZyb20gJ2lnbml0ZXVpLWFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5cbi8qKlxuICogUG9zaXRpb25zIHRoZSBlbGVtZW50IGFzIGluICoqQ29ubmVjdGVkKiogcG9zaXRpb25pbmcgc3RyYXRlZ3kgYW5kIHJlLXBvc2l0aW9ucyB0aGUgZWxlbWVudCBpblxuICogdGhlIHZpZXcgcG9ydCAoY2FsY3VsYXRpbmcgYSBkaWZmZXJlbnQgc3RhcnQgcG9pbnQpIGluIGNhc2UgdGhlIGVsZW1lbnQgaXMgcGFydGlhbGx5IGdldHRpbmcgb3V0IG9mIHZpZXdcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dG9Qb3NpdGlvblN0cmF0ZWd5IGV4dGVuZHMgQmFzZUZpdFBvc2l0aW9uU3RyYXRlZ3kge1xuXG4gICAgLyoqXG4gICAgICogRml0cyB0aGUgZWxlbWVudCBpbnRvIHZpZXdwb3J0IGFjY29yZGluZyB0byB0aGUgcG9zaXRpb24gc2V0dGluZ3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50IGVsZW1lbnQgdG8gZml0IGluIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIGNvbm5lY3RlZEZpdCBjb25uZWN0ZWRGaXQgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIG5lY2Vzc2FyeSBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGZpdEluVmlld3BvcnQoZWxlbWVudDogSFRNTEVsZW1lbnQsIGNvbm5lY3RlZEZpdDogQ29ubmVjdGVkRml0KSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybVN0cmluZzogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgaWYgKGNvbm5lY3RlZEZpdC5maXRIb3Jpem9udGFsLmJhY2sgPCAwIHx8IGNvbm5lY3RlZEZpdC5maXRIb3Jpem9udGFsLmZvcndhcmQgPCAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5GbGlwSG9yaXpvbnRhbChjb25uZWN0ZWRGaXQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mbGlwSG9yaXpvbnRhbCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmxpcEFuaW1hdGlvbihGbGlwRGlyZWN0aW9uLkhvcml6b250YWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBob3Jpem9udGFsUHVzaCA9IHRoaXMuaG9yaXpvbnRhbFB1c2goY29ubmVjdGVkRml0KTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1TdHJpbmcucHVzaChgdHJhbnNsYXRlWCgke2hvcml6b250YWxQdXNofXB4KWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbm5lY3RlZEZpdC5maXRWZXJ0aWNhbC5iYWNrIDwgMCB8fCBjb25uZWN0ZWRGaXQuZml0VmVydGljYWwuZm9yd2FyZCA8IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbkZsaXBWZXJ0aWNhbChjb25uZWN0ZWRGaXQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mbGlwVmVydGljYWwoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsaXBBbmltYXRpb24oRmxpcERpcmVjdGlvbi5WZXJ0aWNhbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnRpY2FsUHVzaCA9IHRoaXMudmVydGljYWxQdXNoKGNvbm5lY3RlZEZpdCk7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtU3RyaW5nLnB1c2goYHRyYW5zbGF0ZVkoJHt2ZXJ0aWNhbFB1c2h9cHgpYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVN0cmluZy5qb2luKCcgJykudHJpbSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBlbGVtZW50IGNhbiBiZSBmbGlwcGVkIHdpdGhvdXQgZ2V0IG9mZiB0aGUgdmlld3BvcnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25uZWN0ZWRGaXQgY29ubmVjdGVkRml0IG9iamVjdCBjb250YWluaW5nIGFsbCBuZWNlc3NhcnkgcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm5zIHRydWUgaWYgZWxlbWVudCBjYW4gYmUgZmxpcHBlZCBhbmQgc3RhaW4gaW4gdmlld3BvcnRcbiAgICAgKi9cbiAgICBwcml2YXRlIGNhbkZsaXBIb3Jpem9udGFsKGNvbm5lY3RlZEZpdDogQ29ubmVjdGVkRml0KTogYm9vbGVhbiB7XG4gICAgICAgIC8vICBIb3Jpem9udGFsQWxpZ25tZW50IGNhbiBiZSBMZWZ0ID0gLTE7IENlbnRlciA9IC0wLjUgb3IgUmlnaHQgPSAwLlxuICAgICAgICAvLyAgVG8gdmlydHVhbGx5IGZsaXAgZGlyZWN0aW9uIGFuZCBzdGFydCBwb2ludCAoYm90aCBhcmUgSG9yaXpvbnRhbEFsaWdubWVudCkgd2UgY2FuIGRvIHRoaXM6XG4gICAgICAgIC8vICBmbGlwcGVkQWxpZ25tZW50ID0gKC0xKSAqIChIb3Jpem9udGFsQWxpZ25tZW50ICsgMSlcbiAgICAgICAgLy8gIHRoaXMgd2F5OlxuICAgICAgICAvLyAgKC0xKSAqIChMZWZ0ICsgMSkgPSAwID0gUmlnaHRcbiAgICAgICAgLy8gICgtMSkgKiAoQ2VudGVyICsgMSkgPSAtMC41ID0gQ2VudGVyXG4gICAgICAgIC8vICAoLTEpICogKFJpZ2h0ICsgMSkgPSAtMSA9IExlZnRcbiAgICAgICAgY29uc3QgZmxpcHBlZFN0YXJ0UG9pbnQgPSAoLTEpICogKHRoaXMuc2V0dGluZ3MuaG9yaXpvbnRhbFN0YXJ0UG9pbnQgKyAxKTtcbiAgICAgICAgY29uc3QgZmxpcHBlZERpcmVjdGlvbiA9ICgtMSkgKiAodGhpcy5zZXR0aW5ncy5ob3Jpem9udGFsRGlyZWN0aW9uICsgMSk7XG5cbiAgICAgICAgY29uc3QgbGVmdEJvcmRlciA9IHRoaXMuY2FsY3VsYXRlTGVmdChcbiAgICAgICAgICAgIGNvbm5lY3RlZEZpdC50YXJnZXRSZWN0LCBjb25uZWN0ZWRGaXQuY29udGVudEVsZW1lbnRSZWN0LCBmbGlwcGVkU3RhcnRQb2ludCwgZmxpcHBlZERpcmVjdGlvbiwgMCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0Qm9yZGVyID0gbGVmdEJvcmRlciArIGNvbm5lY3RlZEZpdC5jb250ZW50RWxlbWVudFJlY3Qud2lkdGg7XG4gICAgICAgIHJldHVybiAwIDwgbGVmdEJvcmRlciAmJiByaWdodEJvcmRlciA8IGNvbm5lY3RlZEZpdC52aWV3UG9ydFJlY3Qud2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGVsZW1lbnQgY2FuIGJlIGZsaXBwZWQgd2l0aG91dCBnZXQgb2ZmIHRoZSB2aWV3cG9ydFxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbm5lY3RlZEZpdCBjb25uZWN0ZWRGaXQgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIG5lY2Vzc2FyeSBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBlbGVtZW50IGNhbiBiZSBmbGlwcGVkIGFuZCBzdGFpbiBpbiB2aWV3cG9ydFxuICAgICAqL1xuICAgIHByaXZhdGUgY2FuRmxpcFZlcnRpY2FsKGNvbm5lY3RlZEZpdDogQ29ubmVjdGVkRml0KTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGZsaXBwZWRTdGFydFBvaW50ID0gKC0xKSAqICh0aGlzLnNldHRpbmdzLnZlcnRpY2FsU3RhcnRQb2ludCArIDEpO1xuICAgICAgICBjb25zdCBmbGlwcGVkRGlyZWN0aW9uID0gKC0xKSAqICh0aGlzLnNldHRpbmdzLnZlcnRpY2FsRGlyZWN0aW9uICsgMSk7XG5cbiAgICAgICAgY29uc3QgdG9wQm9yZGVyID0gdGhpcy5jYWxjdWxhdGVUb3AoXG4gICAgICAgICAgICBjb25uZWN0ZWRGaXQudGFyZ2V0UmVjdCwgY29ubmVjdGVkRml0LmNvbnRlbnRFbGVtZW50UmVjdCwgZmxpcHBlZFN0YXJ0UG9pbnQsIGZsaXBwZWREaXJlY3Rpb24sIDApO1xuICAgICAgICBjb25zdCBib3R0b21Cb3JkZXIgPSB0b3BCb3JkZXIgKyBjb25uZWN0ZWRGaXQuY29udGVudEVsZW1lbnRSZWN0LmhlaWdodDtcbiAgICAgICAgcmV0dXJuIDAgPCB0b3BCb3JkZXIgJiYgYm90dG9tQm9yZGVyIDwgY29ubmVjdGVkRml0LnZpZXdQb3J0UmVjdC5oZWlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxpcHMgZGlyZWN0aW9uIGFuZCBzdGFydCBwb2ludCBvZiB0aGUgcG9zaXRpb24gc2V0dGluZ3NcbiAgICAgKi9cbiAgICBwcml2YXRlIGZsaXBIb3Jpem9udGFsKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc2V0dGluZ3MuaG9yaXpvbnRhbERpcmVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBIb3Jpem9udGFsQWxpZ25tZW50LkxlZnQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5ob3Jpem9udGFsRGlyZWN0aW9uID0gSG9yaXpvbnRhbEFsaWdubWVudC5SaWdodDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSG9yaXpvbnRhbEFsaWdubWVudC5SaWdodDpcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmhvcml6b250YWxEaXJlY3Rpb24gPSBIb3Jpem9udGFsQWxpZ25tZW50LkxlZnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLnNldHRpbmdzLmhvcml6b250YWxTdGFydFBvaW50KSB7XG4gICAgICAgICAgICBjYXNlIEhvcml6b250YWxBbGlnbm1lbnQuTGVmdDpcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmhvcml6b250YWxTdGFydFBvaW50ID0gSG9yaXpvbnRhbEFsaWdubWVudC5SaWdodDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSG9yaXpvbnRhbEFsaWdubWVudC5SaWdodDpcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmhvcml6b250YWxTdGFydFBvaW50ID0gSG9yaXpvbnRhbEFsaWdubWVudC5MZWZ0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxpcHMgZGlyZWN0aW9uIGFuZCBzdGFydCBwb2ludCBvZiB0aGUgcG9zaXRpb24gc2V0dGluZ3NcbiAgICAgKi9cbiAgICBwcml2YXRlIGZsaXBWZXJ0aWNhbCgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNldHRpbmdzLnZlcnRpY2FsRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIFZlcnRpY2FsQWxpZ25tZW50LlRvcDpcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnZlcnRpY2FsRGlyZWN0aW9uID0gVmVydGljYWxBbGlnbm1lbnQuQm90dG9tO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBWZXJ0aWNhbEFsaWdubWVudC5Cb3R0b206XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy52ZXJ0aWNhbERpcmVjdGlvbiA9IFZlcnRpY2FsQWxpZ25tZW50LlRvcDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMuc2V0dGluZ3MudmVydGljYWxTdGFydFBvaW50KSB7XG4gICAgICAgICAgICBjYXNlIFZlcnRpY2FsQWxpZ25tZW50LlRvcDpcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnZlcnRpY2FsU3RhcnRQb2ludCA9IFZlcnRpY2FsQWxpZ25tZW50LkJvdHRvbTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVmVydGljYWxBbGlnbm1lbnQuQm90dG9tOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MudmVydGljYWxTdGFydFBvaW50ID0gVmVydGljYWxBbGlnbm1lbnQuVG9wO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBuZWNlc3NhcnkgaG9yaXpvbnRhbCBwdXNoIGFjY29yZGluZyB0byBwcm92aWRlZCBjb25uZWN0ZWRGaXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25uZWN0ZWRGaXQgY29ubmVjdGVkRml0IG9iamVjdCBjb250YWluaW5nIGFsbCBuZWNlc3NhcnkgcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm5zIGFtb3VudCBvZiBuZWNlc3NhcnkgdHJhbnNsYXRpb24gd2hpY2ggd2lsbCBwdXNoIHRoZSBlbGVtZW50IGludG8gdmlld3BvcnRcbiAgICAgKi9cbiAgICBwcml2YXRlIGhvcml6b250YWxQdXNoKGNvbm5lY3RlZEZpdDogQ29ubmVjdGVkRml0KTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgbGVmdEV4dGVuZCA9IGNvbm5lY3RlZEZpdC5sZWZ0O1xuICAgICAgICBjb25zdCByaWdodEV4dGVuZCA9IGNvbm5lY3RlZEZpdC5yaWdodCAtIGNvbm5lY3RlZEZpdC52aWV3UG9ydFJlY3Qud2lkdGg7XG4gICAgICAgIC8vICBpZiBsZWZ0RXh0ZW5kIDwgMCBvdmVybGF5IGdvZXMgYmV5b25kIGxlZnQgZW5kIG9mIHRoZSBzY3JlZW4uIFdlIHNob3VsZCBwdXNoIGl0IGJhY2sgd2l0aCBleGFjdGx5XG4gICAgICAgIC8vICBhcyBtdWNoIGFzIGl0IGlzIGJleW9uZCB0aGUgc2NyZWVuLlxuICAgICAgICAvLyAgaWYgcmlnaHRFeHRlbmQgPiAwIG92ZXJsYXkgZ29lcyBiZXlvbmQgcmlnaHQgZW5kIG9mIHRoZSBzY3JlZW4uIFdlIHNob3VsZCBwdXNoIGl0IGJhY2sgd2l0aCB0aGVcbiAgICAgICAgLy8gIGV4dGVuZCBidXQgd2l0aCBhbW91bnQgbm90IGJpZ2dlciB0aGFuIHdoYXQgbGVmdCBiZXR3ZWVuIGxlZnQgYm9yZGVyIG9mIHNjcmVlbiBhbmQgbGVmdCBib3JkZXIgb2ZcbiAgICAgICAgLy8gIG92ZXJsYXksIGUuZy4gbGVmdEV4dGVuZFxuICAgICAgICBpZiAobGVmdEV4dGVuZCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhsZWZ0RXh0ZW5kKTtcbiAgICAgICAgfSBlbHNlIGlmIChyaWdodEV4dGVuZCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiAtIE1hdGgubWluKHJpZ2h0RXh0ZW5kLCBsZWZ0RXh0ZW5kKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBuZWNlc3NhcnkgdmVydGljYWwgcHVzaCBhY2NvcmRpbmcgdG8gcHJvdmlkZWQgY29ubmVjdGVkRml0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29ubmVjdGVkRml0IGNvbm5lY3RlZEZpdCBvYmplY3QgY29udGFpbmluZyBhbGwgbmVjZXNzYXJ5IHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJucyBhbW91bnQgb2YgbmVjZXNzYXJ5IHRyYW5zbGF0aW9uIHdoaWNoIHdpbGwgcHVzaCB0aGUgZWxlbWVudCBpbnRvIHZpZXdwb3J0XG4gICAgICovXG4gICAgcHJpdmF0ZSB2ZXJ0aWNhbFB1c2goY29ubmVjdGVkRml0OiBDb25uZWN0ZWRGaXQpOiBudW1iZXIge1xuICAgICAgICBjb25zdCB0b3BFeHRlbmQgPSBjb25uZWN0ZWRGaXQudG9wO1xuICAgICAgICBjb25zdCBib3R0b21FeHRlbmQgPSBjb25uZWN0ZWRGaXQuYm90dG9tIC0gY29ubmVjdGVkRml0LnZpZXdQb3J0UmVjdC5oZWlnaHQ7XG4gICAgICAgIGlmICh0b3BFeHRlbmQgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnModG9wRXh0ZW5kKTtcbiAgICAgICAgfSBlbHNlIGlmIChib3R0b21FeHRlbmQgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLSBNYXRoLm1pbihib3R0b21FeHRlbmQsIHRvcEV4dGVuZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgb3BlbiBhbmQgY2xvc2UgYW5pbWF0aW9uIHdpdGggcmV2ZXJzZSBhbmltYXRpb24gaWYgb25lIGV4aXN0c1xuICAgICAqXG4gICAgICogQHBhcmFtIGZsaXBEaXJlY3Rpb24gZGlyZWN0aW9uIGZvciB3aGljaCB0byBjaGFuZ2UgdGhlIGFuaW1hdGlvbnNcbiAgICAgKi9cbiAgICBwcml2YXRlIGZsaXBBbmltYXRpb24oZmxpcERpcmVjdGlvbjogRmxpcERpcmVjdGlvbik6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5vcGVuQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLm9wZW5BbmltYXRpb24gPSB0aGlzLnVwZGF0ZUFuaW1hdGlvbih0aGlzLnNldHRpbmdzLm9wZW5BbmltYXRpb24sIGZsaXBEaXJlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNsb3NlQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLmNsb3NlQW5pbWF0aW9uID0gdGhpcy51cGRhdGVBbmltYXRpb24odGhpcy5zZXR0aW5ncy5jbG9zZUFuaW1hdGlvbiwgZmxpcERpcmVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmllcyB0byBmaW5kIHRoZSByZXZlcnNlIGFuaW1hdGlvbiBhY2NvcmRpbmcgdG8gcHJvdmlkZWQgZGlyZWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW5pbWF0aW9uIGFuaW1hdGlvbiB0byB1cGRhdGVcbiAgICAgKiBAcGFyYW0gZGlyZWN0aW9uIHJlcXVpcmVkIGFuaW1hdGlvbiBkaXJlY3Rpb25cbiAgICAgKiBAcmV0dXJucyByZXZlcnNlIGFuaW1hdGlvbiBpbiBnaXZlbiBkaXJlY3Rpb24gaWYgb25lIGV4aXN0c1xuICAgICAqL1xuICAgIHByaXZhdGUgdXBkYXRlQW5pbWF0aW9uKGFuaW1hdGlvbjogQW5pbWF0aW9uUmVmZXJlbmNlTWV0YWRhdGEsIGRpcmVjdGlvbjogRmxpcERpcmVjdGlvbik6IEFuaW1hdGlvblJlZmVyZW5jZU1ldGFkYXRhIHtcbiAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgRmxpcERpcmVjdGlvbi5Ib3Jpem9udGFsOlxuICAgICAgICAgICAgICAgIGlmIChBbmltYXRpb25VdGlsLmluc3RhbmNlKCkuaXNIb3Jpem9udGFsQW5pbWF0aW9uKGFuaW1hdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFuaW1hdGlvblV0aWwuaW5zdGFuY2UoKS5yZXZlcnNlQW5pbWF0aW9uUmVzb2x2ZXIoYW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEZsaXBEaXJlY3Rpb24uVmVydGljYWw6XG4gICAgICAgICAgICAgICAgaWYgKEFuaW1hdGlvblV0aWwuaW5zdGFuY2UoKS5pc1ZlcnRpY2FsQW5pbWF0aW9uKGFuaW1hdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFuaW1hdGlvblV0aWwuaW5zdGFuY2UoKS5yZXZlcnNlQW5pbWF0aW9uUmVzb2x2ZXIoYW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYW5pbWF0aW9uO1xuICAgIH1cbn1cblxuZW51bSBGbGlwRGlyZWN0aW9uIHtcbiAgICBIb3Jpem9udGFsLFxuICAgIFZlcnRpY2FsXG59XG4iXX0=