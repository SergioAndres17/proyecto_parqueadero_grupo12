import { TransactionType } from './transaction';
import { EventEmitter } from '@angular/core';
import { isObject, mergeObjects } from '../../core/utils';
import { DefaultDataCloneStrategy } from '../../data-operations/data-clone-strategy';
export class IgxBaseTransactionService {
    constructor() {
        /**
         * Event fired when transaction state has changed - add transaction, commit all transactions, undo and redo
         */
        this.onStateUpdate = new EventEmitter();
        this._isPending = false;
        this._pendingTransactions = [];
        this._pendingStates = new Map();
        this._cloneStrategy = new DefaultDataCloneStrategy();
    }
    /**
     * Gets/Sets the data clone strategy used to clone data
     */
    get cloneStrategy() {
        return this._cloneStrategy;
    }
    set cloneStrategy(strategy) {
        if (strategy) {
            this._cloneStrategy = strategy;
        }
    }
    /**
     * @returns if there are any transactions in the Redo stack
     */
    get canRedo() {
        return false;
    }
    /**
     * @returns if there are any transactions in the Undo stack
     */
    get canUndo() {
        return false;
    }
    /**
     * Returns whether transaction is enabled for this service
     */
    get enabled() {
        return this._isPending;
    }
    /**
     * Adds provided  transaction with recordRef if any
     *
     * @param transaction Transaction to be added
     * @param recordRef Reference to the value of the record in the data source related to the changed item
     */
    add(transaction, recordRef) {
        if (this._isPending) {
            this.updateState(this._pendingStates, transaction, recordRef);
            this._pendingTransactions.push(transaction);
        }
    }
    /**
     * Returns all recorded transactions in chronological order
     *
     * @param id Optional record id to get transactions for
     * @returns All transaction in the service or for the specified record
     */
    getTransactionLog(_id) {
        return [];
    }
    /**
     * Remove the last transaction if any
     */
    undo() { }
    /**
     * Applies the last undone transaction if any
     */
    redo() { }
    /**
     * Returns aggregated changes from all transactions
     *
     * @param mergeChanges If set to true will merge each state's value over relate recordRef
     * and will record resulting value in the related transaction
     * @returns Collection of aggregated transactions for each changed record
     */
    getAggregatedChanges(mergeChanges) {
        const result = [];
        this._pendingStates.forEach((state, key) => {
            const value = mergeChanges ? this.getAggregatedValue(key, mergeChanges) : state.value;
            result.push({ id: key, newValue: value, type: state.type });
        });
        return result;
    }
    /**
     * Returns the state of the record with provided id
     *
     * @param id The id of the record
     * @param pending Should get pending state
     * @returns State of the record if any
     */
    getState(id) {
        return this._pendingStates.get(id);
    }
    /**
     * Returns value of the required id including all uncommitted changes
     *
     * @param id The id of the record to return value for
     * @param mergeChanges If set to true will merge state's value over relate recordRef
     * and will return merged value
     * @returns Value with changes or **null**
     */
    getAggregatedValue(id, mergeChanges) {
        const state = this._pendingStates.get(id);
        if (!state) {
            return null;
        }
        if (mergeChanges && state.recordRef) {
            return this.updateValue(state);
        }
        return state.value;
    }
    /**
     * Applies all transactions over the provided data
     *
     * @param data Data source to update
     * @param id Optional record id to commit transactions for
     */
    commit(_data, _id) { }
    /**
     * Clears all transactions
     *
     * @param id Optional record id to clear transactions for
     */
    clear(_id) {
        this._pendingStates.clear();
        this._pendingTransactions = [];
    }
    /**
     * Starts pending transactions. All transactions passed after call to startPending
     * will not be added to transaction log
     */
    startPending() {
        this._isPending = true;
    }
    /**
     * Clears all pending transactions and aggregated pending state. If commit is set to true
     * commits pending states as single transaction
     *
     * @param commit Should commit the pending states
     */
    endPending(_commit) {
        this._isPending = false;
        this._pendingStates.clear();
        this._pendingTransactions = [];
    }
    /**
     * Updates the provided states collection according to passed transaction and recordRef
     *
     * @param states States collection to apply the update to
     * @param transaction Transaction to apply to the current state
     * @param recordRef Reference to the value of the record in data source, if any, where transaction should be applied
     */
    updateState(states, transaction, recordRef) {
        let state = states.get(transaction.id);
        if (state) {
            if (isObject(state.value)) {
                mergeObjects(state.value, transaction.newValue);
            }
            else {
                state.value = transaction.newValue;
            }
        }
        else {
            state = { value: this.cloneStrategy.clone(transaction.newValue), recordRef, type: transaction.type };
            states.set(transaction.id, state);
        }
        this.cleanState(transaction.id, states);
    }
    /**
     * Updates the recordRef of the provided state with all the changes in the state. Accepts primitive and object value types
     *
     * @param state State to update value for
     * @returns updated value including all the changes in provided state
     */
    updateValue(state) {
        return this.mergeValues(state.recordRef, state.value);
    }
    /**
     * Merges second values in first value and the result in empty object. If values are primitive type
     * returns second value if exists, or first value.
     *
     * @param first Value to merge into
     * @param second Value to merge
     */
    mergeValues(first, second) {
        if (isObject(first) || isObject(second)) {
            return mergeObjects(this.cloneStrategy.clone(first), second);
        }
        else {
            return second ? second : first;
        }
    }
    /**
     * Compares the state with recordRef and clears all duplicated values. If any state ends as
     * empty object removes it from states.
     *
     * @param state State to clean
     */
    cleanState(id, states) {
        const state = states.get(id);
        //  do nothing if
        //  there is no state, or
        //  there is no state value (e.g. DELETED transaction), or
        //  there is no recordRef (e.g. ADDED transaction)
        if (state && state.value && state.recordRef) {
            //  if state's value is object compare each key with the ones in recordRef
            //  if values in any key are the same delete it from state's value
            //  if state's value is not object, simply compare with recordRef and remove
            //  the state if they are equal
            if (isObject(state.recordRef)) {
                for (const key of Object.keys(state.value)) {
                    if (JSON.stringify(state.recordRef[key]) === JSON.stringify(state.value[key])) {
                        delete state.value[key];
                    }
                }
                //  if state's value is empty remove the state from the states, only if state is not DELETE type
                if (state.type !== TransactionType.DELETE && Object.keys(state.value).length === 0) {
                    states.delete(id);
                }
            }
            else {
                if (state.recordRef === state.value) {
                    states.delete(id);
                }
            }
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS10cmFuc2FjdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9zZXJ2aWNlcy90cmFuc2FjdGlvbi9iYXNlLXRyYW5zYWN0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBNEQsZUFBZSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzFHLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDN0MsT0FBTyxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUMxRCxPQUFPLEVBQUUsd0JBQXdCLEVBQXNCLE1BQU0sMkNBQTJDLENBQUM7QUFFekcsTUFBTSxPQUFPLHlCQUF5QjtJQUF0QztRQW1DSTs7V0FFRztRQUNJLGtCQUFhLEdBQUcsSUFBSSxZQUFZLEVBQW9CLENBQUM7UUFFbEQsZUFBVSxHQUFHLEtBQUssQ0FBQztRQUNuQix5QkFBb0IsR0FBUSxFQUFFLENBQUM7UUFDL0IsbUJBQWMsR0FBZ0IsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUMxQyxtQkFBYyxHQUF1QixJQUFJLHdCQUF3QixFQUFFLENBQUM7SUEyTWhGLENBQUM7SUFyUEc7O09BRUc7SUFDSCxJQUFXLGFBQWE7UUFDcEIsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDO0lBQy9CLENBQUM7SUFFRCxJQUFXLGFBQWEsQ0FBQyxRQUE0QjtRQUNqRCxJQUFJLFFBQVEsRUFBRSxDQUFDO1lBQ1gsSUFBSSxDQUFDLGNBQWMsR0FBRyxRQUFRLENBQUM7UUFDbkMsQ0FBQztJQUNMLENBQUM7SUFFRDs7T0FFRztJQUNILElBQVcsT0FBTztRQUNkLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLENBQUM7SUFFRDs7T0FFRztJQUNILElBQVcsT0FBTztRQUNkLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLENBQUM7SUFFRDs7T0FFRztJQUNILElB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LENBQUMsQ0FBQztnQkFDdEIsQ0FBQztZQUNMLENBQUM7UUFDTCxDQUFDO0lBQ0wsQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVHJhbnNhY3Rpb25TZXJ2aWNlLCBUcmFuc2FjdGlvbiwgU3RhdGUsIFN0YXRlVXBkYXRlRXZlbnQsIFRyYW5zYWN0aW9uVHlwZSB9IGZyb20gJy4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBpc09iamVjdCwgbWVyZ2VPYmplY3RzIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBEZWZhdWx0RGF0YUNsb25lU3RyYXRlZ3ksIElEYXRhQ2xvbmVTdHJhdGVneSB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9kYXRhLWNsb25lLXN0cmF0ZWd5JztcblxuZXhwb3J0IGNsYXNzIElneEJhc2VUcmFuc2FjdGlvblNlcnZpY2U8VCBleHRlbmRzIFRyYW5zYWN0aW9uLCBTIGV4dGVuZHMgU3RhdGU+IGltcGxlbWVudHMgVHJhbnNhY3Rpb25TZXJ2aWNlPFQsIFM+IHtcbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgdGhlIGRhdGEgY2xvbmUgc3RyYXRlZ3kgdXNlZCB0byBjbG9uZSBkYXRhXG4gICAgICovXG4gICAgcHVibGljIGdldCBjbG9uZVN0cmF0ZWd5KCk6IElEYXRhQ2xvbmVTdHJhdGVneSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZVN0cmF0ZWd5O1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgY2xvbmVTdHJhdGVneShzdHJhdGVneTogSURhdGFDbG9uZVN0cmF0ZWd5KSB7XG4gICAgICAgIGlmIChzdHJhdGVneSkge1xuICAgICAgICAgICAgdGhpcy5fY2xvbmVTdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgaWYgdGhlcmUgYXJlIGFueSB0cmFuc2FjdGlvbnMgaW4gdGhlIFJlZG8gc3RhY2tcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGNhblJlZG8oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBpZiB0aGVyZSBhcmUgYW55IHRyYW5zYWN0aW9ucyBpbiB0aGUgVW5kbyBzdGFja1xuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgY2FuVW5kbygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0cmFuc2FjdGlvbiBpcyBlbmFibGVkIGZvciB0aGlzIHNlcnZpY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGVuYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1BlbmRpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiB0cmFuc2FjdGlvbiBzdGF0ZSBoYXMgY2hhbmdlZCAtIGFkZCB0cmFuc2FjdGlvbiwgY29tbWl0IGFsbCB0cmFuc2FjdGlvbnMsIHVuZG8gYW5kIHJlZG9cbiAgICAgKi9cbiAgICBwdWJsaWMgb25TdGF0ZVVwZGF0ZSA9IG5ldyBFdmVudEVtaXR0ZXI8U3RhdGVVcGRhdGVFdmVudD4oKTtcblxuICAgIHByb3RlY3RlZCBfaXNQZW5kaW5nID0gZmFsc2U7XG4gICAgcHJvdGVjdGVkIF9wZW5kaW5nVHJhbnNhY3Rpb25zOiBUW10gPSBbXTtcbiAgICBwcm90ZWN0ZWQgX3BlbmRpbmdTdGF0ZXM6IE1hcDxhbnksIFM+ID0gbmV3IE1hcCgpO1xuICAgIHByaXZhdGUgX2Nsb25lU3RyYXRlZ3k6IElEYXRhQ2xvbmVTdHJhdGVneSA9IG5ldyBEZWZhdWx0RGF0YUNsb25lU3RyYXRlZ3koKTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgcHJvdmlkZWQgIHRyYW5zYWN0aW9uIHdpdGggcmVjb3JkUmVmIGlmIGFueVxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIFRyYW5zYWN0aW9uIHRvIGJlIGFkZGVkXG4gICAgICogQHBhcmFtIHJlY29yZFJlZiBSZWZlcmVuY2UgdG8gdGhlIHZhbHVlIG9mIHRoZSByZWNvcmQgaW4gdGhlIGRhdGEgc291cmNlIHJlbGF0ZWQgdG8gdGhlIGNoYW5nZWQgaXRlbVxuICAgICAqL1xuICAgIHB1YmxpYyBhZGQodHJhbnNhY3Rpb246IFQsIHJlY29yZFJlZj86IGFueSk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5faXNQZW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKHRoaXMuX3BlbmRpbmdTdGF0ZXMsIHRyYW5zYWN0aW9uLCByZWNvcmRSZWYpO1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1RyYW5zYWN0aW9ucy5wdXNoKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIHJlY29yZGVkIHRyYW5zYWN0aW9ucyBpbiBjaHJvbm9sb2dpY2FsIG9yZGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgT3B0aW9uYWwgcmVjb3JkIGlkIHRvIGdldCB0cmFuc2FjdGlvbnMgZm9yXG4gICAgICogQHJldHVybnMgQWxsIHRyYW5zYWN0aW9uIGluIHRoZSBzZXJ2aWNlIG9yIGZvciB0aGUgc3BlY2lmaWVkIHJlY29yZFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRUcmFuc2FjdGlvbkxvZyhfaWQ/OiBhbnkpOiBUW10ge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBsYXN0IHRyYW5zYWN0aW9uIGlmIGFueVxuICAgICAqL1xuICAgIHB1YmxpYyB1bmRvKCk6IHZvaWQgeyB9XG5cbiAgICAgLyoqXG4gICAgICAqIEFwcGxpZXMgdGhlIGxhc3QgdW5kb25lIHRyYW5zYWN0aW9uIGlmIGFueVxuICAgICAgKi9cbiAgICBwdWJsaWMgcmVkbygpOiB2b2lkIHsgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhZ2dyZWdhdGVkIGNoYW5nZXMgZnJvbSBhbGwgdHJhbnNhY3Rpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVyZ2VDaGFuZ2VzIElmIHNldCB0byB0cnVlIHdpbGwgbWVyZ2UgZWFjaCBzdGF0ZSdzIHZhbHVlIG92ZXIgcmVsYXRlIHJlY29yZFJlZlxuICAgICAqIGFuZCB3aWxsIHJlY29yZCByZXN1bHRpbmcgdmFsdWUgaW4gdGhlIHJlbGF0ZWQgdHJhbnNhY3Rpb25cbiAgICAgKiBAcmV0dXJucyBDb2xsZWN0aW9uIG9mIGFnZ3JlZ2F0ZWQgdHJhbnNhY3Rpb25zIGZvciBlYWNoIGNoYW5nZWQgcmVjb3JkXG4gICAgICovXG4gICAgcHVibGljIGdldEFnZ3JlZ2F0ZWRDaGFuZ2VzKG1lcmdlQ2hhbmdlczogYm9vbGVhbik6IFRbXSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogVFtdID0gW107XG4gICAgICAgIHRoaXMuX3BlbmRpbmdTdGF0ZXMuZm9yRWFjaCgoc3RhdGU6IFMsIGtleTogYW55KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG1lcmdlQ2hhbmdlcyA/IHRoaXMuZ2V0QWdncmVnYXRlZFZhbHVlKGtleSwgbWVyZ2VDaGFuZ2VzKSA6IHN0YXRlLnZhbHVlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBpZDoga2V5LCBuZXdWYWx1ZTogdmFsdWUsIHR5cGU6IHN0YXRlLnR5cGUgfSBhcyBUKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RhdGUgb2YgdGhlIHJlY29yZCB3aXRoIHByb3ZpZGVkIGlkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSByZWNvcmRcbiAgICAgKiBAcGFyYW0gcGVuZGluZyBTaG91bGQgZ2V0IHBlbmRpbmcgc3RhdGVcbiAgICAgKiBAcmV0dXJucyBTdGF0ZSBvZiB0aGUgcmVjb3JkIGlmIGFueVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRTdGF0ZShpZDogYW55KTogUyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wZW5kaW5nU3RhdGVzLmdldChpZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB2YWx1ZSBvZiB0aGUgcmVxdWlyZWQgaWQgaW5jbHVkaW5nIGFsbCB1bmNvbW1pdHRlZCBjaGFuZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSByZWNvcmQgdG8gcmV0dXJuIHZhbHVlIGZvclxuICAgICAqIEBwYXJhbSBtZXJnZUNoYW5nZXMgSWYgc2V0IHRvIHRydWUgd2lsbCBtZXJnZSBzdGF0ZSdzIHZhbHVlIG92ZXIgcmVsYXRlIHJlY29yZFJlZlxuICAgICAqIGFuZCB3aWxsIHJldHVybiBtZXJnZWQgdmFsdWVcbiAgICAgKiBAcmV0dXJucyBWYWx1ZSB3aXRoIGNoYW5nZXMgb3IgKipudWxsKipcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0QWdncmVnYXRlZFZhbHVlKGlkOiBhbnksIG1lcmdlQ2hhbmdlczogYm9vbGVhbik6IGFueSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fcGVuZGluZ1N0YXRlcy5nZXQoaWQpO1xuICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVyZ2VDaGFuZ2VzICYmIHN0YXRlLnJlY29yZFJlZikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlVmFsdWUoc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZS52YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGFsbCB0cmFuc2FjdGlvbnMgb3ZlciB0aGUgcHJvdmlkZWQgZGF0YVxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgRGF0YSBzb3VyY2UgdG8gdXBkYXRlXG4gICAgICogQHBhcmFtIGlkIE9wdGlvbmFsIHJlY29yZCBpZCB0byBjb21taXQgdHJhbnNhY3Rpb25zIGZvclxuICAgICAqL1xuICAgIHB1YmxpYyBjb21taXQoX2RhdGE6IGFueVtdLCBfaWQ/OiBhbnkpOiB2b2lkIHsgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCB0cmFuc2FjdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBPcHRpb25hbCByZWNvcmQgaWQgdG8gY2xlYXIgdHJhbnNhY3Rpb25zIGZvclxuICAgICAqL1xuICAgIHB1YmxpYyBjbGVhcihfaWQ/OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1N0YXRlcy5jbGVhcigpO1xuICAgICAgICB0aGlzLl9wZW5kaW5nVHJhbnNhY3Rpb25zID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIHBlbmRpbmcgdHJhbnNhY3Rpb25zLiBBbGwgdHJhbnNhY3Rpb25zIHBhc3NlZCBhZnRlciBjYWxsIHRvIHN0YXJ0UGVuZGluZ1xuICAgICAqIHdpbGwgbm90IGJlIGFkZGVkIHRvIHRyYW5zYWN0aW9uIGxvZ1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGFydFBlbmRpbmcoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2lzUGVuZGluZyA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCBwZW5kaW5nIHRyYW5zYWN0aW9ucyBhbmQgYWdncmVnYXRlZCBwZW5kaW5nIHN0YXRlLiBJZiBjb21taXQgaXMgc2V0IHRvIHRydWVcbiAgICAgKiBjb21taXRzIHBlbmRpbmcgc3RhdGVzIGFzIHNpbmdsZSB0cmFuc2FjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbW1pdCBTaG91bGQgY29tbWl0IHRoZSBwZW5kaW5nIHN0YXRlc1xuICAgICAqL1xuICAgIHB1YmxpYyBlbmRQZW5kaW5nKF9jb21taXQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5faXNQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdTdGF0ZXMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1RyYW5zYWN0aW9ucyA9IFtdO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcHJvdmlkZWQgc3RhdGVzIGNvbGxlY3Rpb24gYWNjb3JkaW5nIHRvIHBhc3NlZCB0cmFuc2FjdGlvbiBhbmQgcmVjb3JkUmVmXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdGVzIFN0YXRlcyBjb2xsZWN0aW9uIHRvIGFwcGx5IHRoZSB1cGRhdGUgdG9cbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gVHJhbnNhY3Rpb24gdG8gYXBwbHkgdG8gdGhlIGN1cnJlbnQgc3RhdGVcbiAgICAgKiBAcGFyYW0gcmVjb3JkUmVmIFJlZmVyZW5jZSB0byB0aGUgdmFsdWUgb2YgdGhlIHJlY29yZCBpbiBkYXRhIHNvdXJjZSwgaWYgYW55LCB3aGVyZSB0cmFuc2FjdGlvbiBzaG91bGQgYmUgYXBwbGllZFxuICAgICAqL1xuICAgIHByb3RlY3RlZCB1cGRhdGVTdGF0ZShzdGF0ZXM6IE1hcDxhbnksIFM+LCB0cmFuc2FjdGlvbjogVCwgcmVjb3JkUmVmPzogYW55KTogdm9pZCB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHN0YXRlcy5nZXQodHJhbnNhY3Rpb24uaWQpO1xuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdChzdGF0ZS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBtZXJnZU9iamVjdHMoc3RhdGUudmFsdWUsIHRyYW5zYWN0aW9uLm5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWUgPSB0cmFuc2FjdGlvbi5uZXdWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0geyB2YWx1ZTogdGhpcy5jbG9uZVN0cmF0ZWd5LmNsb25lKHRyYW5zYWN0aW9uLm5ld1ZhbHVlKSwgcmVjb3JkUmVmLCB0eXBlOiB0cmFuc2FjdGlvbi50eXBlIH0gYXMgUztcbiAgICAgICAgICAgIHN0YXRlcy5zZXQodHJhbnNhY3Rpb24uaWQsIHN0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2xlYW5TdGF0ZSh0cmFuc2FjdGlvbi5pZCwgc3RhdGVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSByZWNvcmRSZWYgb2YgdGhlIHByb3ZpZGVkIHN0YXRlIHdpdGggYWxsIHRoZSBjaGFuZ2VzIGluIHRoZSBzdGF0ZS4gQWNjZXB0cyBwcmltaXRpdmUgYW5kIG9iamVjdCB2YWx1ZSB0eXBlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlIFN0YXRlIHRvIHVwZGF0ZSB2YWx1ZSBmb3JcbiAgICAgKiBAcmV0dXJucyB1cGRhdGVkIHZhbHVlIGluY2x1ZGluZyBhbGwgdGhlIGNoYW5nZXMgaW4gcHJvdmlkZWQgc3RhdGVcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgdXBkYXRlVmFsdWUoc3RhdGU6IFMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2VWYWx1ZXMoc3RhdGUucmVjb3JkUmVmLCBzdGF0ZS52YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIHNlY29uZCB2YWx1ZXMgaW4gZmlyc3QgdmFsdWUgYW5kIHRoZSByZXN1bHQgaW4gZW1wdHkgb2JqZWN0LiBJZiB2YWx1ZXMgYXJlIHByaW1pdGl2ZSB0eXBlXG4gICAgICogcmV0dXJucyBzZWNvbmQgdmFsdWUgaWYgZXhpc3RzLCBvciBmaXJzdCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaXJzdCBWYWx1ZSB0byBtZXJnZSBpbnRvXG4gICAgICogQHBhcmFtIHNlY29uZCBWYWx1ZSB0byBtZXJnZVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBtZXJnZVZhbHVlczxVPihmaXJzdDogVSwgc2Vjb25kOiBVKTogVSB7XG4gICAgICAgIGlmIChpc09iamVjdChmaXJzdCkgfHwgaXNPYmplY3Qoc2Vjb25kKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1lcmdlT2JqZWN0cyh0aGlzLmNsb25lU3RyYXRlZ3kuY2xvbmUoZmlyc3QpLCBzZWNvbmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNlY29uZCA/IHNlY29uZCA6IGZpcnN0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdGhlIHN0YXRlIHdpdGggcmVjb3JkUmVmIGFuZCBjbGVhcnMgYWxsIGR1cGxpY2F0ZWQgdmFsdWVzLiBJZiBhbnkgc3RhdGUgZW5kcyBhc1xuICAgICAqIGVtcHR5IG9iamVjdCByZW1vdmVzIGl0IGZyb20gc3RhdGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlIFN0YXRlIHRvIGNsZWFuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNsZWFuU3RhdGUoaWQ6IGFueSwgc3RhdGVzOiBNYXA8YW55LCBTPik6IHZvaWQge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0YXRlcy5nZXQoaWQpO1xuICAgICAgICAvLyAgZG8gbm90aGluZyBpZlxuICAgICAgICAvLyAgdGhlcmUgaXMgbm8gc3RhdGUsIG9yXG4gICAgICAgIC8vICB0aGVyZSBpcyBubyBzdGF0ZSB2YWx1ZSAoZS5nLiBERUxFVEVEIHRyYW5zYWN0aW9uKSwgb3JcbiAgICAgICAgLy8gIHRoZXJlIGlzIG5vIHJlY29yZFJlZiAoZS5nLiBBRERFRCB0cmFuc2FjdGlvbilcbiAgICAgICAgaWYgKHN0YXRlICYmIHN0YXRlLnZhbHVlICYmIHN0YXRlLnJlY29yZFJlZikge1xuICAgICAgICAgICAgLy8gIGlmIHN0YXRlJ3MgdmFsdWUgaXMgb2JqZWN0IGNvbXBhcmUgZWFjaCBrZXkgd2l0aCB0aGUgb25lcyBpbiByZWNvcmRSZWZcbiAgICAgICAgICAgIC8vICBpZiB2YWx1ZXMgaW4gYW55IGtleSBhcmUgdGhlIHNhbWUgZGVsZXRlIGl0IGZyb20gc3RhdGUncyB2YWx1ZVxuICAgICAgICAgICAgLy8gIGlmIHN0YXRlJ3MgdmFsdWUgaXMgbm90IG9iamVjdCwgc2ltcGx5IGNvbXBhcmUgd2l0aCByZWNvcmRSZWYgYW5kIHJlbW92ZVxuICAgICAgICAgICAgLy8gIHRoZSBzdGF0ZSBpZiB0aGV5IGFyZSBlcXVhbFxuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHN0YXRlLnJlY29yZFJlZikpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzdGF0ZS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KHN0YXRlLnJlY29yZFJlZltrZXldKSA9PT0gSlNPTi5zdHJpbmdpZnkoc3RhdGUudmFsdWVba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS52YWx1ZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gIGlmIHN0YXRlJ3MgdmFsdWUgaXMgZW1wdHkgcmVtb3ZlIHRoZSBzdGF0ZSBmcm9tIHRoZSBzdGF0ZXMsIG9ubHkgaWYgc3RhdGUgaXMgbm90IERFTEVURSB0eXBlXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnR5cGUgIT09IFRyYW5zYWN0aW9uVHlwZS5ERUxFVEUgJiYgT2JqZWN0LmtleXMoc3RhdGUudmFsdWUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZXMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5yZWNvcmRSZWYgPT09IHN0YXRlLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlcy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==