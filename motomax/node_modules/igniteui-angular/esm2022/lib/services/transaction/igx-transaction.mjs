import { TransactionType, TransactionEventOrigin } from './transaction';
import { IgxBaseTransactionService } from './base-transaction';
import { isObject, mergeObjects } from '../../core/utils';
export class IgxTransactionService extends IgxBaseTransactionService {
    constructor() {
        super(...arguments);
        this._transactions = [];
        this._redoStack = [];
        this._undoStack = [];
        this._states = new Map();
    }
    /**
     * @returns if there are any transactions in the Undo stack
     */
    get canUndo() {
        return this._undoStack.length > 0;
    }
    /**
     * @returns if there are any transactions in the Redo stack
     */
    get canRedo() {
        return this._redoStack.length > 0;
    }
    /**
     * Adds provided  transaction with recordRef if any
     *
     * @param transaction Transaction to be added
     * @param recordRef Reference to the value of the record in the data source related to the changed item
     */
    add(transaction, recordRef) {
        const states = this._isPending ? this._pendingStates : this._states;
        this.verifyAddedTransaction(states, transaction, recordRef);
        this.addTransaction(transaction, states, recordRef);
    }
    /**
     * Returns all recorded transactions in chronological order
     *
     * @param id Optional record id to get transactions for
     * @returns All transaction in the service or for the specified record
     */
    getTransactionLog(id) {
        if (id !== undefined) {
            return this._transactions.filter(t => t.id === id);
        }
        return [...this._transactions];
    }
    /**
     * Returns aggregated changes from all transactions
     *
     * @param mergeChanges If set to true will merge each state's value over relate recordRef
     * and will record resulting value in the related transaction
     * @returns Collection of aggregated transactions for each changed record
     */
    getAggregatedChanges(mergeChanges) {
        const result = [];
        this._states.forEach((state, key) => {
            const value = mergeChanges ? this.mergeValues(state.recordRef, state.value) : state.value;
            result.push({ id: key, newValue: value, type: state.type });
        });
        return result;
    }
    /**
     * Returns the state of the record with provided id
     *
     * @param id The id of the record
     * @param pending Should get pending state
     * @returns State of the record if any
     */
    getState(id, pending = false) {
        return pending ? this._pendingStates.get(id) : this._states.get(id);
    }
    /**
     * Returns whether transaction is enabled for this service
     */
    get enabled() {
        return true;
    }
    /**
     * Returns value of the required id including all uncommitted changes
     *
     * @param id The id of the record to return value for
     * @param mergeChanges If set to true will merge state's value over relate recordRef
     * and will return merged value
     * @returns Value with changes or **null**
     */
    getAggregatedValue(id, mergeChanges) {
        const state = this._states.get(id);
        const pendingState = super.getState(id);
        //  if there is no state and there is no pending state return null
        if (!state && !pendingState) {
            return null;
        }
        const pendingChange = super.getAggregatedValue(id, false);
        const change = state && state.value;
        let aggregatedValue = this.mergeValues(change, pendingChange);
        if (mergeChanges) {
            const originalValue = state ? state.recordRef : pendingState.recordRef;
            aggregatedValue = this.mergeValues(originalValue, aggregatedValue);
        }
        return aggregatedValue;
    }
    /**
     * Clears all pending transactions and aggregated pending state. If commit is set to true
     * commits pending states as single transaction
     *
     * @param commit Should commit the pending states
     */
    endPending(commit) {
        this._isPending = false;
        if (commit) {
            const actions = [];
            // don't use addTransaction due to custom undo handling
            for (const transaction of this._pendingTransactions) {
                const pendingState = this._pendingStates.get(transaction.id);
                this._transactions.push(transaction);
                this.updateState(this._states, transaction, pendingState.recordRef);
                actions.push({ transaction, recordRef: pendingState.recordRef });
            }
            this._undoStack.push(actions);
            this._redoStack = [];
            this.onStateUpdate.emit({ origin: TransactionEventOrigin.END, actions });
        }
        super.endPending(commit);
    }
    /**
     * Applies all transactions over the provided data
     *
     * @param data Data source to update
     * @param id Optional record id to commit transactions for
     */
    commit(data, id) {
        if (id !== undefined) {
            const state = this.getState(id);
            if (state) {
                this.updateRecord(data, state);
            }
        }
        else {
            this._states.forEach((s) => {
                this.updateRecord(data, s);
            });
        }
        this.clear(id);
    }
    /**
     * Clears all transactions
     *
     * @param id Optional record id to clear transactions for
     */
    clear(id) {
        if (id !== undefined) {
            this._transactions = this._transactions.filter(t => t.id !== id);
            this._states.delete(id);
            //  Undo stack is an array of actions. Each action is array of transaction like objects
            //  We are going trough all the actions. For each action we are filtering out transactions
            //  with provided id. Finally if any action ends up as empty array we are removing it from
            //  undo stack
            this._undoStack = this._undoStack.map(a => a.filter(t => t.transaction.id !== id)).filter(a => a.length > 0);
        }
        else {
            this._transactions = [];
            this._states.clear();
            this._undoStack = [];
        }
        this._redoStack = [];
        this.onStateUpdate.emit({ origin: TransactionEventOrigin.CLEAR, actions: [] });
    }
    /**
     * Remove the last transaction if any
     */
    undo() {
        if (this._undoStack.length <= 0) {
            return;
        }
        const lastActions = this._undoStack.pop();
        this._transactions.splice(this._transactions.length - lastActions.length);
        this._redoStack.push(lastActions);
        this._states.clear();
        for (const currentActions of this._undoStack) {
            for (const transaction of currentActions) {
                this.updateState(this._states, transaction.transaction, transaction.recordRef);
            }
        }
        this.onStateUpdate.emit({ origin: TransactionEventOrigin.UNDO, actions: lastActions });
    }
    /**
     * Applies the last undone transaction if any
     */
    redo() {
        if (this._redoStack.length > 0) {
            const actions = this._redoStack.pop();
            for (const action of actions) {
                this.updateState(this._states, action.transaction, action.recordRef);
                this._transactions.push(action.transaction);
            }
            this._undoStack.push(actions);
            this.onStateUpdate.emit({ origin: TransactionEventOrigin.REDO, actions });
        }
    }
    addTransaction(transaction, states, recordRef) {
        this.updateState(states, transaction, recordRef);
        const transactions = this._isPending ? this._pendingTransactions : this._transactions;
        transactions.push(transaction);
        if (!this._isPending) {
            const actions = [{ transaction, recordRef }];
            this._undoStack.push(actions);
            this._redoStack = [];
            this.onStateUpdate.emit({ origin: TransactionEventOrigin.ADD, actions });
        }
    }
    /**
     * Verifies if the passed transaction is correct. If not throws an exception.
     *
     * @param transaction Transaction to be verified
     */
    verifyAddedTransaction(states, transaction, recordRef) {
        const state = states.get(transaction.id);
        switch (transaction.type) {
            case TransactionType.ADD:
                if (state) {
                    //  cannot add same item twice
                    throw new Error(`Cannot add this transaction. Transaction with id: ${transaction.id} has been already added.`);
                }
                break;
            case TransactionType.DELETE:
            case TransactionType.UPDATE:
                if (state && state.type === TransactionType.DELETE) {
                    //  cannot delete or update deleted items
                    throw new Error(`Cannot add this transaction. Transaction with id: ${transaction.id} has been already deleted.`);
                }
                if (!state && !recordRef && !this._isPending) {
                    //  cannot initially add transaction or delete item with no recordRef
                    throw new Error(`Cannot add this transaction. This is first transaction of type ${transaction.type} ` +
                        `for id ${transaction.id}. For first transaction of this type recordRef is mandatory.`);
                }
                break;
        }
    }
    /**
     * Updates the provided states collection according to passed transaction and recordRef
     *
     * @param states States collection to apply the update to
     * @param transaction Transaction to apply to the current state
     * @param recordRef Reference to the value of the record in data source, if any, where transaction should be applied
     */
    updateState(states, transaction, recordRef) {
        let state = states.get(transaction.id);
        //  if TransactionType is ADD simply add transaction to states;
        //  if TransactionType is DELETE:
        //    - if there is state with this id of type ADD remove it from the states;
        //    - if there is state with this id of type UPDATE change its type to DELETE;
        //    - if there is no state with this id add transaction to states;
        //  if TransactionType is UPDATE:
        //    - if there is state with this id of type ADD merge new value and state recordRef into state new value
        //    - if there is state with this id of type UPDATE merge new value into state new value
        //    - if there is state with this id and state type is DELETE change its type to UPDATE
        //    - if there is no state with this id add transaction to states;
        if (state) {
            switch (transaction.type) {
                case TransactionType.DELETE:
                    if (state.type === TransactionType.ADD) {
                        states.delete(transaction.id);
                    }
                    else if (state.type === TransactionType.UPDATE) {
                        state.value = transaction.newValue;
                        state.type = TransactionType.DELETE;
                    }
                    break;
                case TransactionType.UPDATE:
                    if (isObject(state.value)) {
                        if (state.type === TransactionType.ADD) {
                            state.value = this.mergeValues(state.value, transaction.newValue);
                        }
                        if (state.type === TransactionType.UPDATE) {
                            mergeObjects(state.value, transaction.newValue);
                        }
                    }
                    else {
                        state.value = transaction.newValue;
                    }
            }
        }
        else {
            state = { value: this.cloneStrategy.clone(transaction.newValue), recordRef, type: transaction.type };
            states.set(transaction.id, state);
        }
        this.cleanState(transaction.id, states);
    }
    /**
     * Updates state related record in the provided data
     *
     * @param data Data source to update
     * @param state State to update data from
     */
    updateRecord(data, state) {
        const index = data.findIndex(i => JSON.stringify(i) === JSON.stringify(state.recordRef || {}));
        switch (state.type) {
            case TransactionType.ADD:
                data.push(state.value);
                break;
            case TransactionType.DELETE:
                if (0 <= index && index < data.length) {
                    data.splice(index, 1);
                }
                break;
            case TransactionType.UPDATE:
                if (0 <= index && index < data.length) {
                    data[index] = this.updateValue(state);
                }
                break;
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWd4LXRyYW5zYWN0aW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL3NlcnZpY2VzL3RyYW5zYWN0aW9uL2lneC10cmFuc2FjdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQXNCLGVBQWUsRUFBRSxzQkFBc0IsRUFBVSxNQUFNLGVBQWUsQ0FBQztBQUNwRyxPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUMvRCxPQUFPLEVBQUUsUUFBUSxFQUFFLFlBQVksRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBRTFELE1BQU0sT0FBTyxxQkFBOEQsU0FBUSx5QkFBK0I7SUFBbEg7O1FBRWMsa0JBQWEsR0FBUSxFQUFFLENBQUM7UUFDeEIsZUFBVSxHQUFrQixFQUFFLENBQUM7UUFDL0IsZUFBVSxHQUFrQixFQUFFLENBQUM7UUFDL0IsWUFBTyxHQUFnQixJQUFJLEdBQUcsRUFBRSxDQUFDO0lBcVUvQyxDQUFDO0lBblVHOztPQUVHO0lBQ0gsSUFBb0IsT0FBTztRQUN2QixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFvQixPQUFPO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNhLEdBQUcsQ0FBQyxXQUFjLEVBQUUsU0FBZTtRQUMvQyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQ3BFLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxNQUFNLEVBQUUsV0FBVyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQzVE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QUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQzFDLENBQUM7Z0JBQ0QsTUFBTTtRQUNkLENBQUM7SUFDTCxDQUFDO0NBQ0oiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUcmFuc2FjdGlvbiwgU3RhdGUsIFRyYW5zYWN0aW9uVHlwZSwgVHJhbnNhY3Rpb25FdmVudE9yaWdpbiwgQWN0aW9uIH0gZnJvbSAnLi90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBJZ3hCYXNlVHJhbnNhY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi9iYXNlLXRyYW5zYWN0aW9uJztcbmltcG9ydCB7IGlzT2JqZWN0LCBtZXJnZU9iamVjdHMgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcblxuZXhwb3J0IGNsYXNzIElneFRyYW5zYWN0aW9uU2VydmljZTxUIGV4dGVuZHMgVHJhbnNhY3Rpb24sIFMgZXh0ZW5kcyBTdGF0ZT4gZXh0ZW5kcyBJZ3hCYXNlVHJhbnNhY3Rpb25TZXJ2aWNlPFQsIFM+IHtcblxuICAgIHByb3RlY3RlZCBfdHJhbnNhY3Rpb25zOiBUW10gPSBbXTtcbiAgICBwcm90ZWN0ZWQgX3JlZG9TdGFjazogQWN0aW9uPFQ+W11bXSA9IFtdO1xuICAgIHByb3RlY3RlZCBfdW5kb1N0YWNrOiBBY3Rpb248VD5bXVtdID0gW107XG4gICAgcHJvdGVjdGVkIF9zdGF0ZXM6IE1hcDxhbnksIFM+ID0gbmV3IE1hcCgpO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgaWYgdGhlcmUgYXJlIGFueSB0cmFuc2FjdGlvbnMgaW4gdGhlIFVuZG8gc3RhY2tcbiAgICAgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgZ2V0IGNhblVuZG8oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl91bmRvU3RhY2subGVuZ3RoID4gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBpZiB0aGVyZSBhcmUgYW55IHRyYW5zYWN0aW9ucyBpbiB0aGUgUmVkbyBzdGFja1xuICAgICAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBnZXQgY2FuUmVkbygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZG9TdGFjay5sZW5ndGggPiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgcHJvdmlkZWQgIHRyYW5zYWN0aW9uIHdpdGggcmVjb3JkUmVmIGlmIGFueVxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIFRyYW5zYWN0aW9uIHRvIGJlIGFkZGVkXG4gICAgICogQHBhcmFtIHJlY29yZFJlZiBSZWZlcmVuY2UgdG8gdGhlIHZhbHVlIG9mIHRoZSByZWNvcmQgaW4gdGhlIGRhdGEgc291cmNlIHJlbGF0ZWQgdG8gdGhlIGNoYW5nZWQgaXRlbVxuICAgICAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBhZGQodHJhbnNhY3Rpb246IFQsIHJlY29yZFJlZj86IGFueSk6IHZvaWQge1xuICAgICAgICBjb25zdCBzdGF0ZXMgPSB0aGlzLl9pc1BlbmRpbmcgPyB0aGlzLl9wZW5kaW5nU3RhdGVzIDogdGhpcy5fc3RhdGVzO1xuICAgICAgICB0aGlzLnZlcmlmeUFkZGVkVHJhbnNhY3Rpb24oc3RhdGVzLCB0cmFuc2FjdGlvbiwgcmVjb3JkUmVmKTtcbiAgICAgICAgdGhpcy5hZGRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgc3RhdGVzLCByZWNvcmRSZWYpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIHJlY29yZGVkIHRyYW5zYWN0aW9ucyBpbiBjaHJvbm9sb2dpY2FsIG9yZGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgT3B0aW9uYWwgcmVjb3JkIGlkIHRvIGdldCB0cmFuc2FjdGlvbnMgZm9yXG4gICAgICogQHJldHVybnMgQWxsIHRyYW5zYWN0aW9uIGluIHRoZSBzZXJ2aWNlIG9yIGZvciB0aGUgc3BlY2lmaWVkIHJlY29yZFxuICAgICAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBnZXRUcmFuc2FjdGlvbkxvZyhpZD86IGFueSk6IFRbXSB7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb25zLmZpbHRlcih0ID0+IHQuaWQgPT09IGlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWy4uLnRoaXMuX3RyYW5zYWN0aW9uc107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhZ2dyZWdhdGVkIGNoYW5nZXMgZnJvbSBhbGwgdHJhbnNhY3Rpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVyZ2VDaGFuZ2VzIElmIHNldCB0byB0cnVlIHdpbGwgbWVyZ2UgZWFjaCBzdGF0ZSdzIHZhbHVlIG92ZXIgcmVsYXRlIHJlY29yZFJlZlxuICAgICAqIGFuZCB3aWxsIHJlY29yZCByZXN1bHRpbmcgdmFsdWUgaW4gdGhlIHJlbGF0ZWQgdHJhbnNhY3Rpb25cbiAgICAgKiBAcmV0dXJucyBDb2xsZWN0aW9uIG9mIGFnZ3JlZ2F0ZWQgdHJhbnNhY3Rpb25zIGZvciBlYWNoIGNoYW5nZWQgcmVjb3JkXG4gICAgICovXG4gICAgcHVibGljIG92ZXJyaWRlIGdldEFnZ3JlZ2F0ZWRDaGFuZ2VzKG1lcmdlQ2hhbmdlczogYm9vbGVhbik6IFRbXSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogVFtdID0gW107XG4gICAgICAgIHRoaXMuX3N0YXRlcy5mb3JFYWNoKChzdGF0ZTogUywga2V5OiBhbnkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbWVyZ2VDaGFuZ2VzID8gdGhpcy5tZXJnZVZhbHVlcyhzdGF0ZS5yZWNvcmRSZWYsIHN0YXRlLnZhbHVlKSA6IHN0YXRlLnZhbHVlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBpZDoga2V5LCBuZXdWYWx1ZTogdmFsdWUsIHR5cGU6IHN0YXRlLnR5cGUgfSBhcyBUKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RhdGUgb2YgdGhlIHJlY29yZCB3aXRoIHByb3ZpZGVkIGlkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSByZWNvcmRcbiAgICAgKiBAcGFyYW0gcGVuZGluZyBTaG91bGQgZ2V0IHBlbmRpbmcgc3RhdGVcbiAgICAgKiBAcmV0dXJucyBTdGF0ZSBvZiB0aGUgcmVjb3JkIGlmIGFueVxuICAgICAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBnZXRTdGF0ZShpZDogYW55LCBwZW5kaW5nID0gZmFsc2UpOiBTIHtcbiAgICAgICAgcmV0dXJuIHBlbmRpbmcgPyB0aGlzLl9wZW5kaW5nU3RhdGVzLmdldChpZCkgOiB0aGlzLl9zdGF0ZXMuZ2V0KGlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdHJhbnNhY3Rpb24gaXMgZW5hYmxlZCBmb3IgdGhpcyBzZXJ2aWNlXG4gICAgICovXG4gICAgcHVibGljIG92ZXJyaWRlIGdldCBlbmFibGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHZhbHVlIG9mIHRoZSByZXF1aXJlZCBpZCBpbmNsdWRpbmcgYWxsIHVuY29tbWl0dGVkIGNoYW5nZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIHJlY29yZCB0byByZXR1cm4gdmFsdWUgZm9yXG4gICAgICogQHBhcmFtIG1lcmdlQ2hhbmdlcyBJZiBzZXQgdG8gdHJ1ZSB3aWxsIG1lcmdlIHN0YXRlJ3MgdmFsdWUgb3ZlciByZWxhdGUgcmVjb3JkUmVmXG4gICAgICogYW5kIHdpbGwgcmV0dXJuIG1lcmdlZCB2YWx1ZVxuICAgICAqIEByZXR1cm5zIFZhbHVlIHdpdGggY2hhbmdlcyBvciAqKm51bGwqKlxuICAgICAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBnZXRBZ2dyZWdhdGVkVmFsdWUoaWQ6IGFueSwgbWVyZ2VDaGFuZ2VzOiBib29sZWFuKTogYW55IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZXMuZ2V0KGlkKTtcbiAgICAgICAgY29uc3QgcGVuZGluZ1N0YXRlID0gc3VwZXIuZ2V0U3RhdGUoaWQpO1xuXG4gICAgICAgIC8vICBpZiB0aGVyZSBpcyBubyBzdGF0ZSBhbmQgdGhlcmUgaXMgbm8gcGVuZGluZyBzdGF0ZSByZXR1cm4gbnVsbFxuICAgICAgICBpZiAoIXN0YXRlICYmICFwZW5kaW5nU3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGVuZGluZ0NoYW5nZSA9IHN1cGVyLmdldEFnZ3JlZ2F0ZWRWYWx1ZShpZCwgZmFsc2UpO1xuICAgICAgICBjb25zdCBjaGFuZ2UgPSBzdGF0ZSAmJiBzdGF0ZS52YWx1ZTtcbiAgICAgICAgbGV0IGFnZ3JlZ2F0ZWRWYWx1ZSA9IHRoaXMubWVyZ2VWYWx1ZXMoY2hhbmdlLCBwZW5kaW5nQ2hhbmdlKTtcbiAgICAgICAgaWYgKG1lcmdlQ2hhbmdlcykge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxWYWx1ZSA9IHN0YXRlID8gc3RhdGUucmVjb3JkUmVmIDogcGVuZGluZ1N0YXRlLnJlY29yZFJlZjtcbiAgICAgICAgICAgIGFnZ3JlZ2F0ZWRWYWx1ZSA9IHRoaXMubWVyZ2VWYWx1ZXMob3JpZ2luYWxWYWx1ZSwgYWdncmVnYXRlZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWdncmVnYXRlZFZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgcGVuZGluZyB0cmFuc2FjdGlvbnMgYW5kIGFnZ3JlZ2F0ZWQgcGVuZGluZyBzdGF0ZS4gSWYgY29tbWl0IGlzIHNldCB0byB0cnVlXG4gICAgICogY29tbWl0cyBwZW5kaW5nIHN0YXRlcyBhcyBzaW5nbGUgdHJhbnNhY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb21taXQgU2hvdWxkIGNvbW1pdCB0aGUgcGVuZGluZyBzdGF0ZXNcbiAgICAgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgZW5kUGVuZGluZyhjb21taXQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5faXNQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChjb21taXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbnM6IEFjdGlvbjxUPltdID0gW107XG4gICAgICAgICAgICAvLyBkb24ndCB1c2UgYWRkVHJhbnNhY3Rpb24gZHVlIHRvIGN1c3RvbSB1bmRvIGhhbmRsaW5nXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRyYW5zYWN0aW9uIG9mIHRoaXMuX3BlbmRpbmdUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nU3RhdGUgPSB0aGlzLl9wZW5kaW5nU3RhdGVzLmdldCh0cmFuc2FjdGlvbi5pZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb25zLnB1c2godHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUodGhpcy5fc3RhdGVzLCB0cmFuc2FjdGlvbiwgcGVuZGluZ1N0YXRlLnJlY29yZFJlZik7XG4gICAgICAgICAgICAgICAgYWN0aW9ucy5wdXNoKHsgdHJhbnNhY3Rpb24sIHJlY29yZFJlZjogcGVuZGluZ1N0YXRlLnJlY29yZFJlZiB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdW5kb1N0YWNrLnB1c2goYWN0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLl9yZWRvU3RhY2sgPSBbXTtcblxuICAgICAgICAgICAgdGhpcy5vblN0YXRlVXBkYXRlLmVtaXQoeyBvcmlnaW46IFRyYW5zYWN0aW9uRXZlbnRPcmlnaW4uRU5ELCBhY3Rpb25zIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmVuZFBlbmRpbmcoY29tbWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGFsbCB0cmFuc2FjdGlvbnMgb3ZlciB0aGUgcHJvdmlkZWQgZGF0YVxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgRGF0YSBzb3VyY2UgdG8gdXBkYXRlXG4gICAgICogQHBhcmFtIGlkIE9wdGlvbmFsIHJlY29yZCBpZCB0byBjb21taXQgdHJhbnNhY3Rpb25zIGZvclxuICAgICAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBjb21taXQoZGF0YTogYW55W10sIGlkPzogYW55KTogdm9pZCB7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoaWQpO1xuICAgICAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVSZWNvcmQoZGF0YSwgc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVzLmZvckVhY2goKHM6IFMpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJlY29yZChkYXRhLCBzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXIoaWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgdHJhbnNhY3Rpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgT3B0aW9uYWwgcmVjb3JkIGlkIHRvIGNsZWFyIHRyYW5zYWN0aW9ucyBmb3JcbiAgICAgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgY2xlYXIoaWQ/OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zYWN0aW9ucyA9IHRoaXMuX3RyYW5zYWN0aW9ucy5maWx0ZXIodCA9PiB0LmlkICE9PSBpZCk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZXMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIC8vICBVbmRvIHN0YWNrIGlzIGFuIGFycmF5IG9mIGFjdGlvbnMuIEVhY2ggYWN0aW9uIGlzIGFycmF5IG9mIHRyYW5zYWN0aW9uIGxpa2Ugb2JqZWN0c1xuICAgICAgICAgICAgLy8gIFdlIGFyZSBnb2luZyB0cm91Z2ggYWxsIHRoZSBhY3Rpb25zLiBGb3IgZWFjaCBhY3Rpb24gd2UgYXJlIGZpbHRlcmluZyBvdXQgdHJhbnNhY3Rpb25zXG4gICAgICAgICAgICAvLyAgd2l0aCBwcm92aWRlZCBpZC4gRmluYWxseSBpZiBhbnkgYWN0aW9uIGVuZHMgdXAgYXMgZW1wdHkgYXJyYXkgd2UgYXJlIHJlbW92aW5nIGl0IGZyb21cbiAgICAgICAgICAgIC8vICB1bmRvIHN0YWNrXG4gICAgICAgICAgICB0aGlzLl91bmRvU3RhY2sgPSB0aGlzLl91bmRvU3RhY2subWFwKGEgPT4gYS5maWx0ZXIodCA9PiB0LnRyYW5zYWN0aW9uLmlkICE9PSBpZCkpLmZpbHRlcihhID0+IGEubGVuZ3RoID4gMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2FjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlcy5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5fdW5kb1N0YWNrID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVkb1N0YWNrID0gW107XG4gICAgICAgIHRoaXMub25TdGF0ZVVwZGF0ZS5lbWl0KHsgb3JpZ2luOiBUcmFuc2FjdGlvbkV2ZW50T3JpZ2luLkNMRUFSLCBhY3Rpb25zOiBbXSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGxhc3QgdHJhbnNhY3Rpb24gaWYgYW55XG4gICAgICovXG4gICAgcHVibGljIG92ZXJyaWRlIHVuZG8oKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl91bmRvU3RhY2subGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxhc3RBY3Rpb25zOiBBY3Rpb248VD5bXSA9IHRoaXMuX3VuZG9TdGFjay5wb3AoKTtcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb25zLnNwbGljZSh0aGlzLl90cmFuc2FjdGlvbnMubGVuZ3RoIC0gbGFzdEFjdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5fcmVkb1N0YWNrLnB1c2gobGFzdEFjdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuX3N0YXRlcy5jbGVhcigpO1xuICAgICAgICBmb3IgKGNvbnN0IGN1cnJlbnRBY3Rpb25zIG9mIHRoaXMuX3VuZG9TdGFjaykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0cmFuc2FjdGlvbiBvZiBjdXJyZW50QWN0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUodGhpcy5fc3RhdGVzLCB0cmFuc2FjdGlvbi50cmFuc2FjdGlvbiwgdHJhbnNhY3Rpb24ucmVjb3JkUmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub25TdGF0ZVVwZGF0ZS5lbWl0KHsgb3JpZ2luOiBUcmFuc2FjdGlvbkV2ZW50T3JpZ2luLlVORE8sIGFjdGlvbnM6IGxhc3RBY3Rpb25zIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIGxhc3QgdW5kb25lIHRyYW5zYWN0aW9uIGlmIGFueVxuICAgICAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSByZWRvKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fcmVkb1N0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbnM6IEFjdGlvbjxUPltdID0gdGhpcy5fcmVkb1N0YWNrLnBvcCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBhY3Rpb24gb2YgYWN0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUodGhpcy5fc3RhdGVzLCBhY3Rpb24udHJhbnNhY3Rpb24sIGFjdGlvbi5yZWNvcmRSZWYpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zYWN0aW9ucy5wdXNoKGFjdGlvbi50cmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3VuZG9TdGFjay5wdXNoKGFjdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5vblN0YXRlVXBkYXRlLmVtaXQoeyBvcmlnaW46IFRyYW5zYWN0aW9uRXZlbnRPcmlnaW4uUkVETywgYWN0aW9ucyB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBhZGRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbjogVCwgc3RhdGVzOiBNYXA8YW55LCBTPiwgcmVjb3JkUmVmPzogYW55KSB7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoc3RhdGVzLCB0cmFuc2FjdGlvbiwgcmVjb3JkUmVmKTtcblxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSB0aGlzLl9pc1BlbmRpbmcgPyB0aGlzLl9wZW5kaW5nVHJhbnNhY3Rpb25zIDogdGhpcy5fdHJhbnNhY3Rpb25zO1xuICAgICAgICB0cmFuc2FjdGlvbnMucHVzaCh0cmFuc2FjdGlvbik7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9pc1BlbmRpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSBbeyB0cmFuc2FjdGlvbiwgcmVjb3JkUmVmIH1dO1xuICAgICAgICAgICAgdGhpcy5fdW5kb1N0YWNrLnB1c2goYWN0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLl9yZWRvU3RhY2sgPSBbXTtcbiAgICAgICAgICAgIHRoaXMub25TdGF0ZVVwZGF0ZS5lbWl0KHsgb3JpZ2luOiBUcmFuc2FjdGlvbkV2ZW50T3JpZ2luLkFERCwgYWN0aW9ucyB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGlmIHRoZSBwYXNzZWQgdHJhbnNhY3Rpb24gaXMgY29ycmVjdC4gSWYgbm90IHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gVHJhbnNhY3Rpb24gdG8gYmUgdmVyaWZpZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgdmVyaWZ5QWRkZWRUcmFuc2FjdGlvbihzdGF0ZXM6IE1hcDxhbnksIFM+LCB0cmFuc2FjdGlvbjogVCwgcmVjb3JkUmVmPzogYW55KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gc3RhdGVzLmdldCh0cmFuc2FjdGlvbi5pZCk7XG4gICAgICAgIHN3aXRjaCAodHJhbnNhY3Rpb24udHlwZSkge1xuICAgICAgICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuQUREOlxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAgY2Fubm90IGFkZCBzYW1lIGl0ZW0gdHdpY2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgYWRkIHRoaXMgdHJhbnNhY3Rpb24uIFRyYW5zYWN0aW9uIHdpdGggaWQ6ICR7dHJhbnNhY3Rpb24uaWR9IGhhcyBiZWVuIGFscmVhZHkgYWRkZWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuREVMRVRFOlxuICAgICAgICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuVVBEQVRFOlxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuREVMRVRFKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICBjYW5ub3QgZGVsZXRlIG9yIHVwZGF0ZSBkZWxldGVkIGl0ZW1zXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGFkZCB0aGlzIHRyYW5zYWN0aW9uLiBUcmFuc2FjdGlvbiB3aXRoIGlkOiAke3RyYW5zYWN0aW9uLmlkfSBoYXMgYmVlbiBhbHJlYWR5IGRlbGV0ZWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc3RhdGUgJiYgIXJlY29yZFJlZiAmJiAhdGhpcy5faXNQZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICBjYW5ub3QgaW5pdGlhbGx5IGFkZCB0cmFuc2FjdGlvbiBvciBkZWxldGUgaXRlbSB3aXRoIG5vIHJlY29yZFJlZlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBhZGQgdGhpcyB0cmFuc2FjdGlvbi4gVGhpcyBpcyBmaXJzdCB0cmFuc2FjdGlvbiBvZiB0eXBlICR7dHJhbnNhY3Rpb24udHlwZX0gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgZm9yIGlkICR7dHJhbnNhY3Rpb24uaWR9LiBGb3IgZmlyc3QgdHJhbnNhY3Rpb24gb2YgdGhpcyB0eXBlIHJlY29yZFJlZiBpcyBtYW5kYXRvcnkuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcHJvdmlkZWQgc3RhdGVzIGNvbGxlY3Rpb24gYWNjb3JkaW5nIHRvIHBhc3NlZCB0cmFuc2FjdGlvbiBhbmQgcmVjb3JkUmVmXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdGVzIFN0YXRlcyBjb2xsZWN0aW9uIHRvIGFwcGx5IHRoZSB1cGRhdGUgdG9cbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gVHJhbnNhY3Rpb24gdG8gYXBwbHkgdG8gdGhlIGN1cnJlbnQgc3RhdGVcbiAgICAgKiBAcGFyYW0gcmVjb3JkUmVmIFJlZmVyZW5jZSB0byB0aGUgdmFsdWUgb2YgdGhlIHJlY29yZCBpbiBkYXRhIHNvdXJjZSwgaWYgYW55LCB3aGVyZSB0cmFuc2FjdGlvbiBzaG91bGQgYmUgYXBwbGllZFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBvdmVycmlkZSB1cGRhdGVTdGF0ZShzdGF0ZXM6IE1hcDxhbnksIFM+LCB0cmFuc2FjdGlvbjogVCwgcmVjb3JkUmVmPzogYW55KTogdm9pZCB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHN0YXRlcy5nZXQodHJhbnNhY3Rpb24uaWQpO1xuICAgICAgICAvLyAgaWYgVHJhbnNhY3Rpb25UeXBlIGlzIEFERCBzaW1wbHkgYWRkIHRyYW5zYWN0aW9uIHRvIHN0YXRlcztcbiAgICAgICAgLy8gIGlmIFRyYW5zYWN0aW9uVHlwZSBpcyBERUxFVEU6XG4gICAgICAgIC8vICAgIC0gaWYgdGhlcmUgaXMgc3RhdGUgd2l0aCB0aGlzIGlkIG9mIHR5cGUgQUREIHJlbW92ZSBpdCBmcm9tIHRoZSBzdGF0ZXM7XG4gICAgICAgIC8vICAgIC0gaWYgdGhlcmUgaXMgc3RhdGUgd2l0aCB0aGlzIGlkIG9mIHR5cGUgVVBEQVRFIGNoYW5nZSBpdHMgdHlwZSB0byBERUxFVEU7XG4gICAgICAgIC8vICAgIC0gaWYgdGhlcmUgaXMgbm8gc3RhdGUgd2l0aCB0aGlzIGlkIGFkZCB0cmFuc2FjdGlvbiB0byBzdGF0ZXM7XG4gICAgICAgIC8vICBpZiBUcmFuc2FjdGlvblR5cGUgaXMgVVBEQVRFOlxuICAgICAgICAvLyAgICAtIGlmIHRoZXJlIGlzIHN0YXRlIHdpdGggdGhpcyBpZCBvZiB0eXBlIEFERCBtZXJnZSBuZXcgdmFsdWUgYW5kIHN0YXRlIHJlY29yZFJlZiBpbnRvIHN0YXRlIG5ldyB2YWx1ZVxuICAgICAgICAvLyAgICAtIGlmIHRoZXJlIGlzIHN0YXRlIHdpdGggdGhpcyBpZCBvZiB0eXBlIFVQREFURSBtZXJnZSBuZXcgdmFsdWUgaW50byBzdGF0ZSBuZXcgdmFsdWVcbiAgICAgICAgLy8gICAgLSBpZiB0aGVyZSBpcyBzdGF0ZSB3aXRoIHRoaXMgaWQgYW5kIHN0YXRlIHR5cGUgaXMgREVMRVRFIGNoYW5nZSBpdHMgdHlwZSB0byBVUERBVEVcbiAgICAgICAgLy8gICAgLSBpZiB0aGVyZSBpcyBubyBzdGF0ZSB3aXRoIHRoaXMgaWQgYWRkIHRyYW5zYWN0aW9uIHRvIHN0YXRlcztcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRyYW5zYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5ERUxFVEU6XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQUREKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZXMuZGVsZXRlKHRyYW5zYWN0aW9uLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuVVBEQVRFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZSA9IHRyYW5zYWN0aW9uLm5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudHlwZSA9IFRyYW5zYWN0aW9uVHlwZS5ERUxFVEU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuVVBEQVRFOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3Qoc3RhdGUudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUudHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkFERCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlID0gdGhpcy5tZXJnZVZhbHVlcyhzdGF0ZS52YWx1ZSwgdHJhbnNhY3Rpb24ubmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5VUERBVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZU9iamVjdHMoc3RhdGUudmFsdWUsIHRyYW5zYWN0aW9uLm5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlID0gdHJhbnNhY3Rpb24ubmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0geyB2YWx1ZTogdGhpcy5jbG9uZVN0cmF0ZWd5LmNsb25lKHRyYW5zYWN0aW9uLm5ld1ZhbHVlKSwgcmVjb3JkUmVmLCB0eXBlOiB0cmFuc2FjdGlvbi50eXBlIH0gYXMgUztcbiAgICAgICAgICAgIHN0YXRlcy5zZXQodHJhbnNhY3Rpb24uaWQsIHN0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2xlYW5TdGF0ZSh0cmFuc2FjdGlvbi5pZCwgc3RhdGVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHN0YXRlIHJlbGF0ZWQgcmVjb3JkIGluIHRoZSBwcm92aWRlZCBkYXRhXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSBEYXRhIHNvdXJjZSB0byB1cGRhdGVcbiAgICAgKiBAcGFyYW0gc3RhdGUgU3RhdGUgdG8gdXBkYXRlIGRhdGEgZnJvbVxuICAgICAqL1xuICAgIHByb3RlY3RlZCB1cGRhdGVSZWNvcmQoZGF0YTogYW55W10sIHN0YXRlOiBTKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZGF0YS5maW5kSW5kZXgoaSA9PiBKU09OLnN0cmluZ2lmeShpKSA9PT0gSlNPTi5zdHJpbmdpZnkoc3RhdGUucmVjb3JkUmVmIHx8IHt9KSk7XG4gICAgICAgIHN3aXRjaCAoc3RhdGUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuQUREOlxuICAgICAgICAgICAgICAgIGRhdGEucHVzaChzdGF0ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5ERUxFVEU6XG4gICAgICAgICAgICAgICAgaWYgKDAgPD0gaW5kZXggJiYgaW5kZXggPCBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuVVBEQVRFOlxuICAgICAgICAgICAgICAgIGlmICgwIDw9IGluZGV4ICYmIGluZGV4IDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpbmRleF0gPSB0aGlzLnVwZGF0ZVZhbHVlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=