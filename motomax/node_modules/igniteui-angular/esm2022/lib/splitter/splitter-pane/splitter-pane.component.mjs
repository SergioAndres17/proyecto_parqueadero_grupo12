import { Component, HostBinding, Input, Output, EventEmitter, booleanAttribute } from '@angular/core';
import * as i0 from "@angular/core";
/**
 * Represents individual resizable/collapsible panes.
 *
 * @igxModule IgxSplitterModule
 *
 * @igxParent IgxSplitterComponent
 *
 * @igxKeywords pane
 *
 * @igxGroup presentation
 *
 * @remarks
 *  Users can control the resize behavior via the min and max size properties.
 */
export class IgxSplitterPaneComponent {
    /**
     * Gets/Sets the minimum allowed size of the current pane.
     *
     * @example
     * ```html
     * <igx-splitter>
     *  <igx-splitter-pane [minSize]='minSize'>...</igx-splitter-pane>
     * </igx-splitter>
     * ```
     */
    get minSize() {
        return this._minSize;
    }
    set minSize(value) {
        this._minSize = value;
        if (this.owner) {
            this.owner.panes.notifyOnChanges();
        }
    }
    /**
     * Gets/Set the maximum allowed size of the current pane.
     *
     * @example
     * ```html
     * <igx-splitter>
     *  <igx-splitter-pane [maxSize]='maxSize'>...</igx-splitter-pane>
     * </igx-splitter>
     * ```
     */
    get maxSize() {
        return this._maxSize;
    }
    set maxSize(value) {
        this._maxSize = value;
        if (this.owner) {
            this.owner.panes.notifyOnChanges();
        }
    }
    /**
     * Gets/Sets the size of the current pane.
     *  * @example
     * ```html
     * <igx-splitter>
     *  <igx-splitter-pane [size]='size'>...</igx-splitter-pane>
     * </igx-splitter>
     * ```
     */
    get size() {
        return this._size;
    }
    set size(value) {
        this._size = value;
        this.el.nativeElement.style.flex = this.flex;
    }
    /** @hidden @internal */
    get isPercentageSize() {
        return this.size === 'auto' || this.size.indexOf('%') !== -1;
    }
    /** @hidden @internal */
    get dragSize() {
        return this._dragSize;
    }
    set dragSize(val) {
        this._dragSize = val;
        this.el.nativeElement.style.flex = this.flex;
    }
    /**
     *
     * @hidden @internal
     * Gets the host native element.
     */
    get element() {
        return this.el.nativeElement;
    }
    /**
     * @hidden @internal
     * Gets the `flex` property of the current `IgxSplitterPaneComponent`.
     */
    get flex() {
        const size = this.dragSize || this.size;
        const grow = this.isPercentageSize && !this.dragSize ? 1 : 0;
        return `${grow} ${grow} ${size}`;
    }
    /**
     * Gets/Sets whether current pane is collapsed.
     *
     * @example
     * ```typescript
     * const isCollapsed = pane.collapsed;
     * ```
     */
    set collapsed(value) {
        if (this.owner) {
            // reset sibling sizes when pane collapse state changes.
            this._getSiblings().forEach(sibling => {
                sibling.size = 'auto';
                sibling.dragSize = null;
            });
        }
        this._collapsed = value;
        this.display = this._collapsed ? 'none' : 'flex';
        this.collapsedChange.emit(this._collapsed);
    }
    get collapsed() {
        return this._collapsed;
    }
    constructor(el) {
        this.el = el;
        /**
         * @hidden @internal
         * Gets/Sets the 'display' property of the current pane.
         */
        this.display = 'flex';
        /**
         * Gets/Sets whether pane is resizable.
         *
         * @example
         * ```html
         * <igx-splitter>
         *  <igx-splitter-pane [resizable]='false'>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         * @remarks
         * If pane is not resizable its related splitter bar cannot be dragged.
         */
        this.resizable = true;
        /**
         * Event fired when collapsed state of pane is changed.
         *
         * @example
         * ```html
         * <igx-splitter>
         *  <igx-splitter-pane (collapsedChange)='paneCollapsedChange($event)'>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.collapsedChange = new EventEmitter();
        /**
         * @hidden @internal
         * Gets/Sets the `overflow`.
         */
        this.overflow = 'auto';
        /**
         * @hidden @internal
         * Get/Sets the `minWidth` properties of the current pane.
         */
        this.minWidth = '0';
        /**
         * @hidden @internal
         * Get/Sets the `maxWidth` properties of the current pane.
         */
        this.maxWidth = '100%';
        /**
         * @hidden @internal
         * Gets/Sets the `minHeight` properties of the current pane.
         */
        this.minHeight = '0';
        /**
         * @hidden @internal
         * Gets/Sets the `maxHeight` properties of the current `IgxSplitterPaneComponent`.
         */
        this.maxHeight = '100%';
        this._size = 'auto';
        this._collapsed = false;
    }
    /**
     * Toggles the collapsed state of the pane.
     *
     * @example
     * ```typescript
     * pane.toggle();
     * ```
     */
    toggle() {
        this.collapsed = !this.collapsed;
    }
    /** @hidden @internal */
    _getSiblings() {
        const panes = this.owner.panes.toArray();
        const index = panes.indexOf(this);
        const siblings = [];
        if (index !== 0) {
            siblings.push(panes[index - 1]);
        }
        if (index !== panes.length - 1) {
            siblings.push(panes[index + 1]);
        }
        return siblings;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxSplitterPaneComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "18.2.4", type: IgxSplitterPaneComponent, isStandalone: true, selector: "igx-splitter-pane", inputs: { minSize: "minSize", maxSize: "maxSize", resizable: ["resizable", "resizable", booleanAttribute], size: "size", collapsed: ["collapsed", "collapsed", booleanAttribute] }, outputs: { collapsedChange: "collapsedChange" }, host: { properties: { "style.display": "this.display", "style.order": "this.order", "style.overflow": "this.overflow", "style.min-width": "this.minWidth", "style.max-width": "this.maxWidth", "style.min-height": "this.minHeight", "style.max-height": "this.maxHeight", "style.flex": "this.flex" } }, ngImport: i0, template: "<ng-content></ng-content>" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxSplitterPaneComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-splitter-pane', standalone: true, template: "<ng-content></ng-content>" }]
        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { display: [{
                type: HostBinding,
                args: ['style.display']
            }], minSize: [{
                type: Input
            }], maxSize: [{
                type: Input
            }], resizable: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], collapsedChange: [{
                type: Output
            }], order: [{
                type: HostBinding,
                args: ['style.order']
            }], overflow: [{
                type: HostBinding,
                args: ['style.overflow']
            }], minWidth: [{
                type: HostBinding,
                args: ['style.min-width']
            }], maxWidth: [{
                type: HostBinding,
                args: ['style.max-width']
            }], minHeight: [{
                type: HostBinding,
                args: ['style.min-height']
            }], maxHeight: [{
                type: HostBinding,
                args: ['style.max-height']
            }], size: [{
                type: Input
            }], flex: [{
                type: HostBinding,
                args: ['style.flex']
            }], collapsed: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BsaXR0ZXItcGFuZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvc3BsaXR0ZXIvc3BsaXR0ZXItcGFuZS9zcGxpdHRlci1wYW5lLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9zcGxpdHRlci9zcGxpdHRlci1wYW5lL3NwbGl0dGVyLXBhbmUuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsS0FBSyxFQUFjLE1BQU0sRUFBRSxZQUFZLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxlQUFlLENBQUM7O0FBRWxIOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFNSCxNQUFNLE9BQU8sd0JBQXdCO0lBV2pDOzs7Ozs7Ozs7T0FTRztJQUNILElBQ1csT0FBTztRQUNkLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQztJQUN6QixDQUFDO0lBQ0QsSUFBVyxPQUFPLENBQUMsS0FBYTtRQUM1QixJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQztRQUN0QixJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUNiLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQ3ZDLENBQUM7SUFDTCxDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0gsSUFDVyxPQUFPO1FBQ2QsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3pCLENBQUM7SUFDRCxJQUFXLE9BQU8sQ0FBQyxLQUFhO1FBQzVCLElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ3RCLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ2IsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsZUFB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QixNQUFNO2dCQUtBLEtBQUs7c0JBRFgsV0FBVzt1QkFBQyxhQUFhO2dCQVFuQixRQUFRO3NCQURkLFdBQVc7dUJBQUMsZ0JBQWdCO2dCQVF0QixRQUFRO3NCQURkLFdBQVc7dUJBQUMsaUJBQWlCO2dCQVF2QixRQUFRO3NCQURkLFdBQVc7dUJBQUMsaUJBQWlCO2dCQVF2QixTQUFTO3NCQURmLFdBQVc7dUJBQUMsa0JBQWtCO2dCQVF4QixTQUFTO3NCQURmLFdBQVc7dUJBQUMsa0JBQWtCO2dCQWdCcEIsSUFBSTtzQkFEZCxLQUFLO2dCQXNDSyxJQUFJO3NCQURkLFdBQVc7dUJBQUMsWUFBWTtnQkFnQmQsU0FBUztzQkFEbkIsS0FBSzt1QkFBQyxFQUFFLFNBQVMsRUFBRSxnQkFBZ0IsRUFBRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgSG9zdEJpbmRpbmcsIElucHV0LCBFbGVtZW50UmVmLCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgYm9vbGVhbkF0dHJpYnV0ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgaW5kaXZpZHVhbCByZXNpemFibGUvY29sbGFwc2libGUgcGFuZXMuXG4gKlxuICogQGlneE1vZHVsZSBJZ3hTcGxpdHRlck1vZHVsZVxuICpcbiAqIEBpZ3hQYXJlbnQgSWd4U3BsaXR0ZXJDb21wb25lbnRcbiAqXG4gKiBAaWd4S2V5d29yZHMgcGFuZVxuICpcbiAqIEBpZ3hHcm91cCBwcmVzZW50YXRpb25cbiAqXG4gKiBAcmVtYXJrc1xuICogIFVzZXJzIGNhbiBjb250cm9sIHRoZSByZXNpemUgYmVoYXZpb3IgdmlhIHRoZSBtaW4gYW5kIG1heCBzaXplIHByb3BlcnRpZXMuXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnaWd4LXNwbGl0dGVyLXBhbmUnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9zcGxpdHRlci1wYW5lLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneFNwbGl0dGVyUGFuZUNvbXBvbmVudCB7XG4gICAgcHJpdmF0ZSBfbWluU2l6ZTogc3RyaW5nO1xuICAgIHByaXZhdGUgX21heFNpemU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogR2V0cy9TZXRzIHRoZSAnZGlzcGxheScgcHJvcGVydHkgb2YgdGhlIGN1cnJlbnQgcGFuZS5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLmRpc3BsYXknKVxuICAgIHB1YmxpYyBkaXNwbGF5ID0gJ2ZsZXgnO1xuXG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSBtaW5pbXVtIGFsbG93ZWQgc2l6ZSBvZiB0aGUgY3VycmVudCBwYW5lLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zcGxpdHRlcj5cbiAgICAgKiAgPGlneC1zcGxpdHRlci1wYW5lIFttaW5TaXplXT0nbWluU2l6ZSc+Li4uPC9pZ3gtc3BsaXR0ZXItcGFuZT5cbiAgICAgKiA8L2lneC1zcGxpdHRlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgbWluU2l6ZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWluU2l6ZTtcbiAgICB9XG4gICAgcHVibGljIHNldCBtaW5TaXplKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fbWluU2l6ZSA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5vd25lcikge1xuICAgICAgICAgICAgdGhpcy5vd25lci5wYW5lcy5ub3RpZnlPbkNoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0IHRoZSBtYXhpbXVtIGFsbG93ZWQgc2l6ZSBvZiB0aGUgY3VycmVudCBwYW5lLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zcGxpdHRlcj5cbiAgICAgKiAgPGlneC1zcGxpdHRlci1wYW5lIFttYXhTaXplXT0nbWF4U2l6ZSc+Li4uPC9pZ3gtc3BsaXR0ZXItcGFuZT5cbiAgICAgKiA8L2lneC1zcGxpdHRlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgbWF4U2l6ZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4U2l6ZTtcbiAgICB9XG4gICAgcHVibGljIHNldCBtYXhTaXplKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fbWF4U2l6ZSA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5vd25lcikge1xuICAgICAgICAgICAgdGhpcy5vd25lci5wYW5lcy5ub3RpZnlPbkNoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB3aGV0aGVyIHBhbmUgaXMgcmVzaXphYmxlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zcGxpdHRlcj5cbiAgICAgKiAgPGlneC1zcGxpdHRlci1wYW5lIFtyZXNpemFibGVdPSdmYWxzZSc+Li4uPC9pZ3gtc3BsaXR0ZXItcGFuZT5cbiAgICAgKiA8L2lneC1zcGxpdHRlcj5cbiAgICAgKiBgYGBcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHBhbmUgaXMgbm90IHJlc2l6YWJsZSBpdHMgcmVsYXRlZCBzcGxpdHRlciBiYXIgY2Fubm90IGJlIGRyYWdnZWQuXG4gICAgICovXG4gICAgQElucHV0KHsgdHJhbnNmb3JtOiBib29sZWFuQXR0cmlidXRlIH0pXG4gICAgcHVibGljIHJlc2l6YWJsZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIGNvbGxhcHNlZCBzdGF0ZSBvZiBwYW5lIGlzIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNwbGl0dGVyPlxuICAgICAqICA8aWd4LXNwbGl0dGVyLXBhbmUgKGNvbGxhcHNlZENoYW5nZSk9J3BhbmVDb2xsYXBzZWRDaGFuZ2UoJGV2ZW50KSc+Li4uPC9pZ3gtc3BsaXR0ZXItcGFuZT5cbiAgICAgKiA8L2lneC1zcGxpdHRlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgY29sbGFwc2VkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5vcmRlcicpXG4gICAgcHVibGljIG9yZGVyITogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBHZXRzL1NldHMgdGhlIGBvdmVyZmxvd2AuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5vdmVyZmxvdycpXG4gICAgcHVibGljIG92ZXJmbG93ID0gJ2F1dG8nO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBHZXQvU2V0cyB0aGUgYG1pbldpZHRoYCBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHBhbmUuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5taW4td2lkdGgnKVxuICAgIHB1YmxpYyBtaW5XaWR0aCA9ICcwJztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogR2V0L1NldHMgdGhlIGBtYXhXaWR0aGAgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBwYW5lLlxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUubWF4LXdpZHRoJylcbiAgICBwdWJsaWMgbWF4V2lkdGggPSAnMTAwJSc7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEdldHMvU2V0cyB0aGUgYG1pbkhlaWdodGAgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBwYW5lLlxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUubWluLWhlaWdodCcpXG4gICAgcHVibGljIG1pbkhlaWdodCA9ICcwJztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogR2V0cy9TZXRzIHRoZSBgbWF4SGVpZ2h0YCBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IGBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnRgLlxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUubWF4LWhlaWdodCcpXG4gICAgcHVibGljIG1heEhlaWdodCA9ICcxMDAlJztcblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBvd25lcjtcblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgc2l6ZSBvZiB0aGUgY3VycmVudCBwYW5lLlxuICAgICAqICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc3BsaXR0ZXI+XG4gICAgICogIDxpZ3gtc3BsaXR0ZXItcGFuZSBbc2l6ZV09J3NpemUnPi4uLjwvaWd4LXNwbGl0dGVyLXBhbmU+XG4gICAgICogPC9pZ3gtc3BsaXR0ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgc2l6ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zaXplID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZWwubmF0aXZlRWxlbWVudC5zdHlsZS5mbGV4ID0gdGhpcy5mbGV4O1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBnZXQgaXNQZXJjZW50YWdlU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ2F1dG8nIHx8IHRoaXMuc2l6ZS5pbmRleE9mKCclJykgIT09IC0xO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBnZXQgZHJhZ1NpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kcmFnU2l6ZTtcbiAgICB9XG4gICAgcHVibGljIHNldCBkcmFnU2l6ZSh2YWwpIHtcbiAgICAgICAgdGhpcy5fZHJhZ1NpemUgPSB2YWw7XG4gICAgICAgIHRoaXMuZWwubmF0aXZlRWxlbWVudC5zdHlsZS5mbGV4ID0gdGhpcy5mbGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBHZXRzIHRoZSBob3N0IG5hdGl2ZSBlbGVtZW50LlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZWxlbWVudCgpOiBhbnkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogR2V0cyB0aGUgYGZsZXhgIHByb3BlcnR5IG9mIHRoZSBjdXJyZW50IGBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnRgLlxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUuZmxleCcpXG4gICAgcHVibGljIGdldCBmbGV4KCkge1xuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5kcmFnU2l6ZSB8fCB0aGlzLnNpemU7XG4gICAgICAgIGNvbnN0IGdyb3cgPSB0aGlzLmlzUGVyY2VudGFnZVNpemUgJiYgIXRoaXMuZHJhZ1NpemUgPyAxIDogMDtcbiAgICAgICAgcmV0dXJuIGAke2dyb3d9ICR7Z3Jvd30gJHtzaXplfWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHdoZXRoZXIgY3VycmVudCBwYW5lIGlzIGNvbGxhcHNlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGlzQ29sbGFwc2VkID0gcGFuZS5jb2xsYXBzZWQ7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KHsgdHJhbnNmb3JtOiBib29sZWFuQXR0cmlidXRlIH0pXG4gICAgcHVibGljIHNldCBjb2xsYXBzZWQodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMub3duZXIpIHtcbiAgICAgICAgICAgIC8vIHJlc2V0IHNpYmxpbmcgc2l6ZXMgd2hlbiBwYW5lIGNvbGxhcHNlIHN0YXRlIGNoYW5nZXMuXG4gICAgICAgICAgICB0aGlzLl9nZXRTaWJsaW5ncygpLmZvckVhY2goc2libGluZyA9PiB7XG4gICAgICAgICAgICAgICAgc2libGluZy5zaXplID0gJ2F1dG8nXG4gICAgICAgICAgICAgICAgc2libGluZy5kcmFnU2l6ZSA9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb2xsYXBzZWQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5kaXNwbGF5ID0gdGhpcy5fY29sbGFwc2VkID8gJ25vbmUnIDogJ2ZsZXgnO1xuICAgICAgICB0aGlzLmNvbGxhcHNlZENoYW5nZS5lbWl0KHRoaXMuX2NvbGxhcHNlZCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBjb2xsYXBzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xsYXBzZWQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfc2l6ZSA9ICdhdXRvJztcbiAgICBwcml2YXRlIF9kcmFnU2l6ZTtcbiAgICBwcml2YXRlIF9jb2xsYXBzZWQgPSBmYWxzZTtcblxuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBlbDogRWxlbWVudFJlZikgeyB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBjb2xsYXBzZWQgc3RhdGUgb2YgdGhlIHBhbmUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwYW5lLnRvZ2dsZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyB0b2dnbGUoKSB7XG4gICAgICAgIHRoaXMuY29sbGFwc2VkID0gIXRoaXMuY29sbGFwc2VkO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHByaXZhdGUgX2dldFNpYmxpbmdzKCkge1xuICAgICAgICBjb25zdCBwYW5lcyA9IHRoaXMub3duZXIucGFuZXMudG9BcnJheSgpO1xuICAgICAgICBjb25zdCBpbmRleCA9IHBhbmVzLmluZGV4T2YodGhpcyk7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gW107XG4gICAgICAgIGlmIChpbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgc2libGluZ3MucHVzaChwYW5lc1tpbmRleCAtIDFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggIT09IHBhbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHNpYmxpbmdzLnB1c2gocGFuZXNbaW5kZXggKyAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpYmxpbmdzO1xuICAgIH1cbn1cbiIsIjxuZy1jb250ZW50PjwvbmctY29udGVudD4iXX0=