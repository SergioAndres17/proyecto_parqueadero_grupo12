import { Input, HostBinding, Output, EventEmitter, Directive, Inject } from '@angular/core';
import { Navigate } from './drop-down.common';
import { DropDownActionKey } from './drop-down.common';
import { DOCUMENT } from '@angular/common';
import * as i0 from "@angular/core";
let NEXT_ID = 0;
/**
 * An abstract class, defining a drop-down component, with:
 * Properties for display styles and classes
 * A collection items of type `IgxDropDownItemBaseDirective`
 * Properties and methods for navigating (highlighting/focusing) items from the collection
 * Properties and methods for selecting items from the collection
 */
export class IgxDropDownBaseDirective {
    /**
     * Gets/Sets the drop down's id
     *
     * ```typescript
     * // get
     * let myDropDownCurrentId = this.dropdown.id;
     * ```
     * ```html
     * <!--set-->
     * <igx-drop-down [id]='newDropDownId'></igx-drop-down>
     * ```
     */
    get id() {
        return this._id;
    }
    set id(value) {
        this._id = value;
    }
    /**
     * Get all non-header items
     *
     * ```typescript
     * let myDropDownItems = this.dropdown.items;
     * ```
     */
    get items() {
        const items = [];
        if (this.children !== undefined) {
            for (const child of this.children.toArray()) {
                if (!child.isHeader) {
                    items.push(child);
                }
            }
        }
        return items;
    }
    /**
     * Get all header items
     *
     * ```typescript
     * let myDropDownHeaderItems = this.dropdown.headers;
     * ```
     */
    get headers() {
        const headers = [];
        if (this.children !== undefined) {
            for (const child of this.children.toArray()) {
                if (child.isHeader) {
                    headers.push(child);
                }
            }
        }
        return headers;
    }
    /**
     * Get dropdown html element
     *
     * ```typescript
     * let myDropDownElement = this.dropdown.element;
     * ```
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden @internal
     * Get dropdown's html element of its scroll container
     */
    get scrollContainer() {
        return this.element;
    }
    constructor(elementRef, cdr, document) {
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.document = document;
        /**
         * Emitted when item selection is changing, before the selection completes
         *
         * ```html
         * <igx-drop-down (selectionChanging)='handleSelection()'></igx-drop-down>
         * ```
         */
        this.selectionChanging = new EventEmitter();
        /**
         * Gets/Sets the drop down's container max height.
         *
         * ```typescript
         * // get
         * let maxHeight = this.dropdown.maxHeight;
         * ```
         * ```html
         * <!--set-->
         * <igx-drop-down [maxHeight]='200px'></igx-drop-down>
         * ```
         */
        this.maxHeight = null;
        /**
         * @hidden @internal
         */
        this.cssClass = true;
        this._focusedItem = null;
        this._id = `igx-drop-down-${NEXT_ID++}`;
    }
    ngOnInit() {
        this.computedStyles = this.document.defaultView.getComputedStyle(this.elementRef.nativeElement);
    }
    /** Keydown Handler */
    onItemActionKey(key, event) {
        switch (key) {
            case DropDownActionKey.ENTER:
            case DropDownActionKey.SPACE:
                this.selectItem(this.focusedItem, event);
                break;
            case DropDownActionKey.ESCAPE:
        }
    }
    /**
     * Emits selectionChanging with the target item & event
     *
     * @hidden @internal
     * @param newSelection the item selected
     * @param event the event that triggered the call
     */
    selectItem(newSelection, event, emit = true) {
        this.selectionChanging.emit({
            newSelection,
            oldSelection: null,
            cancel: false
        });
    }
    /**
     * @hidden @internal
     */
    get focusedItem() {
        return this._focusedItem;
    }
    /**
     * @hidden @internal
     */
    set focusedItem(item) {
        this._focusedItem = item;
    }
    /**
     * Navigates to the item on the specified index
     *
     * @param newIndex number - the index of the item in the `items` collection
     */
    navigateItem(newIndex) {
        if (newIndex !== -1) {
            const oldItem = this._focusedItem;
            const newItem = this.items[newIndex];
            if (oldItem) {
                oldItem.focused = false;
            }
            this.focusedItem = newItem;
            this.scrollToHiddenItem(newItem);
            this.focusedItem.focused = true;
        }
    }
    /**
     * @hidden @internal
     */
    navigateFirst() {
        this.navigate(Navigate.Down, -1);
    }
    /**
     * @hidden @internal
     */
    navigateLast() {
        this.navigate(Navigate.Up, this.items.length);
    }
    /**
     * @hidden @internal
     */
    navigateNext() {
        this.navigate(Navigate.Down);
    }
    /**
     * @hidden @internal
     */
    navigatePrev() {
        this.navigate(Navigate.Up);
    }
    scrollToHiddenItem(newItem) {
        const elementRect = newItem.element.nativeElement.getBoundingClientRect();
        const parentRect = this.scrollContainer.getBoundingClientRect();
        if (parentRect.top > elementRect.top) {
            this.scrollContainer.scrollTop -= (parentRect.top - elementRect.top);
        }
        if (parentRect.bottom < elementRect.bottom) {
            this.scrollContainer.scrollTop += (elementRect.bottom - parentRect.bottom);
        }
    }
    navigate(direction, currentIndex) {
        let index = -1;
        if (this._focusedItem) {
            index = currentIndex ? currentIndex : this.focusedItem.itemIndex;
        }
        const newIndex = this.getNearestSiblingFocusableItemIndex(index, direction);
        this.navigateItem(newIndex);
    }
    getNearestSiblingFocusableItemIndex(startIndex, direction) {
        let index = startIndex;
        const items = this.items;
        while (items[index + direction] && items[index + direction].disabled) {
            index += direction;
        }
        index += direction;
        if (index >= 0 && index < items.length) {
            return index;
        }
        else {
            return -1;
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxDropDownBaseDirective, deps: [{ token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.4", type: IgxDropDownBaseDirective, inputs: { width: "width", height: "height", id: "id", maxHeight: "maxHeight" }, outputs: { selectionChanging: "selectionChanging" }, host: { properties: { "attr.id": "this.id", "style.maxHeight": "this.maxHeight", "class.igx-drop-down": "this.cssClass" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxDropDownBaseDirective, decorators: [{
            type: Directive
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }], propDecorators: { selectionChanging: [{
                type: Output
            }], width: [{
                type: Input
            }], height: [{
                type: Input
            }], id: [{
                type: HostBinding,
                args: ['attr.id']
            }, {
                type: Input
            }], maxHeight: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['style.maxHeight']
            }], cssClass: [{
                type: HostBinding,
                args: ['class.igx-drop-down']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJvcC1kb3duLmJhc2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZHJvcC1kb3duL2Ryb3AtZG93bi5iYXNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDSCxLQUFLLEVBQUUsV0FBVyxFQUF5QixNQUFNLEVBQUUsWUFBWSxFQUFxQixTQUFTLEVBRTdGLE1BQU0sRUFDVCxNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsUUFBUSxFQUF1QixNQUFNLG9CQUFvQixDQUFDO0FBRW5FLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBRXZELE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQzs7QUFFM0MsSUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDO0FBRWhCOzs7Ozs7R0FNRztBQUVILE1BQU0sT0FBZ0Isd0JBQXdCO0lBeUMxQzs7Ozs7Ozs7Ozs7T0FXRztJQUNILElBRVcsRUFBRTtRQUNULE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQztJQUNwQixDQUFDO0lBQ0QsSUFBVyxFQUFFLENBQUMsS0FBYTtRQUN2QixJQUFJLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQztJQUNyQixDQUFDO0lBd0JEOzs7Ozs7T0FNRztJQUNILElBQVcsS0FBSztRQUNaLE1BQU0sS0FBSyxHQUFtQyxFQUFFLENBQUM7UUFDakQsSUFBSSxJQUFJLENBQUMsUUFBUSxLQUFLLFNBQVMsRUFBRSxDQUFDO1lBQzlCLEtBQUssTUFBTSxLQUFLLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDO2dCQUMxQyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO29CQUNsQixLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUN0QixDQUFDO1lBQ0wsQ0FBQztRQUNM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QUFDLFFBQVE7eUNBekpiLGlCQUFpQjtzQkFEdkIsTUFBTTtnQkFnQkEsS0FBSztzQkFEWCxLQUFLO2dCQWdCQyxNQUFNO3NCQURaLEtBQUs7Z0JBaUJLLEVBQUU7c0JBRlosV0FBVzt1QkFBQyxTQUFTOztzQkFDckIsS0FBSztnQkFzQkMsU0FBUztzQkFGZixLQUFLOztzQkFDTCxXQUFXO3VCQUFDLGlCQUFpQjtnQkFPdkIsUUFBUTtzQkFEZCxXQUFXO3VCQUFDLHFCQUFxQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgSW5wdXQsIEhvc3RCaW5kaW5nLCBFbGVtZW50UmVmLCBRdWVyeUxpc3QsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBDaGFuZ2VEZXRlY3RvclJlZiwgRGlyZWN0aXZlLFxuICAgIE9uSW5pdCxcbiAgICBJbmplY3Rcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IE5hdmlnYXRlLCBJU2VsZWN0aW9uRXZlbnRBcmdzIH0gZnJvbSAnLi9kcm9wLWRvd24uY29tbW9uJztcbmltcG9ydCB7IElEcm9wRG93bkxpc3QgfSBmcm9tICcuL2Ryb3AtZG93bi5jb21tb24nO1xuaW1wb3J0IHsgRHJvcERvd25BY3Rpb25LZXkgfSBmcm9tICcuL2Ryb3AtZG93bi5jb21tb24nO1xuaW1wb3J0IHsgSWd4RHJvcERvd25JdGVtQmFzZURpcmVjdGl2ZSB9IGZyb20gJy4vZHJvcC1kb3duLWl0ZW0uYmFzZSc7XG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbmxldCBORVhUX0lEID0gMDtcblxuLyoqXG4gKiBBbiBhYnN0cmFjdCBjbGFzcywgZGVmaW5pbmcgYSBkcm9wLWRvd24gY29tcG9uZW50LCB3aXRoOlxuICogUHJvcGVydGllcyBmb3IgZGlzcGxheSBzdHlsZXMgYW5kIGNsYXNzZXNcbiAqIEEgY29sbGVjdGlvbiBpdGVtcyBvZiB0eXBlIGBJZ3hEcm9wRG93bkl0ZW1CYXNlRGlyZWN0aXZlYFxuICogUHJvcGVydGllcyBhbmQgbWV0aG9kcyBmb3IgbmF2aWdhdGluZyAoaGlnaGxpZ2h0aW5nL2ZvY3VzaW5nKSBpdGVtcyBmcm9tIHRoZSBjb2xsZWN0aW9uXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciBzZWxlY3RpbmcgaXRlbXMgZnJvbSB0aGUgY29sbGVjdGlvblxuICovXG5ARGlyZWN0aXZlKClcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBJZ3hEcm9wRG93bkJhc2VEaXJlY3RpdmUgaW1wbGVtZW50cyBJRHJvcERvd25MaXN0LCBPbkluaXQge1xuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiBpdGVtIHNlbGVjdGlvbiBpcyBjaGFuZ2luZywgYmVmb3JlIHRoZSBzZWxlY3Rpb24gY29tcGxldGVzXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1kcm9wLWRvd24gKHNlbGVjdGlvbkNoYW5naW5nKT0naGFuZGxlU2VsZWN0aW9uKCknPjwvaWd4LWRyb3AtZG93bj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgc2VsZWN0aW9uQ2hhbmdpbmcgPSBuZXcgRXZlbnRFbWl0dGVyPElTZWxlY3Rpb25FdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiAgR2V0cy9TZXRzIHRoZSB3aWR0aCBvZiB0aGUgZHJvcCBkb3duXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0XG4gICAgICogbGV0IG15RHJvcERvd25DdXJyZW50V2lkdGggPSB0aGlzLmRyb3Bkb3duLndpZHRoO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8IS0tc2V0LS0+XG4gICAgICogPGlneC1kcm9wLWRvd24gW3dpZHRoXT0nMTYwcHgnPjwvaWd4LWRyb3AtZG93bj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB3aWR0aDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSBoZWlnaHQgb2YgdGhlIGRyb3AgZG93blxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldFxuICAgICAqIGxldCBteURyb3BEb3duQ3VycmVudEhlaWdodCA9IHRoaXMuZHJvcGRvd24uaGVpZ2h0O1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8IS0tc2V0LS0+XG4gICAgICogPGlneC1kcm9wLWRvd24gW2hlaWdodF09JzQwMHB4Jz48L2lneC1kcm9wLWRvd24+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaGVpZ2h0OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgdGhlIGRyb3AgZG93bidzIGlkXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0XG4gICAgICogbGV0IG15RHJvcERvd25DdXJyZW50SWQgPSB0aGlzLmRyb3Bkb3duLmlkO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8IS0tc2V0LS0+XG4gICAgICogPGlneC1kcm9wLWRvd24gW2lkXT0nbmV3RHJvcERvd25JZCc+PC9pZ3gtZHJvcC1kb3duPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5pZCcpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGlkKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICB9XG4gICAgcHVibGljIHNldCBpZCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX2lkID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSBkcm9wIGRvd24ncyBjb250YWluZXIgbWF4IGhlaWdodC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRcbiAgICAgKiBsZXQgbWF4SGVpZ2h0ID0gdGhpcy5kcm9wZG93bi5tYXhIZWlnaHQ7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8aWd4LWRyb3AtZG93biBbbWF4SGVpZ2h0XT0nMjAwcHgnPjwvaWd4LWRyb3AtZG93bj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIEBIb3N0QmluZGluZygnc3R5bGUubWF4SGVpZ2h0JylcbiAgICBwdWJsaWMgbWF4SGVpZ2h0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtZHJvcC1kb3duJylcbiAgICBwdWJsaWMgY3NzQ2xhc3MgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBub24taGVhZGVyIGl0ZW1zXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IG15RHJvcERvd25JdGVtcyA9IHRoaXMuZHJvcGRvd24uaXRlbXM7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBpdGVtcygpOiBJZ3hEcm9wRG93bkl0ZW1CYXNlRGlyZWN0aXZlW10ge1xuICAgICAgICBjb25zdCBpdGVtczogSWd4RHJvcERvd25JdGVtQmFzZURpcmVjdGl2ZVtdID0gW107XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbi50b0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkLmlzSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIGhlYWRlciBpdGVtc1xuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBteURyb3BEb3duSGVhZGVySXRlbXMgPSB0aGlzLmRyb3Bkb3duLmhlYWRlcnM7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBoZWFkZXJzKCk6IElneERyb3BEb3duSXRlbUJhc2VEaXJlY3RpdmVbXSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnM6IElneERyb3BEb3duSXRlbUJhc2VEaXJlY3RpdmVbXSA9IFtdO1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4udG9BcnJheSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmlzSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGRyb3Bkb3duIGh0bWwgZWxlbWVudFxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBteURyb3BEb3duRWxlbWVudCA9IHRoaXMuZHJvcGRvd24uZWxlbWVudDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBHZXQgZHJvcGRvd24ncyBodG1sIGVsZW1lbnQgb2YgaXRzIHNjcm9sbCBjb250YWluZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHNjcm9sbENvbnRhaW5lcigpOiBIVE1MRWxlbWVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBjaGlsZHJlbjogUXVlcnlMaXN0PElneERyb3BEb3duSXRlbUJhc2VEaXJlY3RpdmU+O1xuXG4gICAgcHJvdGVjdGVkIF93aWR0aDtcbiAgICBwcm90ZWN0ZWQgX2hlaWdodDtcbiAgICBwcm90ZWN0ZWQgX2ZvY3VzZWRJdGVtOiBhbnkgPSBudWxsO1xuICAgIHByb3RlY3RlZCBfaWQgPSBgaWd4LWRyb3AtZG93bi0ke05FWFRfSUQrK31gO1xuICAgIHByb3RlY3RlZCBjb21wdXRlZFN0eWxlcztcblxuICAgIC8qKlxuICAgICAqIEdldHMgaWYgdGhlIGRyb3Bkb3duIGlzIGNvbGxhcHNlZFxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBjb2xsYXBzZWQ6IGJvb2xlYW47XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJvdGVjdGVkIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgIHByb3RlY3RlZCBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBASW5qZWN0KERPQ1VNRU5UKSBwdWJsaWMgZG9jdW1lbnQ6IGFueSkge31cblxuICAgIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jb21wdXRlZFN0eWxlcyA9IHRoaXMuZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG4gICAgfVxuXG4gICAgLyoqIEtleWRvd24gSGFuZGxlciAqL1xuICAgIHB1YmxpYyBvbkl0ZW1BY3Rpb25LZXkoa2V5OiBEcm9wRG93bkFjdGlvbktleSwgZXZlbnQ/OiBFdmVudCkge1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSBEcm9wRG93bkFjdGlvbktleS5FTlRFUjpcbiAgICAgICAgICAgIGNhc2UgRHJvcERvd25BY3Rpb25LZXkuU1BBQ0U6XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RJdGVtKHRoaXMuZm9jdXNlZEl0ZW0sIGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRHJvcERvd25BY3Rpb25LZXkuRVNDQVBFOlxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW1pdHMgc2VsZWN0aW9uQ2hhbmdpbmcgd2l0aCB0aGUgdGFyZ2V0IGl0ZW0gJiBldmVudFxuICAgICAqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gbmV3U2VsZWN0aW9uIHRoZSBpdGVtIHNlbGVjdGVkXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGUgY2FsbFxuICAgICAqL1xuICAgIHB1YmxpYyBzZWxlY3RJdGVtKG5ld1NlbGVjdGlvbj86IElneERyb3BEb3duSXRlbUJhc2VEaXJlY3RpdmUsIGV2ZW50PzogRXZlbnQsIGVtaXQgPSB0cnVlKSB7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdpbmcuZW1pdCh7XG4gICAgICAgICAgICBuZXdTZWxlY3Rpb24sXG4gICAgICAgICAgICBvbGRTZWxlY3Rpb246IG51bGwsXG4gICAgICAgICAgICBjYW5jZWw6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldCBmb2N1c2VkSXRlbSgpOiBJZ3hEcm9wRG93bkl0ZW1CYXNlRGlyZWN0aXZlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvY3VzZWRJdGVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIHNldCBmb2N1c2VkSXRlbShpdGVtOiBJZ3hEcm9wRG93bkl0ZW1CYXNlRGlyZWN0aXZlKSB7XG4gICAgICAgIHRoaXMuX2ZvY3VzZWRJdGVtID0gaXRlbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOYXZpZ2F0ZXMgdG8gdGhlIGl0ZW0gb24gdGhlIHNwZWNpZmllZCBpbmRleFxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld0luZGV4IG51bWJlciAtIHRoZSBpbmRleCBvZiB0aGUgaXRlbSBpbiB0aGUgYGl0ZW1zYCBjb2xsZWN0aW9uXG4gICAgICovXG4gICAgcHVibGljIG5hdmlnYXRlSXRlbShuZXdJbmRleDogbnVtYmVyKSB7XG4gICAgICAgIGlmIChuZXdJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZEl0ZW0gPSB0aGlzLl9mb2N1c2VkSXRlbTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW0gPSB0aGlzLml0ZW1zW25ld0luZGV4XTtcbiAgICAgICAgICAgIGlmIChvbGRJdGVtKSB7XG4gICAgICAgICAgICAgICAgb2xkSXRlbS5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZvY3VzZWRJdGVtID0gbmV3SXRlbTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9IaWRkZW5JdGVtKG5ld0l0ZW0pO1xuICAgICAgICAgICAgdGhpcy5mb2N1c2VkSXRlbS5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG5hdmlnYXRlRmlyc3QoKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGUoTmF2aWdhdGUuRG93biwgLTEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG5hdmlnYXRlTGFzdCgpIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0ZShOYXZpZ2F0ZS5VcCwgdGhpcy5pdGVtcy5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG5hdmlnYXRlTmV4dCgpIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0ZShOYXZpZ2F0ZS5Eb3duKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBuYXZpZ2F0ZVByZXYoKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGUoTmF2aWdhdGUuVXApO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBzY3JvbGxUb0hpZGRlbkl0ZW0obmV3SXRlbTogSWd4RHJvcERvd25JdGVtQmFzZURpcmVjdGl2ZSkge1xuICAgICAgICBjb25zdCBlbGVtZW50UmVjdCA9IG5ld0l0ZW0uZWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCBwYXJlbnRSZWN0ID0gdGhpcy5zY3JvbGxDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChwYXJlbnRSZWN0LnRvcCA+IGVsZW1lbnRSZWN0LnRvcCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wIC09IChwYXJlbnRSZWN0LnRvcCAtIGVsZW1lbnRSZWN0LnRvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyZW50UmVjdC5ib3R0b20gPCBlbGVtZW50UmVjdC5ib3R0b20pIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCArPSAoZWxlbWVudFJlY3QuYm90dG9tIC0gcGFyZW50UmVjdC5ib3R0b20pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIG5hdmlnYXRlKGRpcmVjdGlvbjogTmF2aWdhdGUsIGN1cnJlbnRJbmRleD86IG51bWJlcikge1xuICAgICAgICBsZXQgaW5kZXggPSAtMTtcbiAgICAgICAgaWYgKHRoaXMuX2ZvY3VzZWRJdGVtKSB7XG4gICAgICAgICAgICBpbmRleCA9IGN1cnJlbnRJbmRleCA/IGN1cnJlbnRJbmRleCA6IHRoaXMuZm9jdXNlZEl0ZW0uaXRlbUluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5nZXROZWFyZXN0U2libGluZ0ZvY3VzYWJsZUl0ZW1JbmRleChpbmRleCwgZGlyZWN0aW9uKTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0ZUl0ZW0obmV3SW5kZXgpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXROZWFyZXN0U2libGluZ0ZvY3VzYWJsZUl0ZW1JbmRleChzdGFydEluZGV4OiBudW1iZXIsIGRpcmVjdGlvbjogTmF2aWdhdGUpOiBudW1iZXIge1xuICAgICAgICBsZXQgaW5kZXggPSBzdGFydEluZGV4O1xuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgICAgIHdoaWxlIChpdGVtc1tpbmRleCArIGRpcmVjdGlvbl0gJiYgaXRlbXNbaW5kZXggKyBkaXJlY3Rpb25dLmRpc2FibGVkKSB7XG4gICAgICAgICAgICBpbmRleCArPSBkaXJlY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCArPSBkaXJlY3Rpb247XG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=