import { Directive, EventEmitter, HostBinding, HostListener, Inject, Input, Optional, Output } from '@angular/core';
import { AbsoluteScrollStrategy } from '../../services/overlay/scroll/absolute-scroll-strategy';
import { ConnectedPositioningStrategy } from '../../services/overlay/position/connected-positioning-strategy';
import { filter, first, takeUntil } from 'rxjs/operators';
import { IgxOverlayService } from '../../services/overlay/overlay';
import { Subject } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "../../core/navigation";
import * as i2 from "../../core/utils";
import * as i3 from "../../services/overlay/overlay";
export class IgxToggleDirective {
    /**
     * @hidden
     */
    get collapsed() {
        return this._collapsed;
    }
    /**
     * @hidden
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     */
    get hiddenClass() {
        return this.collapsed;
    }
    get hiddenWebkitClass() {
        const isSafari = this.platform?.isSafari;
        const browserVersion = this.platform?.browserVersion;
        return this.collapsed && isSafari && !!browserVersion && browserVersion < 17.5;
    }
    /**
     * @hidden
     */
    get defaultClass() {
        return !this.collapsed;
    }
    /**
     * @hidden
     */
    constructor(elementRef, cdr, overlayService, navigationService, platform) {
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.overlayService = overlayService;
        this.navigationService = navigationService;
        this.platform = platform;
        /**
         * Emits an event after the toggle container is opened.
         *
         * ```typescript
         * onToggleOpened(event) {
         *    alert("Toggle opened!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (opened)='onToggleOpened($event)'>
         * </div>
         * ```
         */
        this.opened = new EventEmitter();
        /**
         * Emits an event before the toggle container is opened.
         *
         * ```typescript
         * onToggleOpening(event) {
         *  alert("Toggle opening!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (opening)='onToggleOpening($event)'>
         * </div>
         * ```
         */
        this.opening = new EventEmitter();
        /**
         * Emits an event after the toggle container is closed.
         *
         * ```typescript
         * onToggleClosed(event) {
         *  alert("Toggle closed!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (closed)='onToggleClosed($event)'>
         * </div>
         * ```
         */
        this.closed = new EventEmitter();
        /**
         * Emits an event before the toggle container is closed.
         *
         * ```typescript
         * onToggleClosing(event) {
         *  alert("Toggle closing!");
         * }
         * ```
         *
         * ```html
         * <div
         *  igxToggle
         *  (closing)='onToggleClosing($event)'>
         * </div>
         * ```
         */
        this.closing = new EventEmitter();
        /**
         * Emits an event after the toggle element is appended to the overlay container.
         *
         * ```typescript
         * onAppended() {
         *  alert("Content appended!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (appended)='onToggleAppended()'>
         * </div>
         * ```
         */
        this.appended = new EventEmitter();
        this._collapsed = true;
        this.destroy$ = new Subject();
        this._overlaySubFilter = [
            filter(x => x.id === this._overlayId),
            takeUntil(this.destroy$)
        ];
        this.overlayClosed = (e) => {
            this._collapsed = true;
            this.cdr.detectChanges();
            this.unsubscribe();
            this.overlayService.detach(this.overlayId);
            const args = { owner: this, id: this._overlayId, event: e.event };
            delete this._overlayId;
            this.closed.emit(args);
            this.cdr.markForCheck();
        };
    }
    /**
     * Opens the toggle.
     *
     * ```typescript
     * this.myToggle.open();
     * ```
     */
    open(overlaySettings) {
        //  if there is open animation do nothing
        //  if toggle is not collapsed and there is no close animation do nothing
        const info = this.overlayService.getOverlayById(this._overlayId);
        const openAnimationStarted = info?.openAnimationPlayer?.hasStarted() ?? false;
        const closeAnimationStarted = info?.closeAnimationPlayer?.hasStarted() ?? false;
        if (openAnimationStarted || !(this._collapsed || closeAnimationStarted)) {
            return;
        }
        this._collapsed = false;
        this.cdr.detectChanges();
        if (!info) {
            this.unsubscribe();
            this.subscribe();
            this._overlayId = this.overlayService.attach(this.elementRef, overlaySettings);
        }
        const args = { cancel: false, owner: this, id: this._overlayId };
        this.opening.emit(args);
        if (args.cancel) {
            this.unsubscribe();
            this.overlayService.detach(this._overlayId);
            this._collapsed = true;
            delete this._overlayId;
            this.cdr.detectChanges();
            return;
        }
        this.overlayService.show(this._overlayId, overlaySettings);
    }
    /**
     * Closes the toggle.
     *
     * ```typescript
     * this.myToggle.close();
     * ```
     */
    close(event) {
        //  if toggle is collapsed do nothing
        //  if there is close animation do nothing, toggle will close anyway
        const info = this.overlayService.getOverlayById(this._overlayId);
        const closeAnimationStarted = info?.closeAnimationPlayer?.hasStarted() || false;
        if (this._collapsed || closeAnimationStarted) {
            return;
        }
        this.overlayService.hide(this._overlayId, event);
    }
    /**
     * Opens or closes the toggle, depending on its current state.
     *
     * ```typescript
     * this.myToggle.toggle();
     * ```
     */
    toggle(overlaySettings) {
        //  if toggle is collapsed call open
        //  if there is running close animation call open
        if (this.collapsed || this.isClosing) {
            this.open(overlaySettings);
        }
        else {
            this.close();
        }
    }
    /** @hidden @internal */
    get isClosing() {
        const info = this.overlayService.getOverlayById(this._overlayId);
        return info ? info.closeAnimationPlayer?.hasStarted() : false;
    }
    /**
     * Returns the id of the overlay the content is rendered in.
     * ```typescript
     * this.myToggle.overlayId;
     * ```
     */
    get overlayId() {
        return this._overlayId;
    }
    /**
     * Repositions the toggle.
     * ```typescript
     * this.myToggle.reposition();
     * ```
     */
    reposition() {
        this.overlayService.reposition(this._overlayId);
    }
    /**
     * Offsets the content along the corresponding axis by the provided amount with optional
     * offsetMode that determines whether to add (by default) or set the offset values with OffsetMode.Add and OffsetMode.Set
     */
    setOffset(deltaX, deltaY, offsetMode) {
        this.overlayService.setOffset(this._overlayId, deltaX, deltaY, offsetMode);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        if (this.navigationService && this.id) {
            this.navigationService.add(this.id, this);
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.navigationService && this.id) {
            this.navigationService.remove(this.id);
        }
        if (this._overlayId) {
            this.overlayService.detach(this._overlayId);
        }
        this.unsubscribe();
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    subscribe() {
        this._overlayContentAppendedSub = this.overlayService
            .contentAppended
            .pipe(first(), takeUntil(this.destroy$))
            .subscribe(() => {
            const args = { owner: this, id: this._overlayId };
            this.appended.emit(args);
        });
        this._overlayOpenedSub = this.overlayService
            .opened
            .pipe(...this._overlaySubFilter)
            .subscribe(() => {
            const args = { owner: this, id: this._overlayId };
            this.opened.emit(args);
        });
        this._overlayClosingSub = this.overlayService
            .closing
            .pipe(...this._overlaySubFilter)
            .subscribe((e) => {
            const args = { cancel: false, event: e.event, owner: this, id: this._overlayId };
            this.closing.emit(args);
            e.cancel = args.cancel;
            //  in case event is not canceled this will close the toggle and we need to unsubscribe.
            //  Otherwise if for some reason, e.g. close on outside click, close() gets called before
            //  closed was fired we will end with calling closing more than once
            if (!e.cancel) {
                this.clearSubscription(this._overlayClosingSub);
            }
        });
        this._overlayClosedSub = this.overlayService
            .closed
            .pipe(...this._overlaySubFilter)
            .subscribe(this.overlayClosed);
    }
    unsubscribe() {
        this.clearSubscription(this._overlayOpenedSub);
        this.clearSubscription(this._overlayClosingSub);
        this.clearSubscription(this._overlayClosedSub);
        this.clearSubscription(this._overlayContentAppendedSub);
    }
    clearSubscription(subscription) {
        if (subscription && !subscription.closed) {
            subscription.unsubscribe();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxToggleDirective, deps: [{ token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: IgxOverlayService }, { token: i1.IgxNavigationService, optional: true }, { token: i2.PlatformUtil, optional: true }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.4", type: IgxToggleDirective, isStandalone: true, selector: "[igxToggle]", inputs: { id: "id" }, outputs: { opened: "opened", opening: "opening", closed: "closed", closing: "closing", appended: "appended" }, host: { properties: { "class.igx-toggle--hidden": "this.hiddenClass", "attr.aria-hidden": "this.hiddenClass", "class.igx-toggle--hidden-webkit": "this.hiddenWebkitClass", "class.igx-toggle": "this.defaultClass" } }, exportAs: ["toggle"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxToggleDirective, decorators: [{
            type: Directive,
            args: [{
                    exportAs: 'toggle',
                    selector: '[igxToggle]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i3.IgxOverlayService, decorators: [{
                    type: Inject,
                    args: [IgxOverlayService]
                }] }, { type: i1.IgxNavigationService, decorators: [{
                    type: Optional
                }] }, { type: i2.PlatformUtil, decorators: [{
                    type: Optional
                }] }], propDecorators: { opened: [{
                type: Output
            }], opening: [{
                type: Output
            }], closed: [{
                type: Output
            }], closing: [{
                type: Output
            }], appended: [{
                type: Output
            }], id: [{
                type: Input
            }], hiddenClass: [{
                type: HostBinding,
                args: ['class.igx-toggle--hidden']
            }, {
                type: HostBinding,
                args: ['attr.aria-hidden']
            }], hiddenWebkitClass: [{
                type: HostBinding,
                args: ['class.igx-toggle--hidden-webkit']
            }], defaultClass: [{
                type: HostBinding,
                args: ['class.igx-toggle']
            }] } });
export class IgxToggleActionDirective {
    /**
     * @hidden
     */
    set target(target) {
        if (target !== null && target !== '') {
            this._target = target;
        }
    }
    /**
     * @hidden
     */
    get target() {
        if (typeof this._target === 'string') {
            return this.navigationService.get(this._target);
        }
        return this._target;
    }
    constructor(element, navigationService) {
        this.element = element;
        this.navigationService = navigationService;
    }
    /**
     * @hidden
     */
    onClick() {
        if (this.outlet) {
            this._overlayDefaults.outlet = this.outlet;
        }
        const clonedSettings = Object.assign({}, this._overlayDefaults, this.overlaySettings);
        this.updateOverlaySettings(clonedSettings);
        this.target.toggle(clonedSettings);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        const targetElement = this.element.nativeElement;
        this._overlayDefaults = {
            target: targetElement,
            positionStrategy: new ConnectedPositioningStrategy(),
            scrollStrategy: new AbsoluteScrollStrategy(),
            closeOnOutsideClick: true,
            modal: false,
            excludeFromOutsideClick: [targetElement]
        };
    }
    /**
     * Updates provided overlay settings
     *
     * @param settings settings to update
     * @returns returns updated copy of provided overlay settings
     */
    updateOverlaySettings(settings) {
        if (settings && settings.positionStrategy) {
            const positionStrategyClone = settings.positionStrategy.clone();
            settings.target = this.element.nativeElement;
            settings.positionStrategy = positionStrategyClone;
        }
        return settings;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxToggleActionDirective, deps: [{ token: i0.ElementRef }, { token: i1.IgxNavigationService, optional: true }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.4", type: IgxToggleActionDirective, isStandalone: true, selector: "[igxToggleAction]", inputs: { overlaySettings: "overlaySettings", outlet: ["igxToggleOutlet", "outlet"], target: ["igxToggleAction", "target"] }, host: { listeners: { "click": "onClick()" } }, exportAs: ["toggle-action"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxToggleActionDirective, decorators: [{
            type: Directive,
            args: [{
                    exportAs: 'toggle-action',
                    selector: '[igxToggleAction]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i1.IgxNavigationService, decorators: [{
                    type: Optional
                }] }], propDecorators: { overlaySettings: [{
                type: Input
            }], outlet: [{
                type: Input,
                args: ['igxToggleOutlet']
            }], target: [{
                type: Input,
                args: ['igxToggleAction']
            }], onClick: [{
                type: HostListener,
                args: ['click']
            }] } });
/**
 * Mark an element as an igxOverlay outlet container.
 * Directive instance is exported as `overlay-outlet` to be assigned to templates variables:
 * ```html
 * <div igxOverlayOutlet #outlet="overlay-outlet"></div>
 * ```
 */
export class IgxOverlayOutletDirective {
    constructor(element) {
        this.element = element;
    }
    /** @hidden */
    get nativeElement() {
        return this.element.nativeElement;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxOverlayOutletDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.4", type: IgxOverlayOutletDirective, isStandalone: true, selector: "[igxOverlayOutlet]", exportAs: ["overlay-outlet"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxOverlayOutletDirective, decorators: [{
            type: Directive,
            args: [{
                    exportAs: 'overlay-outlet',
                    selector: '[igxOverlayOutlet]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9nZ2xlLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9kaXJlY3RpdmVzL3RvZ2dsZS90b2dnbGUuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFFSCxTQUFTLEVBRVQsWUFBWSxFQUNaLFdBQVcsRUFDWCxZQUFZLEVBQ1osTUFBTSxFQUNOLEtBQUssRUFHTCxRQUFRLEVBQ1IsTUFBTSxFQUNULE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLHdEQUF3RCxDQUFDO0FBRWhHLE9BQU8sRUFBRSw0QkFBNEIsRUFBRSxNQUFNLGdFQUFnRSxDQUFDO0FBQzlHLE9BQU8sRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTFELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBR25FLE9BQU8sRUFBZ0IsT0FBTyxFQUE0QixNQUFNLE1BQU0sQ0FBQzs7Ozs7QUFnQnZFLE1BQU0sT0FBTyxrQkFBa0I7SUFnRzNCOztPQUVHO0lBQ0gsSUFBVyxTQUFTO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQztJQUMzQixDQUFDO0lBWUQ7O09BRUc7SUFDSCxJQUFXLE9BQU87UUFDZCxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDO0lBQ3pDLENBQUM7SUFFRDs7T0FFRztJQUNILElBRVcsV0FBVztRQUNsQixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7SUFDMUIsQ0FBQztJQUVELElBQ1csaUJBQWlCO1FBQ3hCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDO1FBQ3pDLE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsY0FBYyxDQUFDO1FB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eUJBQXlCOzsyRkFBekIseUJBQXlCO2tCQUxyQyxTQUFTO21CQUFDO29CQUNQLFFBQVEsRUFBRSxnQkFBZ0I7b0JBQzFCLFFBQVEsRUFBRSxvQkFBb0I7b0JBQzlCLFVBQVUsRUFBRSxJQUFJO2lCQUNuQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgRGlyZWN0aXZlLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIEhvc3RCaW5kaW5nLFxuICAgIEhvc3RMaXN0ZW5lcixcbiAgICBJbmplY3QsXG4gICAgSW5wdXQsXG4gICAgT25EZXN0cm95LFxuICAgIE9uSW5pdCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBYnNvbHV0ZVNjcm9sbFN0cmF0ZWd5IH0gZnJvbSAnLi4vLi4vc2VydmljZXMvb3ZlcmxheS9zY3JvbGwvYWJzb2x1dGUtc2Nyb2xsLXN0cmF0ZWd5JztcbmltcG9ydCB7IENhbmNlbGFibGVCcm93c2VyRXZlbnRBcmdzLCBJQmFzZUV2ZW50QXJncywgUGxhdGZvcm1VdGlsIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBDb25uZWN0ZWRQb3NpdGlvbmluZ1N0cmF0ZWd5IH0gZnJvbSAnLi4vLi4vc2VydmljZXMvb3ZlcmxheS9wb3NpdGlvbi9jb25uZWN0ZWQtcG9zaXRpb25pbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgZmlsdGVyLCBmaXJzdCwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgSWd4TmF2aWdhdGlvblNlcnZpY2UsIElUb2dnbGVWaWV3IH0gZnJvbSAnLi4vLi4vY29yZS9uYXZpZ2F0aW9uJztcbmltcG9ydCB7IElneE92ZXJsYXlTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvb3ZlcmxheS9vdmVybGF5JztcbmltcG9ydCB7IElQb3NpdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi4vLi4vc2VydmljZXMvb3ZlcmxheS9wb3NpdGlvbi9JUG9zaXRpb25TdHJhdGVneSc7XG5pbXBvcnQgeyBPZmZzZXRNb2RlLCBPdmVybGF5Q2xvc2luZ0V2ZW50QXJncywgT3ZlcmxheUV2ZW50QXJncywgT3ZlcmxheVNldHRpbmdzIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvb3ZlcmxheS91dGlsaXRpZXMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uLCBTdWJqZWN0LCBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb24gfSBmcm9tICdyeGpzJztcblxuZXhwb3J0IGludGVyZmFjZSBUb2dnbGVWaWV3RXZlbnRBcmdzIGV4dGVuZHMgSUJhc2VFdmVudEFyZ3Mge1xuICAgIC8qKiBJZCBvZiB0aGUgdG9nZ2xlIHZpZXcgKi9cbiAgICBpZDogc3RyaW5nO1xuICAgIC8qIGJsYXpvclN1cHByZXNzICovXG4gICAgZXZlbnQ/OiBFdmVudDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUb2dnbGVWaWV3Q2FuY2VsYWJsZUV2ZW50QXJncyBleHRlbmRzIFRvZ2dsZVZpZXdFdmVudEFyZ3MsIENhbmNlbGFibGVCcm93c2VyRXZlbnRBcmdzIHsgfVxuXG5ARGlyZWN0aXZlKHtcbiAgICBleHBvcnRBczogJ3RvZ2dsZScsXG4gICAgc2VsZWN0b3I6ICdbaWd4VG9nZ2xlXScsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hUb2dnbGVEaXJlY3RpdmUgaW1wbGVtZW50cyBJVG9nZ2xlVmlldywgT25Jbml0LCBPbkRlc3Ryb3kge1xuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IGFmdGVyIHRoZSB0b2dnbGUgY29udGFpbmVyIGlzIG9wZW5lZC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBvblRvZ2dsZU9wZW5lZChldmVudCkge1xuICAgICAqICAgIGFsZXJ0KFwiVG9nZ2xlIG9wZW5lZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXZcbiAgICAgKiAgIGlneFRvZ2dsZVxuICAgICAqICAgKG9wZW5lZCk9J29uVG9nZ2xlT3BlbmVkKCRldmVudCknPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvcGVuZWQgPSBuZXcgRXZlbnRFbWl0dGVyPFRvZ2dsZVZpZXdFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBiZWZvcmUgdGhlIHRvZ2dsZSBjb250YWluZXIgaXMgb3BlbmVkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIG9uVG9nZ2xlT3BlbmluZyhldmVudCkge1xuICAgICAqICBhbGVydChcIlRvZ2dsZSBvcGVuaW5nIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdlxuICAgICAqICAgaWd4VG9nZ2xlXG4gICAgICogICAob3BlbmluZyk9J29uVG9nZ2xlT3BlbmluZygkZXZlbnQpJz5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb3BlbmluZyA9IG5ldyBFdmVudEVtaXR0ZXI8VG9nZ2xlVmlld0NhbmNlbGFibGVFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBhZnRlciB0aGUgdG9nZ2xlIGNvbnRhaW5lciBpcyBjbG9zZWQuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogb25Ub2dnbGVDbG9zZWQoZXZlbnQpIHtcbiAgICAgKiAgYWxlcnQoXCJUb2dnbGUgY2xvc2VkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdlxuICAgICAqICAgaWd4VG9nZ2xlXG4gICAgICogICAoY2xvc2VkKT0nb25Ub2dnbGVDbG9zZWQoJGV2ZW50KSc+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGNsb3NlZCA9IG5ldyBFdmVudEVtaXR0ZXI8VG9nZ2xlVmlld0V2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IGJlZm9yZSB0aGUgdG9nZ2xlIGNvbnRhaW5lciBpcyBjbG9zZWQuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogb25Ub2dnbGVDbG9zaW5nKGV2ZW50KSB7XG4gICAgICogIGFsZXJ0KFwiVG9nZ2xlIGNsb3NpbmchXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2XG4gICAgICogIGlneFRvZ2dsZVxuICAgICAqICAoY2xvc2luZyk9J29uVG9nZ2xlQ2xvc2luZygkZXZlbnQpJz5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgY2xvc2luZyA9IG5ldyBFdmVudEVtaXR0ZXI8VG9nZ2xlVmlld0NhbmNlbGFibGVFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBhZnRlciB0aGUgdG9nZ2xlIGVsZW1lbnQgaXMgYXBwZW5kZWQgdG8gdGhlIG92ZXJsYXkgY29udGFpbmVyLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIG9uQXBwZW5kZWQoKSB7XG4gICAgICogIGFsZXJ0KFwiQ29udGVudCBhcHBlbmRlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXZcbiAgICAgKiAgIGlneFRvZ2dsZVxuICAgICAqICAgKGFwcGVuZGVkKT0nb25Ub2dnbGVBcHBlbmRlZCgpJz5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgYXBwZW5kZWQgPSBuZXcgRXZlbnRFbWl0dGVyPFRvZ2dsZVZpZXdFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBjb2xsYXBzZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xsYXBzZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWRlbnRpZmllciB3aGljaCBpcyByZWdpc3RlcmVkIGludG8gYElneE5hdmlnYXRpb25TZXJ2aWNlYFxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBteVRvZ2dsZUlkID0gdGhpcy50b2dnbGUuaWQ7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaWQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGVsZW1lbnQoKTogSFRNTEVsZW1lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LXRvZ2dsZS0taGlkZGVuJylcbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1oaWRkZW4nKVxuICAgIHB1YmxpYyBnZXQgaGlkZGVuQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbGxhcHNlZDtcbiAgICB9XG5cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC10b2dnbGUtLWhpZGRlbi13ZWJraXQnKVxuICAgIHB1YmxpYyBnZXQgaGlkZGVuV2Via2l0Q2xhc3MoKSB7XG4gICAgICAgIGNvbnN0IGlzU2FmYXJpID0gdGhpcy5wbGF0Zm9ybT8uaXNTYWZhcmk7XG4gICAgICAgIGNvbnN0IGJyb3dzZXJWZXJzaW9uID0gdGhpcy5wbGF0Zm9ybT8uYnJvd3NlclZlcnNpb247XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGFwc2VkICYmIGlzU2FmYXJpICYmICEhYnJvd3NlclZlcnNpb24gJiYgYnJvd3NlclZlcnNpb24gPCAxNy41O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC10b2dnbGUnKVxuICAgIHB1YmxpYyBnZXQgZGVmYXVsdENsYXNzKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29sbGFwc2VkO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfb3ZlcmxheUlkOiBzdHJpbmc7XG5cbiAgICBwcml2YXRlIF9jb2xsYXBzZWQgPSB0cnVlO1xuICAgIHByb3RlY3RlZCBkZXN0cm95JCA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG4gICAgcHJpdmF0ZSBfb3ZlcmxheVN1YkZpbHRlcjogW01vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbjxPdmVybGF5RXZlbnRBcmdzPiwgTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uPE92ZXJsYXlFdmVudEFyZ3M+XSA9IFtcbiAgICAgICAgZmlsdGVyKHggPT4geC5pZCA9PT0gdGhpcy5fb3ZlcmxheUlkKSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpXG4gICAgXTtcbiAgICBwcml2YXRlIF9vdmVybGF5T3BlbmVkU3ViOiBTdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBfb3ZlcmxheUNsb3NpbmdTdWI6IFN1YnNjcmlwdGlvbjtcbiAgICBwcml2YXRlIF9vdmVybGF5Q2xvc2VkU3ViOiBTdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBfb3ZlcmxheUNvbnRlbnRBcHBlbmRlZFN1YjogU3Vic2NyaXB0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgIHByaXZhdGUgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgQEluamVjdChJZ3hPdmVybGF5U2VydmljZSkgcHJvdGVjdGVkIG92ZXJsYXlTZXJ2aWNlOiBJZ3hPdmVybGF5U2VydmljZSxcbiAgICAgICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBuYXZpZ2F0aW9uU2VydmljZTogSWd4TmF2aWdhdGlvblNlcnZpY2UsXG4gICAgICAgIEBPcHRpb25hbCgpIHByaXZhdGUgcGxhdGZvcm0/OiBQbGF0Zm9ybVV0aWxcbiAgICApIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgdG9nZ2xlLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMubXlUb2dnbGUub3BlbigpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBvcGVuKG92ZXJsYXlTZXR0aW5ncz86IE92ZXJsYXlTZXR0aW5ncykge1xuICAgICAgICAvLyAgaWYgdGhlcmUgaXMgb3BlbiBhbmltYXRpb24gZG8gbm90aGluZ1xuICAgICAgICAvLyAgaWYgdG9nZ2xlIGlzIG5vdCBjb2xsYXBzZWQgYW5kIHRoZXJlIGlzIG5vIGNsb3NlIGFuaW1hdGlvbiBkbyBub3RoaW5nXG4gICAgICAgIGNvbnN0IGluZm8gPSB0aGlzLm92ZXJsYXlTZXJ2aWNlLmdldE92ZXJsYXlCeUlkKHRoaXMuX292ZXJsYXlJZCk7XG4gICAgICAgIGNvbnN0IG9wZW5BbmltYXRpb25TdGFydGVkID0gaW5mbz8ub3BlbkFuaW1hdGlvblBsYXllcj8uaGFzU3RhcnRlZCgpID8/IGZhbHNlO1xuICAgICAgICBjb25zdCBjbG9zZUFuaW1hdGlvblN0YXJ0ZWQgPSBpbmZvPy5jbG9zZUFuaW1hdGlvblBsYXllcj8uaGFzU3RhcnRlZCgpID8/IGZhbHNlO1xuICAgICAgICBpZiAob3BlbkFuaW1hdGlvblN0YXJ0ZWQgfHwgISh0aGlzLl9jb2xsYXBzZWQgfHwgY2xvc2VBbmltYXRpb25TdGFydGVkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY29sbGFwc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcblxuICAgICAgICBpZiAoIWluZm8pIHtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5SWQgPSB0aGlzLm92ZXJsYXlTZXJ2aWNlLmF0dGFjaCh0aGlzLmVsZW1lbnRSZWYsIG92ZXJsYXlTZXR0aW5ncyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhcmdzOiBUb2dnbGVWaWV3Q2FuY2VsYWJsZUV2ZW50QXJncyA9IHsgY2FuY2VsOiBmYWxzZSwgb3duZXI6IHRoaXMsIGlkOiB0aGlzLl9vdmVybGF5SWQgfTtcbiAgICAgICAgdGhpcy5vcGVuaW5nLmVtaXQoYXJncyk7XG4gICAgICAgIGlmIChhcmdzLmNhbmNlbCkge1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5U2VydmljZS5kZXRhY2godGhpcy5fb3ZlcmxheUlkKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxhcHNlZCA9IHRydWU7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fb3ZlcmxheUlkO1xuICAgICAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3ZlcmxheVNlcnZpY2Uuc2hvdyh0aGlzLl9vdmVybGF5SWQsIG92ZXJsYXlTZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB0b2dnbGUuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5teVRvZ2dsZS5jbG9zZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBjbG9zZShldmVudD86IEV2ZW50KSB7XG4gICAgICAgIC8vICBpZiB0b2dnbGUgaXMgY29sbGFwc2VkIGRvIG5vdGhpbmdcbiAgICAgICAgLy8gIGlmIHRoZXJlIGlzIGNsb3NlIGFuaW1hdGlvbiBkbyBub3RoaW5nLCB0b2dnbGUgd2lsbCBjbG9zZSBhbnl3YXlcbiAgICAgICAgY29uc3QgaW5mbyA9IHRoaXMub3ZlcmxheVNlcnZpY2UuZ2V0T3ZlcmxheUJ5SWQodGhpcy5fb3ZlcmxheUlkKTtcbiAgICAgICAgY29uc3QgY2xvc2VBbmltYXRpb25TdGFydGVkID0gaW5mbz8uY2xvc2VBbmltYXRpb25QbGF5ZXI/Lmhhc1N0YXJ0ZWQoKSB8fCBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2NvbGxhcHNlZCB8fCBjbG9zZUFuaW1hdGlvblN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3ZlcmxheVNlcnZpY2UuaGlkZSh0aGlzLl9vdmVybGF5SWQsIGV2ZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVucyBvciBjbG9zZXMgdGhlIHRvZ2dsZSwgZGVwZW5kaW5nIG9uIGl0cyBjdXJyZW50IHN0YXRlLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMubXlUb2dnbGUudG9nZ2xlKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHRvZ2dsZShvdmVybGF5U2V0dGluZ3M/OiBPdmVybGF5U2V0dGluZ3MpIHtcbiAgICAgICAgLy8gIGlmIHRvZ2dsZSBpcyBjb2xsYXBzZWQgY2FsbCBvcGVuXG4gICAgICAgIC8vICBpZiB0aGVyZSBpcyBydW5uaW5nIGNsb3NlIGFuaW1hdGlvbiBjYWxsIG9wZW5cbiAgICAgICAgaWYgKHRoaXMuY29sbGFwc2VkIHx8IHRoaXMuaXNDbG9zaW5nKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW4ob3ZlcmxheVNldHRpbmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBnZXQgaXNDbG9zaW5nKCkge1xuICAgICAgICBjb25zdCBpbmZvID0gdGhpcy5vdmVybGF5U2VydmljZS5nZXRPdmVybGF5QnlJZCh0aGlzLl9vdmVybGF5SWQpO1xuICAgICAgICByZXR1cm4gaW5mbyA/IGluZm8uY2xvc2VBbmltYXRpb25QbGF5ZXI/Lmhhc1N0YXJ0ZWQoKSA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGlkIG9mIHRoZSBvdmVybGF5IHRoZSBjb250ZW50IGlzIHJlbmRlcmVkIGluLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLm15VG9nZ2xlLm92ZXJsYXlJZDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG92ZXJsYXlJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXlJZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBvc2l0aW9ucyB0aGUgdG9nZ2xlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLm15VG9nZ2xlLnJlcG9zaXRpb24oKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgcmVwb3NpdGlvbigpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5U2VydmljZS5yZXBvc2l0aW9uKHRoaXMuX292ZXJsYXlJZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT2Zmc2V0cyB0aGUgY29udGVudCBhbG9uZyB0aGUgY29ycmVzcG9uZGluZyBheGlzIGJ5IHRoZSBwcm92aWRlZCBhbW91bnQgd2l0aCBvcHRpb25hbFxuICAgICAqIG9mZnNldE1vZGUgdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdG8gYWRkIChieSBkZWZhdWx0KSBvciBzZXQgdGhlIG9mZnNldCB2YWx1ZXMgd2l0aCBPZmZzZXRNb2RlLkFkZCBhbmQgT2Zmc2V0TW9kZS5TZXRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0T2Zmc2V0KGRlbHRhWDogbnVtYmVyLCBkZWx0YVk6IG51bWJlciwgb2Zmc2V0TW9kZT86IE9mZnNldE1vZGUpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5U2VydmljZS5zZXRPZmZzZXQodGhpcy5fb3ZlcmxheUlkLCBkZWx0YVgsIGRlbHRhWSwgb2Zmc2V0TW9kZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMubmF2aWdhdGlvblNlcnZpY2UgJiYgdGhpcy5pZCkge1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5hZGQodGhpcy5pZCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5uYXZpZ2F0aW9uU2VydmljZSAmJiB0aGlzLmlkKSB7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnJlbW92ZSh0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheUlkKSB7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlTZXJ2aWNlLmRldGFjaCh0aGlzLl9vdmVybGF5SWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5uZXh0KHRydWUpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvdmVybGF5Q2xvc2VkID0gKGUpID0+IHtcbiAgICAgICAgdGhpcy5fY29sbGFwc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMub3ZlcmxheVNlcnZpY2UuZGV0YWNoKHRoaXMub3ZlcmxheUlkKTtcbiAgICAgICAgY29uc3QgYXJnczogVG9nZ2xlVmlld0V2ZW50QXJncyA9IHsgb3duZXI6IHRoaXMsIGlkOiB0aGlzLl9vdmVybGF5SWQsIGV2ZW50OiBlLmV2ZW50IH07XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9vdmVybGF5SWQ7XG4gICAgICAgIHRoaXMuY2xvc2VkLmVtaXQoYXJncyk7XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgIH07XG5cbiAgICBwcml2YXRlIHN1YnNjcmliZSgpIHtcbiAgICAgICAgdGhpcy5fb3ZlcmxheUNvbnRlbnRBcHBlbmRlZFN1YiA9IHRoaXMub3ZlcmxheVNlcnZpY2VcbiAgICAgICAgICAgIC5jb250ZW50QXBwZW5kZWRcbiAgICAgICAgICAgIC5waXBlKGZpcnN0KCksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3M6IFRvZ2dsZVZpZXdFdmVudEFyZ3MgPSB7IG93bmVyOiB0aGlzLCBpZDogdGhpcy5fb3ZlcmxheUlkIH07XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRlZC5lbWl0KGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fb3ZlcmxheU9wZW5lZFN1YiA9IHRoaXMub3ZlcmxheVNlcnZpY2VcbiAgICAgICAgICAgIC5vcGVuZWRcbiAgICAgICAgICAgIC5waXBlKC4uLnRoaXMuX292ZXJsYXlTdWJGaWx0ZXIpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzOiBUb2dnbGVWaWV3RXZlbnRBcmdzID0geyBvd25lcjogdGhpcywgaWQ6IHRoaXMuX292ZXJsYXlJZCB9O1xuICAgICAgICAgICAgICAgIHRoaXMub3BlbmVkLmVtaXQoYXJncyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9vdmVybGF5Q2xvc2luZ1N1YiA9IHRoaXMub3ZlcmxheVNlcnZpY2VcbiAgICAgICAgICAgIC5jbG9zaW5nXG4gICAgICAgICAgICAucGlwZSguLi50aGlzLl9vdmVybGF5U3ViRmlsdGVyKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoZTogT3ZlcmxheUNsb3NpbmdFdmVudEFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzOiBUb2dnbGVWaWV3Q2FuY2VsYWJsZUV2ZW50QXJncyA9IHsgY2FuY2VsOiBmYWxzZSwgZXZlbnQ6IGUuZXZlbnQsIG93bmVyOiB0aGlzLCBpZDogdGhpcy5fb3ZlcmxheUlkIH07XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zaW5nLmVtaXQoYXJncyk7XG4gICAgICAgICAgICAgICAgZS5jYW5jZWwgPSBhcmdzLmNhbmNlbDtcblxuICAgICAgICAgICAgICAgIC8vICBpbiBjYXNlIGV2ZW50IGlzIG5vdCBjYW5jZWxlZCB0aGlzIHdpbGwgY2xvc2UgdGhlIHRvZ2dsZSBhbmQgd2UgbmVlZCB0byB1bnN1YnNjcmliZS5cbiAgICAgICAgICAgICAgICAvLyAgT3RoZXJ3aXNlIGlmIGZvciBzb21lIHJlYXNvbiwgZS5nLiBjbG9zZSBvbiBvdXRzaWRlIGNsaWNrLCBjbG9zZSgpIGdldHMgY2FsbGVkIGJlZm9yZVxuICAgICAgICAgICAgICAgIC8vICBjbG9zZWQgd2FzIGZpcmVkIHdlIHdpbGwgZW5kIHdpdGggY2FsbGluZyBjbG9zaW5nIG1vcmUgdGhhbiBvbmNlXG4gICAgICAgICAgICAgICAgaWYgKCFlLmNhbmNlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyU3Vic2NyaXB0aW9uKHRoaXMuX292ZXJsYXlDbG9zaW5nU3ViKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9vdmVybGF5Q2xvc2VkU3ViID0gdGhpcy5vdmVybGF5U2VydmljZVxuICAgICAgICAgICAgLmNsb3NlZFxuICAgICAgICAgICAgLnBpcGUoLi4udGhpcy5fb3ZlcmxheVN1YkZpbHRlcilcbiAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy5vdmVybGF5Q2xvc2VkKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICB0aGlzLmNsZWFyU3Vic2NyaXB0aW9uKHRoaXMuX292ZXJsYXlPcGVuZWRTdWIpO1xuICAgICAgICB0aGlzLmNsZWFyU3Vic2NyaXB0aW9uKHRoaXMuX292ZXJsYXlDbG9zaW5nU3ViKTtcbiAgICAgICAgdGhpcy5jbGVhclN1YnNjcmlwdGlvbih0aGlzLl9vdmVybGF5Q2xvc2VkU3ViKTtcbiAgICAgICAgdGhpcy5jbGVhclN1YnNjcmlwdGlvbih0aGlzLl9vdmVybGF5Q29udGVudEFwcGVuZGVkU3ViKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNsZWFyU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24gJiYgIXN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgICBleHBvcnRBczogJ3RvZ2dsZS1hY3Rpb24nLFxuICAgIHNlbGVjdG9yOiAnW2lneFRvZ2dsZUFjdGlvbl0nLFxuICAgIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgSWd4VG9nZ2xlQWN0aW9uRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0IHtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlIHNldHRpbmdzIHRoYXQgY29udHJvbCB0aGUgdG9nZ2xlIG92ZXJsYXkgcG9zaXRpb25pbmcsIGludGVyYWN0aW9uIGFuZCBzY3JvbGwgYmVoYXZpb3IuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHNldHRpbmdzOiBPdmVybGF5U2V0dGluZ3MgPSB7XG4gICAgICogICAgICBjbG9zZU9uT3V0c2lkZUNsaWNrOiBmYWxzZSxcbiAgICAgKiAgICAgIG1vZGFsOiBmYWxzZVxuICAgICAqICB9XG4gICAgICogYGBgXG4gICAgICogLS0tXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8ZGl2IGlneFRvZ2dsZUFjdGlvbiBbb3ZlcmxheVNldHRpbmdzXT1cInNldHRpbmdzXCI+PC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgb3ZlcmxheVNldHRpbmdzOiBPdmVybGF5U2V0dGluZ3M7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXJlIHRoZSB0b2dnbGUgZWxlbWVudCBvdmVybGF5IHNob3VsZCBiZSBhdHRhY2hlZC5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8IS0tc2V0LS0+XG4gICAgICogPGRpdiBpZ3hUb2dnbGVBY3Rpb24gW2lneFRvZ2dsZU91dGxldF09XCJvdXRsZXRcIj48L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBXaGVyZSBgb3V0bGV0YCBpbiBhbiBpbnN0YW5jZSBvZiBgSWd4T3ZlcmxheU91dGxldERpcmVjdGl2ZWAgb3IgYW4gYEVsZW1lbnRSZWZgXG4gICAgICovXG4gICAgQElucHV0KCdpZ3hUb2dnbGVPdXRsZXQnKVxuICAgIHB1YmxpYyBvdXRsZXQ6IElneE92ZXJsYXlPdXRsZXREaXJlY3RpdmUgfCBFbGVtZW50UmVmO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBJbnB1dCgnaWd4VG9nZ2xlQWN0aW9uJylcbiAgICBwdWJsaWMgc2V0IHRhcmdldCh0YXJnZXQ6IGFueSkge1xuICAgICAgICBpZiAodGFyZ2V0ICE9PSBudWxsICYmIHRhcmdldCAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHRhcmdldCgpOiBhbnkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX3RhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmdldCh0aGlzLl90YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXQ7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9vdmVybGF5RGVmYXVsdHM6IE92ZXJsYXlTZXR0aW5ncztcbiAgICBwcm90ZWN0ZWQgX3RhcmdldDogSVRvZ2dsZVZpZXcgfCBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIEBPcHRpb25hbCgpIHByaXZhdGUgbmF2aWdhdGlvblNlcnZpY2U6IElneE5hdmlnYXRpb25TZXJ2aWNlKSB7IH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycpXG4gICAgcHVibGljIG9uQ2xpY2soKSB7XG4gICAgICAgIGlmICh0aGlzLm91dGxldCkge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheURlZmF1bHRzLm91dGxldCA9IHRoaXMub3V0bGV0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2xvbmVkU2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9vdmVybGF5RGVmYXVsdHMsIHRoaXMub3ZlcmxheVNldHRpbmdzKTtcbiAgICAgICAgdGhpcy51cGRhdGVPdmVybGF5U2V0dGluZ3MoY2xvbmVkU2V0dGluZ3MpO1xuICAgICAgICB0aGlzLnRhcmdldC50b2dnbGUoY2xvbmVkU2V0dGluZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkluaXQoKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdGhpcy5fb3ZlcmxheURlZmF1bHRzID0ge1xuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXRFbGVtZW50LFxuICAgICAgICAgICAgcG9zaXRpb25TdHJhdGVneTogbmV3IENvbm5lY3RlZFBvc2l0aW9uaW5nU3RyYXRlZ3koKSxcbiAgICAgICAgICAgIHNjcm9sbFN0cmF0ZWd5OiBuZXcgQWJzb2x1dGVTY3JvbGxTdHJhdGVneSgpLFxuICAgICAgICAgICAgY2xvc2VPbk91dHNpZGVDbGljazogdHJ1ZSxcbiAgICAgICAgICAgIG1vZGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGV4Y2x1ZGVGcm9tT3V0c2lkZUNsaWNrOiBbdGFyZ2V0RWxlbWVudCBhcyBIVE1MRWxlbWVudF1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHByb3ZpZGVkIG92ZXJsYXkgc2V0dGluZ3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZXR0aW5ncyBzZXR0aW5ncyB0byB1cGRhdGVcbiAgICAgKiBAcmV0dXJucyByZXR1cm5zIHVwZGF0ZWQgY29weSBvZiBwcm92aWRlZCBvdmVybGF5IHNldHRpbmdzXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHVwZGF0ZU92ZXJsYXlTZXR0aW5ncyhzZXR0aW5nczogT3ZlcmxheVNldHRpbmdzKTogT3ZlcmxheVNldHRpbmdzIHtcbiAgICAgICAgaWYgKHNldHRpbmdzICYmIHNldHRpbmdzLnBvc2l0aW9uU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uU3RyYXRlZ3lDbG9uZTogSVBvc2l0aW9uU3RyYXRlZ3kgPSBzZXR0aW5ncy5wb3NpdGlvblN0cmF0ZWd5LmNsb25lKCk7XG4gICAgICAgICAgICBzZXR0aW5ncy50YXJnZXQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIHNldHRpbmdzLnBvc2l0aW9uU3RyYXRlZ3kgPSBwb3NpdGlvblN0cmF0ZWd5Q2xvbmU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2V0dGluZ3M7XG4gICAgfVxufVxuXG4vKipcbiAqIE1hcmsgYW4gZWxlbWVudCBhcyBhbiBpZ3hPdmVybGF5IG91dGxldCBjb250YWluZXIuXG4gKiBEaXJlY3RpdmUgaW5zdGFuY2UgaXMgZXhwb3J0ZWQgYXMgYG92ZXJsYXktb3V0bGV0YCB0byBiZSBhc3NpZ25lZCB0byB0ZW1wbGF0ZXMgdmFyaWFibGVzOlxuICogYGBgaHRtbFxuICogPGRpdiBpZ3hPdmVybGF5T3V0bGV0ICNvdXRsZXQ9XCJvdmVybGF5LW91dGxldFwiPjwvZGl2PlxuICogYGBgXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIGV4cG9ydEFzOiAnb3ZlcmxheS1vdXRsZXQnLFxuICAgIHNlbGVjdG9yOiAnW2lneE92ZXJsYXlPdXRsZXRdJyxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneE92ZXJsYXlPdXRsZXREaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbGVtZW50OiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PikgeyB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHB1YmxpYyBnZXQgbmF0aXZlRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgIH1cbn1cbiJdfQ==