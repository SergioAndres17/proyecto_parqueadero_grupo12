/* eslint-disable @angular-eslint/no-conflicting-lifecycle */
import { DOCUMENT } from '@angular/common';
import { Directive, EventEmitter, Input, Output, Inject, booleanAttribute } from '@angular/core';
import { DisplayContainerComponent } from './display.container';
import { HVirtualHelperComponent } from './horizontal.virtual.helper.component';
import { VirtualHelperComponent } from './virtual.helper.component';
import { IgxForOfScrollSyncService } from './for_of.sync.service';
import { Subject } from 'rxjs';
import { takeUntil, filter, throttleTime, first } from 'rxjs/operators';
import { getResizeObserver } from '../../core/utils';
import * as i0 from "@angular/core";
import * as i1 from "./for_of.sync.service";
import * as i2 from "../../core/utils";
const MAX_PERF_SCROLL_DIFF = 4;
/**
 *  @publicApi
 */
export class IgxForOfContext {
    constructor($implicit, igxForOf, index, count) {
        this.$implicit = $implicit;
        this.igxForOf = igxForOf;
        this.index = index;
        this.count = count;
    }
    /**
     * A function that returns whether the element is the first or not
     */
    get first() {
        return this.index === 0;
    }
    /**
     * A function that returns whether the element is the last or not
     */
    get last() {
        return this.index === this.count - 1;
    }
    /**
     * A function that returns whether the element is even or not
     */
    get even() {
        return this.index % 2 === 0;
    }
    /**
     * A function that returns whether the element is odd or not
     */
    get odd() {
        return !this.even;
    }
}
/** @hidden @internal */
export class IgxForOfToken {
}
export class IgxForOfDirective extends IgxForOfToken {
    /**
     * The total count of the virtual data items, when using remote service.
     * Similar to the property totalItemCount, but this will allow setting the data count into the template.
     * ```html
     * <ng-template igxFor let-item [igxForOf]="data | async" [igxForTotalItemCount]="count | async"
     *  [igxForContainerSize]="'500px'" [igxForItemSize]="'50px'"></ng-template>
     * ```
     */
    get igxForTotalItemCount() {
        return this.totalItemCount;
    }
    set igxForTotalItemCount(value) {
        this.totalItemCount = value;
    }
    /**
     * The total count of the virtual data items, when using remote service.
     * ```typescript
     * this.parentVirtDir.totalItemCount = data.Count;
     * ```
     */
    get totalItemCount() {
        return this._totalItemCount;
    }
    set totalItemCount(val) {
        if (this._totalItemCount !== val) {
            this._totalItemCount = val;
            // update sizes in case total count changes.
            const newSize = this.initSizesCache(this.igxForOf);
            const sizeDiff = this.scrollComponent.size - newSize;
            this.scrollComponent.size = newSize;
            const lastChunkExceeded = this.state.startIndex + this.state.chunkSize > val;
            if (lastChunkExceeded) {
                this.state.startIndex = val - this.state.chunkSize;
            }
            this._adjustScrollPositionAfterSizeChange(sizeDiff);
        }
    }
    get displayContainer() {
        return this.dc?.instance?._viewContainer?.element?.nativeElement;
    }
    get virtualHelper() {
        return this.scrollComponent.nativeElement;
    }
    /**
     * @hidden
     */
    get isRemote() {
        return this.totalItemCount !== null;
    }
    /**
     *
     * Gets/Sets the scroll position.
     * ```typescript
     * const position = directive.scrollPosition;
     * directive.scrollPosition = value;
     * ```
     */
    get scrollPosition() {
        return this.scrollComponent.scrollAmount;
    }
    set scrollPosition(val) {
        if (val === this.scrollComponent.scrollAmount) {
            return;
        }
        if (this.igxForScrollOrientation === 'horizontal' && this.scrollComponent) {
            this.scrollComponent.nativeElement.scrollLeft = this.isRTL ? -val : val;
        }
        else if (this.scrollComponent) {
            this.scrollComponent.nativeElement.scrollTop = val;
        }
    }
    /**
     * @hidden
     */
    get isRTL() {
        const dir = window.getComputedStyle(this.dc.instance._viewContainer.element.nativeElement).getPropertyValue('direction');
        return dir === 'rtl';
    }
    get sizesCache() {
        return this._sizesCache;
    }
    set sizesCache(value) {
        this._sizesCache = value;
    }
    get _isScrolledToBottom() {
        if (!this.getScroll()) {
            return true;
        }
        const scrollHeight = this.getScroll().scrollHeight;
        // Use === and not >= because `scrollTop + container size` can't be bigger than `scrollHeight`, unless something isn't updated.
        // Also use Math.round because Chrome has some inconsistencies and `scrollTop + container` can be float when zooming the page.
        return Math.round(this.getScroll().scrollTop + this.igxForContainerSize) === scrollHeight;
    }
    get _isAtBottomIndex() {
        return this.igxForOf && this.state.startIndex + this.state.chunkSize > this.igxForOf.length;
    }
    constructor(_viewContainer, _template, _differs, cdr, _zone, syncScrollService, platformUtil, document) {
        super();
        this._viewContainer = _viewContainer;
        this._template = _template;
        this._differs = _differs;
        this.cdr = cdr;
        this._zone = _zone;
        this.syncScrollService = syncScrollService;
        this.platformUtil = platformUtil;
        this.document = document;
        /**
         * Specifies the scroll orientation.
         * Scroll orientation can be "vertical" or "horizontal".
         * ```html
         * <ng-template igxFor let-item [igxForOf]="data" [igxForScrollOrientation]="'horizontal'"></ng-template>
         * ```
         */
        this.igxForScrollOrientation = 'vertical';
        /**
         * An event that is emitted after a new chunk has been loaded.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (chunkLoad)="loadChunk($event)"></ng-template>
         * ```
         * ```typescript
         * loadChunk(e){
         * alert("chunk loaded!");
         * }
         * ```
         */
        this.chunkLoad = new EventEmitter();
        /**
         * @hidden @internal
         * An event that is emitted when scrollbar visibility has changed.
         */
        this.scrollbarVisibilityChanged = new EventEmitter();
        /**
         * An event that is emitted after the rendered content size of the igxForOf has been changed.
         */
        this.contentSizeChange = new EventEmitter();
        /**
         * An event that is emitted after data has been changed.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (dataChanged)="dataChanged($event)"></ng-template>
         * ```
         * ```typescript
         * dataChanged(e){
         * alert("data changed!");
         * }
         * ```
         */
        this.dataChanged = new EventEmitter();
        this.beforeViewDestroyed = new EventEmitter();
        /**
         * An event that is emitted on chunk loading to emit the current state information - startIndex, endIndex, totalCount.
         * Can be used for implementing remote load on demand for the igxFor data.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (chunkPreload)="chunkPreload($event)"></ng-template>
         * ```
         * ```typescript
         * chunkPreload(e){
         * alert("chunk is loading!");
         * }
         * ```
         */
        this.chunkPreload = new EventEmitter();
        /**
         * The current state of the directive. It contains `startIndex` and `chunkSize`.
         * state.startIndex - The index of the item at which the current visible chunk begins.
         * state.chunkSize - The number of items the current visible chunk holds.
         * These options can be used when implementing remote virtualization as they provide the necessary state information.
         * ```typescript
         * const gridState = this.parentVirtDir.state;
         * ```
         */
        this.state = {
            startIndex: 0,
            chunkSize: 0
        };
        this._sizesCache = [];
        this._differ = null;
        this.individualSizeCache = [];
        /** Internal track for scroll top that is being virtualized */
        this._virtScrollPosition = 0;
        /** If the next onScroll event is triggered due to internal setting of scrollTop */
        this._bScrollInternal = false;
        // End properties related to virtual height handling
        this._embeddedViews = [];
        this.contentResizeNotify = new Subject();
        /** Size that is being virtualized. */
        this._virtSize = 0;
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
        this._totalItemCount = null;
        /**
         * Ratio for height that's being virtualizaed and the one visible
         * If _virtHeightRatio = 1, the visible height and the virtualized are the same, also _maxSize > _virtHeight.
         */
        this._virtRatio = 1;
    }
    verticalScrollHandler(event) {
        this.onScroll(event);
    }
    isScrollable() {
        return this.scrollComponent.size > parseInt(this.igxForContainerSize, 10);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        const vc = this.igxForScrollContainer ? this.igxForScrollContainer._viewContainer : this._viewContainer;
        this.igxForSizePropName = this.igxForSizePropName || 'width';
        this.dc = this._viewContainer.createComponent(DisplayContainerComponent, { index: 0 });
        this.dc.instance.scrollDirection = this.igxForScrollOrientation;
        if (this.igxForOf && this.igxForOf.length) {
            this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);
            this.state.chunkSize = this._calculateChunkSize();
            this.dc.instance.notVirtual = !(this.igxForContainerSize && this.state.chunkSize < this.igxForOf.length);
            if (this.scrollComponent && !this.scrollComponent.destroyed) {
                this.state.startIndex = Math.min(this.getIndexAt(this.scrollPosition, this.sizesCache), this.igxForOf.length - this.state.chunkSize);
            }
            for (let i = this.state.startIndex; i < this.state.startIndex + this.state.chunkSize &&
                this.igxForOf[i] !== undefined; i++) {
                const input = this.igxForOf[i];
                const embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.igxForOf, this.getContextIndex(input), this.igxForOf.length));
                this._embeddedViews.push(embeddedView);
            }
        }
        this._maxSize = this._calcMaxBrowserSize();
        if (this.igxForScrollOrientation === 'vertical') {
            this.dc.instance._viewContainer.element.nativeElement.style.top = '0px';
            this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);
            if (!this.scrollComponent || this.scrollComponent.destroyed) {
                this.scrollComponent = vc.createComponent(VirtualHelperComponent).instance;
            }
            this.scrollComponent.size = this.igxForOf ? this._calcSize() : 0;
            this.syncScrollService.setScrollMaster(this.igxForScrollOrientation, this.scrollComponent);
            this._zone.runOutsideAngular(() => {
                this.verticalScrollHandler = this.verticalScrollHandler.bind(this);
                this.scrollComponent.nativeElement.addEventListener('scroll', this.verticalScrollHandler);
                this.dc.instance.scrollContainer = this.scrollComponent.nativeElement;
            });
            const destructor = takeUntil(this.destroy$);
            this.contentResizeNotify.pipe(filter(() => this.igxForContainerSize && this.igxForOf && this.igxForOf.length > 0), throttleTime(40, undefined, { leading: false, trailing: true }), destructor).subscribe(() => this._zone.runTask(() => this.updateSizes()));
        }
        if (this.igxForScrollOrientation === 'horizontal') {
            this.func = (evt) => this.onHScroll(evt);
            this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);
            if (!this.scrollComponent) {
                this.scrollComponent = vc.createComponent(HVirtualHelperComponent).instance;
                this.scrollComponent.size = this.igxForOf ? this._calcSize() : 0;
                this.syncScrollService.setScrollMaster(this.igxForScrollOrientation, this.scrollComponent);
                this._zone.runOutsideAngular(() => {
                    this.scrollComponent.nativeElement.addEventListener('scroll', this.func);
                    this.dc.instance.scrollContainer = this.scrollComponent.nativeElement;
                });
            }
            else {
                this._zone.runOutsideAngular(() => {
                    this.scrollComponent.nativeElement.addEventListener('scroll', this.func);
                    this.dc.instance.scrollContainer = this.scrollComponent.nativeElement;
                });
            }
            this._updateScrollOffset();
        }
    }
    ngAfterViewInit() {
        if (this.igxForScrollOrientation === 'vertical') {
            this._zone.runOutsideAngular(() => {
                this.contentObserver = new (getResizeObserver())(() => this.contentResizeNotify.next());
                this.contentObserver.observe(this.dc.instance._viewContainer.element.nativeElement);
            });
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.removeScrollEventListeners();
        this.destroy$.next(true);
        this.destroy$.complete();
        if (this.contentObserver) {
            this.contentObserver.disconnect();
        }
    }
    /**
     * @hidden @internal
     * Asserts the correct type of the context for the template that `igxForOf` will render.
     *
     * The presence of this method is a signal to the Ivy template type-check compiler that the
     * `IgxForOf` structural directive renders its template with a specific context type.
     */
    static ngTemplateContextGuard(dir, ctx) {
        return true;
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        const forOf = 'igxForOf';
        if (forOf in changes) {
            const value = changes[forOf].currentValue;
            if (!this._differ && value) {
                try {
                    this._differ = this._differs.find(value).create(this.igxForTrackBy);
                }
                catch (e) {
                    throw new Error(`Cannot find a differ supporting object "${value}" of type "${getTypeNameForDebugging(value)}".
                     NgFor only supports binding to Iterables such as Arrays.`);
                }
            }
        }
        const defaultItemSize = 'igxForItemSize';
        if (defaultItemSize in changes && !changes[defaultItemSize].firstChange && this.igxForOf) {
            // handle default item size changed.
            this.initSizesCache(this.igxForOf);
            this._applyChanges();
        }
        const containerSize = 'igxForContainerSize';
        if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {
            const prevSize = parseInt(changes[containerSize].previousValue, 10);
            const newSize = parseInt(changes[containerSize].currentValue, 10);
            this._recalcOnContainerChange({ prevSize, newSize });
        }
    }
    /**
     * @hidden
     */
    ngDoCheck() {
        if (this._differ) {
            const changes = this._differ.diff(this.igxForOf);
            if (changes) {
                //  re-init cache.
                if (!this.igxForOf) {
                    this.igxForOf = [];
                }
                this._updateSizeCache();
                this._zone.run(() => {
                    this._applyChanges();
                    this.cdr.markForCheck();
                    this._updateScrollOffset();
                    const args = {
                        containerSize: this.igxForContainerSize,
                        state: this.state
                    };
                    this.dataChanged.emit(args);
                });
            }
        }
    }
    /**
     * Shifts the scroll thumb position.
     * ```typescript
     * this.parentVirtDir.addScroll(5);
     * ```
     *
     * @param addTop negative value to scroll up and positive to scroll down;
     */
    addScrollTop(add) {
        return this.addScroll(add);
    }
    /**
     * Shifts the scroll thumb position.
     * ```typescript
     * this.parentVirtDir.addScroll(5);
     * ```
     *
     * @param add negative value to scroll previous and positive to scroll next;
     */
    addScroll(add) {
        if (add === 0) {
            return false;
        }
        const originalVirtScrollTop = this._virtScrollPosition;
        const containerSize = parseInt(this.igxForContainerSize, 10);
        const maxVirtScrollTop = this._virtSize - containerSize;
        this._bScrollInternal = true;
        this._virtScrollPosition += add;
        this._virtScrollPosition = this._virtScrollPosition > 0 ?
            (this._virtScrollPosition < maxVirtScrollTop ? this._virtScrollPosition : maxVirtScrollTop) :
            0;
        this.scrollPosition += add / this._virtRatio;
        if (Math.abs(add / this._virtRatio) < 1) {
            // Actual scroll delta that was added is smaller than 1 and onScroll handler doesn't trigger when scrolling < 1px
            const scrollOffset = this.fixedUpdateAllElements(this._virtScrollPosition);
            // scrollOffset = scrollOffset !== parseInt(this.igxForItemSize, 10) ? scrollOffset : 0;
            this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        }
        const maxRealScrollTop = this.scrollComponent.nativeElement.scrollHeight - containerSize;
        if ((this._virtScrollPosition > 0 && this.scrollPosition === 0) ||
            (this._virtScrollPosition < maxVirtScrollTop && this.scrollPosition === maxRealScrollTop)) {
            // Actual scroll position is at the top or bottom, but virtual one is not at the top or bottom (there's more to scroll)
            // Recalculate actual scroll position based on the virtual scroll.
            this.scrollPosition = this._virtScrollPosition / this._virtRatio;
        }
        else if (this._virtScrollPosition === 0 && this.scrollPosition > 0) {
            // Actual scroll position is not at the top, but virtual scroll is. Just update the actual scroll
            this.scrollPosition = 0;
        }
        else if (this._virtScrollPosition === maxVirtScrollTop && this.scrollPosition < maxRealScrollTop) {
            // Actual scroll position is not at the bottom, but virtual scroll is. Just update the acual scroll
            this.scrollPosition = maxRealScrollTop;
        }
        return this._virtScrollPosition !== originalVirtScrollTop;
    }
    /**
     * Scrolls to the specified index.
     * ```typescript
     * this.parentVirtDir.scrollTo(5);
     * ```
     *
     * @param index
     */
    scrollTo(index) {
        if (index < 0 || index > (this.isRemote ? this.totalItemCount : this.igxForOf.length) - 1) {
            return;
        }
        const containerSize = parseInt(this.igxForContainerSize, 10);
        const isPrevItem = index < this.state.startIndex || this.scrollPosition > this.sizesCache[index];
        let nextScroll = isPrevItem ? this.sizesCache[index] : this.sizesCache[index + 1] - containerSize;
        if (nextScroll < 0) {
            return;
        }
        const maxVirtScrollTop = this._virtSize - containerSize;
        if (nextScroll > maxVirtScrollTop) {
            nextScroll = maxVirtScrollTop;
        }
        this._bScrollInternal = true;
        this._virtScrollPosition = nextScroll;
        this.scrollPosition = this._virtScrollPosition / this._virtRatio;
        this._adjustToIndex = !isPrevItem ? index : null;
    }
    /**
     * Scrolls by one item into the appropriate next direction.
     * For "horizontal" orientation that will be the right column and for "vertical" that is the lower row.
     * ```typescript
     * this.parentVirtDir.scrollNext();
     * ```
     */
    scrollNext() {
        const scr = Math.abs(Math.ceil(this.scrollPosition));
        const endIndex = this.getIndexAt(scr + parseInt(this.igxForContainerSize, 10), this.sizesCache);
        this.scrollTo(endIndex);
    }
    /**
     * Scrolls by one item into the appropriate previous direction.
     * For "horizontal" orientation that will be the left column and for "vertical" that is the upper row.
     * ```typescript
     * this.parentVirtDir.scrollPrev();
     * ```
     */
    scrollPrev() {
        this.scrollTo(this.state.startIndex - 1);
    }
    /**
     * Scrolls by one page into the appropriate next direction.
     * For "horizontal" orientation that will be one view to the right and for "vertical" that is one view to the bottom.
     * ```typescript
     * this.parentVirtDir.scrollNextPage();
     * ```
     */
    scrollNextPage() {
        this.addScroll(parseInt(this.igxForContainerSize, 10));
    }
    /**
     * Scrolls by one page into the appropriate previous direction.
     * For "horizontal" orientation that will be one view to the left and for "vertical" that is one view to the top.
     * ```typescript
     * this.parentVirtDir.scrollPrevPage();
     * ```
     */
    scrollPrevPage() {
        const containerSize = (parseInt(this.igxForContainerSize, 10));
        this.addScroll(-containerSize);
    }
    /**
     * @hidden
     */
    getColumnScrollLeft(colIndex) {
        return this.sizesCache[colIndex];
    }
    /**
     * Returns the total number of items that are fully visible.
     * ```typescript
     * this.parentVirtDir.getItemCountInView();
     * ```
     */
    getItemCountInView() {
        let startIndex = this.getIndexAt(this.scrollPosition, this.sizesCache);
        if (this.scrollPosition - this.sizesCache[startIndex] > 0) {
            // fisrt item is not fully in view
            startIndex++;
        }
        const endIndex = this.getIndexAt(this.scrollPosition + parseInt(this.igxForContainerSize, 10), this.sizesCache);
        return endIndex - startIndex;
    }
    /**
     * Returns a reference to the scrollbar DOM element.
     * This is either a vertical or horizontal scrollbar depending on the specified igxForScrollOrientation.
     * ```typescript
     * dir.getScroll();
     * ```
     */
    getScroll() {
        return this.scrollComponent?.nativeElement;
    }
    /**
     * Returns the size of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getSizeAt(1);
     * ```
     */
    getSizeAt(index) {
        return this.sizesCache[index + 1] - this.sizesCache[index];
    }
    /**
     * @hidden
     * Function that is called to get the native scrollbar size that the browsers renders.
     */
    getScrollNativeSize() {
        return this.scrollComponent ? this.scrollComponent.scrollNativeSize : 0;
    }
    /**
     * Returns the scroll offset of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getScrollForIndex(1);
     * ```
     */
    getScrollForIndex(index, bottom) {
        const containerSize = parseInt(this.igxForContainerSize, 10);
        const scroll = bottom ? Math.max(0, this.sizesCache[index + 1] - containerSize) : this.sizesCache[index];
        return scroll;
    }
    /**
     * Returns the index of the element at the specified offset.
     * ```typescript
     * this.parentVirtDir.getIndexAtScroll(100);
     * ```
     */
    getIndexAtScroll(scrollOffset) {
        return this.getIndexAt(scrollOffset, this.sizesCache);
    }
    /**
     * Returns whether the target index is outside the view.
     * ```typescript
     * this.parentVirtDir.isIndexOutsideView(10);
     * ```
     */
    isIndexOutsideView(index) {
        const targetNode = index >= this.state.startIndex && index <= this.state.startIndex + this.state.chunkSize ?
            this._embeddedViews.map(view => view.rootNodes.find(node => node.nodeType === Node.ELEMENT_NODE) || view.rootNodes[0].nextElementSibling)[index - this.state.startIndex] : null;
        const rowHeight = this.getSizeAt(index);
        const containerSize = parseInt(this.igxForContainerSize, 10);
        const containerOffset = -(this.scrollPosition - this.sizesCache[this.state.startIndex]);
        const endTopOffset = targetNode ? targetNode.offsetTop + rowHeight + containerOffset : containerSize + rowHeight;
        return !targetNode || targetNode.offsetTop < Math.abs(containerOffset)
            || containerSize && endTopOffset - containerSize > 5;
    }
    /**
     * @hidden
     * Function that recalculates and updates cache sizes.
     */
    recalcUpdateSizes() {
        const dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        const diffs = [];
        let totalDiff = 0;
        const l = this._embeddedViews.length;
        const rNodes = this._embeddedViews.map(view => view.rootNodes.find(node => node.nodeType === Node.ELEMENT_NODE) || view.rootNodes[0].nextElementSibling);
        for (let i = 0; i < l; i++) {
            const rNode = rNodes[i];
            if (rNode) {
                const height = window.getComputedStyle(rNode).getPropertyValue('height');
                const h = parseFloat(height) || parseInt(this.igxForItemSize, 10);
                const index = this.state.startIndex + i;
                if (!this.isRemote && !this.igxForOf[index]) {
                    continue;
                }
                const margin = this.getMargin(rNode, dimension);
                const oldVal = this.individualSizeCache[index];
                const newVal = (dimension === 'height' ? h : rNode.clientWidth) + margin;
                this.individualSizeCache[index] = newVal;
                const currDiff = newVal - oldVal;
                diffs.push(currDiff);
                totalDiff += currDiff;
                this.sizesCache[index + 1] = (this.sizesCache[index] || 0) + newVal;
            }
        }
        // update cache
        if (Math.abs(totalDiff) > 0) {
            for (let j = this.state.startIndex + this.state.chunkSize + 1; j < this.sizesCache.length; j++) {
                this.sizesCache[j] = (this.sizesCache[j] || 0) + totalDiff;
            }
            // update scrBar heights/widths
            const reducer = (acc, val) => acc + val;
            const hSum = this.individualSizeCache.reduce(reducer);
            if (hSum > this._maxSize) {
                this._virtRatio = hSum / this._maxSize;
            }
            this.scrollComponent.size = Math.min(this.scrollComponent.size + totalDiff, this._maxSize);
            this._virtSize = hSum;
            if (!this.scrollComponent.destroyed) {
                this.scrollComponent.cdr.detectChanges();
            }
            const scrToBottom = this._isScrolledToBottom && !this.dc.instance.notVirtual;
            if (scrToBottom && !this._isAtBottomIndex) {
                const containerSize = parseInt(this.igxForContainerSize, 10);
                const maxVirtScrollTop = this._virtSize - containerSize;
                this._bScrollInternal = true;
                this._virtScrollPosition = maxVirtScrollTop;
                this.scrollPosition = maxVirtScrollTop;
                return;
            }
            if (this._adjustToIndex) {
                // in case scrolled to specific index where after scroll heights are changed
                // need to adjust the offsets so that item is last in view.
                const updatesToIndex = this._adjustToIndex - this.state.startIndex + 1;
                const sumDiffs = diffs.slice(0, updatesToIndex).reduce(reducer);
                if (sumDiffs !== 0) {
                    this.addScroll(sumDiffs);
                }
                this._adjustToIndex = null;
            }
        }
    }
    /**
     * @hidden
     * Reset scroll position.
     * Needed in case scrollbar is hidden/detached but we still need to reset it.
     */
    resetScrollPosition() {
        this.scrollPosition = 0;
        this.scrollComponent.scrollAmount = 0;
    }
    /**
     * @hidden
     */
    removeScrollEventListeners() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this._zone.runOutsideAngular(() => this.scrollComponent?.nativeElement?.removeEventListener('scroll', this.func));
        }
        else {
            this._zone.runOutsideAngular(() => this.scrollComponent?.nativeElement?.removeEventListener('scroll', this.verticalScrollHandler));
        }
    }
    /**
     * @hidden
     * Function that is called when scrolling vertically
     */
    onScroll(event) {
        /* in certain situations this may be called when no scrollbar is visible */
        if (!parseInt(this.scrollComponent.nativeElement.style.height, 10)) {
            return;
        }
        if (!this._bScrollInternal) {
            this._calcVirtualScrollPosition(event.target.scrollTop);
        }
        else {
            this._bScrollInternal = false;
        }
        const prevStartIndex = this.state.startIndex;
        const scrollOffset = this.fixedUpdateAllElements(this._virtScrollPosition);
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        this._zone.onStable.pipe(first()).subscribe(this.recalcUpdateSizes.bind(this));
        this.dc.changeDetectorRef.detectChanges();
        if (prevStartIndex !== this.state.startIndex) {
            this.chunkLoad.emit(this.state);
        }
    }
    /**
     * @hidden
     * @internal
     */
    updateScroll() {
        if (this.igxForScrollOrientation === "horizontal") {
            const scrollAmount = this.scrollComponent.nativeElement["scrollLeft"];
            this.scrollComponent.scrollAmount = scrollAmount;
            this._updateScrollOffset();
        }
    }
    updateSizes() {
        if (!this.scrollComponent.nativeElement.isConnected)
            return;
        const scrollable = this.isScrollable();
        this.recalcUpdateSizes();
        this._applyChanges();
        this._updateScrollOffset();
        if (scrollable !== this.isScrollable()) {
            this.scrollbarVisibilityChanged.emit();
        }
        else {
            this.contentSizeChange.emit();
        }
    }
    /**
     * @hidden
     */
    fixedUpdateAllElements(inScrollTop) {
        const count = this.isRemote ? this.totalItemCount : this.igxForOf.length;
        let newStart = this.getIndexAt(inScrollTop, this.sizesCache);
        if (newStart + this.state.chunkSize > count) {
            newStart = count - this.state.chunkSize;
        }
        const prevStart = this.state.startIndex;
        const diff = newStart - this.state.startIndex;
        this.state.startIndex = newStart;
        if (diff) {
            this.chunkPreload.emit(this.state);
            if (!this.isRemote) {
                // recalculate and apply page size.
                if (diff && Math.abs(diff) <= MAX_PERF_SCROLL_DIFF) {
                    if (diff > 0) {
                        this.moveApplyScrollNext(prevStart);
                    }
                    else {
                        this.moveApplyScrollPrev(prevStart);
                    }
                }
                else {
                    this.fixedApplyScroll();
                }
            }
        }
        return inScrollTop - this.sizesCache[this.state.startIndex];
    }
    /**
     * @hidden
     * The function applies an optimized state change for scrolling down/right employing context change with view rearrangement
     */
    moveApplyScrollNext(prevIndex) {
        const start = prevIndex + this.state.chunkSize;
        const end = start + this.state.startIndex - prevIndex;
        const container = this.dc.instance._vcr;
        for (let i = start; i < end && this.igxForOf[i] !== undefined; i++) {
            const embView = this._embeddedViews.shift();
            if (!embView.destroyed) {
                this.scrollFocus(embView.rootNodes.find(node => node.nodeType === Node.ELEMENT_NODE)
                    || embView.rootNodes[0].nextElementSibling);
                const view = container.detach(0);
                this.updateTemplateContext(embView.context, i);
                container.insert(view);
                this._embeddedViews.push(embView);
            }
        }
    }
    /**
     * @hidden
     * The function applies an optimized state change for scrolling up/left employing context change with view rearrangement
     */
    moveApplyScrollPrev(prevIndex) {
        const container = this.dc.instance._vcr;
        for (let i = prevIndex - 1; i >= this.state.startIndex && this.igxForOf[i] !== undefined; i--) {
            const embView = this._embeddedViews.pop();
            if (!embView.destroyed) {
                this.scrollFocus(embView.rootNodes.find(node => node.nodeType === Node.ELEMENT_NODE)
                    || embView.rootNodes[0].nextElementSibling);
                const view = container.detach(container.length - 1);
                this.updateTemplateContext(embView.context, i);
                container.insert(view, 0);
                this._embeddedViews.unshift(embView);
            }
        }
    }
    /**
     * @hidden
     */
    getContextIndex(input) {
        return this.isRemote ? this.state.startIndex + this.igxForOf.indexOf(input) : this.igxForOf.indexOf(input);
    }
    /**
     * @hidden
     * Function which updates the passed context of an embedded view with the provided index
     * from the view container.
     * Often, called while handling a scroll event.
     */
    updateTemplateContext(context, index = 0) {
        context.$implicit = this.igxForOf[index];
        context.index = this.getContextIndex(this.igxForOf[index]);
        context.count = this.igxForOf.length;
    }
    /**
     * @hidden
     * The function applies an optimized state change through context change for each view
     */
    fixedApplyScroll() {
        let j = 0;
        const endIndex = this.state.startIndex + this.state.chunkSize;
        for (let i = this.state.startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
            const embView = this._embeddedViews[j++];
            this.updateTemplateContext(embView.context, i);
        }
    }
    /**
     * @hidden
     * @internal
     *
     * Clears focus inside the virtualized container on small scroll swaps.
     */
    scrollFocus(node) {
        if (!node) {
            return;
        }
        const document = node.getRootNode();
        const activeElement = document.activeElement;
        // Remove focus in case the the active element is inside the view container.
        // Otherwise we hit an exception while doing the 'small' scrolls swapping.
        // For more information:
        //
        // https://developer.mozilla.org/en-US/docs/Web/API/Node/removeChild
        // https://bugs.chromium.org/p/chromium/issues/detail?id=432392
        if (node && node.contains(activeElement)) {
            activeElement.blur();
        }
    }
    /**
     * @hidden
     * Function that is called when scrolling horizontally
     */
    onHScroll(event) {
        /* in certain situations this may be called when no scrollbar is visible */
        const firstScrollChild = this.scrollComponent.nativeElement.children.item(0);
        if (!parseInt(firstScrollChild.style.width, 10)) {
            return;
        }
        if (!this._bScrollInternal) {
            this._calcVirtualScrollPosition(event.target.scrollLeft);
        }
        else {
            this._bScrollInternal = false;
        }
        const prevStartIndex = this.state.startIndex;
        const scrLeft = event.target.scrollLeft;
        // Updating horizontal chunks
        const scrollOffset = this.fixedUpdateAllElements(Math.abs(this._virtScrollPosition));
        if (scrLeft < 0) {
            // RTL
            this.dc.instance._viewContainer.element.nativeElement.style.left = scrollOffset + 'px';
        }
        else {
            this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        }
        this._zone.onStable.pipe(first()).subscribe(this.recalcUpdateSizes.bind(this));
        this.dc.changeDetectorRef.detectChanges();
        if (prevStartIndex !== this.state.startIndex) {
            this.chunkLoad.emit(this.state);
        }
    }
    /**
     * Gets the function used to track changes in the items collection.
     * By default the object references are compared. However this can be optimized if you have unique identifier
     * value that can be used for the comparison instead of the object ref or if you have some other property values
     * in the item object that should be tracked for changes.
     * This option is similar to ngForTrackBy.
     * ```typescript
     * const trackFunc = this.parentVirtDir.igxForTrackBy;
     * ```
     */
    get igxForTrackBy() {
        return this._trackByFn;
    }
    /**
     * Sets the function used to track changes in the items collection.
     * This function can be set in scenarios where you want to optimize or
     * customize the tracking of changes for the items in the collection.
     * The igxForTrackBy function takes the index and the current item as arguments and needs to return the unique identifier for this item.
     * ```typescript
     * this.parentVirtDir.igxForTrackBy = (index, item) => {
     *      return item.id + item.width;
     * };
     * ```
     */
    set igxForTrackBy(fn) {
        this._trackByFn = fn;
    }
    /**
     * @hidden
     */
    _applyChanges() {
        const prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        if (this.igxForOf && this.igxForOf.length && this.dc) {
            const embeddedViewCopy = Object.assign([], this._embeddedViews);
            let startIndex = this.state.startIndex;
            let endIndex = this.state.chunkSize + this.state.startIndex;
            if (this.isRemote) {
                startIndex = 0;
                endIndex = this.igxForOf.length;
            }
            for (let i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
                const embView = embeddedViewCopy.shift();
                this.updateTemplateContext(embView.context, i);
            }
            if (prevChunkSize !== this.state.chunkSize) {
                this.chunkLoad.emit(this.state);
            }
        }
    }
    /**
     * @hidden
     */
    _calcMaxBrowserSize() {
        if (!this.platformUtil.isBrowser) {
            return 0;
        }
        const div = this.document.createElement('div');
        const style = div.style;
        style.position = 'absolute';
        const dir = this.igxForScrollOrientation === 'horizontal' ? 'left' : 'top';
        style[dir] = '9999999999999999px';
        this.document.body.appendChild(div);
        const size = Math.abs(div.getBoundingClientRect()[dir]);
        this.document.body.removeChild(div);
        return size;
    }
    /**
     * @hidden
     * Recalculates the chunkSize based on current startIndex and returns the new size.
     * This should be called after this.state.startIndex is updated, not before.
     */
    _calculateChunkSize() {
        let chunkSize = 0;
        if (this.igxForContainerSize !== null && this.igxForContainerSize !== undefined) {
            if (!this.sizesCache || this.sizesCache.length === 0) {
                this.initSizesCache(this.igxForOf);
            }
            chunkSize = this._calcMaxChunkSize();
            if (this.igxForOf && chunkSize > this.igxForOf.length) {
                chunkSize = this.igxForOf.length;
            }
        }
        else {
            if (this.igxForOf) {
                chunkSize = this.igxForOf.length;
            }
        }
        return chunkSize;
    }
    /**
     * @hidden
     */
    getElement(viewref, nodeName) {
        const elem = viewref.element.nativeElement.parentNode.getElementsByTagName(nodeName);
        return elem.length > 0 ? elem[0] : null;
    }
    /**
     * @hidden
     */
    initSizesCache(items) {
        let totalSize = 0;
        let size = 0;
        const dimension = this.igxForSizePropName || 'height';
        let i = 0;
        this.sizesCache = [];
        this.individualSizeCache = [];
        this.sizesCache.push(0);
        const count = this.isRemote ? this.totalItemCount : items.length;
        for (i; i < count; i++) {
            size = this._getItemSize(items[i], dimension);
            this.individualSizeCache.push(size);
            totalSize += size;
            this.sizesCache.push(totalSize);
        }
        return totalSize;
    }
    _updateSizeCache() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.initSizesCache(this.igxForOf);
            return;
        }
        const oldHeight = this.individualSizeCache.length > 0 ? this.individualSizeCache.reduce((acc, val) => acc + val) : 0;
        const newHeight = this.initSizesCache(this.igxForOf);
        const diff = oldHeight - newHeight;
        this._adjustScrollPositionAfterSizeChange(diff);
    }
    /**
     * @hidden
     */
    _calcMaxChunkSize() {
        let i = 0;
        let length = 0;
        let maxLength = 0;
        const arr = [];
        let sum = 0;
        const availableSize = parseInt(this.igxForContainerSize, 10);
        if (!availableSize) {
            return 0;
        }
        const dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        const reducer = (accumulator, currentItem) => accumulator + this._getItemSize(currentItem, dimension);
        for (i; i < this.igxForOf.length; i++) {
            let item = this.igxForOf[i];
            if (dimension === 'height') {
                item = { value: this.igxForOf[i], height: this.individualSizeCache[i] };
            }
            const size = dimension === 'height' ?
                this.individualSizeCache[i] :
                this._getItemSize(item, dimension);
            sum = arr.reduce(reducer, size);
            if (sum < availableSize) {
                arr.push(item);
                length = arr.length;
                if (i === this.igxForOf.length - 1) {
                    // reached end without exceeding
                    // include prev items until size is filled or first item is reached.
                    let curItem = dimension === 'height' ? arr[0].value : arr[0];
                    let prevIndex = this.igxForOf.indexOf(curItem) - 1;
                    while (prevIndex >= 0 && sum <= availableSize) {
                        curItem = dimension === 'height' ? arr[0].value : arr[0];
                        prevIndex = this.igxForOf.indexOf(curItem) - 1;
                        const prevItem = this.igxForOf[prevIndex];
                        const prevSize = dimension === 'height' ?
                            this.individualSizeCache[prevIndex] :
                            parseInt(prevItem[dimension], 10);
                        sum = arr.reduce(reducer, prevSize);
                        arr.unshift(prevItem);
                        length = arr.length;
                    }
                }
            }
            else {
                arr.push(item);
                length = arr.length + 1;
                arr.shift();
            }
            if (length > maxLength) {
                maxLength = length;
            }
        }
        return maxLength;
    }
    /**
     * @hidden
     */
    getIndexAt(left, set) {
        let start = 0;
        let end = set.length - 1;
        if (left === 0) {
            return 0;
        }
        while (start <= end) {
            const midIdx = Math.floor((start + end) / 2);
            const midLeft = set[midIdx];
            const cmp = left - midLeft;
            if (cmp > 0) {
                start = midIdx + 1;
            }
            else if (cmp < 0) {
                end = midIdx - 1;
            }
            else {
                return midIdx;
            }
        }
        return end;
    }
    _recalcScrollBarSize(containerSizeInfo = null) {
        const count = this.isRemote ? this.totalItemCount : (this.igxForOf ? this.igxForOf.length : 0);
        this.dc.instance.notVirtual = !(this.igxForContainerSize && this.dc && this.state.chunkSize < count);
        const scrollable = containerSizeInfo ? this.scrollComponent.size > containerSizeInfo.prevSize : this.isScrollable();
        if (this.igxForScrollOrientation === 'horizontal') {
            const totalWidth = parseInt(this.igxForContainerSize, 10) > 0 ? this._calcSize() : 0;
            if (totalWidth <= parseInt(this.igxForContainerSize, 10)) {
                this.resetScrollPosition();
            }
            this.scrollComponent.nativeElement.style.width = this.igxForContainerSize + 'px';
            this.scrollComponent.size = totalWidth;
        }
        if (this.igxForScrollOrientation === 'vertical') {
            const totalHeight = this._calcSize();
            if (totalHeight <= parseInt(this.igxForContainerSize, 10)) {
                this.resetScrollPosition();
            }
            this.scrollComponent.nativeElement.style.height = parseInt(this.igxForContainerSize, 10) + 'px';
            this.scrollComponent.size = totalHeight;
        }
        if (scrollable !== this.isScrollable()) {
            // scrollbar visibility has changed
            this.scrollbarVisibilityChanged.emit();
        }
    }
    _calcSize() {
        let size;
        if (this.individualSizeCache && this.individualSizeCache.length > 0) {
            size = this.individualSizeCache.reduce((acc, val) => acc + val, 0);
        }
        else {
            size = this.initSizesCache(this.igxForOf);
        }
        this._virtSize = size;
        if (size > this._maxSize) {
            this._virtRatio = size / this._maxSize;
            size = this._maxSize;
        }
        return size;
    }
    _recalcOnContainerChange(containerSizeInfo = null) {
        const prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize(containerSizeInfo);
        if (prevChunkSize !== this.state.chunkSize) {
            this.chunkLoad.emit(this.state);
        }
    }
    /**
     * @hidden
     * Removes an element from the embedded views and updates chunkSize.
     */
    removeLastElem() {
        const oldElem = this._embeddedViews.pop();
        this.beforeViewDestroyed.emit(oldElem);
        // also detach from ViewContainerRef to make absolutely sure this is removed from the view container.
        this.dc.instance._vcr.detach(this.dc.instance._vcr.length - 1);
        oldElem.destroy();
        this.state.chunkSize--;
    }
    /**
     * @hidden
     * If there exists an element that we can create embedded view for creates it, appends it and updates chunkSize
     */
    addLastElem() {
        let elemIndex = this.state.startIndex + this.state.chunkSize;
        if (!this.isRemote && !this.igxForOf) {
            return;
        }
        if (elemIndex >= this.igxForOf.length) {
            elemIndex = this.igxForOf.length - this.state.chunkSize;
        }
        const input = this.igxForOf[elemIndex];
        const embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.igxForOf, this.getContextIndex(input), this.igxForOf.length));
        this._embeddedViews.push(embeddedView);
        this.state.chunkSize++;
        this._zone.run(() => this.cdr.markForCheck());
    }
    /**
     * Recalculates chunkSize and adds/removes elements if need due to the change.
     * this.state.chunkSize is updated in @addLastElem() or @removeLastElem()
     */
    applyChunkSizeChange() {
        const chunkSize = this.isRemote ? (this.igxForOf ? this.igxForOf.length : 0) : this._calculateChunkSize();
        if (chunkSize > this.state.chunkSize) {
            const diff = chunkSize - this.state.chunkSize;
            for (let i = 0; i < diff; i++) {
                this.addLastElem();
            }
        }
        else if (chunkSize < this.state.chunkSize) {
            const diff = this.state.chunkSize - chunkSize;
            for (let i = 0; i < diff; i++) {
                this.removeLastElem();
            }
        }
    }
    _calcVirtualScrollPosition(scrollPosition) {
        const containerSize = parseInt(this.igxForContainerSize, 10);
        const maxRealScrollPosition = this.scrollComponent.size - containerSize;
        const realPercentScrolled = maxRealScrollPosition !== 0 ? scrollPosition / maxRealScrollPosition : 0;
        const maxVirtScroll = this._virtSize - containerSize;
        this._virtScrollPosition = realPercentScrolled * maxVirtScroll;
    }
    _getItemSize(item, dimension) {
        const dim = item ? item[dimension] : null;
        return typeof dim === 'number' ? dim : parseInt(this.igxForItemSize, 10) || 0;
    }
    _updateScrollOffset() {
        let scrollOffset = 0;
        let currentScroll = this.scrollPosition;
        if (this._virtRatio !== 1) {
            this._calcVirtualScrollPosition(this.scrollPosition);
            currentScroll = this._virtScrollPosition;
        }
        const scroll = this.scrollComponent.nativeElement;
        scrollOffset = scroll && this.scrollComponent.size ?
            currentScroll - this.sizesCache[this.state.startIndex] : 0;
        const dir = this.igxForScrollOrientation === 'horizontal' ? 'left' : 'top';
        this.dc.instance._viewContainer.element.nativeElement.style[dir] = -(scrollOffset) + 'px';
    }
    _adjustScrollPositionAfterSizeChange(sizeDiff) {
        // if data has been changed while container is scrolled
        // should update scroll top/left according to change so that same startIndex is in view
        if (Math.abs(sizeDiff) > 0 && this.scrollPosition > 0) {
            this.recalcUpdateSizes();
            const offset = this.igxForScrollOrientation === 'horizontal' ?
                parseInt(this.dc.instance._viewContainer.element.nativeElement.style.left, 10) :
                parseInt(this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
            const newSize = this.sizesCache[this.state.startIndex] - offset;
            this.scrollPosition = newSize;
            if (this.scrollPosition !== newSize) {
                this.scrollComponent.scrollAmount = newSize;
            }
        }
    }
    getMargin(node, dimension) {
        const styles = window.getComputedStyle(node);
        if (dimension === 'height') {
            return parseFloat(styles['marginTop']) +
                parseFloat(styles['marginBottom']) || 0;
        }
        return parseFloat(styles['marginLeft']) +
            parseFloat(styles['marginRight']) || 0;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxForOfDirective, deps: [{ token: i0.ViewContainerRef }, { token: i0.TemplateRef }, { token: i0.IterableDiffers }, { token: i0.ChangeDetectorRef }, { token: i0.NgZone }, { token: i1.IgxForOfScrollSyncService }, { token: i2.PlatformUtil }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.4", type: IgxForOfDirective, isStandalone: true, selector: "[igxFor][igxForOf]", inputs: { igxForOf: "igxForOf", igxForSizePropName: "igxForSizePropName", igxForScrollOrientation: "igxForScrollOrientation", igxForScrollContainer: "igxForScrollContainer", igxForContainerSize: "igxForContainerSize", igxForItemSize: "igxForItemSize", igxForTotalItemCount: "igxForTotalItemCount", igxForTrackBy: "igxForTrackBy" }, outputs: { chunkLoad: "chunkLoad", scrollbarVisibilityChanged: "scrollbarVisibilityChanged", contentSizeChange: "contentSizeChange", dataChanged: "dataChanged", beforeViewDestroyed: "beforeViewDestroyed", chunkPreload: "chunkPreload" }, providers: [
            IgxForOfScrollSyncService,
            { provide: IgxForOfToken, useExisting: IgxForOfDirective }
        ], usesInheritance: true, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxForOfDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igxFor][igxForOf]',
                    providers: [
                        IgxForOfScrollSyncService,
                        { provide: IgxForOfToken, useExisting: IgxForOfDirective }
                    ],
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ViewContainerRef }, { type: i0.TemplateRef }, { type: i0.IterableDiffers }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i1.IgxForOfScrollSyncService }, { type: i2.PlatformUtil }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }], propDecorators: { igxForOf: [{
                type: Input
            }], igxForSizePropName: [{
                type: Input
            }], igxForScrollOrientation: [{
                type: Input
            }], igxForScrollContainer: [{
                type: Input
            }], igxForContainerSize: [{
                type: Input
            }], igxForItemSize: [{
                type: Input
            }], chunkLoad: [{
                type: Output
            }], scrollbarVisibilityChanged: [{
                type: Output
            }], contentSizeChange: [{
                type: Output
            }], dataChanged: [{
                type: Output
            }], beforeViewDestroyed: [{
                type: Output
            }], chunkPreload: [{
                type: Output
            }], igxForTotalItemCount: [{
                type: Input
            }], igxForTrackBy: [{
                type: Input
            }] } });
export const getTypeNameForDebugging = (type) => type.name || typeof type;
export class IgxGridForOfContext extends IgxForOfContext {
    constructor($implicit, igxGridForOf, index, count) {
        super($implicit, igxGridForOf, index, count);
        this.igxGridForOf = igxGridForOf;
    }
}
export class IgxGridForOfDirective extends IgxForOfDirective {
    set igxGridForOf(value) {
        this.igxForOf = value;
    }
    get igxGridForOf() {
        return this.igxForOf;
    }
    /**
     * @hidden
     * @internal
     */
    get sizesCache() {
        if (this.igxForScrollOrientation === 'horizontal') {
            if (this.igxGridForOfUniqueSizeCache || this.syncService.isMaster(this)) {
                return this._sizesCache;
            }
            return this.syncService.sizesCache(this.igxForScrollOrientation);
        }
        else {
            return this._sizesCache;
        }
    }
    /**
     * @hidden
     * @internal
     */
    set sizesCache(value) {
        this._sizesCache = value;
    }
    get itemsDimension() {
        return this.igxForSizePropName || 'height';
    }
    recalcUpdateSizes() {
        if (this.igxGridForOfVariableSizes && this.igxForScrollOrientation === 'vertical') {
            super.recalcUpdateSizes();
        }
    }
    constructor(_viewContainer, _template, _differs, cdr, _zone, _platformUtil, _document, syncScrollService, syncService) {
        super(_viewContainer, _template, _differs, cdr, _zone, syncScrollService, _platformUtil, _document);
        this.syncService = syncService;
        this.igxGridForOfUniqueSizeCache = false;
        this.igxGridForOfVariableSizes = true;
        /**
         * @hidden @internal
         * An event that is emitted after data has been changed but before the view is refreshed
         */
        this.dataChanging = new EventEmitter();
    }
    /**
     * @hidden @internal
     * Asserts the correct type of the context for the template that `IgxGridForOfDirective` will render.
     *
     * The presence of this method is a signal to the Ivy template type-check compiler that the
     * `IgxGridForOfDirective` structural directive renders its template with a specific context type.
     */
    static ngTemplateContextGuard(dir, ctx) {
        return true;
    }
    ngOnInit() {
        this.syncService.setMaster(this);
        super.ngOnInit();
        this.removeScrollEventListeners();
    }
    ngOnChanges(changes) {
        const forOf = 'igxGridForOf';
        this.syncService.setMaster(this);
        if (forOf in changes) {
            const value = changes[forOf].currentValue;
            if (!this._differ && value) {
                try {
                    this._differ = this._differs.find(value).create(this.igxForTrackBy);
                }
                catch (e) {
                    throw new Error(`Cannot find a differ supporting object "${value}" of type "${getTypeNameForDebugging(value)}".
                     NgFor only supports binding to Iterables such as Arrays.`);
                }
            }
            if (this.igxForScrollOrientation === 'horizontal') {
                // in case collection has changes, reset sync service
                this.syncService.setMaster(this, this.igxGridForOfUniqueSizeCache);
            }
        }
        const defaultItemSize = 'igxForItemSize';
        if (defaultItemSize in changes && !changes[defaultItemSize].firstChange &&
            this.igxForScrollOrientation === 'vertical' && this.igxForOf) {
            // handle default item size changed.
            this.initSizesCache(this.igxForOf);
        }
        const containerSize = 'igxForContainerSize';
        if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {
            const prevSize = parseInt(changes[containerSize].previousValue, 10);
            const newSize = parseInt(changes[containerSize].currentValue, 10);
            this._recalcOnContainerChange({ prevSize, newSize });
        }
    }
    /**
     * @hidden
     * @internal
     */
    assumeMaster() {
        this._sizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);
        this.syncService.setMaster(this, true);
    }
    ngDoCheck() {
        if (this._differ) {
            const changes = this._differ.diff(this.igxForOf);
            if (changes) {
                const args = {
                    containerSize: this.igxForContainerSize,
                    state: this.state
                };
                this.dataChanging.emit(args);
                //  re-init cache.
                if (!this.igxForOf) {
                    this.igxForOf = [];
                }
                /* we need to reset the master dir if all rows are removed
                (e.g. because of filtering); if all columns are hidden, rows are
                still rendered empty, so we should not reset master */
                if (!this.igxForOf.length &&
                    this.igxForScrollOrientation === 'vertical') {
                    this.syncService.resetMaster();
                }
                this.syncService.setMaster(this);
                this.igxForContainerSize = args.containerSize;
                const sizeDiff = this._updateSizeCache(changes);
                this._applyChanges();
                if (sizeDiff) {
                    this._adjustScrollPositionAfterSizeChange(sizeDiff);
                }
                this._updateScrollOffset();
                this.dataChanged.emit(args);
            }
        }
    }
    onScroll(event) {
        if (!parseInt(this.scrollComponent.nativeElement.style.height, 10)) {
            return;
        }
        if (!this._bScrollInternal) {
            this._calcVirtualScrollPosition(event.target.scrollTop);
        }
        else {
            this._bScrollInternal = false;
        }
        const scrollOffset = this.fixedUpdateAllElements(this._virtScrollPosition);
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        this._zone.onStable.pipe(first()).subscribe(this.recalcUpdateSizes.bind(this));
        this.cdr.markForCheck();
    }
    onHScroll(scrollAmount) {
        /* in certain situations this may be called when no scrollbar is visible */
        const firstScrollChild = this.scrollComponent.nativeElement.children.item(0);
        if (!this.scrollComponent || !parseInt(firstScrollChild.style.width, 10)) {
            return;
        }
        // Updating horizontal chunks
        const scrollOffset = this.fixedUpdateAllElements(Math.abs(scrollAmount));
        if (scrollAmount < 0) {
            // RTL
            this.dc.instance._viewContainer.element.nativeElement.style.left = scrollOffset + 'px';
        }
        else {
            // LTR
            this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        }
    }
    getItemSize(item) {
        let size = 0;
        const dimension = this.igxForSizePropName || 'height';
        if (this.igxForScrollOrientation === 'vertical') {
            size = this._getItemSize(item, dimension);
            if (item && item.summaries) {
                size = item.max;
            }
            else if (item && item.groups && item.height) {
                size = item.height;
            }
        }
        else {
            size = parseInt(item[dimension], 10) || 0;
        }
        return size;
    }
    initSizesCache(items) {
        if (!this.syncService.isMaster(this) && this.igxForScrollOrientation === 'horizontal') {
            const masterSizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);
            return masterSizesCache[masterSizesCache.length - 1];
        }
        let totalSize = 0;
        let size = 0;
        let i = 0;
        this.sizesCache = [];
        this.individualSizeCache = [];
        this.sizesCache.push(0);
        const count = this.isRemote ? this.totalItemCount : items.length;
        for (i; i < count; i++) {
            size = this.getItemSize(items[i]);
            this.individualSizeCache.push(size);
            totalSize += size;
            this.sizesCache.push(totalSize);
        }
        return totalSize;
    }
    _updateSizeCache(changes = null) {
        const oldSize = this.individualSizeCache.length > 0 ? this.individualSizeCache.reduce((acc, val) => acc + val) : 0;
        let newSize = oldSize;
        if (changes && !this.isRemote) {
            newSize = this.handleCacheChanges(changes);
        }
        else {
            return;
        }
        const diff = oldSize - newSize;
        return diff;
    }
    handleCacheChanges(changes) {
        const identityChanges = [];
        const newHeightCache = [];
        const newSizesCache = [];
        newSizesCache.push(0);
        let newHeight = 0;
        // When there are more than one removed items the changes are not reliable so those with identity change should be default size.
        let numRemovedItems = 0;
        changes.forEachRemovedItem(() => numRemovedItems++);
        // Get the identity changes to determine later if those that have changed their indexes should be assigned default item size.
        changes.forEachIdentityChange((item) => {
            if (item.currentIndex !== item.previousIndex) {
                // Filter out ones that have not changed their index.
                identityChanges[item.currentIndex] = item;
            }
        });
        // Processing each item that is passed to the igxForOf so far seem to be most reliable. We parse the updated list of items.
        changes.forEachItem((item) => {
            if (item.previousIndex !== null &&
                (numRemovedItems < 2 || !identityChanges.length || identityChanges[item.currentIndex])
                && this.igxForScrollOrientation !== "horizontal") {
                // Reuse cache on those who have previousIndex.
                // When there are more than one removed items currently the changes are not readable so ones with identity change
                // should be racalculated.
                newHeightCache[item.currentIndex] = this.individualSizeCache[item.previousIndex];
            }
            else {
                // Assign default item size.
                newHeightCache[item.currentIndex] = this.getItemSize(item.item);
            }
            newSizesCache[item.currentIndex + 1] = newSizesCache[item.currentIndex] + newHeightCache[item.currentIndex];
            newHeight += newHeightCache[item.currentIndex];
        });
        this.individualSizeCache = newHeightCache;
        this.sizesCache = newSizesCache;
        return newHeight;
    }
    addLastElem() {
        let elemIndex = this.state.startIndex + this.state.chunkSize;
        if (!this.isRemote && !this.igxForOf) {
            return;
        }
        if (elemIndex >= this.igxForOf.length) {
            elemIndex = this.igxForOf.length - this.state.chunkSize;
        }
        const input = this.igxForOf[elemIndex];
        const embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxGridForOfContext(input, this.igxForOf, this.getContextIndex(input), this.igxForOf.length));
        this._embeddedViews.push(embeddedView);
        this.state.chunkSize++;
    }
    _updateViews(prevChunkSize) {
        if (this.igxForOf && this.igxForOf.length && this.dc) {
            const embeddedViewCopy = Object.assign([], this._embeddedViews);
            let startIndex;
            let endIndex;
            if (this.isRemote) {
                startIndex = 0;
                endIndex = this.igxForOf.length;
            }
            else {
                startIndex = this.getIndexAt(this.scrollPosition, this.sizesCache);
                if (startIndex + this.state.chunkSize > this.igxForOf.length) {
                    startIndex = this.igxForOf.length - this.state.chunkSize;
                }
                this.state.startIndex = startIndex;
                endIndex = this.state.chunkSize + this.state.startIndex;
            }
            for (let i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
                const embView = embeddedViewCopy.shift();
                this.updateTemplateContext(embView.context, i);
            }
            if (prevChunkSize !== this.state.chunkSize) {
                this.chunkLoad.emit(this.state);
            }
        }
    }
    _applyChanges() {
        const prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        this._updateViews(prevChunkSize);
    }
    /**
     * @hidden
     */
    _calcMaxChunkSize() {
        if (this.igxForScrollOrientation === 'horizontal') {
            if (this.syncService.isMaster(this)) {
                return super._calcMaxChunkSize();
            }
            return this.syncService.chunkSize(this.igxForScrollOrientation);
        }
        else {
            return super._calcMaxChunkSize();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxGridForOfDirective, deps: [{ token: i0.ViewContainerRef }, { token: i0.TemplateRef }, { token: i0.IterableDiffers }, { token: i0.ChangeDetectorRef }, { token: i0.NgZone }, { token: i2.PlatformUtil }, { token: DOCUMENT }, { token: i1.IgxForOfScrollSyncService }, { token: i1.IgxForOfSyncService }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "18.2.4", type: IgxGridForOfDirective, isStandalone: true, selector: "[igxGridFor][igxGridForOf]", inputs: { igxGridForOf: "igxGridForOf", igxGridForOfUniqueSizeCache: ["igxGridForOfUniqueSizeCache", "igxGridForOfUniqueSizeCache", booleanAttribute], igxGridForOfVariableSizes: ["igxGridForOfVariableSizes", "igxGridForOfVariableSizes", booleanAttribute] }, outputs: { dataChanging: "dataChanging" }, usesInheritance: true, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxGridForOfDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igxGridFor][igxGridForOf]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ViewContainerRef }, { type: i0.TemplateRef }, { type: i0.IterableDiffers }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i2.PlatformUtil }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i1.IgxForOfScrollSyncService }, { type: i1.IgxForOfSyncService }], propDecorators: { igxGridForOf: [{
                type: Input
            }], igxGridForOfUniqueSizeCache: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], igxGridForOfVariableSizes: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], dataChanging: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9yX29mLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9kaXJlY3RpdmVzL2Zvci1vZi9mb3Jfb2YuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDZEQUE2RDtBQUM3RCxPQUFPLEVBQUUsUUFBUSxFQUFrQixNQUFNLGlCQUFpQixDQUFDO0FBQzNELE9BQU8sRUFHSCxTQUFTLEVBR1QsWUFBWSxFQUNaLEtBQUssRUFRTCxNQUFNLEVBTU4sTUFBTSxFQUNOLGdCQUFnQixFQUNuQixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUNoRSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSx1Q0FBdUMsQ0FBQztBQUNoRixPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUVwRSxPQUFPLEVBQXVCLHlCQUF5QixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDdkYsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sa0JBQWtCLENBQUM7Ozs7QUFJckQsTUFBTSxvQkFBb0IsR0FBRyxDQUFDLENBQUM7QUFFL0I7O0dBRUc7QUFDSCxNQUFNLE9BQU8sZUFBZTtJQUN4QixZQUNXLFNBQVksRUFDWixRQUFXLEVBQ1gsS0FBYSxFQUNiLEtBQWE7UUFIYixjQUFTLEdBQVQsU0FBUyxDQUFHO1FBQ1osYUFBUSxHQUFSLFFBQVEsQ0FBRztRQUNYLFVBQUssR0FBTCxLQUFLLENBQVE7UUFDYixVQUFLLEdBQUwsS0FBSyxDQUFRO0lBQ3BCLENBQUM7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QUUsSUFBSTtpQkFDbkI7OzBCQStEUSxNQUFNOzJCQUFDLFFBQVE7bUhBNURULFlBQVk7c0JBRHRCLEtBQUs7Z0JBVUMsMkJBQTJCO3NCQURqQyxLQUFLO3VCQUFDLEVBQUUsU0FBUyxFQUFFLGdCQUFnQixFQUFFO2dCQUkvQix5QkFBeUI7c0JBRC9CLEtBQUs7dUJBQUMsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUU7Z0JBd0MvQixZQUFZO3NCQURsQixNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQGFuZ3VsYXItZXNsaW50L25vLWNvbmZsaWN0aW5nLWxpZmVjeWNsZSAqL1xuaW1wb3J0IHsgRE9DVU1FTlQsIE5nRm9yT2ZDb250ZXh0IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ29tcG9uZW50UmVmLFxuICAgIERpcmVjdGl2ZSxcbiAgICBEb0NoZWNrLFxuICAgIEVtYmVkZGVkVmlld1JlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSW5wdXQsXG4gICAgSXRlcmFibGVDaGFuZ2VzLFxuICAgIEl0ZXJhYmxlRGlmZmVyLFxuICAgIEl0ZXJhYmxlRGlmZmVycyxcbiAgICBOZ1pvbmUsXG4gICAgT25DaGFuZ2VzLFxuICAgIE9uRGVzdHJveSxcbiAgICBPbkluaXQsXG4gICAgT3V0cHV0LFxuICAgIFNpbXBsZUNoYW5nZXMsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgVHJhY2tCeUZ1bmN0aW9uLFxuICAgIFZpZXdDb250YWluZXJSZWYsXG4gICAgQWZ0ZXJWaWV3SW5pdCxcbiAgICBJbmplY3QsXG4gICAgYm9vbGVhbkF0dHJpYnV0ZVxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRGlzcGxheUNvbnRhaW5lckNvbXBvbmVudCB9IGZyb20gJy4vZGlzcGxheS5jb250YWluZXInO1xuaW1wb3J0IHsgSFZpcnR1YWxIZWxwZXJDb21wb25lbnQgfSBmcm9tICcuL2hvcml6b250YWwudmlydHVhbC5oZWxwZXIuY29tcG9uZW50JztcbmltcG9ydCB7IFZpcnR1YWxIZWxwZXJDb21wb25lbnQgfSBmcm9tICcuL3ZpcnR1YWwuaGVscGVyLmNvbXBvbmVudCc7XG5cbmltcG9ydCB7IElneEZvck9mU3luY1NlcnZpY2UsIElneEZvck9mU2Nyb2xsU3luY1NlcnZpY2UgfSBmcm9tICcuL2Zvcl9vZi5zeW5jLnNlcnZpY2UnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsLCBmaWx0ZXIsIHRocm90dGxlVGltZSwgZmlyc3QgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBnZXRSZXNpemVPYnNlcnZlciB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgSUJhc2VFdmVudEFyZ3MsIFBsYXRmb3JtVXRpbCB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgVmlydHVhbEhlbHBlckJhc2VEaXJlY3RpdmUgfSBmcm9tICcuL2Jhc2UuaGVscGVyLmNvbXBvbmVudCc7XG5cbmNvbnN0IE1BWF9QRVJGX1NDUk9MTF9ESUZGID0gNDtcblxuLyoqXG4gKiAgQHB1YmxpY0FwaVxuICovXG5leHBvcnQgY2xhc3MgSWd4Rm9yT2ZDb250ZXh0PFQsIFUgZXh0ZW5kcyBUW10gPSBUW10+IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHVibGljICRpbXBsaWNpdDogVCxcbiAgICAgICAgcHVibGljIGlneEZvck9mOiBVLFxuICAgICAgICBwdWJsaWMgaW5kZXg6IG51bWJlcixcbiAgICAgICAgcHVibGljIGNvdW50OiBudW1iZXJcbiAgICApIHsgfVxuXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0aGUgZmlyc3Qgb3Igbm90XG4gICAgICovXG4gICAgcHVibGljIGdldCBmaXJzdCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXggPT09IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyB0aGUgbGFzdCBvciBub3RcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGxhc3QoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4ID09PSB0aGlzLmNvdW50IC0gMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGV2ZW4gb3Igbm90XG4gICAgICovXG4gICAgcHVibGljIGdldCBldmVuKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleCAlIDIgPT09IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyBvZGQgb3Igbm90XG4gICAgICovXG4gICAgcHVibGljIGdldCBvZGQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhdGhpcy5ldmVuO1xuICAgIH1cblxufVxuXG4vKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBJZ3hGb3JPZlRva2VuPFQsIFUgZXh0ZW5kcyBUW10gPSBUW10+IHtcbiAgICBwdWJsaWMgYWJzdHJhY3QgaWd4Rm9yT2Y6IFUgJiBUW10gfCBudWxsO1xuICAgIHB1YmxpYyBhYnN0cmFjdCBzdGF0ZTogSUZvck9mU3RhdGU7XG4gICAgcHVibGljIGFic3RyYWN0IHRvdGFsSXRlbUNvdW50OiBudW1iZXI7XG4gICAgcHVibGljIGFic3RyYWN0IHNjcm9sbFBvc2l0aW9uOiBudW1iZXI7XG5cbiAgICBwdWJsaWMgYWJzdHJhY3QgY2h1bmtMb2FkOiBFdmVudEVtaXR0ZXI8SUZvck9mU3RhdGU+O1xuICAgIHB1YmxpYyBhYnN0cmFjdCBjaHVua1ByZWxvYWQ6IEV2ZW50RW1pdHRlcjxJRm9yT2ZTdGF0ZT47XG5cbiAgICBwdWJsaWMgYWJzdHJhY3Qgc2Nyb2xsVG8oaW5kZXg6IG51bWJlcik6IHZvaWQ7XG4gICAgcHVibGljIGFic3RyYWN0IGdldFNjcm9sbEZvckluZGV4KGluZGV4OiBudW1iZXIsIGJvdHRvbT86IGJvb2xlYW4pOiBudW1iZXI7XG4gICAgcHVibGljIGFic3RyYWN0IGdldFNjcm9sbCgpOiBIVE1MRWxlbWVudCB8IHVuZGVmaW5lZDtcblxuICAgIC8vIFRPRE86IFJlLWV2YWx1YXRlIHVzZSBmb3IgdGhpcyBpbnRlcm5hbGx5LCBiZXR0ZXIgZXhwb3NlIHRocm91Z2ggc2VwYXJhdGUgQVBJXG4gICAgcHVibGljIGFic3RyYWN0IGlneEZvckl0ZW1TaXplOiBhbnk7XG4gICAgcHVibGljIGFic3RyYWN0IGlneEZvckNvbnRhaW5lclNpemU6IGFueTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBkYzogQ29tcG9uZW50UmVmPGFueT5cbn1cblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbaWd4Rm9yXVtpZ3hGb3JPZl0nLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBJZ3hGb3JPZlNjcm9sbFN5bmNTZXJ2aWNlLFxuICAgICAgICB7IHByb3ZpZGU6IElneEZvck9mVG9rZW4sIHVzZUV4aXN0aW5nOiBJZ3hGb3JPZkRpcmVjdGl2ZSB9XG4gICAgXSxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneEZvck9mRGlyZWN0aXZlPFQsIFUgZXh0ZW5kcyBUW10gPSBUW10+IGV4dGVuZHMgSWd4Rm9yT2ZUb2tlbjxULFU+IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIERvQ2hlY2ssIE9uRGVzdHJveSwgQWZ0ZXJWaWV3SW5pdCB7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkYXRhIHRvIGJlIHJlbmRlcmVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgaWd4Rm9yIGxldC1pdGVtIFtpZ3hGb3JPZl09XCJkYXRhXCIgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIidob3Jpem9udGFsJ1wiPjwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaWd4Rm9yT2Y6IFUgJiBUW10gfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgbmFtZSBmcm9tIHdoaWNoIHRvIHJlYWQgdGhlIHNpemUgaW4gdGhlIGRhdGEgb2JqZWN0LlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlneEZvclNpemVQcm9wTmFtZTtcblxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgc2Nyb2xsIG9yaWVudGF0aW9uLlxuICAgICAqIFNjcm9sbCBvcmllbnRhdGlvbiBjYW4gYmUgXCJ2ZXJ0aWNhbFwiIG9yIFwiaG9yaXpvbnRhbFwiLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgaWd4Rm9yIGxldC1pdGVtIFtpZ3hGb3JPZl09XCJkYXRhXCIgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIidob3Jpem9udGFsJ1wiPjwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPSAndmVydGljYWwnO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9uYWxseSBwYXNzIHRoZSBwYXJlbnQgYGlneEZvcmAgaW5zdGFuY2UgdG8gY3JlYXRlIGEgdmlydHVhbCB0ZW1wbGF0ZSBzY3JvbGxpbmcgYm90aCBob3Jpem9udGFsbHkgYW5kIHZlcnRpY2FsbHkuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuZy10ZW1wbGF0ZSAjc2Nyb2xsQ29udGFpbmVyIGlneEZvciBsZXQtcm93RGF0YSBbaWd4Rm9yT2ZdPVwiZGF0YVwiXG4gICAgICogICAgICAgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIid2ZXJ0aWNhbCdcIlxuICAgICAqICAgICAgIFtpZ3hGb3JDb250YWluZXJTaXplXT1cIic1MDBweCdcIlxuICAgICAqICAgICAgIFtpZ3hGb3JJdGVtU2l6ZV09XCInNTBweCdcIlxuICAgICAqICAgICAgIGxldC1yb3dJbmRleD1cImluZGV4XCI+XG4gICAgICogICAgICAgPGRpdiBbc3R5bGUuZGlzcGxheV09XCInZmxleCdcIiBbc3R5bGUuaGVpZ2h0XT1cIic1MHB4J1wiPlxuICAgICAqICAgICAgICAgICA8bmctdGVtcGxhdGUgI2NoaWxkQ29udGFpbmVyIGlneEZvciBsZXQtaXRlbSBbaWd4Rm9yT2ZdPVwiZGF0YVwiXG4gICAgICogICAgICAgICAgICAgICBbaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb25dPVwiJ2hvcml6b250YWwnXCJcbiAgICAgKiAgICAgICAgICAgICAgIFtpZ3hGb3JTY3JvbGxDb250YWluZXJdPVwicGFyZW50VmlydERpclwiXG4gICAgICogICAgICAgICAgICAgICBbaWd4Rm9yQ29udGFpbmVyU2l6ZV09XCInNTAwcHgnXCI+XG4gICAgICogICAgICAgICAgICAgICAgICAgPGRpdiBbc3R5bGUubWluLXdpZHRoXT1cIic1MHB4J1wiPnt7cm93SW5kZXh9fSA6IHt7aXRlbS50ZXh0fX08L2Rpdj5cbiAgICAgKiAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiAgICAgICA8L2Rpdj5cbiAgICAgKiA8L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlneEZvclNjcm9sbENvbnRhaW5lcjogYW55O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcHgtYWZmaXhlZCBzaXplIG9mIHRoZSBjb250YWluZXIgYWxvbmcgdGhlIGF4aXMgb2Ygc2Nyb2xsaW5nLlxuICAgICAqIEZvciBcImhvcml6b250YWxcIiBvcmllbnRhdGlvbiB0aGlzIHZhbHVlIGlzIHRoZSB3aWR0aCBvZiB0aGUgY29udGFpbmVyIGFuZCBmb3IgXCJ2ZXJ0aWNhbFwiIGlzIHRoZSBoZWlnaHQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuZy10ZW1wbGF0ZSBpZ3hGb3IgbGV0LWl0ZW0gW2lneEZvck9mXT1cImRhdGFcIiBbaWd4Rm9yQ29udGFpbmVyU2l6ZV09XCInNTAwcHgnXCJcbiAgICAgKiAgICAgIFtpZ3hGb3JTY3JvbGxPcmllbnRhdGlvbl09XCInaG9yaXpvbnRhbCdcIj5cbiAgICAgKiA8L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlneEZvckNvbnRhaW5lclNpemU6IGFueTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHB4LWFmZml4ZWQgc2l6ZSBvZiB0aGUgaXRlbSBhbG9uZyB0aGUgYXhpcyBvZiBzY3JvbGxpbmcuXG4gICAgICogRm9yIFwiaG9yaXpvbnRhbFwiIG9yaWVudGF0aW9uIHRoaXMgdmFsdWUgaXMgdGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4gYW5kIGZvciBcInZlcnRpY2FsXCIgaXMgdGhlIGhlaWdodCBvciB0aGUgcm93LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgaWd4Rm9yIGxldC1pdGVtIFtpZ3hGb3JPZl09XCJkYXRhXCIgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIidob3Jpem9udGFsJ1wiIFtpZ3hGb3JJdGVtU2l6ZV09XCInNTBweCdcIj48L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlneEZvckl0ZW1TaXplOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXIgYSBuZXcgY2h1bmsgaGFzIGJlZW4gbG9hZGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgaWd4Rm9yIFtpZ3hGb3JPZl09XCJkYXRhXCIgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIidob3Jpem9udGFsJ1wiIChjaHVua0xvYWQpPVwibG9hZENodW5rKCRldmVudClcIj48L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsb2FkQ2h1bmsoZSl7XG4gICAgICogYWxlcnQoXCJjaHVuayBsb2FkZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgY2h1bmtMb2FkID0gbmV3IEV2ZW50RW1pdHRlcjxJRm9yT2ZTdGF0ZT4oKTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gc2Nyb2xsYmFyIHZpc2liaWxpdHkgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHNjcm9sbGJhclZpc2liaWxpdHlDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXIgdGhlIHJlbmRlcmVkIGNvbnRlbnQgc2l6ZSBvZiB0aGUgaWd4Rm9yT2YgaGFzIGJlZW4gY2hhbmdlZC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgY29udGVudFNpemVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIC8qKlxuICAgICAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCBhZnRlciBkYXRhIGhhcyBiZWVuIGNoYW5nZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuZy10ZW1wbGF0ZSBpZ3hGb3IgW2lneEZvck9mXT1cImRhdGFcIiBbaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb25dPVwiJ2hvcml6b250YWwnXCIgKGRhdGFDaGFuZ2VkKT1cImRhdGFDaGFuZ2VkKCRldmVudClcIj48L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBkYXRhQ2hhbmdlZChlKXtcbiAgICAgKiBhbGVydChcImRhdGEgY2hhbmdlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBkYXRhQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGJlZm9yZVZpZXdEZXN0cm95ZWQgPSBuZXcgRXZlbnRFbWl0dGVyPEVtYmVkZGVkVmlld1JlZjxhbnk+PigpO1xuXG4gICAgLyoqXG4gICAgICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIG9uIGNodW5rIGxvYWRpbmcgdG8gZW1pdCB0aGUgY3VycmVudCBzdGF0ZSBpbmZvcm1hdGlvbiAtIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCB0b3RhbENvdW50LlxuICAgICAqIENhbiBiZSB1c2VkIGZvciBpbXBsZW1lbnRpbmcgcmVtb3RlIGxvYWQgb24gZGVtYW5kIGZvciB0aGUgaWd4Rm9yIGRhdGEuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuZy10ZW1wbGF0ZSBpZ3hGb3IgW2lneEZvck9mXT1cImRhdGFcIiBbaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb25dPVwiJ2hvcml6b250YWwnXCIgKGNodW5rUHJlbG9hZCk9XCJjaHVua1ByZWxvYWQoJGV2ZW50KVwiPjwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNodW5rUHJlbG9hZChlKXtcbiAgICAgKiBhbGVydChcImNodW5rIGlzIGxvYWRpbmchXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgY2h1bmtQcmVsb2FkID0gbmV3IEV2ZW50RW1pdHRlcjxJRm9yT2ZTdGF0ZT4oKTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZGM6IENvbXBvbmVudFJlZjxEaXNwbGF5Q29udGFpbmVyQ29tcG9uZW50PjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBkaXJlY3RpdmUuIEl0IGNvbnRhaW5zIGBzdGFydEluZGV4YCBhbmQgYGNodW5rU2l6ZWAuXG4gICAgICogc3RhdGUuc3RhcnRJbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgaXRlbSBhdCB3aGljaCB0aGUgY3VycmVudCB2aXNpYmxlIGNodW5rIGJlZ2lucy5cbiAgICAgKiBzdGF0ZS5jaHVua1NpemUgLSBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRoZSBjdXJyZW50IHZpc2libGUgY2h1bmsgaG9sZHMuXG4gICAgICogVGhlc2Ugb3B0aW9ucyBjYW4gYmUgdXNlZCB3aGVuIGltcGxlbWVudGluZyByZW1vdGUgdmlydHVhbGl6YXRpb24gYXMgdGhleSBwcm92aWRlIHRoZSBuZWNlc3Nhcnkgc3RhdGUgaW5mb3JtYXRpb24uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGdyaWRTdGF0ZSA9IHRoaXMucGFyZW50VmlydERpci5zdGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGU6IElGb3JPZlN0YXRlID0ge1xuICAgICAgICBzdGFydEluZGV4OiAwLFxuICAgICAgICBjaHVua1NpemU6IDBcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIGZ1bmM7XG4gICAgcHJvdGVjdGVkIF9zaXplc0NhY2hlOiBudW1iZXJbXSA9IFtdO1xuICAgIHByb3RlY3RlZCBzY3JvbGxDb21wb25lbnQ6IFZpcnR1YWxIZWxwZXJCYXNlRGlyZWN0aXZlO1xuICAgIHByb3RlY3RlZCBfZGlmZmVyOiBJdGVyYWJsZURpZmZlcjxUPiB8IG51bGwgPSBudWxsO1xuICAgIHByb3RlY3RlZCBfdHJhY2tCeUZuOiBUcmFja0J5RnVuY3Rpb248VD47XG4gICAgcHJvdGVjdGVkIGluZGl2aWR1YWxTaXplQ2FjaGU6IG51bWJlcltdID0gW107XG4gICAgLyoqIEludGVybmFsIHRyYWNrIGZvciBzY3JvbGwgdG9wIHRoYXQgaXMgYmVpbmcgdmlydHVhbGl6ZWQgKi9cbiAgICBwcm90ZWN0ZWQgX3ZpcnRTY3JvbGxQb3NpdGlvbiA9IDA7XG4gICAgLyoqIElmIHRoZSBuZXh0IG9uU2Nyb2xsIGV2ZW50IGlzIHRyaWdnZXJlZCBkdWUgdG8gaW50ZXJuYWwgc2V0dGluZyBvZiBzY3JvbGxUb3AgKi9cbiAgICBwcm90ZWN0ZWQgX2JTY3JvbGxJbnRlcm5hbCA9IGZhbHNlO1xuICAgIC8vIEVuZCBwcm9wZXJ0aWVzIHJlbGF0ZWQgdG8gdmlydHVhbCBoZWlnaHQgaGFuZGxpbmdcbiAgICBwcm90ZWN0ZWQgX2VtYmVkZGVkVmlld3M6IEFycmF5PEVtYmVkZGVkVmlld1JlZjxhbnk+PiA9IFtdO1xuICAgIHByb3RlY3RlZCBjb250ZW50UmVzaXplTm90aWZ5ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgICBwcm90ZWN0ZWQgY29udGVudE9ic2VydmVyOiBSZXNpemVPYnNlcnZlcjtcbiAgICAvKiogU2l6ZSB0aGF0IGlzIGJlaW5nIHZpcnR1YWxpemVkLiAqL1xuICAgIHByb3RlY3RlZCBfdmlydFNpemUgPSAwO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZGVzdHJveSQgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG5cbiAgICBwcml2YXRlIF90b3RhbEl0ZW1Db3VudDogbnVtYmVyID0gbnVsbDtcbiAgICBwcml2YXRlIF9hZGp1c3RUb0luZGV4O1xuICAgIC8vIFN0YXJ0IHByb3BlcnRpZXMgcmVsYXRlZCB0byB2aXJ0dWFsIHNpemUgaGFuZGxpbmcgZHVlIHRvIGJyb3dzZXIgbGltaXRhdGlvblxuICAgIC8qKiBNYXhpbXVtIHNpemUgZm9yIGFuIGVsZW1lbnQgb2YgdGhlIGJyb3dzZXIuICovXG4gICAgcHJpdmF0ZSBfbWF4U2l6ZTtcbiAgICAvKipcbiAgICAgKiBSYXRpbyBmb3IgaGVpZ2h0IHRoYXQncyBiZWluZyB2aXJ0dWFsaXphZWQgYW5kIHRoZSBvbmUgdmlzaWJsZVxuICAgICAqIElmIF92aXJ0SGVpZ2h0UmF0aW8gPSAxLCB0aGUgdmlzaWJsZSBoZWlnaHQgYW5kIHRoZSB2aXJ0dWFsaXplZCBhcmUgdGhlIHNhbWUsIGFsc28gX21heFNpemUgPiBfdmlydEhlaWdodC5cbiAgICAgKi9cbiAgICBwcml2YXRlIF92aXJ0UmF0aW8gPSAxO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRvdGFsIGNvdW50IG9mIHRoZSB2aXJ0dWFsIGRhdGEgaXRlbXMsIHdoZW4gdXNpbmcgcmVtb3RlIHNlcnZpY2UuXG4gICAgICogU2ltaWxhciB0byB0aGUgcHJvcGVydHkgdG90YWxJdGVtQ291bnQsIGJ1dCB0aGlzIHdpbGwgYWxsb3cgc2V0dGluZyB0aGUgZGF0YSBjb3VudCBpbnRvIHRoZSB0ZW1wbGF0ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlIGlneEZvciBsZXQtaXRlbSBbaWd4Rm9yT2ZdPVwiZGF0YSB8IGFzeW5jXCIgW2lneEZvclRvdGFsSXRlbUNvdW50XT1cImNvdW50IHwgYXN5bmNcIlxuICAgICAqICBbaWd4Rm9yQ29udGFpbmVyU2l6ZV09XCInNTAwcHgnXCIgW2lneEZvckl0ZW1TaXplXT1cIic1MHB4J1wiPjwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGlneEZvclRvdGFsSXRlbUNvdW50KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvdGFsSXRlbUNvdW50O1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IGlneEZvclRvdGFsSXRlbUNvdW50KHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy50b3RhbEl0ZW1Db3VudCA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB0b3RhbCBjb3VudCBvZiB0aGUgdmlydHVhbCBkYXRhIGl0ZW1zLCB3aGVuIHVzaW5nIHJlbW90ZSBzZXJ2aWNlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnBhcmVudFZpcnREaXIudG90YWxJdGVtQ291bnQgPSBkYXRhLkNvdW50O1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgdG90YWxJdGVtQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b3RhbEl0ZW1Db3VudDtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IHRvdGFsSXRlbUNvdW50KHZhbCkge1xuICAgICAgICBpZiAodGhpcy5fdG90YWxJdGVtQ291bnQgIT09IHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fdG90YWxJdGVtQ291bnQgPSB2YWw7XG4gICAgICAgICAgICAvLyB1cGRhdGUgc2l6ZXMgaW4gY2FzZSB0b3RhbCBjb3VudCBjaGFuZ2VzLlxuICAgICAgICAgICAgY29uc3QgbmV3U2l6ZSA9IHRoaXMuaW5pdFNpemVzQ2FjaGUodGhpcy5pZ3hGb3JPZik7XG4gICAgICAgICAgICBjb25zdCBzaXplRGlmZiA9IHRoaXMuc2Nyb2xsQ29tcG9uZW50LnNpemUgLSBuZXdTaXplO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQuc2l6ZSA9IG5ld1NpemU7XG4gICAgICAgICAgICBjb25zdCBsYXN0Q2h1bmtFeGNlZWRlZCA9IHRoaXMuc3RhdGUuc3RhcnRJbmRleCArIHRoaXMuc3RhdGUuY2h1bmtTaXplID4gdmFsO1xuICAgICAgICAgICAgaWYgKGxhc3RDaHVua0V4Y2VlZGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zdGFydEluZGV4ID0gdmFsIC0gdGhpcy5zdGF0ZS5jaHVua1NpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hZGp1c3RTY3JvbGxQb3NpdGlvbkFmdGVyU2l6ZUNoYW5nZShzaXplRGlmZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGRpc3BsYXlDb250YWluZXIoKTogSFRNTEVsZW1lbnQgfCB1bmRlZmluZWQge1xuICAgICAgICByZXR1cm4gdGhpcy5kYz8uaW5zdGFuY2U/Ll92aWV3Q29udGFpbmVyPy5lbGVtZW50Py5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgdmlydHVhbEhlbHBlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgaXNSZW1vdGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvdGFsSXRlbUNvdW50ICE9PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogR2V0cy9TZXRzIHRoZSBzY3JvbGwgcG9zaXRpb24uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHBvc2l0aW9uID0gZGlyZWN0aXZlLnNjcm9sbFBvc2l0aW9uO1xuICAgICAqIGRpcmVjdGl2ZS5zY3JvbGxQb3NpdGlvbiA9IHZhbHVlO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgc2Nyb2xsUG9zaXRpb24oKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsQ29tcG9uZW50LnNjcm9sbEFtb3VudDtcbiAgICB9XG4gICAgcHVibGljIHNldCBzY3JvbGxQb3NpdGlvbih2YWw6IG51bWJlcikge1xuICAgICAgICBpZiAodmFsID09PSB0aGlzLnNjcm9sbENvbXBvbmVudC5zY3JvbGxBbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnICYmIHRoaXMuc2Nyb2xsQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50LnNjcm9sbExlZnQgPSB0aGlzLmlzUlRMID8gLXZhbCA6IHZhbDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNjcm9sbENvbXBvbmVudCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldCBpc1JUTCgpIHtcbiAgICAgICAgY29uc3QgZGlyID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpO1xuICAgICAgICByZXR1cm4gZGlyID09PSAncnRsJztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0IHNpemVzQ2FjaGUoKTogbnVtYmVyW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZXNDYWNoZTtcbiAgICB9XG4gICAgcHJvdGVjdGVkIHNldCBzaXplc0NhY2hlKHZhbHVlOiBudW1iZXJbXSkge1xuICAgICAgICB0aGlzLl9zaXplc0NhY2hlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXQgX2lzU2Nyb2xsZWRUb0JvdHRvbSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdldFNjcm9sbCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY3JvbGxIZWlnaHQgPSB0aGlzLmdldFNjcm9sbCgpLnNjcm9sbEhlaWdodDtcbiAgICAgICAgLy8gVXNlID09PSBhbmQgbm90ID49IGJlY2F1c2UgYHNjcm9sbFRvcCArIGNvbnRhaW5lciBzaXplYCBjYW4ndCBiZSBiaWdnZXIgdGhhbiBgc2Nyb2xsSGVpZ2h0YCwgdW5sZXNzIHNvbWV0aGluZyBpc24ndCB1cGRhdGVkLlxuICAgICAgICAvLyBBbHNvIHVzZSBNYXRoLnJvdW5kIGJlY2F1c2UgQ2hyb21lIGhhcyBzb21lIGluY29uc2lzdGVuY2llcyBhbmQgYHNjcm9sbFRvcCArIGNvbnRhaW5lcmAgY2FuIGJlIGZsb2F0IHdoZW4gem9vbWluZyB0aGUgcGFnZS5cbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy5nZXRTY3JvbGwoKS5zY3JvbGxUb3AgKyB0aGlzLmlneEZvckNvbnRhaW5lclNpemUpID09PSBzY3JvbGxIZWlnaHQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXQgX2lzQXRCb3R0b21JbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWd4Rm9yT2YgJiYgdGhpcy5zdGF0ZS5zdGFydEluZGV4ICsgdGhpcy5zdGF0ZS5jaHVua1NpemUgPiB0aGlzLmlneEZvck9mLmxlbmd0aDtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgcHJvdGVjdGVkIF90ZW1wbGF0ZTogVGVtcGxhdGVSZWY8TmdGb3JPZkNvbnRleHQ8VD4+LFxuICAgICAgICBwcm90ZWN0ZWQgX2RpZmZlcnM6IEl0ZXJhYmxlRGlmZmVycyxcbiAgICAgICAgcHVibGljIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIHByb3RlY3RlZCBfem9uZTogTmdab25lLFxuICAgICAgICBwcm90ZWN0ZWQgc3luY1Njcm9sbFNlcnZpY2U6IElneEZvck9mU2Nyb2xsU3luY1NlcnZpY2UsXG4gICAgICAgIHByb3RlY3RlZCBwbGF0Zm9ybVV0aWw6IFBsYXRmb3JtVXRpbCxcbiAgICAgICAgQEluamVjdChET0NVTUVOVClcbiAgICAgICAgcHJvdGVjdGVkIGRvY3VtZW50OiBhbnksXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgcHVibGljIHZlcnRpY2FsU2Nyb2xsSGFuZGxlcihldmVudCkge1xuICAgICAgICB0aGlzLm9uU2Nyb2xsKGV2ZW50KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgaXNTY3JvbGxhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxDb21wb25lbnQuc2l6ZSA+IHBhcnNlSW50KHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSwgMTApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHZjID0gdGhpcy5pZ3hGb3JTY3JvbGxDb250YWluZXIgPyB0aGlzLmlneEZvclNjcm9sbENvbnRhaW5lci5fdmlld0NvbnRhaW5lciA6IHRoaXMuX3ZpZXdDb250YWluZXI7XG4gICAgICAgIHRoaXMuaWd4Rm9yU2l6ZVByb3BOYW1lID0gdGhpcy5pZ3hGb3JTaXplUHJvcE5hbWUgfHwgJ3dpZHRoJztcbiAgICAgICAgdGhpcy5kYyA9IHRoaXMuX3ZpZXdDb250YWluZXIuY3JlYXRlQ29tcG9uZW50KERpc3BsYXlDb250YWluZXJDb21wb25lbnQsIHsgaW5kZXg6IDAgfSk7XG4gICAgICAgIHRoaXMuZGMuaW5zdGFuY2Uuc2Nyb2xsRGlyZWN0aW9uID0gdGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yT2YgJiYgdGhpcy5pZ3hGb3JPZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50ID0gdGhpcy5zeW5jU2Nyb2xsU2VydmljZS5nZXRTY3JvbGxNYXN0ZXIodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbik7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmNodW5rU2l6ZSA9IHRoaXMuX2NhbGN1bGF0ZUNodW5rU2l6ZSgpO1xuICAgICAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5ub3RWaXJ0dWFsID0gISh0aGlzLmlneEZvckNvbnRhaW5lclNpemUgJiYgdGhpcy5zdGF0ZS5jaHVua1NpemUgPCB0aGlzLmlneEZvck9mLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxDb21wb25lbnQgJiYgIXRoaXMuc2Nyb2xsQ29tcG9uZW50LmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RhcnRJbmRleCA9IE1hdGgubWluKHRoaXMuZ2V0SW5kZXhBdCh0aGlzLnNjcm9sbFBvc2l0aW9uLCB0aGlzLnNpemVzQ2FjaGUpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlneEZvck9mLmxlbmd0aCAtIHRoaXMuc3RhdGUuY2h1bmtTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXg7IGkgPCB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggKyB0aGlzLnN0YXRlLmNodW5rU2l6ZSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuaWd4Rm9yT2ZbaV0gIT09IHVuZGVmaW5lZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLmlneEZvck9mW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVtYmVkZGVkVmlldyA9IHRoaXMuZGMuaW5zdGFuY2UuX3Zjci5jcmVhdGVFbWJlZGRlZFZpZXcoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlLFxuICAgICAgICAgICAgICAgICAgICBuZXcgSWd4Rm9yT2ZDb250ZXh0PFQsIFU+KGlucHV0LCB0aGlzLmlneEZvck9mLCB0aGlzLmdldENvbnRleHRJbmRleChpbnB1dCksIHRoaXMuaWd4Rm9yT2YubGVuZ3RoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1iZWRkZWRWaWV3cy5wdXNoKGVtYmVkZGVkVmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWF4U2l6ZSA9IHRoaXMuX2NhbGNNYXhCcm93c2VyU2l6ZSgpO1xuICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudG9wID0gJzBweCc7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudCA9IHRoaXMuc3luY1Njcm9sbFNlcnZpY2UuZ2V0U2Nyb2xsTWFzdGVyKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNjcm9sbENvbXBvbmVudCB8fCB0aGlzLnNjcm9sbENvbXBvbmVudC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudCA9IHZjLmNyZWF0ZUNvbXBvbmVudChWaXJ0dWFsSGVscGVyQ29tcG9uZW50KS5pbnN0YW5jZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQuc2l6ZSA9IHRoaXMuaWd4Rm9yT2YgPyB0aGlzLl9jYWxjU2l6ZSgpIDogMDtcbiAgICAgICAgICAgIHRoaXMuc3luY1Njcm9sbFNlcnZpY2Uuc2V0U2Nyb2xsTWFzdGVyKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24sIHRoaXMuc2Nyb2xsQ29tcG9uZW50KTtcbiAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudmVydGljYWxTY3JvbGxIYW5kbGVyID0gdGhpcy52ZXJ0aWNhbFNjcm9sbEhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMudmVydGljYWxTY3JvbGxIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRjLmluc3RhbmNlLnNjcm9sbENvbnRhaW5lciA9IHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGRlc3RydWN0b3IgPSB0YWtlVW50aWw8YW55Pih0aGlzLmRlc3Ryb3kkKTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudFJlc2l6ZU5vdGlmeS5waXBlKFxuICAgICAgICAgICAgICAgIGZpbHRlcigoKSA9PiB0aGlzLmlneEZvckNvbnRhaW5lclNpemUgJiYgdGhpcy5pZ3hGb3JPZiAmJiB0aGlzLmlneEZvck9mLmxlbmd0aCA+IDApLFxuICAgICAgICAgICAgICAgIHRocm90dGxlVGltZSg0MCwgdW5kZWZpbmVkLCB7IGxlYWRpbmc6IGZhbHNlLCB0cmFpbGluZzogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICBkZXN0cnVjdG9yXG4gICAgICAgICAgICApLnN1YnNjcmliZSgoKSA9PiB0aGlzLl96b25lLnJ1blRhc2soKCkgPT4gdGhpcy51cGRhdGVTaXplcygpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICB0aGlzLmZ1bmMgPSAoZXZ0KSA9PiB0aGlzLm9uSFNjcm9sbChldnQpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQgPSB0aGlzLnN5bmNTY3JvbGxTZXJ2aWNlLmdldFNjcm9sbE1hc3Rlcih0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zY3JvbGxDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudCA9IHZjLmNyZWF0ZUNvbXBvbmVudChIVmlydHVhbEhlbHBlckNvbXBvbmVudCkuaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQuc2l6ZSA9IHRoaXMuaWd4Rm9yT2YgPyB0aGlzLl9jYWxjU2l6ZSgpIDogMDtcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmNTY3JvbGxTZXJ2aWNlLnNldFNjcm9sbE1hc3Rlcih0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uLCB0aGlzLnNjcm9sbENvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5mdW5jKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5zY3JvbGxDb250YWluZXIgPSB0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmZ1bmMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRjLmluc3RhbmNlLnNjcm9sbENvbnRhaW5lciA9IHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTY3JvbGxPZmZzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRPYnNlcnZlciA9IG5ldyAoZ2V0UmVzaXplT2JzZXJ2ZXIoKSkoKCkgPT4gdGhpcy5jb250ZW50UmVzaXplTm90aWZ5Lm5leHQoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50T2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmRjLmluc3RhbmNlLl92aWV3Q29udGFpbmVyLmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlU2Nyb2xsRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5uZXh0KHRydWUpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRPYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50T2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBBc3NlcnRzIHRoZSBjb3JyZWN0IHR5cGUgb2YgdGhlIGNvbnRleHQgZm9yIHRoZSB0ZW1wbGF0ZSB0aGF0IGBpZ3hGb3JPZmAgd2lsbCByZW5kZXIuXG4gICAgICpcbiAgICAgKiBUaGUgcHJlc2VuY2Ugb2YgdGhpcyBtZXRob2QgaXMgYSBzaWduYWwgdG8gdGhlIEl2eSB0ZW1wbGF0ZSB0eXBlLWNoZWNrIGNvbXBpbGVyIHRoYXQgdGhlXG4gICAgICogYElneEZvck9mYCBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZSByZW5kZXJzIGl0cyB0ZW1wbGF0ZSB3aXRoIGEgc3BlY2lmaWMgY29udGV4dCB0eXBlLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgbmdUZW1wbGF0ZUNvbnRleHRHdWFyZDxULCBVIGV4dGVuZHMgVFtdPihkaXI6IElneEZvck9mRGlyZWN0aXZlPFQsIFU+LCBjdHg6IGFueSk6XG4gICAgICAgIGN0eCBpcyBJZ3hGb3JPZkNvbnRleHQ8VCwgVT4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZm9yT2YgPSAnaWd4Rm9yT2YnO1xuICAgICAgICBpZiAoZm9yT2YgaW4gY2hhbmdlcykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjaGFuZ2VzW2Zvck9mXS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RpZmZlciAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpZmZlciA9IHRoaXMuX2RpZmZlcnMuZmluZCh2YWx1ZSkuY3JlYXRlKHRoaXMuaWd4Rm9yVHJhY2tCeSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBgQ2Fubm90IGZpbmQgYSBkaWZmZXIgc3VwcG9ydGluZyBvYmplY3QgXCIke3ZhbHVlfVwiIG9mIHR5cGUgXCIke2dldFR5cGVOYW1lRm9yRGVidWdnaW5nKHZhbHVlKX1cIi5cbiAgICAgICAgICAgICAgICAgICAgIE5nRm9yIG9ubHkgc3VwcG9ydHMgYmluZGluZyB0byBJdGVyYWJsZXMgc3VjaCBhcyBBcnJheXMuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmF1bHRJdGVtU2l6ZSA9ICdpZ3hGb3JJdGVtU2l6ZSc7XG4gICAgICAgIGlmIChkZWZhdWx0SXRlbVNpemUgaW4gY2hhbmdlcyAmJiAhY2hhbmdlc1tkZWZhdWx0SXRlbVNpemVdLmZpcnN0Q2hhbmdlICYmIHRoaXMuaWd4Rm9yT2YpIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBkZWZhdWx0IGl0ZW0gc2l6ZSBjaGFuZ2VkLlxuICAgICAgICAgICAgdGhpcy5pbml0U2l6ZXNDYWNoZSh0aGlzLmlneEZvck9mKTtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5Q2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclNpemUgPSAnaWd4Rm9yQ29udGFpbmVyU2l6ZSc7XG4gICAgICAgIGlmIChjb250YWluZXJTaXplIGluIGNoYW5nZXMgJiYgIWNoYW5nZXNbY29udGFpbmVyU2l6ZV0uZmlyc3RDaGFuZ2UgJiYgdGhpcy5pZ3hGb3JPZikge1xuICAgICAgICAgICAgY29uc3QgcHJldlNpemUgPSBwYXJzZUludChjaGFuZ2VzW2NvbnRhaW5lclNpemVdLnByZXZpb3VzVmFsdWUsIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NpemUgPSBwYXJzZUludChjaGFuZ2VzW2NvbnRhaW5lclNpemVdLmN1cnJlbnRWYWx1ZSwgMTApO1xuICAgICAgICAgICAgdGhpcy5fcmVjYWxjT25Db250YWluZXJDaGFuZ2Uoe3ByZXZTaXplLCBuZXdTaXplfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nRG9DaGVjaygpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpZmZlcikge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuX2RpZmZlci5kaWZmKHRoaXMuaWd4Rm9yT2YpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAvLyAgcmUtaW5pdCBjYWNoZS5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaWd4Rm9yT2YpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pZ3hGb3JPZiA9IFtdIGFzIFU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNpemVDYWNoZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlDaGFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTY3JvbGxPZmZzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJnczogSUZvck9mRGF0YUNoYW5naW5nRXZlbnRBcmdzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyU2l6ZTogdGhpcy5pZ3hGb3JDb250YWluZXJTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbmdlZC5lbWl0KGFyZ3MpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBTaGlmdHMgdGhlIHNjcm9sbCB0aHVtYiBwb3NpdGlvbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5wYXJlbnRWaXJ0RGlyLmFkZFNjcm9sbCg1KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRUb3AgbmVnYXRpdmUgdmFsdWUgdG8gc2Nyb2xsIHVwIGFuZCBwb3NpdGl2ZSB0byBzY3JvbGwgZG93bjtcbiAgICAgKi9cbiAgICBwdWJsaWMgYWRkU2Nyb2xsVG9wKGFkZDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFNjcm9sbChhZGQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNoaWZ0cyB0aGUgc2Nyb2xsIHRodW1iIHBvc2l0aW9uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnBhcmVudFZpcnREaXIuYWRkU2Nyb2xsKDUpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZCBuZWdhdGl2ZSB2YWx1ZSB0byBzY3JvbGwgcHJldmlvdXMgYW5kIHBvc2l0aXZlIHRvIHNjcm9sbCBuZXh0O1xuICAgICAqL1xuICAgIHB1YmxpYyBhZGRTY3JvbGwoYWRkOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKGFkZCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsVmlydFNjcm9sbFRvcCA9IHRoaXMuX3ZpcnRTY3JvbGxQb3NpdGlvbjtcbiAgICAgICAgY29uc3QgY29udGFpbmVyU2l6ZSA9IHBhcnNlSW50KHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSwgMTApO1xuICAgICAgICBjb25zdCBtYXhWaXJ0U2Nyb2xsVG9wID0gdGhpcy5fdmlydFNpemUgLSBjb250YWluZXJTaXplO1xuXG4gICAgICAgIHRoaXMuX2JTY3JvbGxJbnRlcm5hbCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ZpcnRTY3JvbGxQb3NpdGlvbiArPSBhZGQ7XG4gICAgICAgIHRoaXMuX3ZpcnRTY3JvbGxQb3NpdGlvbiA9IHRoaXMuX3ZpcnRTY3JvbGxQb3NpdGlvbiA+IDAgP1xuICAgICAgICAgICAgKHRoaXMuX3ZpcnRTY3JvbGxQb3NpdGlvbiA8IG1heFZpcnRTY3JvbGxUb3AgPyB0aGlzLl92aXJ0U2Nyb2xsUG9zaXRpb24gOiBtYXhWaXJ0U2Nyb2xsVG9wKSA6XG4gICAgICAgICAgICAwO1xuXG4gICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb24gKz0gYWRkIC8gdGhpcy5fdmlydFJhdGlvO1xuICAgICAgICBpZiAoTWF0aC5hYnMoYWRkIC8gdGhpcy5fdmlydFJhdGlvKSA8IDEpIHtcbiAgICAgICAgICAgIC8vIEFjdHVhbCBzY3JvbGwgZGVsdGEgdGhhdCB3YXMgYWRkZWQgaXMgc21hbGxlciB0aGFuIDEgYW5kIG9uU2Nyb2xsIGhhbmRsZXIgZG9lc24ndCB0cmlnZ2VyIHdoZW4gc2Nyb2xsaW5nIDwgMXB4XG4gICAgICAgICAgICBjb25zdCBzY3JvbGxPZmZzZXQgPSB0aGlzLmZpeGVkVXBkYXRlQWxsRWxlbWVudHModGhpcy5fdmlydFNjcm9sbFBvc2l0aW9uKTtcbiAgICAgICAgICAgIC8vIHNjcm9sbE9mZnNldCA9IHNjcm9sbE9mZnNldCAhPT0gcGFyc2VJbnQodGhpcy5pZ3hGb3JJdGVtU2l6ZSwgMTApID8gc2Nyb2xsT2Zmc2V0IDogMDtcbiAgICAgICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRvcCA9IC0oc2Nyb2xsT2Zmc2V0KSArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtYXhSZWFsU2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxDb21wb25lbnQubmF0aXZlRWxlbWVudC5zY3JvbGxIZWlnaHQgLSBjb250YWluZXJTaXplO1xuICAgICAgICBpZiAoKHRoaXMuX3ZpcnRTY3JvbGxQb3NpdGlvbiA+IDAgJiYgdGhpcy5zY3JvbGxQb3NpdGlvbiA9PT0gMCkgfHxcbiAgICAgICAgICAgICh0aGlzLl92aXJ0U2Nyb2xsUG9zaXRpb24gPCBtYXhWaXJ0U2Nyb2xsVG9wICYmIHRoaXMuc2Nyb2xsUG9zaXRpb24gPT09IG1heFJlYWxTY3JvbGxUb3ApKSB7XG4gICAgICAgICAgICAvLyBBY3R1YWwgc2Nyb2xsIHBvc2l0aW9uIGlzIGF0IHRoZSB0b3Agb3IgYm90dG9tLCBidXQgdmlydHVhbCBvbmUgaXMgbm90IGF0IHRoZSB0b3Agb3IgYm90dG9tICh0aGVyZSdzIG1vcmUgdG8gc2Nyb2xsKVxuICAgICAgICAgICAgLy8gUmVjYWxjdWxhdGUgYWN0dWFsIHNjcm9sbCBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgdmlydHVhbCBzY3JvbGwuXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uID0gdGhpcy5fdmlydFNjcm9sbFBvc2l0aW9uIC8gdGhpcy5fdmlydFJhdGlvO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3ZpcnRTY3JvbGxQb3NpdGlvbiA9PT0gMCAmJiB0aGlzLnNjcm9sbFBvc2l0aW9uID4gMCkge1xuICAgICAgICAgICAgLy8gQWN0dWFsIHNjcm9sbCBwb3NpdGlvbiBpcyBub3QgYXQgdGhlIHRvcCwgYnV0IHZpcnR1YWwgc2Nyb2xsIGlzLiBKdXN0IHVwZGF0ZSB0aGUgYWN0dWFsIHNjcm9sbFxuICAgICAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvbiA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fdmlydFNjcm9sbFBvc2l0aW9uID09PSBtYXhWaXJ0U2Nyb2xsVG9wICYmIHRoaXMuc2Nyb2xsUG9zaXRpb24gPCBtYXhSZWFsU2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAvLyBBY3R1YWwgc2Nyb2xsIHBvc2l0aW9uIGlzIG5vdCBhdCB0aGUgYm90dG9tLCBidXQgdmlydHVhbCBzY3JvbGwgaXMuIEp1c3QgdXBkYXRlIHRoZSBhY3VhbCBzY3JvbGxcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb24gPSBtYXhSZWFsU2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl92aXJ0U2Nyb2xsUG9zaXRpb24gIT09IG9yaWdpbmFsVmlydFNjcm9sbFRvcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY3JvbGxzIHRvIHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMucGFyZW50VmlydERpci5zY3JvbGxUbyg1KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleFxuICAgICAqL1xuICAgIHB1YmxpYyBzY3JvbGxUbyhpbmRleDogbnVtYmVyKSB7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiAodGhpcy5pc1JlbW90ZSA/IHRoaXMudG90YWxJdGVtQ291bnQgOiB0aGlzLmlneEZvck9mLmxlbmd0aCkgLSAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGFpbmVyU2l6ZSA9IHBhcnNlSW50KHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSwgMTApO1xuICAgICAgICBjb25zdCBpc1ByZXZJdGVtID0gaW5kZXggPCB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggfHwgdGhpcy5zY3JvbGxQb3NpdGlvbiA+IHRoaXMuc2l6ZXNDYWNoZVtpbmRleF07XG4gICAgICAgIGxldCBuZXh0U2Nyb2xsID0gaXNQcmV2SXRlbSA/IHRoaXMuc2l6ZXNDYWNoZVtpbmRleF0gOiB0aGlzLnNpemVzQ2FjaGVbaW5kZXggKyAxXSAtIGNvbnRhaW5lclNpemU7XG4gICAgICAgIGlmIChuZXh0U2Nyb2xsIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1heFZpcnRTY3JvbGxUb3AgPSB0aGlzLl92aXJ0U2l6ZSAtIGNvbnRhaW5lclNpemU7XG4gICAgICAgIGlmIChuZXh0U2Nyb2xsID4gbWF4VmlydFNjcm9sbFRvcCkge1xuICAgICAgICAgICAgbmV4dFNjcm9sbCA9IG1heFZpcnRTY3JvbGxUb3A7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYlNjcm9sbEludGVybmFsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdmlydFNjcm9sbFBvc2l0aW9uID0gbmV4dFNjcm9sbDtcbiAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvbiA9IHRoaXMuX3ZpcnRTY3JvbGxQb3NpdGlvbiAvIHRoaXMuX3ZpcnRSYXRpbztcbiAgICAgICAgdGhpcy5fYWRqdXN0VG9JbmRleCA9ICFpc1ByZXZJdGVtID8gaW5kZXggOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjcm9sbHMgYnkgb25lIGl0ZW0gaW50byB0aGUgYXBwcm9wcmlhdGUgbmV4dCBkaXJlY3Rpb24uXG4gICAgICogRm9yIFwiaG9yaXpvbnRhbFwiIG9yaWVudGF0aW9uIHRoYXQgd2lsbCBiZSB0aGUgcmlnaHQgY29sdW1uIGFuZCBmb3IgXCJ2ZXJ0aWNhbFwiIHRoYXQgaXMgdGhlIGxvd2VyIHJvdy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5wYXJlbnRWaXJ0RGlyLnNjcm9sbE5leHQoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2Nyb2xsTmV4dCgpIHtcbiAgICAgICAgY29uc3Qgc2NyID0gTWF0aC5hYnMoTWF0aC5jZWlsKHRoaXMuc2Nyb2xsUG9zaXRpb24pKTtcbiAgICAgICAgY29uc3QgZW5kSW5kZXggPSB0aGlzLmdldEluZGV4QXQoc2NyICsgcGFyc2VJbnQodGhpcy5pZ3hGb3JDb250YWluZXJTaXplLCAxMCksIHRoaXMuc2l6ZXNDYWNoZSk7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG8oZW5kSW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjcm9sbHMgYnkgb25lIGl0ZW0gaW50byB0aGUgYXBwcm9wcmlhdGUgcHJldmlvdXMgZGlyZWN0aW9uLlxuICAgICAqIEZvciBcImhvcml6b250YWxcIiBvcmllbnRhdGlvbiB0aGF0IHdpbGwgYmUgdGhlIGxlZnQgY29sdW1uIGFuZCBmb3IgXCJ2ZXJ0aWNhbFwiIHRoYXQgaXMgdGhlIHVwcGVyIHJvdy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5wYXJlbnRWaXJ0RGlyLnNjcm9sbFByZXYoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2Nyb2xsUHJldigpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxUbyh0aGlzLnN0YXRlLnN0YXJ0SW5kZXggLSAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY3JvbGxzIGJ5IG9uZSBwYWdlIGludG8gdGhlIGFwcHJvcHJpYXRlIG5leHQgZGlyZWN0aW9uLlxuICAgICAqIEZvciBcImhvcml6b250YWxcIiBvcmllbnRhdGlvbiB0aGF0IHdpbGwgYmUgb25lIHZpZXcgdG8gdGhlIHJpZ2h0IGFuZCBmb3IgXCJ2ZXJ0aWNhbFwiIHRoYXQgaXMgb25lIHZpZXcgdG8gdGhlIGJvdHRvbS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5wYXJlbnRWaXJ0RGlyLnNjcm9sbE5leHRQYWdlKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHNjcm9sbE5leHRQYWdlKCkge1xuICAgICAgICB0aGlzLmFkZFNjcm9sbChwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2Nyb2xscyBieSBvbmUgcGFnZSBpbnRvIHRoZSBhcHByb3ByaWF0ZSBwcmV2aW91cyBkaXJlY3Rpb24uXG4gICAgICogRm9yIFwiaG9yaXpvbnRhbFwiIG9yaWVudGF0aW9uIHRoYXQgd2lsbCBiZSBvbmUgdmlldyB0byB0aGUgbGVmdCBhbmQgZm9yIFwidmVydGljYWxcIiB0aGF0IGlzIG9uZSB2aWV3IHRvIHRoZSB0b3AuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMucGFyZW50VmlydERpci5zY3JvbGxQcmV2UGFnZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBzY3JvbGxQcmV2UGFnZSgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyU2l6ZSA9IChwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKSk7XG4gICAgICAgIHRoaXMuYWRkU2Nyb2xsKC1jb250YWluZXJTaXplKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldENvbHVtblNjcm9sbExlZnQoY29sSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZXNDYWNoZVtjb2xJbmRleF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIGl0ZW1zIHRoYXQgYXJlIGZ1bGx5IHZpc2libGUuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMucGFyZW50VmlydERpci5nZXRJdGVtQ291bnRJblZpZXcoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0SXRlbUNvdW50SW5WaWV3KCkge1xuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IHRoaXMuZ2V0SW5kZXhBdCh0aGlzLnNjcm9sbFBvc2l0aW9uLCB0aGlzLnNpemVzQ2FjaGUpO1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxQb3NpdGlvbiAtIHRoaXMuc2l6ZXNDYWNoZVtzdGFydEluZGV4XSA+IDApIHtcbiAgICAgICAgICAgIC8vIGZpc3J0IGl0ZW0gaXMgbm90IGZ1bGx5IGluIHZpZXdcbiAgICAgICAgICAgIHN0YXJ0SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmRJbmRleCA9IHRoaXMuZ2V0SW5kZXhBdCh0aGlzLnNjcm9sbFBvc2l0aW9uICsgcGFyc2VJbnQodGhpcy5pZ3hGb3JDb250YWluZXJTaXplLCAxMCksIHRoaXMuc2l6ZXNDYWNoZSk7XG4gICAgICAgIHJldHVybiBlbmRJbmRleCAtIHN0YXJ0SW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgc2Nyb2xsYmFyIERPTSBlbGVtZW50LlxuICAgICAqIFRoaXMgaXMgZWl0aGVyIGEgdmVydGljYWwgb3IgaG9yaXpvbnRhbCBzY3JvbGxiYXIgZGVwZW5kaW5nIG9uIHRoZSBzcGVjaWZpZWQgaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGRpci5nZXRTY3JvbGwoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0U2Nyb2xsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxDb21wb25lbnQ/Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5wYXJlbnRWaXJ0RGlyLmdldFNpemVBdCgxKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0U2l6ZUF0KGluZGV4OiBudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZXNDYWNoZVtpbmRleCArIDFdIC0gdGhpcy5zaXplc0NhY2hlW2luZGV4XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgdG8gZ2V0IHRoZSBuYXRpdmUgc2Nyb2xsYmFyIHNpemUgdGhhdCB0aGUgYnJvd3NlcnMgcmVuZGVycy5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0U2Nyb2xsTmF0aXZlU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsQ29tcG9uZW50ID8gdGhpcy5zY3JvbGxDb21wb25lbnQuc2Nyb2xsTmF0aXZlU2l6ZSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2Nyb2xsIG9mZnNldCBvZiB0aGUgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnBhcmVudFZpcnREaXIuZ2V0U2Nyb2xsRm9ySW5kZXgoMSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldFNjcm9sbEZvckluZGV4KGluZGV4OiBudW1iZXIsIGJvdHRvbT86IGJvb2xlYW4pIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyU2l6ZSA9IHBhcnNlSW50KHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSwgMTApO1xuICAgICAgICBjb25zdCBzY3JvbGwgPSBib3R0b20gPyBNYXRoLm1heCgwLCB0aGlzLnNpemVzQ2FjaGVbaW5kZXggKyAxXSAtIGNvbnRhaW5lclNpemUpIDogdGhpcy5zaXplc0NhY2hlW2luZGV4XTtcbiAgICAgICAgcmV0dXJuIHNjcm9sbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5wYXJlbnRWaXJ0RGlyLmdldEluZGV4QXRTY3JvbGwoMTAwKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0SW5kZXhBdFNjcm9sbChzY3JvbGxPZmZzZXQ6IG51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRJbmRleEF0KHNjcm9sbE9mZnNldCwgdGhpcy5zaXplc0NhY2hlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSB0YXJnZXQgaW5kZXggaXMgb3V0c2lkZSB0aGUgdmlldy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5wYXJlbnRWaXJ0RGlyLmlzSW5kZXhPdXRzaWRlVmlldygxMCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGlzSW5kZXhPdXRzaWRlVmlldyhpbmRleDogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBpbmRleCA+PSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggJiYgaW5kZXggPD0gdGhpcy5zdGF0ZS5zdGFydEluZGV4ICsgdGhpcy5zdGF0ZS5jaHVua1NpemUgP1xuICAgICAgICAgICAgdGhpcy5fZW1iZWRkZWRWaWV3cy5tYXAodmlldyA9PlxuICAgICAgICAgICAgICAgIHZpZXcucm9vdE5vZGVzLmZpbmQobm9kZSA9PiBub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkgfHwgdmlldy5yb290Tm9kZXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nKVtpbmRleCAtIHRoaXMuc3RhdGUuc3RhcnRJbmRleF0gOiBudWxsO1xuICAgICAgICBjb25zdCByb3dIZWlnaHQgPSB0aGlzLmdldFNpemVBdChpbmRleCk7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclNpemUgPSBwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyT2Zmc2V0ID0gLSh0aGlzLnNjcm9sbFBvc2l0aW9uIC0gdGhpcy5zaXplc0NhY2hlW3RoaXMuc3RhdGUuc3RhcnRJbmRleF0pO1xuICAgICAgICBjb25zdCBlbmRUb3BPZmZzZXQgPSB0YXJnZXROb2RlID8gdGFyZ2V0Tm9kZS5vZmZzZXRUb3AgKyByb3dIZWlnaHQgKyBjb250YWluZXJPZmZzZXQgOiBjb250YWluZXJTaXplICsgcm93SGVpZ2h0O1xuICAgICAgICByZXR1cm4gIXRhcmdldE5vZGUgfHwgdGFyZ2V0Tm9kZS5vZmZzZXRUb3AgPCBNYXRoLmFicyhjb250YWluZXJPZmZzZXQpXG4gICAgICAgICAgICB8fCBjb250YWluZXJTaXplICYmIGVuZFRvcE9mZnNldCAtIGNvbnRhaW5lclNpemUgPiA1O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBGdW5jdGlvbiB0aGF0IHJlY2FsY3VsYXRlcyBhbmQgdXBkYXRlcyBjYWNoZSBzaXplcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVjYWxjVXBkYXRlU2l6ZXMoKSB7XG4gICAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/XG4gICAgICAgICAgICB0aGlzLmlneEZvclNpemVQcm9wTmFtZSA6ICdoZWlnaHQnO1xuICAgICAgICBjb25zdCBkaWZmcyA9IFtdO1xuICAgICAgICBsZXQgdG90YWxEaWZmID0gMDtcbiAgICAgICAgY29uc3QgbCA9IHRoaXMuX2VtYmVkZGVkVmlld3MubGVuZ3RoO1xuICAgICAgICBjb25zdCByTm9kZXMgPSB0aGlzLl9lbWJlZGRlZFZpZXdzLm1hcCh2aWV3ID0+XG4gICAgICAgICAgICB2aWV3LnJvb3ROb2Rlcy5maW5kKG5vZGUgPT4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHx8IHZpZXcucm9vdE5vZGVzWzBdLm5leHRFbGVtZW50U2libGluZyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByTm9kZSA9IHJOb2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChyTm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHJOb2RlKS5nZXRQcm9wZXJ0eVZhbHVlKCdoZWlnaHQnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoID0gcGFyc2VGbG9hdChoZWlnaHQpIHx8IHBhcnNlSW50KHRoaXMuaWd4Rm9ySXRlbVNpemUsIDEwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuc3RhdGUuc3RhcnRJbmRleCArIGk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzUmVtb3RlICYmICF0aGlzLmlneEZvck9mW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbWFyZ2luID0gdGhpcy5nZXRNYXJnaW4ock5vZGUsIGRpbWVuc2lvbik7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkVmFsID0gdGhpcy5pbmRpdmlkdWFsU2l6ZUNhY2hlW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWwgPSAoZGltZW5zaW9uID09PSAnaGVpZ2h0JyA/IGggOiByTm9kZS5jbGllbnRXaWR0aCkgKyBtYXJnaW47XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRpdmlkdWFsU2l6ZUNhY2hlW2luZGV4XSA9IG5ld1ZhbDtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyRGlmZiA9IG5ld1ZhbCAtIG9sZFZhbDtcbiAgICAgICAgICAgICAgICBkaWZmcy5wdXNoKGN1cnJEaWZmKTtcbiAgICAgICAgICAgICAgICB0b3RhbERpZmYgKz0gY3VyckRpZmY7XG4gICAgICAgICAgICAgICAgdGhpcy5zaXplc0NhY2hlW2luZGV4ICsgMV0gPSAodGhpcy5zaXplc0NhY2hlW2luZGV4XSB8fCAwKSArIG5ld1ZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgY2FjaGVcbiAgICAgICAgaWYgKE1hdGguYWJzKHRvdGFsRGlmZikgPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gdGhpcy5zdGF0ZS5zdGFydEluZGV4ICsgdGhpcy5zdGF0ZS5jaHVua1NpemUgKyAxOyBqIDwgdGhpcy5zaXplc0NhY2hlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaXplc0NhY2hlW2pdID0gKHRoaXMuc2l6ZXNDYWNoZVtqXSB8fCAwKSArIHRvdGFsRGlmZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdXBkYXRlIHNjckJhciBoZWlnaHRzL3dpZHRoc1xuICAgICAgICAgICAgY29uc3QgcmVkdWNlciA9IChhY2MsIHZhbCkgPT4gYWNjICsgdmFsO1xuXG4gICAgICAgICAgICBjb25zdCBoU3VtID0gdGhpcy5pbmRpdmlkdWFsU2l6ZUNhY2hlLnJlZHVjZShyZWR1Y2VyKTtcbiAgICAgICAgICAgIGlmIChoU3VtID4gdGhpcy5fbWF4U2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZpcnRSYXRpbyA9IGhTdW0gLyB0aGlzLl9tYXhTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQuc2l6ZSA9IE1hdGgubWluKHRoaXMuc2Nyb2xsQ29tcG9uZW50LnNpemUgKyB0b3RhbERpZmYsIHRoaXMuX21heFNpemUpO1xuICAgICAgICAgICAgdGhpcy5fdmlydFNpemUgPSBoU3VtO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNjcm9sbENvbXBvbmVudC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudC5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2NyVG9Cb3R0b20gPSB0aGlzLl9pc1Njcm9sbGVkVG9Cb3R0b20gJiYgIXRoaXMuZGMuaW5zdGFuY2Uubm90VmlydHVhbDtcbiAgICAgICAgICAgIGlmIChzY3JUb0JvdHRvbSAmJiAhdGhpcy5faXNBdEJvdHRvbUluZGV4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGFpbmVyU2l6ZSA9IHBhcnNlSW50KHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSwgMTApO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heFZpcnRTY3JvbGxUb3AgPSB0aGlzLl92aXJ0U2l6ZSAtIGNvbnRhaW5lclNpemU7XG4gICAgICAgICAgICAgICAgdGhpcy5fYlNjcm9sbEludGVybmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl92aXJ0U2Nyb2xsUG9zaXRpb24gPSBtYXhWaXJ0U2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb24gPSBtYXhWaXJ0U2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9hZGp1c3RUb0luZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gY2FzZSBzY3JvbGxlZCB0byBzcGVjaWZpYyBpbmRleCB3aGVyZSBhZnRlciBzY3JvbGwgaGVpZ2h0cyBhcmUgY2hhbmdlZFxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gYWRqdXN0IHRoZSBvZmZzZXRzIHNvIHRoYXQgaXRlbSBpcyBsYXN0IGluIHZpZXcuXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlc1RvSW5kZXggPSB0aGlzLl9hZGp1c3RUb0luZGV4IC0gdGhpcy5zdGF0ZS5zdGFydEluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdW1EaWZmcyA9IGRpZmZzLnNsaWNlKDAsIHVwZGF0ZXNUb0luZGV4KS5yZWR1Y2UocmVkdWNlcik7XG4gICAgICAgICAgICAgICAgaWYgKHN1bURpZmZzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkU2Nyb2xsKHN1bURpZmZzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRqdXN0VG9JbmRleCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogUmVzZXQgc2Nyb2xsIHBvc2l0aW9uLlxuICAgICAqIE5lZWRlZCBpbiBjYXNlIHNjcm9sbGJhciBpcyBoaWRkZW4vZGV0YWNoZWQgYnV0IHdlIHN0aWxsIG5lZWQgdG8gcmVzZXQgaXQuXG4gICAgICovXG4gICAgcHVibGljIHJlc2V0U2Nyb2xsUG9zaXRpb24oKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb24gPSAwO1xuICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudC5zY3JvbGxBbW91bnQgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcmVtb3ZlU2Nyb2xsRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gdGhpcy5zY3JvbGxDb21wb25lbnQ/Lm5hdGl2ZUVsZW1lbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuZnVuYykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PlxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50Py5uYXRpdmVFbGVtZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLnZlcnRpY2FsU2Nyb2xsSGFuZGxlcilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBzY3JvbGxpbmcgdmVydGljYWxseVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBvblNjcm9sbChldmVudCkge1xuICAgICAgICAvKiBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgdGhpcyBtYXkgYmUgY2FsbGVkIHdoZW4gbm8gc2Nyb2xsYmFyIGlzIHZpc2libGUgKi9cbiAgICAgICAgaWYgKCFwYXJzZUludCh0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50LnN0eWxlLmhlaWdodCwgMTApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9iU2Nyb2xsSW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGNWaXJ0dWFsU2Nyb2xsUG9zaXRpb24oZXZlbnQudGFyZ2V0LnNjcm9sbFRvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9iU2Nyb2xsSW50ZXJuYWwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2U3RhcnRJbmRleCA9IHRoaXMuc3RhdGUuc3RhcnRJbmRleDtcbiAgICAgICAgY29uc3Qgc2Nyb2xsT2Zmc2V0ID0gdGhpcy5maXhlZFVwZGF0ZUFsbEVsZW1lbnRzKHRoaXMuX3ZpcnRTY3JvbGxQb3NpdGlvbik7XG5cbiAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudG9wID0gLShzY3JvbGxPZmZzZXQpICsgJ3B4JztcblxuICAgICAgICB0aGlzLl96b25lLm9uU3RhYmxlLnBpcGUoZmlyc3QoKSkuc3Vic2NyaWJlKHRoaXMucmVjYWxjVXBkYXRlU2l6ZXMuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgdGhpcy5kYy5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIGlmIChwcmV2U3RhcnRJbmRleCAhPT0gdGhpcy5zdGF0ZS5zdGFydEluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLmNodW5rTG9hZC5lbWl0KHRoaXMuc3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIHVwZGF0ZVNjcm9sbCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgICBjb25zdCBzY3JvbGxBbW91bnQgPSB0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50W1wic2Nyb2xsTGVmdFwiXTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50LnNjcm9sbEFtb3VudCA9IHNjcm9sbEFtb3VudDtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNjcm9sbE9mZnNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHVwZGF0ZVNpemVzKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQuaXNDb25uZWN0ZWQpIHJldHVybjtcbiAgICAgICAgY29uc3Qgc2Nyb2xsYWJsZSA9IHRoaXMuaXNTY3JvbGxhYmxlKCk7XG4gICAgICAgIHRoaXMucmVjYWxjVXBkYXRlU2l6ZXMoKTtcbiAgICAgICAgdGhpcy5fYXBwbHlDaGFuZ2VzKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVNjcm9sbE9mZnNldCgpO1xuICAgICAgICBpZiAoc2Nyb2xsYWJsZSAhPT0gdGhpcy5pc1Njcm9sbGFibGUoKSkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxiYXJWaXNpYmlsaXR5Q2hhbmdlZC5lbWl0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRTaXplQ2hhbmdlLmVtaXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZml4ZWRVcGRhdGVBbGxFbGVtZW50cyhpblNjcm9sbFRvcDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLmlzUmVtb3RlID8gdGhpcy50b3RhbEl0ZW1Db3VudCA6IHRoaXMuaWd4Rm9yT2YubGVuZ3RoO1xuICAgICAgICBsZXQgbmV3U3RhcnQgPSB0aGlzLmdldEluZGV4QXQoaW5TY3JvbGxUb3AsIHRoaXMuc2l6ZXNDYWNoZSk7XG5cbiAgICAgICAgaWYgKG5ld1N0YXJ0ICsgdGhpcy5zdGF0ZS5jaHVua1NpemUgPiBjb3VudCkge1xuICAgICAgICAgICAgbmV3U3RhcnQgPSBjb3VudCAtIHRoaXMuc3RhdGUuY2h1bmtTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHJldlN0YXJ0ID0gdGhpcy5zdGF0ZS5zdGFydEluZGV4O1xuICAgICAgICBjb25zdCBkaWZmID0gbmV3U3RhcnQgLSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXg7XG4gICAgICAgIHRoaXMuc3RhdGUuc3RhcnRJbmRleCA9IG5ld1N0YXJ0O1xuXG4gICAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgICAgICB0aGlzLmNodW5rUHJlbG9hZC5lbWl0KHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzUmVtb3RlKSB7XG5cbiAgICAgICAgICAgICAgICAvLyByZWNhbGN1bGF0ZSBhbmQgYXBwbHkgcGFnZSBzaXplLlxuICAgICAgICAgICAgICAgIGlmIChkaWZmICYmIE1hdGguYWJzKGRpZmYpIDw9IE1BWF9QRVJGX1NDUk9MTF9ESUZGKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlQXBwbHlTY3JvbGxOZXh0KHByZXZTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVBcHBseVNjcm9sbFByZXYocHJldlN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZml4ZWRBcHBseVNjcm9sbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpblNjcm9sbFRvcCAtIHRoaXMuc2l6ZXNDYWNoZVt0aGlzLnN0YXRlLnN0YXJ0SW5kZXhdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBUaGUgZnVuY3Rpb24gYXBwbGllcyBhbiBvcHRpbWl6ZWQgc3RhdGUgY2hhbmdlIGZvciBzY3JvbGxpbmcgZG93bi9yaWdodCBlbXBsb3lpbmcgY29udGV4dCBjaGFuZ2Ugd2l0aCB2aWV3IHJlYXJyYW5nZW1lbnRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgbW92ZUFwcGx5U2Nyb2xsTmV4dChwcmV2SW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBjb25zdCBzdGFydCA9IHByZXZJbmRleCArIHRoaXMuc3RhdGUuY2h1bmtTaXplO1xuICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIHRoaXMuc3RhdGUuc3RhcnRJbmRleCAtIHByZXZJbmRleDtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5kYy5pbnN0YW5jZS5fdmNyIGFzIFZpZXdDb250YWluZXJSZWY7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kICYmIHRoaXMuaWd4Rm9yT2ZbaV0gIT09IHVuZGVmaW5lZDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbWJWaWV3ID0gdGhpcy5fZW1iZWRkZWRWaWV3cy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKCFlbWJWaWV3LmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRm9jdXMoZW1iVmlldy5yb290Tm9kZXMuZmluZChub2RlID0+IG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKVxuICAgICAgICAgICAgICAgICAgICB8fCBlbWJWaWV3LnJvb3ROb2Rlc1swXS5uZXh0RWxlbWVudFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBjb250YWluZXIuZGV0YWNoKDApO1xuXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUZW1wbGF0ZUNvbnRleHQoZW1iVmlldy5jb250ZXh0LCBpKTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuaW5zZXJ0KHZpZXcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtYmVkZGVkVmlld3MucHVzaChlbWJWaWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBUaGUgZnVuY3Rpb24gYXBwbGllcyBhbiBvcHRpbWl6ZWQgc3RhdGUgY2hhbmdlIGZvciBzY3JvbGxpbmcgdXAvbGVmdCBlbXBsb3lpbmcgY29udGV4dCBjaGFuZ2Ugd2l0aCB2aWV3IHJlYXJyYW5nZW1lbnRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgbW92ZUFwcGx5U2Nyb2xsUHJldihwcmV2SW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmRjLmluc3RhbmNlLl92Y3IgYXMgVmlld0NvbnRhaW5lclJlZjtcbiAgICAgICAgZm9yIChsZXQgaSA9IHByZXZJbmRleCAtIDE7IGkgPj0gdGhpcy5zdGF0ZS5zdGFydEluZGV4ICYmIHRoaXMuaWd4Rm9yT2ZbaV0gIT09IHVuZGVmaW5lZDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBlbWJWaWV3ID0gdGhpcy5fZW1iZWRkZWRWaWV3cy5wb3AoKTtcbiAgICAgICAgICAgIGlmICghZW1iVmlldy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEZvY3VzKGVtYlZpZXcucm9vdE5vZGVzLmZpbmQobm9kZSA9PiBub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSlcbiAgICAgICAgICAgICAgICAgICAgfHwgZW1iVmlldy5yb290Tm9kZXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gY29udGFpbmVyLmRldGFjaChjb250YWluZXIubGVuZ3RoIC0gMSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRlbXBsYXRlQ29udGV4dChlbWJWaWV3LmNvbnRleHQsIGkpO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5pbnNlcnQodmlldywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1iZWRkZWRWaWV3cy51bnNoaWZ0KGVtYlZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXRDb250ZXh0SW5kZXgoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNSZW1vdGUgPyB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggKyB0aGlzLmlneEZvck9mLmluZGV4T2YoaW5wdXQpIDogdGhpcy5pZ3hGb3JPZi5pbmRleE9mKGlucHV0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRnVuY3Rpb24gd2hpY2ggdXBkYXRlcyB0aGUgcGFzc2VkIGNvbnRleHQgb2YgYW4gZW1iZWRkZWQgdmlldyB3aXRoIHRoZSBwcm92aWRlZCBpbmRleFxuICAgICAqIGZyb20gdGhlIHZpZXcgY29udGFpbmVyLlxuICAgICAqIE9mdGVuLCBjYWxsZWQgd2hpbGUgaGFuZGxpbmcgYSBzY3JvbGwgZXZlbnQuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHVwZGF0ZVRlbXBsYXRlQ29udGV4dChjb250ZXh0OiBhbnksIGluZGV4ID0gMCk6IHZvaWQge1xuICAgICAgICBjb250ZXh0LiRpbXBsaWNpdCA9IHRoaXMuaWd4Rm9yT2ZbaW5kZXhdO1xuICAgICAgICBjb250ZXh0LmluZGV4ID0gdGhpcy5nZXRDb250ZXh0SW5kZXgodGhpcy5pZ3hGb3JPZltpbmRleF0pO1xuICAgICAgICBjb250ZXh0LmNvdW50ID0gdGhpcy5pZ3hGb3JPZi5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFRoZSBmdW5jdGlvbiBhcHBsaWVzIGFuIG9wdGltaXplZCBzdGF0ZSBjaGFuZ2UgdGhyb3VnaCBjb250ZXh0IGNoYW5nZSBmb3IgZWFjaCB2aWV3XG4gICAgICovXG4gICAgcHJvdGVjdGVkIGZpeGVkQXBwbHlTY3JvbGwoKTogdm9pZCB7XG4gICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgY29uc3QgZW5kSW5kZXggPSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggKyB0aGlzLnN0YXRlLmNodW5rU2l6ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGUuc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4ICYmIHRoaXMuaWd4Rm9yT2ZbaV0gIT09IHVuZGVmaW5lZDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbWJWaWV3ID0gdGhpcy5fZW1iZWRkZWRWaWV3c1tqKytdO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUZW1wbGF0ZUNvbnRleHQoZW1iVmlldy5jb250ZXh0LCBpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKlxuICAgICAqIENsZWFycyBmb2N1cyBpbnNpZGUgdGhlIHZpcnR1YWxpemVkIGNvbnRhaW5lciBvbiBzbWFsbCBzY3JvbGwgc3dhcHMuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHNjcm9sbEZvY3VzKG5vZGU/OiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb2N1bWVudCA9IG5vZGUuZ2V0Um9vdE5vZGUoKSBhcyBEb2N1bWVudCB8IFNoYWRvd1Jvb3Q7XG4gICAgICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGFzIEhUTUxFbGVtZW50O1xuXG4gICAgICAgIC8vIFJlbW92ZSBmb2N1cyBpbiBjYXNlIHRoZSB0aGUgYWN0aXZlIGVsZW1lbnQgaXMgaW5zaWRlIHRoZSB2aWV3IGNvbnRhaW5lci5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGhpdCBhbiBleGNlcHRpb24gd2hpbGUgZG9pbmcgdGhlICdzbWFsbCcgc2Nyb2xscyBzd2FwcGluZy5cbiAgICAgICAgLy8gRm9yIG1vcmUgaW5mb3JtYXRpb246XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlL3JlbW92ZUNoaWxkXG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQzMjM5MlxuICAgICAgICBpZiAobm9kZSAmJiBub2RlLmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICBhY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHNjcm9sbGluZyBob3Jpem9udGFsbHlcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgb25IU2Nyb2xsKGV2ZW50KSB7XG4gICAgICAgIC8qIGluIGNlcnRhaW4gc2l0dWF0aW9ucyB0aGlzIG1heSBiZSBjYWxsZWQgd2hlbiBubyBzY3JvbGxiYXIgaXMgdmlzaWJsZSAqL1xuICAgICAgICBjb25zdCBmaXJzdFNjcm9sbENoaWxkID0gdGhpcy5zY3JvbGxDb21wb25lbnQubmF0aXZlRWxlbWVudC5jaGlsZHJlbi5pdGVtKDApIGFzIEhUTUxFbGVtZW50O1xuICAgICAgICBpZiAoIXBhcnNlSW50KGZpcnN0U2Nyb2xsQ2hpbGQuc3R5bGUud2lkdGgsIDEwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fYlNjcm9sbEludGVybmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxjVmlydHVhbFNjcm9sbFBvc2l0aW9uKGV2ZW50LnRhcmdldC5zY3JvbGxMZWZ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2JTY3JvbGxJbnRlcm5hbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZTdGFydEluZGV4ID0gdGhpcy5zdGF0ZS5zdGFydEluZGV4O1xuICAgICAgICBjb25zdCBzY3JMZWZ0ID0gZXZlbnQudGFyZ2V0LnNjcm9sbExlZnQ7XG4gICAgICAgIC8vIFVwZGF0aW5nIGhvcml6b250YWwgY2h1bmtzXG4gICAgICAgIGNvbnN0IHNjcm9sbE9mZnNldCA9IHRoaXMuZml4ZWRVcGRhdGVBbGxFbGVtZW50cyhNYXRoLmFicyh0aGlzLl92aXJ0U2Nyb2xsUG9zaXRpb24pKTtcbiAgICAgICAgaWYgKHNjckxlZnQgPCAwKSB7XG4gICAgICAgICAgICAvLyBSVExcbiAgICAgICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLmxlZnQgPSBzY3JvbGxPZmZzZXQgKyAncHgnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUubGVmdCA9IC1zY3JvbGxPZmZzZXQgKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3pvbmUub25TdGFibGUucGlwZShmaXJzdCgpKS5zdWJzY3JpYmUodGhpcy5yZWNhbGNVcGRhdGVTaXplcy5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLmRjLmNoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgaWYgKHByZXZTdGFydEluZGV4ICE9PSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtMb2FkLmVtaXQodGhpcy5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmdW5jdGlvbiB1c2VkIHRvIHRyYWNrIGNoYW5nZXMgaW4gdGhlIGl0ZW1zIGNvbGxlY3Rpb24uXG4gICAgICogQnkgZGVmYXVsdCB0aGUgb2JqZWN0IHJlZmVyZW5jZXMgYXJlIGNvbXBhcmVkLiBIb3dldmVyIHRoaXMgY2FuIGJlIG9wdGltaXplZCBpZiB5b3UgaGF2ZSB1bmlxdWUgaWRlbnRpZmllclxuICAgICAqIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgZm9yIHRoZSBjb21wYXJpc29uIGluc3RlYWQgb2YgdGhlIG9iamVjdCByZWYgb3IgaWYgeW91IGhhdmUgc29tZSBvdGhlciBwcm9wZXJ0eSB2YWx1ZXNcbiAgICAgKiBpbiB0aGUgaXRlbSBvYmplY3QgdGhhdCBzaG91bGQgYmUgdHJhY2tlZCBmb3IgY2hhbmdlcy5cbiAgICAgKiBUaGlzIG9wdGlvbiBpcyBzaW1pbGFyIHRvIG5nRm9yVHJhY2tCeS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgdHJhY2tGdW5jID0gdGhpcy5wYXJlbnRWaXJ0RGlyLmlneEZvclRyYWNrQnk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGlneEZvclRyYWNrQnkoKTogVHJhY2tCeUZ1bmN0aW9uPFQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNrQnlGbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBmdW5jdGlvbiB1c2VkIHRvIHRyYWNrIGNoYW5nZXMgaW4gdGhlIGl0ZW1zIGNvbGxlY3Rpb24uXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgc2V0IGluIHNjZW5hcmlvcyB3aGVyZSB5b3Ugd2FudCB0byBvcHRpbWl6ZSBvclxuICAgICAqIGN1c3RvbWl6ZSB0aGUgdHJhY2tpbmcgb2YgY2hhbmdlcyBmb3IgdGhlIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqIFRoZSBpZ3hGb3JUcmFja0J5IGZ1bmN0aW9uIHRha2VzIHRoZSBpbmRleCBhbmQgdGhlIGN1cnJlbnQgaXRlbSBhcyBhcmd1bWVudHMgYW5kIG5lZWRzIHRvIHJldHVybiB0aGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgaXRlbS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5wYXJlbnRWaXJ0RGlyLmlneEZvclRyYWNrQnkgPSAoaW5kZXgsIGl0ZW0pID0+IHtcbiAgICAgKiAgICAgIHJldHVybiBpdGVtLmlkICsgaXRlbS53aWR0aDtcbiAgICAgKiB9O1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgaWd4Rm9yVHJhY2tCeShmbjogVHJhY2tCeUZ1bmN0aW9uPFQ+KSB7XG4gICAgICAgIHRoaXMuX3RyYWNrQnlGbiA9IGZuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2FwcGx5Q2hhbmdlcygpIHtcbiAgICAgICAgY29uc3QgcHJldkNodW5rU2l6ZSA9IHRoaXMuc3RhdGUuY2h1bmtTaXplO1xuICAgICAgICB0aGlzLmFwcGx5Q2h1bmtTaXplQ2hhbmdlKCk7XG4gICAgICAgIHRoaXMuX3JlY2FsY1Njcm9sbEJhclNpemUoKTtcbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yT2YgJiYgdGhpcy5pZ3hGb3JPZi5sZW5ndGggJiYgdGhpcy5kYykge1xuICAgICAgICAgICAgY29uc3QgZW1iZWRkZWRWaWV3Q29weSA9IE9iamVjdC5hc3NpZ24oW10sIHRoaXMuX2VtYmVkZGVkVmlld3MpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXg7XG4gICAgICAgICAgICBsZXQgZW5kSW5kZXggPSB0aGlzLnN0YXRlLmNodW5rU2l6ZSArIHRoaXMuc3RhdGUuc3RhcnRJbmRleDtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUmVtb3RlKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgZW5kSW5kZXggPSB0aGlzLmlneEZvck9mLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXggJiYgdGhpcy5pZ3hGb3JPZltpXSAhPT0gdW5kZWZpbmVkOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbWJWaWV3ID0gZW1iZWRkZWRWaWV3Q29weS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVGVtcGxhdGVDb250ZXh0KGVtYlZpZXcuY29udGV4dCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldkNodW5rU2l6ZSAhPT0gdGhpcy5zdGF0ZS5jaHVua1NpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rTG9hZC5lbWl0KHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfY2FsY01heEJyb3dzZXJTaXplKCk6IG51bWJlciB7XG4gICAgICAgIGlmICghdGhpcy5wbGF0Zm9ybVV0aWwuaXNCcm93c2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXYgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb25zdCBzdHlsZSA9IGRpdi5zdHlsZTtcbiAgICAgICAgc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBjb25zdCBkaXIgPSB0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAnbGVmdCcgOiAndG9wJztcbiAgICAgICAgc3R5bGVbZGlyXSA9ICc5OTk5OTk5OTk5OTk5OTk5cHgnO1xuICAgICAgICB0aGlzLmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IE1hdGguYWJzKGRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtkaXJdKTtcbiAgICAgICAgdGhpcy5kb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBSZWNhbGN1bGF0ZXMgdGhlIGNodW5rU2l6ZSBiYXNlZCBvbiBjdXJyZW50IHN0YXJ0SW5kZXggYW5kIHJldHVybnMgdGhlIG5ldyBzaXplLlxuICAgICAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggaXMgdXBkYXRlZCwgbm90IGJlZm9yZS5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2NhbGN1bGF0ZUNodW5rU2l6ZSgpOiBudW1iZXIge1xuICAgICAgICBsZXQgY2h1bmtTaXplID0gMDtcbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSAhPT0gbnVsbCAmJiB0aGlzLmlneEZvckNvbnRhaW5lclNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNpemVzQ2FjaGUgfHwgdGhpcy5zaXplc0NhY2hlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFNpemVzQ2FjaGUodGhpcy5pZ3hGb3JPZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaHVua1NpemUgPSB0aGlzLl9jYWxjTWF4Q2h1bmtTaXplKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pZ3hGb3JPZiAmJiBjaHVua1NpemUgPiB0aGlzLmlneEZvck9mLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNodW5rU2l6ZSA9IHRoaXMuaWd4Rm9yT2YubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWd4Rm9yT2YpIHtcbiAgICAgICAgICAgICAgICBjaHVua1NpemUgPSB0aGlzLmlneEZvck9mLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2h1bmtTaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0RWxlbWVudCh2aWV3cmVmLCBub2RlTmFtZSkge1xuICAgICAgICBjb25zdCBlbGVtID0gdmlld3JlZi5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucGFyZW50Tm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZShub2RlTmFtZSk7XG4gICAgICAgIHJldHVybiBlbGVtLmxlbmd0aCA+IDAgPyBlbGVtWzBdIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGluaXRTaXplc0NhY2hlKGl0ZW1zOiBVKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IHRvdGFsU2l6ZSA9IDA7XG4gICAgICAgIGxldCBzaXplID0gMDtcbiAgICAgICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5pZ3hGb3JTaXplUHJvcE5hbWUgfHwgJ2hlaWdodCc7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgdGhpcy5zaXplc0NhY2hlID0gW107XG4gICAgICAgIHRoaXMuaW5kaXZpZHVhbFNpemVDYWNoZSA9IFtdO1xuICAgICAgICB0aGlzLnNpemVzQ2FjaGUucHVzaCgwKTtcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLmlzUmVtb3RlID8gdGhpcy50b3RhbEl0ZW1Db3VudCA6IGl0ZW1zLmxlbmd0aDtcbiAgICAgICAgZm9yIChpOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgc2l6ZSA9IHRoaXMuX2dldEl0ZW1TaXplKGl0ZW1zW2ldLCBkaW1lbnNpb24pO1xuICAgICAgICAgICAgdGhpcy5pbmRpdmlkdWFsU2l6ZUNhY2hlLnB1c2goc2l6ZSk7XG4gICAgICAgICAgICB0b3RhbFNpemUgKz0gc2l6ZTtcbiAgICAgICAgICAgIHRoaXMuc2l6ZXNDYWNoZS5wdXNoKHRvdGFsU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsU2l6ZTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3VwZGF0ZVNpemVDYWNoZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgdGhpcy5pbml0U2l6ZXNDYWNoZSh0aGlzLmlneEZvck9mKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRIZWlnaHQgPSB0aGlzLmluZGl2aWR1YWxTaXplQ2FjaGUubGVuZ3RoID4gMCA/IHRoaXMuaW5kaXZpZHVhbFNpemVDYWNoZS5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwpIDogMDtcbiAgICAgICAgY29uc3QgbmV3SGVpZ2h0ID0gdGhpcy5pbml0U2l6ZXNDYWNoZSh0aGlzLmlneEZvck9mKTtcblxuICAgICAgICBjb25zdCBkaWZmID0gb2xkSGVpZ2h0IC0gbmV3SGVpZ2h0O1xuICAgICAgICB0aGlzLl9hZGp1c3RTY3JvbGxQb3NpdGlvbkFmdGVyU2l6ZUNoYW5nZShkaWZmKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9jYWxjTWF4Q2h1bmtTaXplKCk6IG51bWJlciB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgICAgIGxldCBtYXhMZW5ndGggPSAwO1xuICAgICAgICBjb25zdCBhcnIgPSBbXTtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZVNpemUgPSBwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKTtcbiAgICAgICAgaWYgKCFhdmFpbGFibGVTaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgP1xuICAgICAgICAgICAgdGhpcy5pZ3hGb3JTaXplUHJvcE5hbWUgOiAnaGVpZ2h0JztcbiAgICAgICAgY29uc3QgcmVkdWNlciA9IChhY2N1bXVsYXRvciwgY3VycmVudEl0ZW0pID0+IGFjY3VtdWxhdG9yICsgdGhpcy5fZ2V0SXRlbVNpemUoY3VycmVudEl0ZW0sIGRpbWVuc2lvbik7XG4gICAgICAgIGZvciAoaTsgaSA8IHRoaXMuaWd4Rm9yT2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpdGVtOiBUIHwgeyB2YWx1ZTogVCwgaGVpZ2h0OiBudW1iZXIgfSA9IHRoaXMuaWd4Rm9yT2ZbaV07XG4gICAgICAgICAgICBpZiAoZGltZW5zaW9uID09PSAnaGVpZ2h0Jykge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSB7IHZhbHVlOiB0aGlzLmlneEZvck9mW2ldLCBoZWlnaHQ6IHRoaXMuaW5kaXZpZHVhbFNpemVDYWNoZVtpXSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGRpbWVuc2lvbiA9PT0gJ2hlaWdodCcgP1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kaXZpZHVhbFNpemVDYWNoZVtpXSA6XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0SXRlbVNpemUoaXRlbSwgZGltZW5zaW9uKTtcbiAgICAgICAgICAgIHN1bSA9IGFyci5yZWR1Y2UocmVkdWNlciwgc2l6ZSk7XG4gICAgICAgICAgICBpZiAoc3VtIDwgYXZhaWxhYmxlU2l6ZSkge1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHRoaXMuaWd4Rm9yT2YubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZWFjaGVkIGVuZCB3aXRob3V0IGV4Y2VlZGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBpbmNsdWRlIHByZXYgaXRlbXMgdW50aWwgc2l6ZSBpcyBmaWxsZWQgb3IgZmlyc3QgaXRlbSBpcyByZWFjaGVkLlxuICAgICAgICAgICAgICAgICAgICBsZXQgY3VySXRlbSA9IGRpbWVuc2lvbiA9PT0gJ2hlaWdodCcgPyBhcnJbMF0udmFsdWUgOiBhcnJbMF07XG4gICAgICAgICAgICAgICAgICAgIGxldCBwcmV2SW5kZXggPSB0aGlzLmlneEZvck9mLmluZGV4T2YoY3VySXRlbSkgLSAxO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocHJldkluZGV4ID49IDAgJiYgc3VtIDw9IGF2YWlsYWJsZVNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckl0ZW0gPSBkaW1lbnNpb24gPT09ICdoZWlnaHQnID8gYXJyWzBdLnZhbHVlIDogYXJyWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkluZGV4ID0gdGhpcy5pZ3hGb3JPZi5pbmRleE9mKGN1ckl0ZW0pIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZJdGVtID0gdGhpcy5pZ3hGb3JPZltwcmV2SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldlNpemUgPSBkaW1lbnNpb24gPT09ICdoZWlnaHQnID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGl2aWR1YWxTaXplQ2FjaGVbcHJldkluZGV4XSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQocHJldkl0ZW1bZGltZW5zaW9uXSwgMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VtID0gYXJyLnJlZHVjZShyZWR1Y2VyLCBwcmV2U2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIudW5zaGlmdChwcmV2SXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBhcnIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBhcnIubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICBhcnIuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBtYXhMZW5ndGggPSBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heExlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldEluZGV4QXQobGVmdCwgc2V0KSB7XG4gICAgICAgIGxldCBzdGFydCA9IDA7XG4gICAgICAgIGxldCBlbmQgPSBzZXQubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pZElkeCA9IE1hdGguZmxvb3IoKHN0YXJ0ICsgZW5kKSAvIDIpO1xuICAgICAgICAgICAgY29uc3QgbWlkTGVmdCA9IHNldFttaWRJZHhdO1xuICAgICAgICAgICAgY29uc3QgY21wID0gbGVmdCAtIG1pZExlZnQ7XG4gICAgICAgICAgICBpZiAoY21wID4gMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gbWlkSWR4ICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgICAgIGVuZCA9IG1pZElkeCAtIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBtaWRJZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuZDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3JlY2FsY1Njcm9sbEJhclNpemUoY29udGFpbmVyU2l6ZUluZm8gPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5pc1JlbW90ZSA/IHRoaXMudG90YWxJdGVtQ291bnQgOiAodGhpcy5pZ3hGb3JPZiA/IHRoaXMuaWd4Rm9yT2YubGVuZ3RoIDogMCk7XG4gICAgICAgIHRoaXMuZGMuaW5zdGFuY2Uubm90VmlydHVhbCA9ICEodGhpcy5pZ3hGb3JDb250YWluZXJTaXplICYmIHRoaXMuZGMgJiYgdGhpcy5zdGF0ZS5jaHVua1NpemUgPCBjb3VudCk7XG4gICAgICAgIGNvbnN0IHNjcm9sbGFibGUgPSBjb250YWluZXJTaXplSW5mbyA/IHRoaXMuc2Nyb2xsQ29tcG9uZW50LnNpemUgPiBjb250YWluZXJTaXplSW5mby5wcmV2U2l6ZSA6IHRoaXMuaXNTY3JvbGxhYmxlKCk7XG4gICAgICAgIGlmICh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsV2lkdGggPSBwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKSA+IDAgPyB0aGlzLl9jYWxjU2l6ZSgpIDogMDtcbiAgICAgICAgICAgIGlmICh0b3RhbFdpZHRoIDw9IHBhcnNlSW50KHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSwgMTApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50LnN0eWxlLndpZHRoID0gdGhpcy5pZ3hGb3JDb250YWluZXJTaXplICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50LnNpemUgPSB0b3RhbFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICBjb25zdCB0b3RhbEhlaWdodCA9IHRoaXMuX2NhbGNTaXplKCk7XG4gICAgICAgICAgICBpZiAodG90YWxIZWlnaHQgPD0gcGFyc2VJbnQodGhpcy5pZ3hGb3JDb250YWluZXJTaXplLCAxMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gcGFyc2VJbnQodGhpcy5pZ3hGb3JDb250YWluZXJTaXplLCAxMCkgKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQuc2l6ZSA9IHRvdGFsSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY3JvbGxhYmxlICE9PSB0aGlzLmlzU2Nyb2xsYWJsZSgpKSB7XG4gICAgICAgICAgICAvLyBzY3JvbGxiYXIgdmlzaWJpbGl0eSBoYXMgY2hhbmdlZFxuICAgICAgICAgICAgdGhpcy5zY3JvbGxiYXJWaXNpYmlsaXR5Q2hhbmdlZC5lbWl0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2NhbGNTaXplKCk6IG51bWJlciB7XG4gICAgICAgIGxldCBzaXplO1xuICAgICAgICBpZiAodGhpcy5pbmRpdmlkdWFsU2l6ZUNhY2hlICYmIHRoaXMuaW5kaXZpZHVhbFNpemVDYWNoZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzaXplID0gdGhpcy5pbmRpdmlkdWFsU2l6ZUNhY2hlLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaXplID0gdGhpcy5pbml0U2l6ZXNDYWNoZSh0aGlzLmlneEZvck9mKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92aXJ0U2l6ZSA9IHNpemU7XG4gICAgICAgIGlmIChzaXplID4gdGhpcy5fbWF4U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fdmlydFJhdGlvID0gc2l6ZSAvIHRoaXMuX21heFNpemU7XG4gICAgICAgICAgICBzaXplID0gdGhpcy5fbWF4U2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3JlY2FsY09uQ29udGFpbmVyQ2hhbmdlKGNvbnRhaW5lclNpemVJbmZvID0gbnVsbCkge1xuICAgICAgICBjb25zdCBwcmV2Q2h1bmtTaXplID0gdGhpcy5zdGF0ZS5jaHVua1NpemU7XG4gICAgICAgIHRoaXMuYXBwbHlDaHVua1NpemVDaGFuZ2UoKTtcbiAgICAgICAgdGhpcy5fcmVjYWxjU2Nyb2xsQmFyU2l6ZShjb250YWluZXJTaXplSW5mbyk7XG4gICAgICAgIGlmIChwcmV2Q2h1bmtTaXplICE9PSB0aGlzLnN0YXRlLmNodW5rU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5jaHVua0xvYWQuZW1pdCh0aGlzLnN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBSZW1vdmVzIGFuIGVsZW1lbnQgZnJvbSB0aGUgZW1iZWRkZWQgdmlld3MgYW5kIHVwZGF0ZXMgY2h1bmtTaXplLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCByZW1vdmVMYXN0RWxlbSgpIHtcbiAgICAgICAgY29uc3Qgb2xkRWxlbSA9IHRoaXMuX2VtYmVkZGVkVmlld3MucG9wKCk7XG4gICAgICAgIHRoaXMuYmVmb3JlVmlld0Rlc3Ryb3llZC5lbWl0KG9sZEVsZW0pO1xuICAgICAgICAvLyBhbHNvIGRldGFjaCBmcm9tIFZpZXdDb250YWluZXJSZWYgdG8gbWFrZSBhYnNvbHV0ZWx5IHN1cmUgdGhpcyBpcyByZW1vdmVkIGZyb20gdGhlIHZpZXcgY29udGFpbmVyLlxuICAgICAgICB0aGlzLmRjLmluc3RhbmNlLl92Y3IuZGV0YWNoKHRoaXMuZGMuaW5zdGFuY2UuX3Zjci5sZW5ndGggLSAxKTtcbiAgICAgICAgb2xkRWxlbS5kZXN0cm95KCk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZS5jaHVua1NpemUtLTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogSWYgdGhlcmUgZXhpc3RzIGFuIGVsZW1lbnQgdGhhdCB3ZSBjYW4gY3JlYXRlIGVtYmVkZGVkIHZpZXcgZm9yIGNyZWF0ZXMgaXQsIGFwcGVuZHMgaXQgYW5kIHVwZGF0ZXMgY2h1bmtTaXplXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFkZExhc3RFbGVtKCkge1xuICAgICAgICBsZXQgZWxlbUluZGV4ID0gdGhpcy5zdGF0ZS5zdGFydEluZGV4ICsgdGhpcy5zdGF0ZS5jaHVua1NpemU7XG4gICAgICAgIGlmICghdGhpcy5pc1JlbW90ZSAmJiAhdGhpcy5pZ3hGb3JPZikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsZW1JbmRleCA+PSB0aGlzLmlneEZvck9mLmxlbmd0aCkge1xuICAgICAgICAgICAgZWxlbUluZGV4ID0gdGhpcy5pZ3hGb3JPZi5sZW5ndGggLSB0aGlzLnN0YXRlLmNodW5rU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMuaWd4Rm9yT2ZbZWxlbUluZGV4XTtcbiAgICAgICAgY29uc3QgZW1iZWRkZWRWaWV3ID0gdGhpcy5kYy5pbnN0YW5jZS5fdmNyLmNyZWF0ZUVtYmVkZGVkVmlldyhcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlLFxuICAgICAgICAgICAgbmV3IElneEZvck9mQ29udGV4dDxULCBVPihpbnB1dCwgdGhpcy5pZ3hGb3JPZiwgdGhpcy5nZXRDb250ZXh0SW5kZXgoaW5wdXQpLCB0aGlzLmlneEZvck9mLmxlbmd0aClcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLl9lbWJlZGRlZFZpZXdzLnB1c2goZW1iZWRkZWRWaWV3KTtcbiAgICAgICAgdGhpcy5zdGF0ZS5jaHVua1NpemUrKztcblxuICAgICAgICB0aGlzLl96b25lLnJ1bigoKSA9PiB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjYWxjdWxhdGVzIGNodW5rU2l6ZSBhbmQgYWRkcy9yZW1vdmVzIGVsZW1lbnRzIGlmIG5lZWQgZHVlIHRvIHRoZSBjaGFuZ2UuXG4gICAgICogdGhpcy5zdGF0ZS5jaHVua1NpemUgaXMgdXBkYXRlZCBpbiBAYWRkTGFzdEVsZW0oKSBvciBAcmVtb3ZlTGFzdEVsZW0oKVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBhcHBseUNodW5rU2l6ZUNoYW5nZSgpIHtcbiAgICAgICAgY29uc3QgY2h1bmtTaXplID0gdGhpcy5pc1JlbW90ZSA/ICh0aGlzLmlneEZvck9mID8gdGhpcy5pZ3hGb3JPZi5sZW5ndGggOiAwKSA6IHRoaXMuX2NhbGN1bGF0ZUNodW5rU2l6ZSgpO1xuICAgICAgICBpZiAoY2h1bmtTaXplID4gdGhpcy5zdGF0ZS5jaHVua1NpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBjaHVua1NpemUgLSB0aGlzLnN0YXRlLmNodW5rU2l6ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRMYXN0RWxlbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNodW5rU2l6ZSA8IHRoaXMuc3RhdGUuY2h1bmtTaXplKSB7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gdGhpcy5zdGF0ZS5jaHVua1NpemUgLSBjaHVua1NpemU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZmY7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGFzdEVsZW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBfY2FsY1ZpcnR1YWxTY3JvbGxQb3NpdGlvbihzY3JvbGxQb3NpdGlvbjogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclNpemUgPSBwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKTtcbiAgICAgICAgY29uc3QgbWF4UmVhbFNjcm9sbFBvc2l0aW9uID0gdGhpcy5zY3JvbGxDb21wb25lbnQuc2l6ZSAtIGNvbnRhaW5lclNpemU7XG4gICAgICAgIGNvbnN0IHJlYWxQZXJjZW50U2Nyb2xsZWQgPSBtYXhSZWFsU2Nyb2xsUG9zaXRpb24gIT09IDAgPyBzY3JvbGxQb3NpdGlvbiAvIG1heFJlYWxTY3JvbGxQb3NpdGlvbiA6IDA7XG4gICAgICAgIGNvbnN0IG1heFZpcnRTY3JvbGwgPSB0aGlzLl92aXJ0U2l6ZSAtIGNvbnRhaW5lclNpemU7XG4gICAgICAgIHRoaXMuX3ZpcnRTY3JvbGxQb3NpdGlvbiA9IHJlYWxQZXJjZW50U2Nyb2xsZWQgKiBtYXhWaXJ0U2Nyb2xsO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfZ2V0SXRlbVNpemUoaXRlbSwgZGltZW5zaW9uOiBzdHJpbmcpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBkaW0gPSBpdGVtID8gaXRlbVtkaW1lbnNpb25dIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkaW0gPT09ICdudW1iZXInID8gZGltIDogcGFyc2VJbnQodGhpcy5pZ3hGb3JJdGVtU2l6ZSwgMTApIHx8IDA7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF91cGRhdGVTY3JvbGxPZmZzZXQoKSB7XG4gICAgICAgIGxldCBzY3JvbGxPZmZzZXQgPSAwO1xuICAgICAgICBsZXQgY3VycmVudFNjcm9sbCA9IHRoaXMuc2Nyb2xsUG9zaXRpb247XG4gICAgICAgIGlmICh0aGlzLl92aXJ0UmF0aW8gIT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGNWaXJ0dWFsU2Nyb2xsUG9zaXRpb24odGhpcy5zY3JvbGxQb3NpdGlvbik7XG4gICAgICAgICAgICBjdXJyZW50U2Nyb2xsID0gdGhpcy5fdmlydFNjcm9sbFBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjcm9sbCA9IHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHNjcm9sbE9mZnNldCA9IHNjcm9sbCAmJiB0aGlzLnNjcm9sbENvbXBvbmVudC5zaXplID9cbiAgICAgICAgY3VycmVudFNjcm9sbCAtIHRoaXMuc2l6ZXNDYWNoZVt0aGlzLnN0YXRlLnN0YXJ0SW5kZXhdIDogMDtcbiAgICAgICAgY29uc3QgZGlyID0gdGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlW2Rpcl0gPSAtKHNjcm9sbE9mZnNldCkgKyAncHgnO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfYWRqdXN0U2Nyb2xsUG9zaXRpb25BZnRlclNpemVDaGFuZ2Uoc2l6ZURpZmYpIHtcbiAgICAgICAgLy8gaWYgZGF0YSBoYXMgYmVlbiBjaGFuZ2VkIHdoaWxlIGNvbnRhaW5lciBpcyBzY3JvbGxlZFxuICAgICAgICAvLyBzaG91bGQgdXBkYXRlIHNjcm9sbCB0b3AvbGVmdCBhY2NvcmRpbmcgdG8gY2hhbmdlIHNvIHRoYXQgc2FtZSBzdGFydEluZGV4IGlzIGluIHZpZXdcbiAgICAgICAgaWYgKE1hdGguYWJzKHNpemVEaWZmKSA+IDAgJiYgdGhpcy5zY3JvbGxQb3NpdGlvbiA+IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVjYWxjVXBkYXRlU2l6ZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQodGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUubGVmdCwgMTApIDpcbiAgICAgICAgICAgICAgICBwYXJzZUludCh0aGlzLmRjLmluc3RhbmNlLl92aWV3Q29udGFpbmVyLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS50b3AsIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NpemUgPSB0aGlzLnNpemVzQ2FjaGVbdGhpcy5zdGF0ZS5zdGFydEluZGV4XSAtIG9mZnNldDtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb24gPSBuZXdTaXplO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Nyb2xsUG9zaXRpb24gIT09IG5ld1NpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudC5zY3JvbGxBbW91bnQgPSBuZXdTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRNYXJnaW4obm9kZSwgZGltZW5zaW9uOiBzdHJpbmcpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICAgICAgaWYgKGRpbWVuc2lvbiA9PT0gJ2hlaWdodCcpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHN0eWxlc1snbWFyZ2luVG9wJ10pICtcbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHN0eWxlc1snbWFyZ2luQm90dG9tJ10pIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGVzWydtYXJnaW5MZWZ0J10pICtcbiAgICAgICAgICAgIHBhcnNlRmxvYXQoc3R5bGVzWydtYXJnaW5SaWdodCddKSB8fCAwO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IGdldFR5cGVOYW1lRm9yRGVidWdnaW5nID0gKHR5cGU6IGFueSk6IHN0cmluZyA9PiB0eXBlLm5hbWUgfHwgdHlwZW9mIHR5cGU7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUZvck9mU3RhdGUgZXh0ZW5kcyBJQmFzZUV2ZW50QXJncyB7XG4gICAgc3RhcnRJbmRleD86IG51bWJlcjtcbiAgICBjaHVua1NpemU/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUZvck9mRGF0YUNoYW5naW5nRXZlbnRBcmdzIGV4dGVuZHMgSUJhc2VFdmVudEFyZ3Mge1xuICAgIGNvbnRhaW5lclNpemU6IG51bWJlcjtcbiAgICBzdGF0ZTogSUZvck9mU3RhdGU7XG59XG5cbmV4cG9ydCBjbGFzcyBJZ3hHcmlkRm9yT2ZDb250ZXh0PFQsIFUgZXh0ZW5kcyBUW10gPSBUW10+IGV4dGVuZHMgSWd4Rm9yT2ZDb250ZXh0PFQsIFU+IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgJGltcGxpY2l0OiBULFxuICAgICAgICBwdWJsaWMgaWd4R3JpZEZvck9mOiBVLFxuICAgICAgICBpbmRleDogbnVtYmVyLFxuICAgICAgICBjb3VudDogbnVtYmVyXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKCRpbXBsaWNpdCwgaWd4R3JpZEZvck9mLCBpbmRleCwgY291bnQpO1xuICAgIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbaWd4R3JpZEZvcl1baWd4R3JpZEZvck9mXScsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hHcmlkRm9yT2ZEaXJlY3RpdmU8VCwgVSBleHRlbmRzIFRbXSA9IFRbXT4gZXh0ZW5kcyBJZ3hGb3JPZkRpcmVjdGl2ZTxULCBVPiBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBEb0NoZWNrIHtcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgaWd4R3JpZEZvck9mKHZhbHVlOiBVICYgVFtdIHwgbnVsbCkge1xuICAgICAgICB0aGlzLmlneEZvck9mID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBpZ3hHcmlkRm9yT2YoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlneEZvck9mO1xuICAgIH1cblxuICAgIEBJbnB1dCh7IHRyYW5zZm9ybTogYm9vbGVhbkF0dHJpYnV0ZSB9KVxuICAgIHB1YmxpYyBpZ3hHcmlkRm9yT2ZVbmlxdWVTaXplQ2FjaGUgPSBmYWxzZTtcblxuICAgIEBJbnB1dCh7IHRyYW5zZm9ybTogYm9vbGVhbkF0dHJpYnV0ZSB9KVxuICAgIHB1YmxpYyBpZ3hHcmlkRm9yT2ZWYXJpYWJsZVNpemVzID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgZ2V0IHNpemVzQ2FjaGUoKTogbnVtYmVyW10ge1xuICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZ3hHcmlkRm9yT2ZVbmlxdWVTaXplQ2FjaGUgfHwgdGhpcy5zeW5jU2VydmljZS5pc01hc3Rlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaXplc0NhY2hlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3luY1NlcnZpY2Uuc2l6ZXNDYWNoZSh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaXplc0NhY2hlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgc2V0IHNpemVzQ2FjaGUodmFsdWU6IG51bWJlcltdKSB7XG4gICAgICAgIHRoaXMuX3NpemVzQ2FjaGUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0IGl0ZW1zRGltZW5zaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZ3hGb3JTaXplUHJvcE5hbWUgfHwgJ2hlaWdodCc7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIHJlY2FsY1VwZGF0ZVNpemVzKCkge1xuICAgICAgICBpZiAodGhpcy5pZ3hHcmlkRm9yT2ZWYXJpYWJsZVNpemVzICYmIHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIHN1cGVyLnJlY2FsY1VwZGF0ZVNpemVzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCBhZnRlciBkYXRhIGhhcyBiZWVuIGNoYW5nZWQgYnV0IGJlZm9yZSB0aGUgdmlldyBpcyByZWZyZXNoZWRcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgZGF0YUNoYW5naW5nID0gbmV3IEV2ZW50RW1pdHRlcjxJRm9yT2ZEYXRhQ2hhbmdpbmdFdmVudEFyZ3M+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgX3ZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgIF90ZW1wbGF0ZTogVGVtcGxhdGVSZWY8TmdGb3JPZkNvbnRleHQ8VD4+LFxuICAgICAgICBfZGlmZmVyczogSXRlcmFibGVEaWZmZXJzLFxuICAgICAgICBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBfem9uZTogTmdab25lLFxuICAgICAgICBfcGxhdGZvcm1VdGlsOiBQbGF0Zm9ybVV0aWwsXG4gICAgICAgIEBJbmplY3QoRE9DVU1FTlQpIF9kb2N1bWVudDogYW55LFxuICAgICAgICBzeW5jU2Nyb2xsU2VydmljZTogSWd4Rm9yT2ZTY3JvbGxTeW5jU2VydmljZSxcbiAgICAgICAgcHJvdGVjdGVkIHN5bmNTZXJ2aWNlOiBJZ3hGb3JPZlN5bmNTZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKF92aWV3Q29udGFpbmVyLCBfdGVtcGxhdGUsIF9kaWZmZXJzLCBjZHIsIF96b25lLCBzeW5jU2Nyb2xsU2VydmljZSwgX3BsYXRmb3JtVXRpbCwgX2RvY3VtZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEFzc2VydHMgdGhlIGNvcnJlY3QgdHlwZSBvZiB0aGUgY29udGV4dCBmb3IgdGhlIHRlbXBsYXRlIHRoYXQgYElneEdyaWRGb3JPZkRpcmVjdGl2ZWAgd2lsbCByZW5kZXIuXG4gICAgICpcbiAgICAgKiBUaGUgcHJlc2VuY2Ugb2YgdGhpcyBtZXRob2QgaXMgYSBzaWduYWwgdG8gdGhlIEl2eSB0ZW1wbGF0ZSB0eXBlLWNoZWNrIGNvbXBpbGVyIHRoYXQgdGhlXG4gICAgICogYElneEdyaWRGb3JPZkRpcmVjdGl2ZWAgc3RydWN0dXJhbCBkaXJlY3RpdmUgcmVuZGVycyBpdHMgdGVtcGxhdGUgd2l0aCBhIHNwZWNpZmljIGNvbnRleHQgdHlwZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIG92ZXJyaWRlIG5nVGVtcGxhdGVDb250ZXh0R3VhcmQ8VCwgVSBleHRlbmRzIFRbXT4oZGlyOiBJZ3hHcmlkRm9yT2ZEaXJlY3RpdmU8VCwgVT4sIGN0eDogYW55KTpcbiAgICAgICAgY3R4IGlzIElneEdyaWRGb3JPZkNvbnRleHQ8VCwgVT4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuc3luY1NlcnZpY2Uuc2V0TWFzdGVyKHRoaXMpO1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICB0aGlzLnJlbW92ZVNjcm9sbEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICAgICAgY29uc3QgZm9yT2YgPSAnaWd4R3JpZEZvck9mJztcbiAgICAgICAgdGhpcy5zeW5jU2VydmljZS5zZXRNYXN0ZXIodGhpcyk7XG4gICAgICAgIGlmIChmb3JPZiBpbiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNoYW5nZXNbZm9yT2ZdLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZGlmZmVyICYmIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlmZmVyID0gdGhpcy5fZGlmZmVycy5maW5kKHZhbHVlKS5jcmVhdGUodGhpcy5pZ3hGb3JUcmFja0J5KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGBDYW5ub3QgZmluZCBhIGRpZmZlciBzdXBwb3J0aW5nIG9iamVjdCBcIiR7dmFsdWV9XCIgb2YgdHlwZSBcIiR7Z2V0VHlwZU5hbWVGb3JEZWJ1Z2dpbmcodmFsdWUpfVwiLlxuICAgICAgICAgICAgICAgICAgICAgTmdGb3Igb25seSBzdXBwb3J0cyBiaW5kaW5nIHRvIEl0ZXJhYmxlcyBzdWNoIGFzIEFycmF5cy5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gY2FzZSBjb2xsZWN0aW9uIGhhcyBjaGFuZ2VzLCByZXNldCBzeW5jIHNlcnZpY2VcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmNTZXJ2aWNlLnNldE1hc3Rlcih0aGlzLCB0aGlzLmlneEdyaWRGb3JPZlVuaXF1ZVNpemVDYWNoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmYXVsdEl0ZW1TaXplID0gJ2lneEZvckl0ZW1TaXplJztcbiAgICAgICAgaWYgKGRlZmF1bHRJdGVtU2l6ZSBpbiBjaGFuZ2VzICYmICFjaGFuZ2VzW2RlZmF1bHRJdGVtU2l6ZV0uZmlyc3RDaGFuZ2UgJiZcbiAgICAgICAgICAgIHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgJiYgdGhpcy5pZ3hGb3JPZikge1xuICAgICAgICAgICAgLy8gaGFuZGxlIGRlZmF1bHQgaXRlbSBzaXplIGNoYW5nZWQuXG4gICAgICAgICAgICB0aGlzLmluaXRTaXplc0NhY2hlKHRoaXMuaWd4Rm9yT2YpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclNpemUgPSAnaWd4Rm9yQ29udGFpbmVyU2l6ZSc7XG4gICAgICAgIGlmIChjb250YWluZXJTaXplIGluIGNoYW5nZXMgJiYgIWNoYW5nZXNbY29udGFpbmVyU2l6ZV0uZmlyc3RDaGFuZ2UgJiYgdGhpcy5pZ3hGb3JPZikge1xuICAgICAgICAgICAgY29uc3QgcHJldlNpemUgPSBwYXJzZUludChjaGFuZ2VzW2NvbnRhaW5lclNpemVdLnByZXZpb3VzVmFsdWUsIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NpemUgPSBwYXJzZUludChjaGFuZ2VzW2NvbnRhaW5lclNpemVdLmN1cnJlbnRWYWx1ZSwgMTApO1xuICAgICAgICAgICAgdGhpcy5fcmVjYWxjT25Db250YWluZXJDaGFuZ2Uoe3ByZXZTaXplLCBuZXdTaXplfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGFzc3VtZU1hc3RlcigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc2l6ZXNDYWNoZSA9IHRoaXMuc3luY1NlcnZpY2Uuc2l6ZXNDYWNoZSh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uKTtcbiAgICAgICAgdGhpcy5zeW5jU2VydmljZS5zZXRNYXN0ZXIodGhpcywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIG5nRG9DaGVjaygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpZmZlcikge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuX2RpZmZlci5kaWZmKHRoaXMuaWd4Rm9yT2YpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzOiBJRm9yT2ZEYXRhQ2hhbmdpbmdFdmVudEFyZ3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lclNpemU6IHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNoYW5naW5nLmVtaXQoYXJncyk7XG4gICAgICAgICAgICAgICAgLy8gIHJlLWluaXQgY2FjaGUuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlneEZvck9mKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaWd4Rm9yT2YgPSBbXSBhcyBVO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiB3ZSBuZWVkIHRvIHJlc2V0IHRoZSBtYXN0ZXIgZGlyIGlmIGFsbCByb3dzIGFyZSByZW1vdmVkXG4gICAgICAgICAgICAgICAgKGUuZy4gYmVjYXVzZSBvZiBmaWx0ZXJpbmcpOyBpZiBhbGwgY29sdW1ucyBhcmUgaGlkZGVuLCByb3dzIGFyZVxuICAgICAgICAgICAgICAgIHN0aWxsIHJlbmRlcmVkIGVtcHR5LCBzbyB3ZSBzaG91bGQgbm90IHJlc2V0IG1hc3RlciAqL1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pZ3hGb3JPZi5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN5bmNTZXJ2aWNlLnJlc2V0TWFzdGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3luY1NlcnZpY2Uuc2V0TWFzdGVyKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSA9IGFyZ3MuY29udGFpbmVyU2l6ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplRGlmZiA9IHRoaXMuX3VwZGF0ZVNpemVDYWNoZShjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUNoYW5nZXMoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZURpZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRqdXN0U2Nyb2xsUG9zaXRpb25BZnRlclNpemVDaGFuZ2Uoc2l6ZURpZmYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTY3JvbGxPZmZzZXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFDaGFuZ2VkLmVtaXQoYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgb25TY3JvbGwoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFwYXJzZUludCh0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50LnN0eWxlLmhlaWdodCwgMTApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9iU2Nyb2xsSW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGNWaXJ0dWFsU2Nyb2xsUG9zaXRpb24oZXZlbnQudGFyZ2V0LnNjcm9sbFRvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9iU2Nyb2xsSW50ZXJuYWwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY3JvbGxPZmZzZXQgPSB0aGlzLmZpeGVkVXBkYXRlQWxsRWxlbWVudHModGhpcy5fdmlydFNjcm9sbFBvc2l0aW9uKTtcblxuICAgICAgICB0aGlzLmRjLmluc3RhbmNlLl92aWV3Q29udGFpbmVyLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS50b3AgPSAtKHNjcm9sbE9mZnNldCkgKyAncHgnO1xuXG4gICAgICAgIHRoaXMuX3pvbmUub25TdGFibGUucGlwZShmaXJzdCgpKS5zdWJzY3JpYmUodGhpcy5yZWNhbGNVcGRhdGVTaXplcy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIG9uSFNjcm9sbChzY3JvbGxBbW91bnQpIHtcbiAgICAgICAgLyogaW4gY2VydGFpbiBzaXR1YXRpb25zIHRoaXMgbWF5IGJlIGNhbGxlZCB3aGVuIG5vIHNjcm9sbGJhciBpcyB2aXNpYmxlICovXG4gICAgICAgIGNvbnN0IGZpcnN0U2Nyb2xsQ2hpbGQgPSB0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50LmNoaWxkcmVuLml0ZW0oMCkgYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgIGlmICghdGhpcy5zY3JvbGxDb21wb25lbnQgfHwgIXBhcnNlSW50KGZpcnN0U2Nyb2xsQ2hpbGQuc3R5bGUud2lkdGgsIDEwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0aW5nIGhvcml6b250YWwgY2h1bmtzXG4gICAgICAgIGNvbnN0IHNjcm9sbE9mZnNldCA9IHRoaXMuZml4ZWRVcGRhdGVBbGxFbGVtZW50cyhNYXRoLmFicyhzY3JvbGxBbW91bnQpKTtcbiAgICAgICAgaWYgKHNjcm9sbEFtb3VudCA8IDApIHtcbiAgICAgICAgICAgIC8vIFJUTFxuICAgICAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUubGVmdCA9IHNjcm9sbE9mZnNldCArICdweCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBMVFJcbiAgICAgICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLmxlZnQgPSAtc2Nyb2xsT2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXRJdGVtU2l6ZShpdGVtKSB7XG4gICAgICAgIGxldCBzaXplID0gMDtcbiAgICAgICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5pZ3hGb3JTaXplUHJvcE5hbWUgfHwgJ2hlaWdodCc7XG4gICAgICAgIGlmICh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICBzaXplID0gdGhpcy5fZ2V0SXRlbVNpemUoaXRlbSwgZGltZW5zaW9uKTtcbiAgICAgICAgICAgIGlmIChpdGVtICYmIGl0ZW0uc3VtbWFyaWVzKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IGl0ZW0ubWF4O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtICYmIGl0ZW0uZ3JvdXBzICYmIGl0ZW0uaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IGl0ZW0uaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2l6ZSA9IHBhcnNlSW50KGl0ZW1bZGltZW5zaW9uXSwgMTApIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIG92ZXJyaWRlIGluaXRTaXplc0NhY2hlKGl0ZW1zOiBVKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKCF0aGlzLnN5bmNTZXJ2aWNlLmlzTWFzdGVyKHRoaXMpICYmIHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgY29uc3QgbWFzdGVyU2l6ZXNDYWNoZSA9IHRoaXMuc3luY1NlcnZpY2Uuc2l6ZXNDYWNoZSh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBtYXN0ZXJTaXplc0NhY2hlW21hc3RlclNpemVzQ2FjaGUubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvdGFsU2l6ZSA9IDA7XG4gICAgICAgIGxldCBzaXplID0gMDtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB0aGlzLnNpemVzQ2FjaGUgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRpdmlkdWFsU2l6ZUNhY2hlID0gW107XG4gICAgICAgIHRoaXMuc2l6ZXNDYWNoZS5wdXNoKDApO1xuICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMuaXNSZW1vdGUgPyB0aGlzLnRvdGFsSXRlbUNvdW50IDogaXRlbXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGk7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBzaXplID0gdGhpcy5nZXRJdGVtU2l6ZShpdGVtc1tpXSk7XG4gICAgICAgICAgICB0aGlzLmluZGl2aWR1YWxTaXplQ2FjaGUucHVzaChzaXplKTtcbiAgICAgICAgICAgIHRvdGFsU2l6ZSArPSBzaXplO1xuICAgICAgICAgICAgdGhpcy5zaXplc0NhY2hlLnB1c2godG90YWxTaXplKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWxTaXplO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBvdmVycmlkZSBfdXBkYXRlU2l6ZUNhY2hlKGNoYW5nZXM6IEl0ZXJhYmxlQ2hhbmdlczxUPiA9IG51bGwpIHtcbiAgICAgICAgY29uc3Qgb2xkU2l6ZSA9IHRoaXMuaW5kaXZpZHVhbFNpemVDYWNoZS5sZW5ndGggPiAwID8gdGhpcy5pbmRpdmlkdWFsU2l6ZUNhY2hlLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCkgOiAwO1xuICAgICAgICBsZXQgbmV3U2l6ZSA9IG9sZFNpemU7XG4gICAgICAgIGlmIChjaGFuZ2VzICYmICF0aGlzLmlzUmVtb3RlKSB7XG4gICAgICAgICAgICBuZXdTaXplID0gdGhpcy5oYW5kbGVDYWNoZUNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkaWZmID0gb2xkU2l6ZSAtIG5ld1NpemU7XG4gICAgICAgIHJldHVybiBkaWZmO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBoYW5kbGVDYWNoZUNoYW5nZXMoY2hhbmdlczogSXRlcmFibGVDaGFuZ2VzPFQ+KSB7XG4gICAgICAgIGNvbnN0IGlkZW50aXR5Q2hhbmdlcyA9IFtdO1xuICAgICAgICBjb25zdCBuZXdIZWlnaHRDYWNoZSA9IFtdO1xuICAgICAgICBjb25zdCBuZXdTaXplc0NhY2hlID0gW107XG4gICAgICAgIG5ld1NpemVzQ2FjaGUucHVzaCgwKTtcbiAgICAgICAgbGV0IG5ld0hlaWdodCA9IDA7XG5cbiAgICAgICAgLy8gV2hlbiB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uZSByZW1vdmVkIGl0ZW1zIHRoZSBjaGFuZ2VzIGFyZSBub3QgcmVsaWFibGUgc28gdGhvc2Ugd2l0aCBpZGVudGl0eSBjaGFuZ2Ugc2hvdWxkIGJlIGRlZmF1bHQgc2l6ZS5cbiAgICAgICAgbGV0IG51bVJlbW92ZWRJdGVtcyA9IDA7XG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaFJlbW92ZWRJdGVtKCgpID0+IG51bVJlbW92ZWRJdGVtcysrKTtcblxuICAgICAgICAvLyBHZXQgdGhlIGlkZW50aXR5IGNoYW5nZXMgdG8gZGV0ZXJtaW5lIGxhdGVyIGlmIHRob3NlIHRoYXQgaGF2ZSBjaGFuZ2VkIHRoZWlyIGluZGV4ZXMgc2hvdWxkIGJlIGFzc2lnbmVkIGRlZmF1bHQgaXRlbSBzaXplLlxuICAgICAgICBjaGFuZ2VzLmZvckVhY2hJZGVudGl0eUNoYW5nZSgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0uY3VycmVudEluZGV4ICE9PSBpdGVtLnByZXZpb3VzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IG9uZXMgdGhhdCBoYXZlIG5vdCBjaGFuZ2VkIHRoZWlyIGluZGV4LlxuICAgICAgICAgICAgICAgIGlkZW50aXR5Q2hhbmdlc1tpdGVtLmN1cnJlbnRJbmRleF0gPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBQcm9jZXNzaW5nIGVhY2ggaXRlbSB0aGF0IGlzIHBhc3NlZCB0byB0aGUgaWd4Rm9yT2Ygc28gZmFyIHNlZW0gdG8gYmUgbW9zdCByZWxpYWJsZS4gV2UgcGFyc2UgdGhlIHVwZGF0ZWQgbGlzdCBvZiBpdGVtcy5cbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoSXRlbSgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0ucHJldmlvdXNJbmRleCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIChudW1SZW1vdmVkSXRlbXMgPCAyIHx8ICFpZGVudGl0eUNoYW5nZXMubGVuZ3RoIHx8IGlkZW50aXR5Q2hhbmdlc1tpdGVtLmN1cnJlbnRJbmRleF0pXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiAhPT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXVzZSBjYWNoZSBvbiB0aG9zZSB3aG8gaGF2ZSBwcmV2aW91c0luZGV4LlxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgcmVtb3ZlZCBpdGVtcyBjdXJyZW50bHkgdGhlIGNoYW5nZXMgYXJlIG5vdCByZWFkYWJsZSBzbyBvbmVzIHdpdGggaWRlbnRpdHkgY2hhbmdlXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIHJhY2FsY3VsYXRlZC5cbiAgICAgICAgICAgICAgICBuZXdIZWlnaHRDYWNoZVtpdGVtLmN1cnJlbnRJbmRleF0gPSB0aGlzLmluZGl2aWR1YWxTaXplQ2FjaGVbaXRlbS5wcmV2aW91c0luZGV4XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQXNzaWduIGRlZmF1bHQgaXRlbSBzaXplLlxuICAgICAgICAgICAgICAgIG5ld0hlaWdodENhY2hlW2l0ZW0uY3VycmVudEluZGV4XSA9IHRoaXMuZ2V0SXRlbVNpemUoaXRlbS5pdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1NpemVzQ2FjaGVbaXRlbS5jdXJyZW50SW5kZXggKyAxXSA9IG5ld1NpemVzQ2FjaGVbaXRlbS5jdXJyZW50SW5kZXhdICsgbmV3SGVpZ2h0Q2FjaGVbaXRlbS5jdXJyZW50SW5kZXhdO1xuICAgICAgICAgICAgbmV3SGVpZ2h0ICs9IG5ld0hlaWdodENhY2hlW2l0ZW0uY3VycmVudEluZGV4XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5kaXZpZHVhbFNpemVDYWNoZSA9IG5ld0hlaWdodENhY2hlO1xuICAgICAgICB0aGlzLnNpemVzQ2FjaGUgPSBuZXdTaXplc0NhY2hlO1xuICAgICAgICByZXR1cm4gbmV3SGVpZ2h0O1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBvdmVycmlkZSBhZGRMYXN0RWxlbSgpIHtcbiAgICAgICAgbGV0IGVsZW1JbmRleCA9IHRoaXMuc3RhdGUuc3RhcnRJbmRleCArIHRoaXMuc3RhdGUuY2h1bmtTaXplO1xuICAgICAgICBpZiAoIXRoaXMuaXNSZW1vdGUgJiYgIXRoaXMuaWd4Rm9yT2YpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbGVtSW5kZXggPj0gdGhpcy5pZ3hGb3JPZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVsZW1JbmRleCA9IHRoaXMuaWd4Rm9yT2YubGVuZ3RoIC0gdGhpcy5zdGF0ZS5jaHVua1NpemU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLmlneEZvck9mW2VsZW1JbmRleF07XG4gICAgICAgIGNvbnN0IGVtYmVkZGVkVmlldyA9IHRoaXMuZGMuaW5zdGFuY2UuX3Zjci5jcmVhdGVFbWJlZGRlZFZpZXcoXG4gICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZSxcbiAgICAgICAgICAgIG5ldyBJZ3hHcmlkRm9yT2ZDb250ZXh0PFQsIFU+KGlucHV0LCB0aGlzLmlneEZvck9mLCB0aGlzLmdldENvbnRleHRJbmRleChpbnB1dCksIHRoaXMuaWd4Rm9yT2YubGVuZ3RoKVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuX2VtYmVkZGVkVmlld3MucHVzaChlbWJlZGRlZFZpZXcpO1xuICAgICAgICB0aGlzLnN0YXRlLmNodW5rU2l6ZSsrO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfdXBkYXRlVmlld3MocHJldkNodW5rU2l6ZSkge1xuICAgICAgICBpZiAodGhpcy5pZ3hGb3JPZiAmJiB0aGlzLmlneEZvck9mLmxlbmd0aCAmJiB0aGlzLmRjKSB7XG4gICAgICAgICAgICBjb25zdCBlbWJlZGRlZFZpZXdDb3B5ID0gT2JqZWN0LmFzc2lnbihbXSwgdGhpcy5fZW1iZWRkZWRWaWV3cyk7XG4gICAgICAgICAgICBsZXQgc3RhcnRJbmRleDtcbiAgICAgICAgICAgIGxldCBlbmRJbmRleDtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUmVtb3RlKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgZW5kSW5kZXggPSB0aGlzLmlneEZvck9mLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IHRoaXMuZ2V0SW5kZXhBdCh0aGlzLnNjcm9sbFBvc2l0aW9uLCB0aGlzLnNpemVzQ2FjaGUpO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydEluZGV4ICsgdGhpcy5zdGF0ZS5jaHVua1NpemUgPiB0aGlzLmlneEZvck9mLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gdGhpcy5pZ3hGb3JPZi5sZW5ndGggLSB0aGlzLnN0YXRlLmNodW5rU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zdGFydEluZGV4ID0gc3RhcnRJbmRleDtcbiAgICAgICAgICAgICAgICBlbmRJbmRleCA9IHRoaXMuc3RhdGUuY2h1bmtTaXplICsgdGhpcy5zdGF0ZS5zdGFydEluZGV4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4ICYmIHRoaXMuaWd4Rm9yT2ZbaV0gIT09IHVuZGVmaW5lZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW1iVmlldyA9IGVtYmVkZGVkVmlld0NvcHkuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRlbXBsYXRlQ29udGV4dChlbWJWaWV3LmNvbnRleHQsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXZDaHVua1NpemUgIT09IHRoaXMuc3RhdGUuY2h1bmtTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaHVua0xvYWQuZW1pdCh0aGlzLnN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgX2FwcGx5Q2hhbmdlcygpIHtcbiAgICAgICAgY29uc3QgcHJldkNodW5rU2l6ZSA9IHRoaXMuc3RhdGUuY2h1bmtTaXplO1xuICAgICAgICB0aGlzLmFwcGx5Q2h1bmtTaXplQ2hhbmdlKCk7XG4gICAgICAgIHRoaXMuX3JlY2FsY1Njcm9sbEJhclNpemUoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlVmlld3MocHJldkNodW5rU2l6ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBvdmVycmlkZSBfY2FsY01heENodW5rU2l6ZSgpOiBudW1iZXIge1xuICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zeW5jU2VydmljZS5pc01hc3Rlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdXBlci5fY2FsY01heENodW5rU2l6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3luY1NlcnZpY2UuY2h1bmtTaXplKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLl9jYWxjTWF4Q2h1bmtTaXplKCk7XG4gICAgICAgIH1cblxuICAgIH1cbn1cbiJdfQ==