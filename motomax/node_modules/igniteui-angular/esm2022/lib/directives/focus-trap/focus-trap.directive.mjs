import { Directive, Input, booleanAttribute } from '@angular/core';
import { fromEvent, Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "../../core/utils";
export class IgxFocusTrapDirective {
    /** @hidden */
    get element() {
        return this.elementRef.nativeElement;
    }
    /** @hidden */
    constructor(elementRef, platformUtil) {
        this.elementRef = elementRef;
        this.platformUtil = platformUtil;
        this.destroy$ = new Subject();
        this._focusTrap = true;
    }
    /**
     * Sets whether the Tab key focus is trapped within the element.
     *
     * @example
     * ```html
     * <div igxFocusTrap="true"></div>
     * ```
     */
    set focusTrap(focusTrap) {
        this._focusTrap = focusTrap;
    }
    /** @hidden */
    get focusTrap() {
        return this._focusTrap;
    }
    /** @hidden */
    ngAfterViewInit() {
        fromEvent(this.element, 'keydown')
            .pipe(takeUntil(this.destroy$))
            .subscribe((event) => {
            if (this._focusTrap && event.key === this.platformUtil.KEYMAP.TAB) {
                this.handleTab(event);
            }
        });
    }
    /** @hidden */
    ngOnDestroy() {
        this.destroy$.complete();
    }
    handleTab(event) {
        const elements = this.getFocusableElements(this.element);
        if (elements.length > 0) {
            const focusedElement = this.getFocusedElement();
            const focusedElementIndex = elements.findIndex((element) => element === focusedElement);
            const direction = event.shiftKey ? -1 : 1;
            let nextFocusableElementIndex = focusedElementIndex + direction;
            if (nextFocusableElementIndex < 0) {
                nextFocusableElementIndex = elements.length - 1;
            }
            if (nextFocusableElementIndex >= elements.length) {
                nextFocusableElementIndex = 0;
            }
            elements[nextFocusableElementIndex].focus();
        }
        else {
            this.element.focus();
        }
        event.preventDefault();
    }
    getFocusableElements(element) {
        return Array.from(element.querySelectorAll('a[href], button, input, textarea, select, details,[tabindex]:not([tabindex="-1"])')).filter(el => !el.hasAttribute('disabled') && !el.getAttribute('aria-hidden'));
    }
    getFocusedElement() {
        let activeElement = typeof document !== 'undefined' && document
            ? document.activeElement
            : null;
        while (activeElement && activeElement.shadowRoot) {
            const newActiveElement = activeElement.shadowRoot.activeElement;
            if (newActiveElement === activeElement) {
                break;
            }
            else {
                activeElement = newActiveElement;
            }
        }
        return activeElement;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxFocusTrapDirective, deps: [{ token: i0.ElementRef }, { token: i1.PlatformUtil }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "18.2.4", type: IgxFocusTrapDirective, isStandalone: true, selector: "[igxFocusTrap]", inputs: { focusTrap: ["igxFocusTrap", "focusTrap", booleanAttribute] }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxFocusTrapDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igxFocusTrap]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i1.PlatformUtil }], propDecorators: { focusTrap: [{
                type: Input,
                args: [{ alias: 'igxFocusTrap', transform: booleanAttribute }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9jdXMtdHJhcC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZGlyZWN0aXZlcy9mb2N1cy10cmFwL2ZvY3VzLXRyYXAuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBaUIsU0FBUyxFQUFjLEtBQUssRUFBYSxnQkFBZ0IsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN6RyxPQUFPLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMxQyxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7OztBQU8zQyxNQUFNLE9BQU8scUJBQXFCO0lBQzlCLGNBQWM7SUFDZCxJQUFXLE9BQU87UUFDZCxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDO0lBQ3pDLENBQUM7SUFLRCxjQUFjO0lBQ2QsWUFDWSxVQUFzQixFQUNwQixZQUEwQjtRQUQ1QixlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQ3BCLGlCQUFZLEdBQVosWUFBWSxDQUFjO1FBTmhDLGFBQVEsR0FBRyxJQUFJLE9BQU8sRUFBRSxDQUFDO1FBQ3pCLGVBQVUsR0FBRyxJQUFJLENBQUM7SUFNMUIsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxJQUNXLFNBQVMsQ0FBQyxTQUFrQjtRQUNuQyxJQUFJLENBQUMsVUFBVSxHQUFHLFNBQVMsQ0FBQztJQUNoQyxDQUFDO0lBRUQsY0FBYztJQUNkLElBQVcsU0FBUztRQUNoQixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7SUFDM0IsQ0FBQztJQUVELGNBQWM7SUFDUCxlQUFlO1FBQ2xCLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQzthQUM3QixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUM5QixT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QUUsY0FBYyxFQUFFLFNBQVMsRUFBRSxnQkFBZ0IsRUFBRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFmdGVyVmlld0luaXQsIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5wdXQsIE9uRGVzdHJveSwgYm9vbGVhbkF0dHJpYnV0ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZnJvbUV2ZW50LCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBQbGF0Zm9ybVV0aWwgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbaWd4Rm9jdXNUcmFwXScsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hGb2N1c1RyYXBEaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIGdldCBlbGVtZW50KCk6IEhUTUxFbGVtZW50IHwgbnVsbCB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGRlc3Ryb3kkID0gbmV3IFN1YmplY3QoKTtcbiAgICBwcml2YXRlIF9mb2N1c1RyYXAgPSB0cnVlO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBwcm90ZWN0ZWQgcGxhdGZvcm1VdGlsOiBQbGF0Zm9ybVV0aWwpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIFRhYiBrZXkgZm9jdXMgaXMgdHJhcHBlZCB3aXRoaW4gdGhlIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneEZvY3VzVHJhcD1cInRydWVcIj48L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoeyBhbGlhczogJ2lneEZvY3VzVHJhcCcsIHRyYW5zZm9ybTogYm9vbGVhbkF0dHJpYnV0ZSB9KVxuICAgIHB1YmxpYyBzZXQgZm9jdXNUcmFwKGZvY3VzVHJhcDogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9mb2N1c1RyYXAgPSBmb2N1c1RyYXA7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwdWJsaWMgZ2V0IGZvY3VzVHJhcCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvY3VzVHJhcDtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHB1YmxpYyBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIGZyb21FdmVudCh0aGlzLmVsZW1lbnQsICdrZXlkb3duJylcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ZvY3VzVHJhcCAmJiBldmVudC5rZXkgPT09IHRoaXMucGxhdGZvcm1VdGlsLktFWU1BUC5UQUIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVUYWIoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVUYWIoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmdldEZvY3VzYWJsZUVsZW1lbnRzKHRoaXMuZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBmb2N1c2VkRWxlbWVudCA9IHRoaXMuZ2V0Rm9jdXNlZEVsZW1lbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzZWRFbGVtZW50SW5kZXggPSBlbGVtZW50cy5maW5kSW5kZXgoKGVsZW1lbnQpID0+IGVsZW1lbnQgYXMgSFRNTEVsZW1lbnQgPT09IGZvY3VzZWRFbGVtZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGV2ZW50LnNoaWZ0S2V5ID8gLTEgOiAxO1xuICAgICAgICAgICAgbGV0IG5leHRGb2N1c2FibGVFbGVtZW50SW5kZXggPSBmb2N1c2VkRWxlbWVudEluZGV4ICsgZGlyZWN0aW9uO1xuICAgICAgICAgICAgaWYgKG5leHRGb2N1c2FibGVFbGVtZW50SW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgbmV4dEZvY3VzYWJsZUVsZW1lbnRJbmRleCA9IGVsZW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dEZvY3VzYWJsZUVsZW1lbnRJbmRleCA+PSBlbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBuZXh0Rm9jdXNhYmxlRWxlbWVudEluZGV4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChlbGVtZW50c1tuZXh0Rm9jdXNhYmxlRWxlbWVudEluZGV4XSBhcyBIVE1MRWxlbWVudCkuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEZvY3VzYWJsZUVsZW1lbnRzKGVsZW1lbnQ6IEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAgICAgJ2FbaHJlZl0sIGJ1dHRvbiwgaW5wdXQsIHRleHRhcmVhLCBzZWxlY3QsIGRldGFpbHMsW3RhYmluZGV4XTpub3QoW3RhYmluZGV4PVwiLTFcIl0pJ1xuICAgICAgICApKS5maWx0ZXIoZWwgPT4gIWVsLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSAmJiAhZWwuZ2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEZvY3VzZWRFbGVtZW50KCk6IEhUTUxFbGVtZW50IHwgbnVsbCB7XG4gICAgICAgIGxldCBhY3RpdmVFbGVtZW50ID1cbiAgICAgICAgICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICA/IChkb2N1bWVudC5hY3RpdmVFbGVtZW50IGFzIEhUTUxFbGVtZW50IHwgbnVsbClcbiAgICAgICAgICAgICAgICA6IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudC5zaGFkb3dSb290KSB7XG4gICAgICAgICAgICBjb25zdCBuZXdBY3RpdmVFbGVtZW50ID0gYWN0aXZlRWxlbWVudC5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQgYXMgSFRNTEVsZW1lbnQgfCBudWxsO1xuICAgICAgICAgICAgaWYgKG5ld0FjdGl2ZUVsZW1lbnQgPT09IGFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlRWxlbWVudCA9IG5ld0FjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWN0aXZlRWxlbWVudDtcbiAgICB9XG59XG4iXX0=