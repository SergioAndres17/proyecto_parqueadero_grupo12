import { Directive, HostBinding, Input, booleanAttribute } from '@angular/core';
import * as i0 from "@angular/core";
export class IgxLayoutDirective {
    constructor() {
        /**
         * Sets the default flow direction of the container's children.
         *
         * Defaults to `rows`.
         *
         * ```html
         *  <div
         *   igxLayout
         *   igxLayoutDir="row">
         *    <div igxFlex>1</div>
         *    <div igxFlex>2</div>
         *    <div igxFlex>3</div>
         *  </div>
         * ```
         */
        this.dir = 'row';
        /**
         * Defines the direction flex children are placed in the flex container.
         *
         * When set to `true`, the `rows` direction goes right to left and `columns` goes bottom to top.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutReverse="true">
         *    <div igxFlex>1</div>
         *    <div igxFlex>2</div>
         *    <div igxFlex>3</div>
         * </div>
         * ```
         */
        this.reverse = false;
        /**
         * By default the immediate children will all try to fit onto one line.
         *
         * The default value `nowrap` sets this behavior.
         *
         * Other accepted values are `wrap` and `wrap-reverse`.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutDir="row"
         *   igxLayoutWrap="wrap">
         *    <div igxFlex igxFlexGrow="0">1</div>
         *    <div igxFlex igxFlexGrow="0">2</div>
         *    <div igxFlex igxFlexGrow="0">3</div>
         * </div>
         * ```
         */
        this.wrap = 'nowrap';
        /**
         * Defines the alignment along the main axis.
         *
         * Defaults to `flex-start` which packs the children toward the start line.
         *
         * Other possible values are `flex-end`, `center`, `space-between`, `space-around`.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutDir="column"
         *   igxLayoutJustify="space-between">
         *    <div>1</div>
         *    <div>2</div>
         *    <div>3</div>
         * </div>
         * ```
         */
        this.justify = 'flex-start';
        /**
         * Defines the default behavior for how children are laid out along the corss axis of the current line.
         *
         * Defaults to `flex-start`.
         *
         * Other possible values are `flex-end`, `center`, `baseline`, and `stretch`.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutDir="column"
         *   igxLayoutItemAlign="start">
         *    <div igxFlex igxFlexGrow="0">1</div>
         *    <div igxFlex igxFlexGrow="0">2</div>
         *    <div igxFlex igxFlexGrow="0">3</div>
         * </div>
         * ```
         */
        this.itemAlign = 'stretch';
        /**
         * @hidden
         */
        this.display = 'flex';
    }
    /**
     * @hidden
     */
    get flexwrap() {
        return this.wrap;
    }
    /**
     * @hidden
     */
    get justifycontent() {
        return this.justify;
    }
    /**
     * @hidden
     */
    get align() {
        return this.itemAlign;
    }
    /**
     * @hidden
     */
    get direction() {
        if (this.reverse) {
            return (this.dir === 'row') ? 'row-reverse' : 'column-reverse';
        }
        return (this.dir === 'row') ? 'row' : 'column';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxLayoutDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "18.2.4", type: IgxLayoutDirective, isStandalone: true, selector: "[igxLayout]", inputs: { dir: ["igxLayoutDir", "dir"], reverse: ["igxLayoutReverse", "reverse", booleanAttribute], wrap: ["igxLayoutWrap", "wrap"], justify: ["igxLayoutJustify", "justify"], itemAlign: ["igxLayoutItemAlign", "itemAlign"] }, host: { properties: { "style.display": "this.display", "style.flex-wrap": "this.flexwrap", "style.justify-content": "this.justifycontent", "style.align-items": "this.align", "style.flex-direction": "this.direction" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxLayoutDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igxLayout]',
                    standalone: true
                }]
        }], propDecorators: { dir: [{
                type: Input,
                args: ['igxLayoutDir']
            }], reverse: [{
                type: Input,
                args: [{ alias: 'igxLayoutReverse', transform: booleanAttribute }]
            }], wrap: [{
                type: Input,
                args: ['igxLayoutWrap']
            }], justify: [{
                type: Input,
                args: ['igxLayoutJustify']
            }], itemAlign: [{
                type: Input,
                args: ['igxLayoutItemAlign']
            }], display: [{
                type: HostBinding,
                args: ['style.display']
            }], flexwrap: [{
                type: HostBinding,
                args: ['style.flex-wrap']
            }], justifycontent: [{
                type: HostBinding,
                args: ['style.justify-content']
            }], align: [{
                type: HostBinding,
                args: ['style.align-items']
            }], direction: [{
                type: HostBinding,
                args: ['style.flex-direction']
            }] } });
export class IgxFlexDirective {
    constructor() {
        /**
         * Applies the `grow` attribute to an element that uses the directive.
         *
         * Default value is `1`.
         *
         * ```html
         * <div>
         *    <div igxFlex igxFlexGrow="0">Content1</div>
         *    <div igxFlex igxFlexGrow="1">Content2</div>
         *    <div igxFlex igxFlexGrow="0">Content3</div>
         * </div>
         * ```
         */
        this.grow = 1;
        /**
         * Applies the `shrink` attribute to an element that uses the directive.
         *
         * Default value is `1`.
         *
         * ```html
         * <div>
         *    <div igxFlex igxFlexShrink="1">Content1</div>
         *    <div igxFlex igxFlexShrink="0">Content2</div>
         *    <div igxFlex igxFlexShrink="1">Content3</div>
         * </div>
         * ```
         */
        this.shrink = 1;
        /**
         * Applies the directive to an element.
         *
         * Possible values include `igxFlexGrow`, `igxFlexShrink`, `igxFlexOrder`, `igxFlexBasis`.
         *
         * ```html
         * <div igxFlex>Content</div>
         * ```
         */
        this.flex = '';
        /**
         * Applies the `order` attribute to an element that uses the directive.
         *
         * Default value is `0`.
         *
         * ```html
         * <div>
         *    <div igxFlex igxFlexOrder="1">Content1</div>
         *    <div igxFlex igxFlexOrder="0">Content2</div>
         *    <div igxFlex igxFlexOrder="2">Content3</div>
         * </div>
         * ```
         */
        this.order = 0;
        /**
         * Applies the `flex-basis` attribute to an element that uses the directive.
         *
         * Default value is `auto`.
         *
         * Other possible values include `content`, `max-content`, `min-content`, `fit-content`.
         *
         * ```html
         * <div igxFlex igxFlexBasis="fit-content">Content</div>
         * ```
         */
        this.basis = 'auto';
    }
    /**
     * @hidden
     */
    get style() {
        if (this.flex) {
            return `${this.flex}`;
        }
        return `${this.grow} ${this.shrink} ${this.basis}`;
    }
    /**
     * @hidden
     */
    get itemorder() {
        return this.order || 0;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxFlexDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.4", type: IgxFlexDirective, isStandalone: true, selector: "[igxFlex]", inputs: { grow: ["igxFlexGrow", "grow"], shrink: ["igxFlexShrink", "shrink"], flex: ["igxFlex", "flex"], order: ["igxFlexOrder", "order"], basis: ["igxFlexBasis", "basis"] }, host: { properties: { "style.flex": "this.style", "style.order": "this.itemorder" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxFlexDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igxFlex]',
                    standalone: true
                }]
        }], propDecorators: { grow: [{
                type: Input,
                args: ['igxFlexGrow']
            }], shrink: [{
                type: Input,
                args: ['igxFlexShrink']
            }], flex: [{
                type: Input,
                args: ['igxFlex']
            }], order: [{
                type: Input,
                args: ['igxFlexOrder']
            }], basis: [{
                type: Input,
                args: ['igxFlexBasis']
            }], style: [{
                type: HostBinding,
                args: ['style.flex']
            }], itemorder: [{
                type: HostBinding,
                args: ['style.order']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGF5b3V0LmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9kaXJlY3RpdmVzL2xheW91dC9sYXlvdXQuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLEtBQUssRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGVBQWUsQ0FBQzs7QUFNaEYsTUFBTSxPQUFPLGtCQUFrQjtJQUovQjtRQUtJOzs7Ozs7Ozs7Ozs7OztXQWNHO1FBQzJCLFFBQUcsR0FBRyxLQUFLLENBQUM7UUFFMUM7Ozs7Ozs7Ozs7Ozs7O1dBY0c7UUFDdUUsWUFBTyxHQUFHLEtBQUssQ0FBQztRQUUxRjs7Ozs7Ozs7Ozs7Ozs7Ozs7V0FpQkc7UUFDNEIsU0FBSSxHQUFHLFFBQVEsQ0FBQztRQUUvQzs7Ozs7Ozs7Ozs7Ozs7Ozs7V0FpQkc7UUFDK0IsWUFBTyxHQUFHLFlBQVksQ0FBQztRQUV6RDs7Ozs7Ozs7Ozs7Ozs7Ozs7V0FpQkc7UUFDaUMsY0FBUyxHQUFHLFNBQVMsQ0FBQztRQUUxRDs7V0FFRztRQUNrQyxZQUFPLEdBQUcsTUFBTSxDQUFDO0tBb0N6RDtJQWxDRzs7T0FFRztJQUNILElBQ1csUUFBUTtRQUNmLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztJQUNyQixDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUNXLGNBQWM7UUFDckIsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO0lBQ3hCLENBQUM7SUFFRDs7T0FFRztJQUNILElBQ1csS0FBSztRQUNaLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztJQUMxQixDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUNXLFNBQVM7UUFDaEIsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDZixPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQztRQUNuRSxDQUFDO1FBQ0QsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDO0lBQ25ELENBQUM7OEdBcklRLGtCQUFrQjtrR0FBbEIsa0JBQWtCLGdJQWlDb0IsZ0JBQWdCOzsyRkFqQ3RELGtCQUFrQjtrQkFKOUIsU0FBUzttQkFBQztvQkFDUCxRQUFRLEVBQUUsYUFBYTtvQkFDdkIsVUFBVSxFQUFFLElBQUk7aUJBQ25COzhCQWlCaUMsR0FBRztzQkFBaEMsS0FBSzt1QkFBQyxjQUFjO2dCQWlCcUQsT0FBTztzQkFBaEYsS0FBSzt1QkFBQyxFQUFFLEtBQUssRUFBRSxrQkFBa0IsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUU7Z0JBb0JsQyxJQUFJO3NCQUFsQyxLQUFLO3VCQUFDLGVBQWU7Z0JBb0JZLE9BQU87c0JBQXhDLEtBQUs7dUJBQUMsa0JBQWtCO2dCQW9CVyxTQUFTO3NCQUE1QyxLQUFLO3VCQUFDLG9CQUFvQjtnQkFLVSxPQUFPO3NCQUEzQyxXQUFXO3VCQUFDLGVBQWU7Z0JBTWpCLFFBQVE7c0JBRGxCLFdBQVc7dUJBQUMsaUJBQWlCO2dCQVNuQixjQUFjO3NCQUR4QixXQUFXO3VCQUFDLHVCQUF1QjtnQkFTekIsS0FBSztzQkFEZixXQUFXO3VCQUFDLG1CQUFtQjtnQkFTckIsU0FBUztzQkFEbkIsV0FBVzt1QkFBQyxzQkFBc0I7O0FBYXZDLE1BQU0sT0FBTyxnQkFBZ0I7SUFKN0I7UUFNSTs7Ozs7Ozs7Ozs7O1dBWUc7UUFDMEIsU0FBSSxHQUFHLENBQUMsQ0FBQztRQUV0Qzs7Ozs7Ozs7Ozs7O1dBWUc7UUFDNEIsV0FBTSxHQUFHLENBQUMsQ0FBQztRQUUxQzs7Ozs7Ozs7V0FRRztRQUNzQixTQUFJLEdBQUcsRUFBRSxDQUFDO1FBRW5DOzs7Ozs7Ozs7Ozs7V0FZRztRQUMyQixVQUFLLEdBQUcsQ0FBQyxDQUFDO1FBRXhDOzs7Ozs7Ozs7O1dBVUc7UUFDMkIsVUFBSyxHQUFHLE1BQU0sQ0FBQztLQW9CaEQ7SUFsQkc7O09BRUc7SUFDSCxJQUNXLEtBQUs7UUFDWixJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNaLE9BQU8sR0FBRyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDMUIsQ0FBQztRQUNELE9BQU8sR0FBRyxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQ3ZELENBQUM7SUFFRDs7T0FFRztJQUNILElBQ1csU0FBUztRQUNoQixPQUFPLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDO0lBQzNCLENBQUM7OEdBeEZRLGdCQUFnQjtrR0FBaEIsZ0JBQWdCOzsyRkFBaEIsZ0JBQWdCO2tCQUo1QixTQUFTO21CQUFDO29CQUNQLFFBQVEsRUFBRSxXQUFXO29CQUNyQixVQUFVLEVBQUUsSUFBSTtpQkFDbkI7OEJBZ0JnQyxJQUFJO3NCQUFoQyxLQUFLO3VCQUFDLGFBQWE7Z0JBZVcsTUFBTTtzQkFBcEMsS0FBSzt1QkFBQyxlQUFlO2dCQVdHLElBQUk7c0JBQTVCLEtBQUs7dUJBQUMsU0FBUztnQkFlYyxLQUFLO3NCQUFsQyxLQUFLO3VCQUFDLGNBQWM7Z0JBYVMsS0FBSztzQkFBbEMsS0FBSzt1QkFBQyxjQUFjO2dCQU1WLEtBQUs7c0JBRGYsV0FBVzt1QkFBQyxZQUFZO2dCQVlkLFNBQVM7c0JBRG5CLFdBQVc7dUJBQUMsYUFBYSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgSG9zdEJpbmRpbmcsIElucHV0LCBib29sZWFuQXR0cmlidXRlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2lneExheW91dF0nLFxuICAgIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgSWd4TGF5b3V0RGlyZWN0aXZlIHtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkZWZhdWx0IGZsb3cgZGlyZWN0aW9uIG9mIHRoZSBjb250YWluZXIncyBjaGlsZHJlbi5cbiAgICAgKlxuICAgICAqIERlZmF1bHRzIHRvIGByb3dzYC5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiAgPGRpdlxuICAgICAqICAgaWd4TGF5b3V0XG4gICAgICogICBpZ3hMYXlvdXREaXI9XCJyb3dcIj5cbiAgICAgKiAgICA8ZGl2IGlneEZsZXg+MTwvZGl2PlxuICAgICAqICAgIDxkaXYgaWd4RmxleD4yPC9kaXY+XG4gICAgICogICAgPGRpdiBpZ3hGbGV4PjM8L2Rpdj5cbiAgICAgKiAgPC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCdpZ3hMYXlvdXREaXInKSBwdWJsaWMgZGlyID0gJ3Jvdyc7XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSBkaXJlY3Rpb24gZmxleCBjaGlsZHJlbiBhcmUgcGxhY2VkIGluIHRoZSBmbGV4IGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqIFdoZW4gc2V0IHRvIGB0cnVlYCwgdGhlIGByb3dzYCBkaXJlY3Rpb24gZ29lcyByaWdodCB0byBsZWZ0IGFuZCBgY29sdW1uc2AgZ29lcyBib3R0b20gdG8gdG9wLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXZcbiAgICAgKiAgIGlneExheW91dFxuICAgICAqICAgaWd4TGF5b3V0UmV2ZXJzZT1cInRydWVcIj5cbiAgICAgKiAgICA8ZGl2IGlneEZsZXg+MTwvZGl2PlxuICAgICAqICAgIDxkaXYgaWd4RmxleD4yPC9kaXY+XG4gICAgICogICAgPGRpdiBpZ3hGbGV4PjM8L2Rpdj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoeyBhbGlhczogJ2lneExheW91dFJldmVyc2UnLCB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGUgfSkgcHVibGljIHJldmVyc2UgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQgdGhlIGltbWVkaWF0ZSBjaGlsZHJlbiB3aWxsIGFsbCB0cnkgdG8gZml0IG9udG8gb25lIGxpbmUuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBgbm93cmFwYCBzZXRzIHRoaXMgYmVoYXZpb3IuXG4gICAgICpcbiAgICAgKiBPdGhlciBhY2NlcHRlZCB2YWx1ZXMgYXJlIGB3cmFwYCBhbmQgYHdyYXAtcmV2ZXJzZWAuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdlxuICAgICAqICAgaWd4TGF5b3V0XG4gICAgICogICBpZ3hMYXlvdXREaXI9XCJyb3dcIlxuICAgICAqICAgaWd4TGF5b3V0V3JhcD1cIndyYXBcIj5cbiAgICAgKiAgICA8ZGl2IGlneEZsZXggaWd4RmxleEdyb3c9XCIwXCI+MTwvZGl2PlxuICAgICAqICAgIDxkaXYgaWd4RmxleCBpZ3hGbGV4R3Jvdz1cIjBcIj4yPC9kaXY+XG4gICAgICogICAgPGRpdiBpZ3hGbGV4IGlneEZsZXhHcm93PVwiMFwiPjM8L2Rpdj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoJ2lneExheW91dFdyYXAnKSBwdWJsaWMgd3JhcCA9ICdub3dyYXAnO1xuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgYWxpZ25tZW50IGFsb25nIHRoZSBtYWluIGF4aXMuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0cyB0byBgZmxleC1zdGFydGAgd2hpY2ggcGFja3MgdGhlIGNoaWxkcmVuIHRvd2FyZCB0aGUgc3RhcnQgbGluZS5cbiAgICAgKlxuICAgICAqIE90aGVyIHBvc3NpYmxlIHZhbHVlcyBhcmUgYGZsZXgtZW5kYCwgYGNlbnRlcmAsIGBzcGFjZS1iZXR3ZWVuYCwgYHNwYWNlLWFyb3VuZGAuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdlxuICAgICAqICAgaWd4TGF5b3V0XG4gICAgICogICBpZ3hMYXlvdXREaXI9XCJjb2x1bW5cIlxuICAgICAqICAgaWd4TGF5b3V0SnVzdGlmeT1cInNwYWNlLWJldHdlZW5cIj5cbiAgICAgKiAgICA8ZGl2PjE8L2Rpdj5cbiAgICAgKiAgICA8ZGl2PjI8L2Rpdj5cbiAgICAgKiAgICA8ZGl2PjM8L2Rpdj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoJ2lneExheW91dEp1c3RpZnknKSBwdWJsaWMganVzdGlmeSA9ICdmbGV4LXN0YXJ0JztcblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IgZm9yIGhvdyBjaGlsZHJlbiBhcmUgbGFpZCBvdXQgYWxvbmcgdGhlIGNvcnNzIGF4aXMgb2YgdGhlIGN1cnJlbnQgbGluZS5cbiAgICAgKlxuICAgICAqIERlZmF1bHRzIHRvIGBmbGV4LXN0YXJ0YC5cbiAgICAgKlxuICAgICAqIE90aGVyIHBvc3NpYmxlIHZhbHVlcyBhcmUgYGZsZXgtZW5kYCwgYGNlbnRlcmAsIGBiYXNlbGluZWAsIGFuZCBgc3RyZXRjaGAuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdlxuICAgICAqICAgaWd4TGF5b3V0XG4gICAgICogICBpZ3hMYXlvdXREaXI9XCJjb2x1bW5cIlxuICAgICAqICAgaWd4TGF5b3V0SXRlbUFsaWduPVwic3RhcnRcIj5cbiAgICAgKiAgICA8ZGl2IGlneEZsZXggaWd4RmxleEdyb3c9XCIwXCI+MTwvZGl2PlxuICAgICAqICAgIDxkaXYgaWd4RmxleCBpZ3hGbGV4R3Jvdz1cIjBcIj4yPC9kaXY+XG4gICAgICogICAgPGRpdiBpZ3hGbGV4IGlneEZsZXhHcm93PVwiMFwiPjM8L2Rpdj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoJ2lneExheW91dEl0ZW1BbGlnbicpIHB1YmxpYyBpdGVtQWxpZ24gPSAnc3RyZXRjaCc7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5kaXNwbGF5JykgcHVibGljIGRpc3BsYXkgPSAnZmxleCc7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5mbGV4LXdyYXAnKVxuICAgIHB1YmxpYyBnZXQgZmxleHdyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyYXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUuanVzdGlmeS1jb250ZW50JylcbiAgICBwdWJsaWMgZ2V0IGp1c3RpZnljb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qdXN0aWZ5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLmFsaWduLWl0ZW1zJylcbiAgICBwdWJsaWMgZ2V0IGFsaWduKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtQWxpZ247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUuZmxleC1kaXJlY3Rpb24nKVxuICAgIHB1YmxpYyBnZXQgZGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5yZXZlcnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuZGlyID09PSAncm93JykgPyAncm93LXJldmVyc2UnIDogJ2NvbHVtbi1yZXZlcnNlJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMuZGlyID09PSAncm93JykgPyAncm93JyA6ICdjb2x1bW4nO1xuICAgIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbaWd4RmxleF0nLFxuICAgIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgSWd4RmxleERpcmVjdGl2ZSB7XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBgZ3Jvd2AgYXR0cmlidXRlIHRvIGFuIGVsZW1lbnQgdGhhdCB1c2VzIHRoZSBkaXJlY3RpdmUuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGAxYC5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2PlxuICAgICAqICAgIDxkaXYgaWd4RmxleCBpZ3hGbGV4R3Jvdz1cIjBcIj5Db250ZW50MTwvZGl2PlxuICAgICAqICAgIDxkaXYgaWd4RmxleCBpZ3hGbGV4R3Jvdz1cIjFcIj5Db250ZW50MjwvZGl2PlxuICAgICAqICAgIDxkaXYgaWd4RmxleCBpZ3hGbGV4R3Jvdz1cIjBcIj5Db250ZW50MzwvZGl2PlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgnaWd4RmxleEdyb3cnKSBwdWJsaWMgZ3JvdyA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBgc2hyaW5rYCBhdHRyaWJ1dGUgdG8gYW4gZWxlbWVudCB0aGF0IHVzZXMgdGhlIGRpcmVjdGl2ZS5cbiAgICAgKlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYDFgLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXY+XG4gICAgICogICAgPGRpdiBpZ3hGbGV4IGlneEZsZXhTaHJpbms9XCIxXCI+Q29udGVudDE8L2Rpdj5cbiAgICAgKiAgICA8ZGl2IGlneEZsZXggaWd4RmxleFNocmluaz1cIjBcIj5Db250ZW50MjwvZGl2PlxuICAgICAqICAgIDxkaXYgaWd4RmxleCBpZ3hGbGV4U2hyaW5rPVwiMVwiPkNvbnRlbnQzPC9kaXY+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCdpZ3hGbGV4U2hyaW5rJykgcHVibGljIHNocmluayA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBkaXJlY3RpdmUgdG8gYW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIFBvc3NpYmxlIHZhbHVlcyBpbmNsdWRlIGBpZ3hGbGV4R3Jvd2AsIGBpZ3hGbGV4U2hyaW5rYCwgYGlneEZsZXhPcmRlcmAsIGBpZ3hGbGV4QmFzaXNgLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RmxleD5Db250ZW50PC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCdpZ3hGbGV4JykgcHVibGljIGZsZXggPSAnJztcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIGBvcmRlcmAgYXR0cmlidXRlIHRvIGFuIGVsZW1lbnQgdGhhdCB1c2VzIHRoZSBkaXJlY3RpdmUuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGAwYC5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2PlxuICAgICAqICAgIDxkaXYgaWd4RmxleCBpZ3hGbGV4T3JkZXI9XCIxXCI+Q29udGVudDE8L2Rpdj5cbiAgICAgKiAgICA8ZGl2IGlneEZsZXggaWd4RmxleE9yZGVyPVwiMFwiPkNvbnRlbnQyPC9kaXY+XG4gICAgICogICAgPGRpdiBpZ3hGbGV4IGlneEZsZXhPcmRlcj1cIjJcIj5Db250ZW50MzwvZGl2PlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgnaWd4RmxleE9yZGVyJykgcHVibGljIG9yZGVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIGBmbGV4LWJhc2lzYCBhdHRyaWJ1dGUgdG8gYW4gZWxlbWVudCB0aGF0IHVzZXMgdGhlIGRpcmVjdGl2ZS5cbiAgICAgKlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGF1dG9gLlxuICAgICAqXG4gICAgICogT3RoZXIgcG9zc2libGUgdmFsdWVzIGluY2x1ZGUgYGNvbnRlbnRgLCBgbWF4LWNvbnRlbnRgLCBgbWluLWNvbnRlbnRgLCBgZml0LWNvbnRlbnRgLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RmxleCBpZ3hGbGV4QmFzaXM9XCJmaXQtY29udGVudFwiPkNvbnRlbnQ8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoJ2lneEZsZXhCYXNpcycpIHB1YmxpYyBiYXNpcyA9ICdhdXRvJztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLmZsZXgnKVxuICAgIHB1YmxpYyBnZXQgc3R5bGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmZsZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmZsZXh9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dGhpcy5ncm93fSAke3RoaXMuc2hyaW5rfSAke3RoaXMuYmFzaXN9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5vcmRlcicpXG4gICAgcHVibGljIGdldCBpdGVtb3JkZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yZGVyIHx8IDA7XG4gICAgfVxufVxuIl19