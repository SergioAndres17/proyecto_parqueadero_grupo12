import { Directive, HostBinding, Input } from '@angular/core';
import * as i0 from "@angular/core";
var IgxHintPosition;
(function (IgxHintPosition) {
    IgxHintPosition[IgxHintPosition["START"] = 0] = "START";
    IgxHintPosition[IgxHintPosition["END"] = 1] = "END";
})(IgxHintPosition || (IgxHintPosition = {}));
export class IgxHintDirective {
    constructor() {
        /**
         * Sets/gets whether the hint position is at the start.
         * Default value is `false`.
         * ```typescript
         * @ViewChild('hint', {read: IgxHintDirective})
         * public igxHint: IgxHintDirective;
         * this.igxHint.isPositionStart = true;
         * ```
         * ```typescript
         * let isHintPositionStart = this.igxHint.isPositionStart;
         * ```
         *
         * @memberof IgxHintDirective
         */
        this.isPositionStart = false;
        /**
         * Sets/gets whether the hint position is at the end.
         * Default value is `false`.
         * ```typescript
         * @ViewChild('hint', {read: IgxHintDirective})
         * public igxHint: IgxHintDirective;
         * this.igxHint.isPositionEnd = true;
         * ```
         * ```typescript
         * let isHintPositionEnd = this.igxHint.isPositionEnd;
         * ```
         *
         * @memberof IgxHintDirective
         */
        this.isPositionEnd = false;
        this._position = IgxHintPosition.START;
    }
    /**
     * Sets the position of the hint.
     * ```html
     * <igx-input-group>
     *  <input igxInput type="text"/>
     *  <igx-hint #hint [position]="'start'">IgxHint displayed at the start</igx-hint>
     * </igx-input-group>
     * ```
     *
     * @memberof IgxHintDirective
     */
    set position(value) {
        const position = IgxHintPosition[value.toUpperCase()];
        if (position !== undefined) {
            this._position = position;
            this._applyPosition(this._position);
        }
    }
    /**
     * Gets the position of the hint.
     * ```typescript
     * @ViewChild('hint', {read: IgxHintDirective})
     * public igxHint: IgxHintDirective;
     * let hintPosition =  this.igxHint.position;
     * ```
     *
     * @memberof IgxHintDirective
     */
    get position() {
        return this._position.toString();
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this._applyPosition(this._position);
    }
    _applyPosition(position) {
        this.isPositionStart = this.isPositionEnd = false;
        switch (position) {
            case IgxHintPosition.START:
                this.isPositionStart = true;
                break;
            case IgxHintPosition.END:
                this.isPositionEnd = true;
                break;
            default: break;
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxHintDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.4", type: IgxHintDirective, isStandalone: true, selector: "igx-hint,[igxHint]", inputs: { position: "position" }, host: { properties: { "class.igx-input-group__hint-item--start": "this.isPositionStart", "class.igx-input-group__hint-item--end": "this.isPositionEnd" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxHintDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'igx-hint,[igxHint]',
                    standalone: true
                }]
        }], propDecorators: { isPositionStart: [{
                type: HostBinding,
                args: ['class.igx-input-group__hint-item--start']
            }], isPositionEnd: [{
                type: HostBinding,
                args: ['class.igx-input-group__hint-item--end']
            }], position: [{
                type: Input,
                args: ['position']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGludC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZGlyZWN0aXZlcy9oaW50L2hpbnQuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLEtBQUssRUFBVSxNQUFNLGVBQWUsQ0FBQzs7QUFFdEUsSUFBSyxlQUdKO0FBSEQsV0FBSyxlQUFlO0lBQ2hCLHVEQUFLLENBQUE7SUFDTCxtREFBRyxDQUFBO0FBQ1AsQ0FBQyxFQUhJLGVBQWUsS0FBZixlQUFlLFFBR25CO0FBTUQsTUFBTSxPQUFPLGdCQUFnQjtJQUo3QjtRQUtJOzs7Ozs7Ozs7Ozs7O1dBYUc7UUFFSSxvQkFBZSxHQUFHLEtBQUssQ0FBQztRQUMvQjs7Ozs7Ozs7Ozs7OztXQWFHO1FBRUksa0JBQWEsR0FBRyxLQUFLLENBQUM7UUFFckIsY0FBUyxHQUFvQixlQUFlLENBQUMsS0FBSyxDQUFDO0tBb0Q5RDtJQW5ERzs7Ozs7Ozs7OztPQVVHO0lBQ0gsSUFDVyxRQUFRLENBQUMsS0FBYTtRQUM3QixNQUFNLFFBQVEsR0FBcUIsZUFBdUIsQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztRQUNoRixJQUFJLFFBQVEsS0FBSyxTQUFTLEVBQUUsQ0FBQztZQUN6QixJQUFJLENBQUMsU0FBUyxHQUFHLFFBQVEsQ0FBQztZQUMxQixJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUN4QyxDQUFDO0lBQ0wsQ0FBQztJQUNEOzs7Ozs7Ozs7T0FTRztJQUNILElBQVcsUUFBUTtRQUNmLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNyQyxDQUFDO0lBQ0Q7O09BRUc7SUFDSSxRQUFRO1FBQ1gsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUVPLGNBQWMsQ0FBQyxRQUF5QjtRQUM1QyxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxhQUFhLEdBQUcsS0FBSyxDQUFDO1FBQ2xELFFBQVEsUUFBUSxFQUFFLENBQUM7WUFDZixLQUFLLGVBQWUsQ0FBQyxLQUFLO2dCQUN0QixJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQztnQkFDNUIsTUFBTTtZQUNWLEtBQUssZUFBZSxDQUFDLEdBQUc7Z0JBQ3BCLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDO2dCQUMxQixNQUFNO1lBQ1YsT0FBTyxDQUFDLENBQUMsTUFBTTtRQUNuQixDQUFDO0lBQ0wsQ0FBQzs4R0FyRlEsZ0JBQWdCO2tHQUFoQixnQkFBZ0I7OzJGQUFoQixnQkFBZ0I7a0JBSjVCLFNBQVM7bUJBQUM7b0JBQ1AsUUFBUSxFQUFFLG9CQUFvQjtvQkFDOUIsVUFBVSxFQUFFLElBQUk7aUJBQ25COzhCQWlCVSxlQUFlO3NCQURyQixXQUFXO3VCQUFDLHlDQUF5QztnQkFpQi9DLGFBQWE7c0JBRG5CLFdBQVc7dUJBQUMsdUNBQXVDO2dCQWdCekMsUUFBUTtzQkFEbEIsS0FBSzt1QkFBQyxVQUFVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBIb3N0QmluZGluZywgSW5wdXQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5lbnVtIElneEhpbnRQb3NpdGlvbiB7XG4gICAgU1RBUlQsXG4gICAgRU5EXG59XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnaWd4LWhpbnQsW2lneEhpbnRdJyxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneEhpbnREaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQge1xuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB3aGV0aGVyIHRoZSBoaW50IHBvc2l0aW9uIGlzIGF0IHRoZSBzdGFydC5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoJ2hpbnQnLCB7cmVhZDogSWd4SGludERpcmVjdGl2ZX0pXG4gICAgICogcHVibGljIGlneEhpbnQ6IElneEhpbnREaXJlY3RpdmU7XG4gICAgICogdGhpcy5pZ3hIaW50LmlzUG9zaXRpb25TdGFydCA9IHRydWU7XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc0hpbnRQb3NpdGlvblN0YXJ0ID0gdGhpcy5pZ3hIaW50LmlzUG9zaXRpb25TdGFydDtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hIaW50RGlyZWN0aXZlXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtaW5wdXQtZ3JvdXBfX2hpbnQtaXRlbS0tc3RhcnQnKVxuICAgIHB1YmxpYyBpc1Bvc2l0aW9uU3RhcnQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgd2hldGhlciB0aGUgaGludCBwb3NpdGlvbiBpcyBhdCB0aGUgZW5kLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGZhbHNlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZCgnaGludCcsIHtyZWFkOiBJZ3hIaW50RGlyZWN0aXZlfSlcbiAgICAgKiBwdWJsaWMgaWd4SGludDogSWd4SGludERpcmVjdGl2ZTtcbiAgICAgKiB0aGlzLmlneEhpbnQuaXNQb3NpdGlvbkVuZCA9IHRydWU7XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc0hpbnRQb3NpdGlvbkVuZCA9IHRoaXMuaWd4SGludC5pc1Bvc2l0aW9uRW5kO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneEhpbnREaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1pbnB1dC1ncm91cF9faGludC1pdGVtLS1lbmQnKVxuICAgIHB1YmxpYyBpc1Bvc2l0aW9uRW5kID0gZmFsc2U7XG5cbiAgICBwcml2YXRlIF9wb3NpdGlvbjogSWd4SGludFBvc2l0aW9uID0gSWd4SGludFBvc2l0aW9uLlNUQVJUO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBoaW50LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWlucHV0LWdyb3VwPlxuICAgICAqICA8aW5wdXQgaWd4SW5wdXQgdHlwZT1cInRleHRcIi8+XG4gICAgICogIDxpZ3gtaGludCAjaGludCBbcG9zaXRpb25dPVwiJ3N0YXJ0J1wiPklneEhpbnQgZGlzcGxheWVkIGF0IHRoZSBzdGFydDwvaWd4LWhpbnQ+XG4gICAgICogPC9pZ3gtaW5wdXQtZ3JvdXA+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4SGludERpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgncG9zaXRpb24nKVxuICAgIHB1YmxpYyBzZXQgcG9zaXRpb24odmFsdWU6IHN0cmluZykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbjogSWd4SGludFBvc2l0aW9uID0gKElneEhpbnRQb3NpdGlvbiBhcyBhbnkpW3ZhbHVlLnRvVXBwZXJDYXNlKCldO1xuICAgICAgICBpZiAocG9zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5UG9zaXRpb24odGhpcy5fcG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBoaW50LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKCdoaW50Jywge3JlYWQ6IElneEhpbnREaXJlY3RpdmV9KVxuICAgICAqIHB1YmxpYyBpZ3hIaW50OiBJZ3hIaW50RGlyZWN0aXZlO1xuICAgICAqIGxldCBoaW50UG9zaXRpb24gPSAgdGhpcy5pZ3hIaW50LnBvc2l0aW9uO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneEhpbnREaXJlY3RpdmVcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb24udG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5fYXBwbHlQb3NpdGlvbih0aGlzLl9wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfYXBwbHlQb3NpdGlvbihwb3NpdGlvbjogSWd4SGludFBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuaXNQb3NpdGlvblN0YXJ0ID0gdGhpcy5pc1Bvc2l0aW9uRW5kID0gZmFsc2U7XG4gICAgICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgSWd4SGludFBvc2l0aW9uLlNUQVJUOlxuICAgICAgICAgICAgICAgIHRoaXMuaXNQb3NpdGlvblN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSWd4SGludFBvc2l0aW9uLkVORDpcbiAgICAgICAgICAgICAgICB0aGlzLmlzUG9zaXRpb25FbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDogYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=