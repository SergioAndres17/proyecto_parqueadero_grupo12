import { useAnimation } from '@angular/animations';
import { NgIf, NgTemplateOutlet, NgFor } from '@angular/common';
import { Component, ContentChild, ContentChildren, EventEmitter, HostBinding, Inject, Input, Output, TemplateRef, booleanAttribute } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { IgxCarouselComponentBase } from '../carousel/carousel-base';
import { IgxAngularAnimationService } from '../services/animation/angular-animation-service';
import { IgxStepComponent } from './step/step.component';
import { IgxStepperOrientation, IgxStepperTitlePosition, IgxStepType, IGX_STEPPER_COMPONENT, VerticalAnimationType } from './stepper.common';
import { IgxStepActiveIndicatorDirective, IgxStepCompletedIndicatorDirective, IgxStepInvalidIndicatorDirective } from './stepper.directive';
import { IgxStepperService } from './stepper.service';
import { fadeIn, growVerIn, growVerOut } from 'igniteui-angular/animations';
import * as i0 from "@angular/core";
import * as i1 from "./stepper.service";
// TODO: common interface between IgxCarouselComponentBase and ToggleAnimationPlayer?
/**
 * IgxStepper provides a wizard-like workflow by dividing content into logical steps.
 *
 * @igxModule IgxStepperModule
 *
 * @igxKeywords stepper
 *
 * @igxGroup Layouts
 *
 * @remarks
 * The Ignite UI for Angular Stepper component allows the user to navigate between multiple steps.
 * It supports horizontal and vertical orientation as well as keyboard navigation and provides API methods to control the active step.
 * The component offers keyboard navigation and API to control the active step.
 *
 * @example
 * ```html
 * <igx-stepper>
 *  <igx-step [active]="true">
 *      <igx-icon igxStepIndicator>home</igx-icon>
 *      <p igxStepTitle>Home</p>
 *      <div igxStepContent>
 *         ...
 *      </div>
 *  </igx-step>
 *  <igx-step [optional]="true">
 *      <div igxStepContent>
 *          ...
 *      </div>
 *  </igx-step>
 *  <igx-step>
 *      <div igxStepContent>
 *          ...
 *      </div>
 *  </igx-step>
 * </igx-stepper>
 * ```
 */
export class IgxStepperComponent extends IgxCarouselComponentBase {
    /**
     * Get/Set the animation type of the stepper when the orientation direction is vertical.
     *
     * @remarks
     * Default value is `grow`. Other possible values are `fade` and `none`.
     *
     * ```html
     * <igx-stepper verticalAnimationType="none">
     * <igx-stepper>
     * ```
     */
    get verticalAnimationType() {
        return this._verticalAnimationType;
    }
    set verticalAnimationType(value) {
        // TODO: activeChange event is not emitted for the collapsing steps (loop through collapsing steps and emit)
        this.stepperService.collapsingSteps.clear();
        this._verticalAnimationType = value;
        switch (value) {
            case 'grow':
                this.verticalAnimationSettings = this.updateVerticalAnimationSettings(growVerIn, growVerOut);
                break;
            case 'fade':
                this.verticalAnimationSettings = this.updateVerticalAnimationSettings(fadeIn, null);
                break;
            case 'none':
                this.verticalAnimationSettings = this.updateVerticalAnimationSettings(null, null);
                break;
        }
    }
    /**
     * Get/Set the animation type of the stepper when the orientation direction is horizontal.
     *
     * @remarks
     * Default value is `grow`. Other possible values are `fade` and `none`.
     *
     * ```html
     * <igx-stepper animationType="none">
     * <igx-stepper>
     * ```
     */
    get horizontalAnimationType() {
        return this.animationType;
    }
    set horizontalAnimationType(value) {
        // TODO: activeChange event is not emitted for the collapsing steps (loop through collapsing steps and emit)
        this.stepperService.collapsingSteps.clear();
        this.animationType = value;
    }
    /**
     * Get/Set the animation duration.
     * ```html
     * <igx-stepper [animationDuration]="500">
     * <igx-stepper>
     * ```
     */
    get animationDuration() {
        return this.defaultAnimationDuration;
    }
    set animationDuration(value) {
        if (value && value > 0) {
            this.defaultAnimationDuration = value;
            return;
        }
        this.defaultAnimationDuration = this._defaultAnimationDuration;
    }
    /**
     * Get/Set whether the stepper is linear.
     *
     * @remarks
     * If the stepper is in linear mode and if the active step is valid only then the user is able to move forward.
     *
     * ```html
     * <igx-stepper [linear]="true"></igx-stepper>
     * ```
     */
    get linear() {
        return this._linear;
    }
    set linear(value) {
        this._linear = value;
        if (this._linear && this.steps.length > 0) {
            // when the stepper is in linear mode we should calculate which steps should be disabled
            // and which are visited i.e. their validity should be correctly displayed.
            this.stepperService.calculateVisitedSteps();
            this.stepperService.calculateLinearDisabledSteps();
        }
        else {
            this.stepperService.linearDisabledSteps.clear();
        }
    }
    /**
     * Get/Set the stepper orientation.
     *
     * ```typescript
     * this.stepper.orientation = IgxStepperOrientation.Vertical;
     * ```
     */
    get orientation() {
        return this._orientation;
    }
    set orientation(value) {
        if (this._orientation === value) {
            return;
        }
        // TODO: activeChange event is not emitted for the collapsing steps
        this.stepperService.collapsingSteps.clear();
        this._orientation = value;
        this._defaultTitlePosition = this._orientation === IgxStepperOrientation.Horizontal ?
            IgxStepperTitlePosition.Bottom : IgxStepperTitlePosition.End;
    }
    /** @hidden @internal **/
    get directionClass() {
        return this.orientation === IgxStepperOrientation.Horizontal;
    }
    /**
     * Get all steps.
     *
     * ```typescript
     * const steps: IgxStepComponent[] = this.stepper.steps;
     * ```
     */
    get steps() {
        return this._steps?.toArray() || [];
    }
    /** @hidden @internal */
    get nativeElement() {
        return this.element.nativeElement;
    }
    constructor(cdr, animationService, stepperService, element) {
        super(animationService, cdr);
        this.stepperService = stepperService;
        this.element = element;
        /**
         * Get/Set the type of the steps.
         *
         * ```typescript
         * this.stepper.stepType = IgxStepType.Indicator;
         * ```
         */
        this.stepType = IgxStepType.Full;
        /**
         * Get/Set whether the content is displayed above the steps.
         *
         * @remarks
         * Default value is `false` and the content is below the steps.
         *
         * ```typescript
         * this.stepper.contentTop = true;
         * ```
         */
        this.contentTop = false;
        /**
         * Get/Set the position of the steps title.
         *
         * @remarks
         * The default value when the stepper is horizontally orientated is `bottom`.
         * In vertical layout the default title position is `end`.
         *
         * ```typescript
         * this.stepper.titlePosition = IgxStepperTitlePosition.Top;
         * ```
         */
        this.titlePosition = null;
        /** @hidden @internal **/
        this.cssClass = 'igx-stepper';
        /** @hidden @internal **/
        this.role = 'tablist';
        /**
         * Emitted when the stepper's active step is changing.
         *
         *```html
         * <igx-stepper (activeStepChanging)="handleActiveStepChanging($event)">
         * </igx-stepper>
         * ```
         *
         *```typescript
         * public handleActiveStepChanging(event: IStepChangingEventArgs) {
         *  if (event.newIndex < event.oldIndex) {
         *      event.cancel = true;
         *  }
         * }
         *```
         */
        this.activeStepChanging = new EventEmitter();
        /**
         * Emitted when the active step is changed.
         *
         * @example
         * ```
         * <igx-stepper (activeStepChanged)="handleActiveStepChanged($event)"></igx-stepper>
         * ```
         */
        this.activeStepChanged = new EventEmitter();
        /** @hidden @internal */
        this.verticalAnimationSettings = {
            openAnimation: growVerIn,
            closeAnimation: growVerOut,
        };
        /** @hidden @internal */
        this._defaultTitlePosition = IgxStepperTitlePosition.Bottom;
        this.destroy$ = new Subject();
        this._orientation = IgxStepperOrientation.Horizontal;
        this._verticalAnimationType = VerticalAnimationType.Grow;
        this._linear = false;
        this._defaultAnimationDuration = 350;
        this.stepperService.stepper = this;
    }
    /** @hidden @internal */
    ngOnChanges(changes) {
        if (changes['animationDuration']) {
            this.verticalAnimationType = this._verticalAnimationType;
        }
    }
    /** @hidden @internal */
    ngOnInit() {
        this.enterAnimationDone.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.activeStepChanged.emit({ owner: this, index: this.stepperService.activeStep.index });
        });
        this.leaveAnimationDone.pipe(takeUntil(this.destroy$)).subscribe(() => {
            if (this.stepperService.collapsingSteps.size === 1) {
                this.stepperService.collapse(this.stepperService.previousActiveStep);
            }
            else {
                Array.from(this.stepperService.collapsingSteps).slice(0, this.stepperService.collapsingSteps.size - 1)
                    .forEach(step => this.stepperService.collapse(step));
            }
        });
    }
    /** @hidden @internal */
    ngAfterContentInit() {
        let activeStep;
        this.steps.forEach((step, index) => {
            this.updateStepAria(step, index);
            if (!activeStep && step.active) {
                activeStep = step;
            }
        });
        if (!activeStep) {
            this.activateFirstStep(true);
        }
        if (this.linear) {
            this.stepperService.calculateLinearDisabledSteps();
        }
        this.handleStepChanges();
    }
    /** @hidden @internal */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     * Activates the step at a given index.
     *
     *```typescript
     * this.stepper.navigateTo(1);
     *```
     */
    navigateTo(index) {
        const step = this.steps[index];
        if (!step || this.stepperService.activeStep === step) {
            return;
        }
        this.activateStep(step);
    }
    /**
     * Activates the next enabled step.
     *
     *```typescript
     * this.stepper.next();
     *```
     */
    next() {
        this.moveToNextStep();
    }
    /**
     * Activates the previous enabled step.
     *
     *```typescript
     * this.stepper.prev();
     *```
     */
    prev() {
        this.moveToNextStep(false);
    }
    /**
     * Resets the stepper to its initial state i.e. activates the first step.
     *
     * @remarks
     * The steps' content will not be automatically reset.
     *```typescript
     * this.stepper.reset();
     *```
     */
    reset() {
        this.stepperService.visitedSteps.clear();
        const activeStep = this.steps.find(s => !s.disabled);
        if (activeStep) {
            this.activateStep(activeStep);
        }
    }
    /** @hidden @internal */
    playHorizontalAnimations() {
        this.previousItem = this.stepperService.previousActiveStep;
        this.currentItem = this.stepperService.activeStep;
        this.triggerAnimations();
    }
    getPreviousElement() {
        return this.stepperService.previousActiveStep?.contentContainer.nativeElement;
    }
    getCurrentElement() {
        return this.stepperService.activeStep.contentContainer.nativeElement;
    }
    updateVerticalAnimationSettings(openAnimation, closeAnimation) {
        const customCloseAnimation = useAnimation(closeAnimation, {
            params: {
                duration: this.animationDuration + 'ms'
            }
        });
        const customOpenAnimation = useAnimation(openAnimation, {
            params: {
                duration: this.animationDuration + 'ms'
            }
        });
        return {
            openAnimation: openAnimation ? customOpenAnimation : null,
            closeAnimation: closeAnimation ? customCloseAnimation : null
        };
    }
    updateStepAria(step, index) {
        step._index = index;
        step.renderer.setAttribute(step.nativeElement, 'aria-setsize', (this.steps.length).toString());
        step.renderer.setAttribute(step.nativeElement, 'aria-posinset', (index + 1).toString());
    }
    handleStepChanges() {
        this._steps.changes.pipe(takeUntil(this.destroy$)).subscribe(steps => {
            Promise.resolve().then(() => {
                steps.forEach((step, index) => {
                    this.updateStepAria(step, index);
                });
                // when the active step is removed
                const hasActiveStep = this.steps.find(s => s === this.stepperService.activeStep);
                if (!hasActiveStep) {
                    this.activateFirstStep();
                }
                // TO DO: mark step added before the active as visited?
                if (this.linear) {
                    this.stepperService.calculateLinearDisabledSteps();
                }
            });
        });
    }
    activateFirstStep(activateInitially = false) {
        const firstEnabledStep = this.steps.find(s => !s.disabled);
        if (firstEnabledStep) {
            firstEnabledStep.active = true;
            if (activateInitially) {
                firstEnabledStep.activeChange.emit(true);
                this.activeStepChanged.emit({ owner: this, index: firstEnabledStep.index });
            }
        }
    }
    activateStep(step) {
        if (this.orientation === IgxStepperOrientation.Horizontal) {
            step.changeHorizontalActiveStep();
        }
        else {
            this.stepperService.expand(step);
        }
    }
    moveToNextStep(next = true) {
        let steps = this.steps;
        let activeStepIndex = this.stepperService.activeStep.index;
        if (!next) {
            steps = this.steps.reverse();
            activeStepIndex = steps.findIndex(s => s === this.stepperService.activeStep);
        }
        const nextStep = steps.find((s, i) => i > activeStepIndex && s.isAccessible);
        if (nextStep) {
            this.activateStep(nextStep);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxStepperComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: IgxAngularAnimationService }, { token: i1.IgxStepperService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "18.2.4", type: IgxStepperComponent, isStandalone: true, selector: "igx-stepper", inputs: { verticalAnimationType: "verticalAnimationType", horizontalAnimationType: "horizontalAnimationType", animationDuration: "animationDuration", linear: ["linear", "linear", booleanAttribute], orientation: "orientation", stepType: "stepType", contentTop: ["contentTop", "contentTop", booleanAttribute], titlePosition: "titlePosition" }, outputs: { activeStepChanging: "activeStepChanging", activeStepChanged: "activeStepChanged" }, host: { properties: { "attr.aria-orientation": "this.orientation", "class.igx-stepper": "this.cssClass", "attr.role": "this.role", "class.igx-stepper--horizontal": "this.directionClass" } }, providers: [
            IgxStepperService,
            { provide: IGX_STEPPER_COMPONENT, useExisting: IgxStepperComponent },
        ], queries: [{ propertyName: "invalidIndicatorTemplate", first: true, predicate: IgxStepInvalidIndicatorDirective, descendants: true, read: TemplateRef }, { propertyName: "completedIndicatorTemplate", first: true, predicate: IgxStepCompletedIndicatorDirective, descendants: true, read: TemplateRef }, { propertyName: "activeIndicatorTemplate", first: true, predicate: IgxStepActiveIndicatorDirective, descendants: true, read: TemplateRef }, { propertyName: "_steps", predicate: IgxStepComponent }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: "<div *ngIf=\"!contentTop || orientation !== 'horizontal'\" class=\"igx-stepper__header\">\n    <ng-template *ngTemplateOutlet=\"stepTemplate\"></ng-template>\n</div>\n\n<div *ngIf=\"orientation === 'horizontal'\" class=\"igx-stepper__body\">\n    <ng-container *ngFor=\"let step of steps\">\n        <ng-container *ngTemplateOutlet=\"step.contentTemplate\"></ng-container>\n    </ng-container>\n</div>\n\n<div *ngIf=\"contentTop && orientation === 'horizontal'\" class=\"igx-stepper__header\">\n    <ng-template *ngTemplateOutlet=\"stepTemplate\"></ng-template>\n</div>\n\n<ng-template #stepTemplate>\n    <ng-content select=\"igx-step\"></ng-content>\n</ng-template>\n", dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxStepperComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-stepper', providers: [
                        IgxStepperService,
                        { provide: IGX_STEPPER_COMPONENT, useExisting: IgxStepperComponent },
                    ], standalone: true, imports: [NgIf, NgTemplateOutlet, NgFor], template: "<div *ngIf=\"!contentTop || orientation !== 'horizontal'\" class=\"igx-stepper__header\">\n    <ng-template *ngTemplateOutlet=\"stepTemplate\"></ng-template>\n</div>\n\n<div *ngIf=\"orientation === 'horizontal'\" class=\"igx-stepper__body\">\n    <ng-container *ngFor=\"let step of steps\">\n        <ng-container *ngTemplateOutlet=\"step.contentTemplate\"></ng-container>\n    </ng-container>\n</div>\n\n<div *ngIf=\"contentTop && orientation === 'horizontal'\" class=\"igx-stepper__header\">\n    <ng-template *ngTemplateOutlet=\"stepTemplate\"></ng-template>\n</div>\n\n<ng-template #stepTemplate>\n    <ng-content select=\"igx-step\"></ng-content>\n</ng-template>\n" }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [IgxAngularAnimationService]
                }] }, { type: i1.IgxStepperService }, { type: i0.ElementRef }], propDecorators: { verticalAnimationType: [{
                type: Input
            }], horizontalAnimationType: [{
                type: Input
            }], animationDuration: [{
                type: Input
            }], linear: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], orientation: [{
                type: HostBinding,
                args: ['attr.aria-orientation']
            }, {
                type: Input
            }], stepType: [{
                type: Input
            }], contentTop: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], titlePosition: [{
                type: Input
            }], cssClass: [{
                type: HostBinding,
                args: ['class.igx-stepper']
            }], role: [{
                type: HostBinding,
                args: ['attr.role']
            }], directionClass: [{
                type: HostBinding,
                args: ['class.igx-stepper--horizontal']
            }], activeStepChanging: [{
                type: Output
            }], activeStepChanged: [{
                type: Output
            }], invalidIndicatorTemplate: [{
                type: ContentChild,
                args: [IgxStepInvalidIndicatorDirective, { read: TemplateRef }]
            }], completedIndicatorTemplate: [{
                type: ContentChild,
                args: [IgxStepCompletedIndicatorDirective, { read: TemplateRef }]
            }], activeIndicatorTemplate: [{
                type: ContentChild,
                args: [IgxStepActiveIndicatorDirective, { read: TemplateRef }]
            }], _steps: [{
                type: ContentChildren,
                args: [IgxStepComponent, { descendants: false }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RlcHBlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvc3RlcHBlci9zdGVwcGVyLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9zdGVwcGVyL3N0ZXBwZXIuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUE4QixZQUFZLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUMvRSxPQUFPLEVBQUUsSUFBSSxFQUFFLGdCQUFnQixFQUFFLEtBQUssRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ2hFLE9BQU8sRUFDa0MsU0FBUyxFQUFFLFlBQVksRUFBRSxlQUFlLEVBQ2pFLFlBQVksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFDNUMsTUFBTSxFQUE0QixXQUFXLEVBQUUsZ0JBQWdCLEVBQzFFLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBR3JFLE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLGlEQUFpRCxDQUFDO0FBRTdGLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3pELE9BQU8sRUFDUyxxQkFBcUIsRUFBRSx1QkFBdUIsRUFBRSxXQUFXLEVBQ3ZFLHFCQUFxQixFQUFpRCxxQkFBcUIsRUFFOUYsTUFBTSxrQkFBa0IsQ0FBQztBQUMxQixPQUFPLEVBQ0gsK0JBQStCLEVBQy9CLGtDQUFrQyxFQUNsQyxnQ0FBZ0MsRUFDbkMsTUFBTSxxQkFBcUIsQ0FBQztBQUM3QixPQUFPLEVB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SztnQkFjQyxVQUFVO3NCQURoQixLQUFLO3VCQUFDLEVBQUUsU0FBUyxFQUFFLGdCQUFnQixFQUFFO2dCQWUvQixhQUFhO3NCQURuQixLQUFLO2dCQUtDLFFBQVE7c0JBRGQsV0FBVzt1QkFBQyxtQkFBbUI7Z0JBS3pCLElBQUk7c0JBRFYsV0FBVzt1QkFBQyxXQUFXO2dCQUtiLGNBQWM7c0JBRHhCLFdBQVc7dUJBQUMsK0JBQStCO2dCQXNCckMsa0JBQWtCO3NCQUR4QixNQUFNO2dCQVlBLGlCQUFpQjtzQkFEdkIsTUFBTTtnQkFLQSx3QkFBd0I7c0JBRDlCLFlBQVk7dUJBQUMsZ0NBQWdDLEVBQUUsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFO2dCQUs5RCwwQkFBMEI7c0JBRGhDLFlBQVk7dUJBQUMsa0NBQWtDLEVBQUUsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFO2dCQUtoRSx1QkFBdUI7c0JBRDdCLFlBQVk7dUJBQUMsK0JBQStCLEVBQUUsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFO2dCQUs1RCxNQUFNO3NCQURiLGVBQWU7dUJBQUMsZ0JBQWdCLEVBQUUsRUFBRSxXQUFXLEVBQUUsS0FBSyxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQW5pbWF0aW9uUmVmZXJlbmNlTWV0YWRhdGEsIHVzZUFuaW1hdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgTmdJZiwgTmdUZW1wbGF0ZU91dGxldCwgTmdGb3IgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgICBBZnRlckNvbnRlbnRJbml0LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIENvbnRlbnRDaGlsZHJlbixcbiAgICBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEhvc3RCaW5kaW5nLCBJbmplY3QsIElucHV0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSxcbiAgICBPbkluaXQsIE91dHB1dCwgUXVlcnlMaXN0LCBTaW1wbGVDaGFuZ2VzLCBUZW1wbGF0ZVJlZiwgYm9vbGVhbkF0dHJpYnV0ZVxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IElneENhcm91c2VsQ29tcG9uZW50QmFzZSB9IGZyb20gJy4uL2Nhcm91c2VsL2Nhcm91c2VsLWJhc2UnO1xuXG5pbXBvcnQgeyBUb2dnbGVBbmltYXRpb25TZXR0aW5ncyB9IGZyb20gJy4uL2V4cGFuc2lvbi1wYW5lbC90b2dnbGUtYW5pbWF0aW9uLWNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hBbmd1bGFyQW5pbWF0aW9uU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2FuaW1hdGlvbi9hbmd1bGFyLWFuaW1hdGlvbi1zZXJ2aWNlJztcbmltcG9ydCB7IEFuaW1hdGlvblNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9hbmltYXRpb24vYW5pbWF0aW9uJztcbmltcG9ydCB7IElneFN0ZXBDb21wb25lbnQgfSBmcm9tICcuL3N0ZXAvc3RlcC5jb21wb25lbnQnO1xuaW1wb3J0IHtcbiAgICBJZ3hTdGVwcGVyLCBJZ3hTdGVwcGVyT3JpZW50YXRpb24sIElneFN0ZXBwZXJUaXRsZVBvc2l0aW9uLCBJZ3hTdGVwVHlwZSxcbiAgICBJR1hfU1RFUFBFUl9DT01QT05FTlQsIElTdGVwQ2hhbmdlZEV2ZW50QXJncywgSVN0ZXBDaGFuZ2luZ0V2ZW50QXJncywgVmVydGljYWxBbmltYXRpb25UeXBlLFxuICAgIEhvcml6b250YWxBbmltYXRpb25UeXBlXG59IGZyb20gJy4vc3RlcHBlci5jb21tb24nO1xuaW1wb3J0IHtcbiAgICBJZ3hTdGVwQWN0aXZlSW5kaWNhdG9yRGlyZWN0aXZlLFxuICAgIElneFN0ZXBDb21wbGV0ZWRJbmRpY2F0b3JEaXJlY3RpdmUsXG4gICAgSWd4U3RlcEludmFsaWRJbmRpY2F0b3JEaXJlY3RpdmVcbn0gZnJvbSAnLi9zdGVwcGVyLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJZ3hTdGVwcGVyU2VydmljZSB9IGZyb20gJy4vc3RlcHBlci5zZXJ2aWNlJztcbmltcG9ydCB7IGZhZGVJbiwgZ3Jvd1ZlckluLCBncm93VmVyT3V0IH0gZnJvbSAnaWduaXRldWktYW5ndWxhci9hbmltYXRpb25zJztcblxuXG4vLyBUT0RPOiBjb21tb24gaW50ZXJmYWNlIGJldHdlZW4gSWd4Q2Fyb3VzZWxDb21wb25lbnRCYXNlIGFuZCBUb2dnbGVBbmltYXRpb25QbGF5ZXI/XG5cbi8qKlxuICogSWd4U3RlcHBlciBwcm92aWRlcyBhIHdpemFyZC1saWtlIHdvcmtmbG93IGJ5IGRpdmlkaW5nIGNvbnRlbnQgaW50byBsb2dpY2FsIHN0ZXBzLlxuICpcbiAqIEBpZ3hNb2R1bGUgSWd4U3RlcHBlck1vZHVsZVxuICpcbiAqIEBpZ3hLZXl3b3JkcyBzdGVwcGVyXG4gKlxuICogQGlneEdyb3VwIExheW91dHNcbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIElnbml0ZSBVSSBmb3IgQW5ndWxhciBTdGVwcGVyIGNvbXBvbmVudCBhbGxvd3MgdGhlIHVzZXIgdG8gbmF2aWdhdGUgYmV0d2VlbiBtdWx0aXBsZSBzdGVwcy5cbiAqIEl0IHN1cHBvcnRzIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIG9yaWVudGF0aW9uIGFzIHdlbGwgYXMga2V5Ym9hcmQgbmF2aWdhdGlvbiBhbmQgcHJvdmlkZXMgQVBJIG1ldGhvZHMgdG8gY29udHJvbCB0aGUgYWN0aXZlIHN0ZXAuXG4gKiBUaGUgY29tcG9uZW50IG9mZmVycyBrZXlib2FyZCBuYXZpZ2F0aW9uIGFuZCBBUEkgdG8gY29udHJvbCB0aGUgYWN0aXZlIHN0ZXAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGh0bWxcbiAqIDxpZ3gtc3RlcHBlcj5cbiAqICA8aWd4LXN0ZXAgW2FjdGl2ZV09XCJ0cnVlXCI+XG4gKiAgICAgIDxpZ3gtaWNvbiBpZ3hTdGVwSW5kaWNhdG9yPmhvbWU8L2lneC1pY29uPlxuICogICAgICA8cCBpZ3hTdGVwVGl0bGU+SG9tZTwvcD5cbiAqICAgICAgPGRpdiBpZ3hTdGVwQ29udGVudD5cbiAqICAgICAgICAgLi4uXG4gKiAgICAgIDwvZGl2PlxuICogIDwvaWd4LXN0ZXA+XG4gKiAgPGlneC1zdGVwIFtvcHRpb25hbF09XCJ0cnVlXCI+XG4gKiAgICAgIDxkaXYgaWd4U3RlcENvbnRlbnQ+XG4gKiAgICAgICAgICAuLi5cbiAqICAgICAgPC9kaXY+XG4gKiAgPC9pZ3gtc3RlcD5cbiAqICA8aWd4LXN0ZXA+XG4gKiAgICAgIDxkaXYgaWd4U3RlcENvbnRlbnQ+XG4gKiAgICAgICAgICAuLi5cbiAqICAgICAgPC9kaXY+XG4gKiAgPC9pZ3gtc3RlcD5cbiAqIDwvaWd4LXN0ZXBwZXI+XG4gKiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtc3RlcHBlcicsXG4gICAgdGVtcGxhdGVVcmw6ICdzdGVwcGVyLmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgSWd4U3RlcHBlclNlcnZpY2UsXG4gICAgICAgIHsgcHJvdmlkZTogSUdYX1NURVBQRVJfQ09NUE9ORU5ULCB1c2VFeGlzdGluZzogSWd4U3RlcHBlckNvbXBvbmVudCB9LFxuICAgIF0sXG4gICAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgICBpbXBvcnRzOiBbTmdJZiwgTmdUZW1wbGF0ZU91dGxldCwgTmdGb3JdXG59KVxuZXhwb3J0IGNsYXNzIElneFN0ZXBwZXJDb21wb25lbnQgZXh0ZW5kcyBJZ3hDYXJvdXNlbENvbXBvbmVudEJhc2UgaW1wbGVtZW50cyBJZ3hTdGVwcGVyLCBPbkNoYW5nZXMsIE9uSW5pdCwgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcblxuICAgIC8qKlxuICAgICAqIEdldC9TZXQgdGhlIGFuaW1hdGlvbiB0eXBlIG9mIHRoZSBzdGVwcGVyIHdoZW4gdGhlIG9yaWVudGF0aW9uIGRpcmVjdGlvbiBpcyB2ZXJ0aWNhbC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZ3Jvd2AuIE90aGVyIHBvc3NpYmxlIHZhbHVlcyBhcmUgYGZhZGVgIGFuZCBgbm9uZWAuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zdGVwcGVyIHZlcnRpY2FsQW5pbWF0aW9uVHlwZT1cIm5vbmVcIj5cbiAgICAgKiA8aWd4LXN0ZXBwZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IHZlcnRpY2FsQW5pbWF0aW9uVHlwZSgpOiBWZXJ0aWNhbEFuaW1hdGlvblR5cGUge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmVydGljYWxBbmltYXRpb25UeXBlO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgdmVydGljYWxBbmltYXRpb25UeXBlKHZhbHVlOiBWZXJ0aWNhbEFuaW1hdGlvblR5cGUpIHtcbiAgICAgICAgLy8gVE9ETzogYWN0aXZlQ2hhbmdlIGV2ZW50IGlzIG5vdCBlbWl0dGVkIGZvciB0aGUgY29sbGFwc2luZyBzdGVwcyAobG9vcCB0aHJvdWdoIGNvbGxhcHNpbmcgc3RlcHMgYW5kIGVtaXQpXG4gICAgICAgIHRoaXMuc3RlcHBlclNlcnZpY2UuY29sbGFwc2luZ1N0ZXBzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX3ZlcnRpY2FsQW5pbWF0aW9uVHlwZSA9IHZhbHVlO1xuXG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2dyb3cnOlxuICAgICAgICAgICAgICAgIHRoaXMudmVydGljYWxBbmltYXRpb25TZXR0aW5ncyA9IHRoaXMudXBkYXRlVmVydGljYWxBbmltYXRpb25TZXR0aW5ncyhncm93VmVySW4sIGdyb3dWZXJPdXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZmFkZSc6XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNhbEFuaW1hdGlvblNldHRpbmdzID0gdGhpcy51cGRhdGVWZXJ0aWNhbEFuaW1hdGlvblNldHRpbmdzKGZhZGVJbiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRpY2FsQW5pbWF0aW9uU2V0dGluZ3MgPSB0aGlzLnVwZGF0ZVZlcnRpY2FsQW5pbWF0aW9uU2V0dGluZ3MobnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQvU2V0IHRoZSBhbmltYXRpb24gdHlwZSBvZiB0aGUgc3RlcHBlciB3aGVuIHRoZSBvcmllbnRhdGlvbiBkaXJlY3Rpb24gaXMgaG9yaXpvbnRhbC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZ3Jvd2AuIE90aGVyIHBvc3NpYmxlIHZhbHVlcyBhcmUgYGZhZGVgIGFuZCBgbm9uZWAuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zdGVwcGVyIGFuaW1hdGlvblR5cGU9XCJub25lXCI+XG4gICAgICogPGlneC1zdGVwcGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBob3Jpem9udGFsQW5pbWF0aW9uVHlwZSgpOiBIb3Jpem9udGFsQW5pbWF0aW9uVHlwZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvblR5cGU7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBob3Jpem9udGFsQW5pbWF0aW9uVHlwZSh2YWx1ZTogSG9yaXpvbnRhbEFuaW1hdGlvblR5cGUpIHtcbiAgICAgICAgLy8gVE9ETzogYWN0aXZlQ2hhbmdlIGV2ZW50IGlzIG5vdCBlbWl0dGVkIGZvciB0aGUgY29sbGFwc2luZyBzdGVwcyAobG9vcCB0aHJvdWdoIGNvbGxhcHNpbmcgc3RlcHMgYW5kIGVtaXQpXG4gICAgICAgIHRoaXMuc3RlcHBlclNlcnZpY2UuY29sbGFwc2luZ1N0ZXBzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uVHlwZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldC9TZXQgdGhlIGFuaW1hdGlvbiBkdXJhdGlvbi5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zdGVwcGVyIFthbmltYXRpb25EdXJhdGlvbl09XCI1MDBcIj5cbiAgICAgKiA8aWd4LXN0ZXBwZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGFuaW1hdGlvbkR1cmF0aW9uKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRBbmltYXRpb25EdXJhdGlvbjtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IGFuaW1hdGlvbkR1cmF0aW9uKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlID4gMCkge1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0QW5pbWF0aW9uRHVyYXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlZmF1bHRBbmltYXRpb25EdXJhdGlvbiA9IHRoaXMuX2RlZmF1bHRBbmltYXRpb25EdXJhdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQvU2V0IHdoZXRoZXIgdGhlIHN0ZXBwZXIgaXMgbGluZWFyLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGUgc3RlcHBlciBpcyBpbiBsaW5lYXIgbW9kZSBhbmQgaWYgdGhlIGFjdGl2ZSBzdGVwIGlzIHZhbGlkIG9ubHkgdGhlbiB0aGUgdXNlciBpcyBhYmxlIHRvIG1vdmUgZm9yd2FyZC5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXN0ZXBwZXIgW2xpbmVhcl09XCJ0cnVlXCI+PC9pZ3gtc3RlcHBlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoeyB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGUgfSlcbiAgICBwdWJsaWMgZ2V0IGxpbmVhcigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVhcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IGxpbmVhcih2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9saW5lYXIgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX2xpbmVhciAmJiB0aGlzLnN0ZXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIHdoZW4gdGhlIHN0ZXBwZXIgaXMgaW4gbGluZWFyIG1vZGUgd2Ugc2hvdWxkIGNhbGN1bGF0ZSB3aGljaCBzdGVwcyBzaG91bGQgYmUgZGlzYWJsZWRcbiAgICAgICAgICAgIC8vIGFuZCB3aGljaCBhcmUgdmlzaXRlZCBpLmUuIHRoZWlyIHZhbGlkaXR5IHNob3VsZCBiZSBjb3JyZWN0bHkgZGlzcGxheWVkLlxuICAgICAgICAgICAgdGhpcy5zdGVwcGVyU2VydmljZS5jYWxjdWxhdGVWaXNpdGVkU3RlcHMoKTtcbiAgICAgICAgICAgIHRoaXMuc3RlcHBlclNlcnZpY2UuY2FsY3VsYXRlTGluZWFyRGlzYWJsZWRTdGVwcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGVwcGVyU2VydmljZS5saW5lYXJEaXNhYmxlZFN0ZXBzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQvU2V0IHRoZSBzdGVwcGVyIG9yaWVudGF0aW9uLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuc3RlcHBlci5vcmllbnRhdGlvbiA9IElneFN0ZXBwZXJPcmllbnRhdGlvbi5WZXJ0aWNhbDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1vcmllbnRhdGlvbicpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IG9yaWVudGF0aW9uKCk6IElneFN0ZXBwZXJPcmllbnRhdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvbjtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IG9yaWVudGF0aW9uKHZhbHVlOiBJZ3hTdGVwcGVyT3JpZW50YXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuX29yaWVudGF0aW9uID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogYWN0aXZlQ2hhbmdlIGV2ZW50IGlzIG5vdCBlbWl0dGVkIGZvciB0aGUgY29sbGFwc2luZyBzdGVwc1xuICAgICAgICB0aGlzLnN0ZXBwZXJTZXJ2aWNlLmNvbGxhcHNpbmdTdGVwcy5jbGVhcigpO1xuICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9kZWZhdWx0VGl0bGVQb3NpdGlvbiA9IHRoaXMuX29yaWVudGF0aW9uID09PSBJZ3hTdGVwcGVyT3JpZW50YXRpb24uSG9yaXpvbnRhbCA/XG4gICAgICAgICAgICBJZ3hTdGVwcGVyVGl0bGVQb3NpdGlvbi5Cb3R0b20gOiBJZ3hTdGVwcGVyVGl0bGVQb3NpdGlvbi5FbmQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0L1NldCB0aGUgdHlwZSBvZiB0aGUgc3RlcHMuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5zdGVwcGVyLnN0ZXBUeXBlID0gSWd4U3RlcFR5cGUuSW5kaWNhdG9yO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHN0ZXBUeXBlOiBJZ3hTdGVwVHlwZSA9IElneFN0ZXBUeXBlLkZ1bGw7XG5cbiAgICAvKipcbiAgICAgKiBHZXQvU2V0IHdoZXRoZXIgdGhlIGNvbnRlbnQgaXMgZGlzcGxheWVkIGFib3ZlIHRoZSBzdGVwcy5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgIGFuZCB0aGUgY29udGVudCBpcyBiZWxvdyB0aGUgc3RlcHMuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5zdGVwcGVyLmNvbnRlbnRUb3AgPSB0cnVlO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCh7IHRyYW5zZm9ybTogYm9vbGVhbkF0dHJpYnV0ZSB9KVxuICAgIHB1YmxpYyBjb250ZW50VG9wID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBHZXQvU2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgc3RlcHMgdGl0bGUuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIHdoZW4gdGhlIHN0ZXBwZXIgaXMgaG9yaXpvbnRhbGx5IG9yaWVudGF0ZWQgaXMgYGJvdHRvbWAuXG4gICAgICogSW4gdmVydGljYWwgbGF5b3V0IHRoZSBkZWZhdWx0IHRpdGxlIHBvc2l0aW9uIGlzIGBlbmRgLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuc3RlcHBlci50aXRsZVBvc2l0aW9uID0gSWd4U3RlcHBlclRpdGxlUG9zaXRpb24uVG9wO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHRpdGxlUG9zaXRpb246IElneFN0ZXBwZXJUaXRsZVBvc2l0aW9uID0gbnVsbDtcblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1zdGVwcGVyJylcbiAgICBwdWJsaWMgY3NzQ2xhc3MgPSAnaWd4LXN0ZXBwZXInO1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICoqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5yb2xlJylcbiAgICBwdWJsaWMgcm9sZSA9ICd0YWJsaXN0JztcblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1zdGVwcGVyLS1ob3Jpem9udGFsJylcbiAgICBwdWJsaWMgZ2V0IGRpcmVjdGlvbkNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmllbnRhdGlvbiA9PT0gSWd4U3RlcHBlck9yaWVudGF0aW9uLkhvcml6b250YWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHRoZSBzdGVwcGVyJ3MgYWN0aXZlIHN0ZXAgaXMgY2hhbmdpbmcuXG4gICAgICpcbiAgICAgKmBgYGh0bWxcbiAgICAgKiA8aWd4LXN0ZXBwZXIgKGFjdGl2ZVN0ZXBDaGFuZ2luZyk9XCJoYW5kbGVBY3RpdmVTdGVwQ2hhbmdpbmcoJGV2ZW50KVwiPlxuICAgICAqIDwvaWd4LXN0ZXBwZXI+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgaGFuZGxlQWN0aXZlU3RlcENoYW5naW5nKGV2ZW50OiBJU3RlcENoYW5naW5nRXZlbnRBcmdzKSB7XG4gICAgICogIGlmIChldmVudC5uZXdJbmRleCA8IGV2ZW50Lm9sZEluZGV4KSB7XG4gICAgICogICAgICBldmVudC5jYW5jZWwgPSB0cnVlO1xuICAgICAqICB9XG4gICAgICogfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGFjdGl2ZVN0ZXBDaGFuZ2luZyA9IG5ldyBFdmVudEVtaXR0ZXI8SVN0ZXBDaGFuZ2luZ0V2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiB0aGUgYWN0aXZlIHN0ZXAgaXMgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgXG4gICAgICogPGlneC1zdGVwcGVyIChhY3RpdmVTdGVwQ2hhbmdlZCk9XCJoYW5kbGVBY3RpdmVTdGVwQ2hhbmdlZCgkZXZlbnQpXCI+PC9pZ3gtc3RlcHBlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgYWN0aXZlU3RlcENoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPElTdGVwQ2hhbmdlZEV2ZW50QXJncz4oKTtcblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIEBDb250ZW50Q2hpbGQoSWd4U3RlcEludmFsaWRJbmRpY2F0b3JEaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYgfSlcbiAgICBwdWJsaWMgaW52YWxpZEluZGljYXRvclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxJZ3hTdGVwSW52YWxpZEluZGljYXRvckRpcmVjdGl2ZT47XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBAQ29udGVudENoaWxkKElneFN0ZXBDb21wbGV0ZWRJbmRpY2F0b3JEaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYgfSlcbiAgICBwdWJsaWMgY29tcGxldGVkSW5kaWNhdG9yVGVtcGxhdGU6IFRlbXBsYXRlUmVmPElneFN0ZXBDb21wbGV0ZWRJbmRpY2F0b3JEaXJlY3RpdmU+O1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hTdGVwQWN0aXZlSW5kaWNhdG9yRGlyZWN0aXZlLCB7IHJlYWQ6IFRlbXBsYXRlUmVmIH0pXG4gICAgcHVibGljIGFjdGl2ZUluZGljYXRvclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxJZ3hTdGVwQWN0aXZlSW5kaWNhdG9yRGlyZWN0aXZlPjtcblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIEBDb250ZW50Q2hpbGRyZW4oSWd4U3RlcENvbXBvbmVudCwgeyBkZXNjZW5kYW50czogZmFsc2UgfSlcbiAgICBwcml2YXRlIF9zdGVwczogUXVlcnlMaXN0PElneFN0ZXBDb21wb25lbnQ+O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBzdGVwcy5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBzdGVwczogSWd4U3RlcENvbXBvbmVudFtdID0gdGhpcy5zdGVwcGVyLnN0ZXBzO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgc3RlcHMoKTogSWd4U3RlcENvbXBvbmVudFtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0ZXBzPy50b0FycmF5KCkgfHwgW107XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGdldCBuYXRpdmVFbGVtZW50KCk6IEhUTUxFbGVtZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyB2ZXJ0aWNhbEFuaW1hdGlvblNldHRpbmdzOiBUb2dnbGVBbmltYXRpb25TZXR0aW5ncyA9IHtcbiAgICAgICAgb3BlbkFuaW1hdGlvbjogZ3Jvd1ZlckluLFxuICAgICAgICBjbG9zZUFuaW1hdGlvbjogZ3Jvd1Zlck91dCxcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBfZGVmYXVsdFRpdGxlUG9zaXRpb246IElneFN0ZXBwZXJUaXRsZVBvc2l0aW9uID0gSWd4U3RlcHBlclRpdGxlUG9zaXRpb24uQm90dG9tO1xuICAgIHByaXZhdGUgZGVzdHJveSQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAgIHByaXZhdGUgX29yaWVudGF0aW9uOiBJZ3hTdGVwcGVyT3JpZW50YXRpb24gPSBJZ3hTdGVwcGVyT3JpZW50YXRpb24uSG9yaXpvbnRhbDtcbiAgICBwcml2YXRlIF92ZXJ0aWNhbEFuaW1hdGlvblR5cGU6IFZlcnRpY2FsQW5pbWF0aW9uVHlwZSA9IFZlcnRpY2FsQW5pbWF0aW9uVHlwZS5Hcm93O1xuICAgIHByaXZhdGUgX2xpbmVhciA9IGZhbHNlO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX2RlZmF1bHRBbmltYXRpb25EdXJhdGlvbiA9IDM1MDtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBASW5qZWN0KElneEFuZ3VsYXJBbmltYXRpb25TZXJ2aWNlKSBhbmltYXRpb25TZXJ2aWNlOiBBbmltYXRpb25TZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIHN0ZXBwZXJTZXJ2aWNlOiBJZ3hTdGVwcGVyU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBlbGVtZW50OiBFbGVtZW50UmVmPEhUTUxFbGVtZW50Pikge1xuICAgICAgICBzdXBlcihhbmltYXRpb25TZXJ2aWNlLCBjZHIpO1xuICAgICAgICB0aGlzLnN0ZXBwZXJTZXJ2aWNlLnN0ZXBwZXIgPSB0aGlzO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgICAgIGlmIChjaGFuZ2VzWydhbmltYXRpb25EdXJhdGlvbiddKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2FsQW5pbWF0aW9uVHlwZSA9IHRoaXMuX3ZlcnRpY2FsQW5pbWF0aW9uVHlwZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5lbnRlckFuaW1hdGlvbkRvbmUucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVN0ZXBDaGFuZ2VkLmVtaXQoeyBvd25lcjogdGhpcywgaW5kZXg6IHRoaXMuc3RlcHBlclNlcnZpY2UuYWN0aXZlU3RlcC5pbmRleCB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGVhdmVBbmltYXRpb25Eb25lLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RlcHBlclNlcnZpY2UuY29sbGFwc2luZ1N0ZXBzLnNpemUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0ZXBwZXJTZXJ2aWNlLmNvbGxhcHNlKHRoaXMuc3RlcHBlclNlcnZpY2UucHJldmlvdXNBY3RpdmVTdGVwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnN0ZXBwZXJTZXJ2aWNlLmNvbGxhcHNpbmdTdGVwcykuc2xpY2UoMCwgdGhpcy5zdGVwcGVyU2VydmljZS5jb2xsYXBzaW5nU3RlcHMuc2l6ZSAtIDEpXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKHN0ZXAgPT4gdGhpcy5zdGVwcGVyU2VydmljZS5jb2xsYXBzZShzdGVwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG5cbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xuICAgICAgICBsZXQgYWN0aXZlU3RlcDtcbiAgICAgICAgdGhpcy5zdGVwcy5mb3JFYWNoKChzdGVwLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGVwQXJpYShzdGVwLCBpbmRleCk7XG4gICAgICAgICAgICBpZiAoIWFjdGl2ZVN0ZXAgJiYgc3RlcC5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVTdGVwID0gc3RlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghYWN0aXZlU3RlcCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZUZpcnN0U3RlcCh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmxpbmVhcikge1xuICAgICAgICAgICAgdGhpcy5zdGVwcGVyU2VydmljZS5jYWxjdWxhdGVMaW5lYXJEaXNhYmxlZFN0ZXBzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhhbmRsZVN0ZXBDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLm5leHQoKTtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRlcyB0aGUgc3RlcCBhdCBhIGdpdmVuIGluZGV4LlxuICAgICAqXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5zdGVwcGVyLm5hdmlnYXRlVG8oMSk7XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgbmF2aWdhdGVUbyhpbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLnN0ZXBzW2luZGV4XTtcbiAgICAgICAgaWYgKCFzdGVwIHx8IHRoaXMuc3RlcHBlclNlcnZpY2UuYWN0aXZlU3RlcCA9PT0gc3RlcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZhdGVTdGVwKHN0ZXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRlcyB0aGUgbmV4dCBlbmFibGVkIHN0ZXAuXG4gICAgICpcbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnN0ZXBwZXIubmV4dCgpO1xuICAgICAqYGBgXG4gICAgICovXG4gICAgcHVibGljIG5leHQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubW92ZVRvTmV4dFN0ZXAoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZXMgdGhlIHByZXZpb3VzIGVuYWJsZWQgc3RlcC5cbiAgICAgKlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuc3RlcHBlci5wcmV2KCk7XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgcHJldigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tb3ZlVG9OZXh0U3RlcChmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBzdGVwcGVyIHRvIGl0cyBpbml0aWFsIHN0YXRlIGkuZS4gYWN0aXZhdGVzIHRoZSBmaXJzdCBzdGVwLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgc3RlcHMnIGNvbnRlbnQgd2lsbCBub3QgYmUgYXV0b21hdGljYWxseSByZXNldC5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnN0ZXBwZXIucmVzZXQoKTtcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zdGVwcGVyU2VydmljZS52aXNpdGVkU3RlcHMuY2xlYXIoKTtcbiAgICAgICAgY29uc3QgYWN0aXZlU3RlcCA9IHRoaXMuc3RlcHMuZmluZChzID0+ICFzLmRpc2FibGVkKTtcbiAgICAgICAgaWYgKGFjdGl2ZVN0ZXApIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVTdGVwKGFjdGl2ZVN0ZXApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIHBsYXlIb3Jpem9udGFsQW5pbWF0aW9ucygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wcmV2aW91c0l0ZW0gPSB0aGlzLnN0ZXBwZXJTZXJ2aWNlLnByZXZpb3VzQWN0aXZlU3RlcDtcbiAgICAgICAgdGhpcy5jdXJyZW50SXRlbSA9IHRoaXMuc3RlcHBlclNlcnZpY2UuYWN0aXZlU3RlcDtcbiAgICAgICAgdGhpcy50cmlnZ2VyQW5pbWF0aW9ucygpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXRQcmV2aW91c0VsZW1lbnQoKTogSFRNTEVsZW1lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGVwcGVyU2VydmljZS5wcmV2aW91c0FjdGl2ZVN0ZXA/LmNvbnRlbnRDb250YWluZXIubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0Q3VycmVudEVsZW1lbnQoKTogSFRNTEVsZW1lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGVwcGVyU2VydmljZS5hY3RpdmVTdGVwLmNvbnRlbnRDb250YWluZXIubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVZlcnRpY2FsQW5pbWF0aW9uU2V0dGluZ3MoXG4gICAgICAgIG9wZW5BbmltYXRpb246IEFuaW1hdGlvblJlZmVyZW5jZU1ldGFkYXRhLFxuICAgICAgICBjbG9zZUFuaW1hdGlvbjogQW5pbWF0aW9uUmVmZXJlbmNlTWV0YWRhdGEpOiBUb2dnbGVBbmltYXRpb25TZXR0aW5ncyB7XG4gICAgICAgIGNvbnN0IGN1c3RvbUNsb3NlQW5pbWF0aW9uID0gdXNlQW5pbWF0aW9uKGNsb3NlQW5pbWF0aW9uLCB7XG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5hbmltYXRpb25EdXJhdGlvbiArICdtcydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGN1c3RvbU9wZW5BbmltYXRpb24gPSB1c2VBbmltYXRpb24ob3BlbkFuaW1hdGlvbiwge1xuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuYW5pbWF0aW9uRHVyYXRpb24gKyAnbXMnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcGVuQW5pbWF0aW9uOiBvcGVuQW5pbWF0aW9uID8gY3VzdG9tT3BlbkFuaW1hdGlvbiA6IG51bGwsXG4gICAgICAgICAgICBjbG9zZUFuaW1hdGlvbjogY2xvc2VBbmltYXRpb24gPyBjdXN0b21DbG9zZUFuaW1hdGlvbiA6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVN0ZXBBcmlhKHN0ZXA6IElneFN0ZXBDb21wb25lbnQsIGluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgc3RlcC5faW5kZXggPSBpbmRleDtcbiAgICAgICAgc3RlcC5yZW5kZXJlci5zZXRBdHRyaWJ1dGUoc3RlcC5uYXRpdmVFbGVtZW50LCAnYXJpYS1zZXRzaXplJywgKHRoaXMuc3RlcHMubGVuZ3RoKS50b1N0cmluZygpKTtcbiAgICAgICAgc3RlcC5yZW5kZXJlci5zZXRBdHRyaWJ1dGUoc3RlcC5uYXRpdmVFbGVtZW50LCAnYXJpYS1wb3NpbnNldCcsIChpbmRleCArIDEpLnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlU3RlcENoYW5nZXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N0ZXBzLmNoYW5nZXMucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZShzdGVwcyA9PiB7XG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzdGVwcy5mb3JFYWNoKChzdGVwLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0ZXBBcmlhKHN0ZXAsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGFjdGl2ZSBzdGVwIGlzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNBY3RpdmVTdGVwID0gdGhpcy5zdGVwcy5maW5kKHMgPT4gcyA9PT0gdGhpcy5zdGVwcGVyU2VydmljZS5hY3RpdmVTdGVwKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0FjdGl2ZVN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZUZpcnN0U3RlcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUTyBETzogbWFyayBzdGVwIGFkZGVkIGJlZm9yZSB0aGUgYWN0aXZlIGFzIHZpc2l0ZWQ/XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGluZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RlcHBlclNlcnZpY2UuY2FsY3VsYXRlTGluZWFyRGlzYWJsZWRTdGVwcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFjdGl2YXRlRmlyc3RTdGVwKGFjdGl2YXRlSW5pdGlhbGx5ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgZmlyc3RFbmFibGVkU3RlcCA9IHRoaXMuc3RlcHMuZmluZChzID0+ICFzLmRpc2FibGVkKTtcbiAgICAgICAgaWYgKGZpcnN0RW5hYmxlZFN0ZXApIHtcbiAgICAgICAgICAgIGZpcnN0RW5hYmxlZFN0ZXAuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChhY3RpdmF0ZUluaXRpYWxseSkge1xuICAgICAgICAgICAgICAgIGZpcnN0RW5hYmxlZFN0ZXAuYWN0aXZlQ2hhbmdlLmVtaXQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVTdGVwQ2hhbmdlZC5lbWl0KHsgb3duZXI6IHRoaXMsIGluZGV4OiBmaXJzdEVuYWJsZWRTdGVwLmluZGV4IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhY3RpdmF0ZVN0ZXAoc3RlcDogSWd4U3RlcENvbXBvbmVudCkge1xuICAgICAgICBpZiAodGhpcy5vcmllbnRhdGlvbiA9PT0gSWd4U3RlcHBlck9yaWVudGF0aW9uLkhvcml6b250YWwpIHtcbiAgICAgICAgICAgIHN0ZXAuY2hhbmdlSG9yaXpvbnRhbEFjdGl2ZVN0ZXAoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RlcHBlclNlcnZpY2UuZXhwYW5kKHN0ZXApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtb3ZlVG9OZXh0U3RlcChuZXh0ID0gdHJ1ZSkge1xuICAgICAgICBsZXQgc3RlcHM6IElneFN0ZXBDb21wb25lbnRbXSA9IHRoaXMuc3RlcHM7XG4gICAgICAgIGxldCBhY3RpdmVTdGVwSW5kZXggPSB0aGlzLnN0ZXBwZXJTZXJ2aWNlLmFjdGl2ZVN0ZXAuaW5kZXg7XG4gICAgICAgIGlmICghbmV4dCkge1xuICAgICAgICAgICAgc3RlcHMgPSB0aGlzLnN0ZXBzLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGFjdGl2ZVN0ZXBJbmRleCA9IHN0ZXBzLmZpbmRJbmRleChzID0+IHMgPT09IHRoaXMuc3RlcHBlclNlcnZpY2UuYWN0aXZlU3RlcCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXh0U3RlcCA9IHN0ZXBzLmZpbmQoKHMsIGkpID0+IGkgPiBhY3RpdmVTdGVwSW5kZXggJiYgcy5pc0FjY2Vzc2libGUpO1xuICAgICAgICBpZiAobmV4dFN0ZXApIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVTdGVwKG5leHRTdGVwKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIjxkaXYgKm5nSWY9XCIhY29udGVudFRvcCB8fCBvcmllbnRhdGlvbiAhPT0gJ2hvcml6b250YWwnXCIgY2xhc3M9XCJpZ3gtc3RlcHBlcl9faGVhZGVyXCI+XG4gICAgPG5nLXRlbXBsYXRlICpuZ1RlbXBsYXRlT3V0bGV0PVwic3RlcFRlbXBsYXRlXCI+PC9uZy10ZW1wbGF0ZT5cbjwvZGl2PlxuXG48ZGl2ICpuZ0lmPVwib3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJ1wiIGNsYXNzPVwiaWd4LXN0ZXBwZXJfX2JvZHlcIj5cbiAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBzdGVwIG9mIHN0ZXBzXCI+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJzdGVwLmNvbnRlbnRUZW1wbGF0ZVwiPjwvbmctY29udGFpbmVyPlxuICAgIDwvbmctY29udGFpbmVyPlxuPC9kaXY+XG5cbjxkaXYgKm5nSWY9XCJjb250ZW50VG9wICYmIG9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCdcIiBjbGFzcz1cImlneC1zdGVwcGVyX19oZWFkZXJcIj5cbiAgICA8bmctdGVtcGxhdGUgKm5nVGVtcGxhdGVPdXRsZXQ9XCJzdGVwVGVtcGxhdGVcIj48L25nLXRlbXBsYXRlPlxuPC9kaXY+XG5cbjxuZy10ZW1wbGF0ZSAjc3RlcFRlbXBsYXRlPlxuICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImlneC1zdGVwXCI+PC9uZy1jb250ZW50PlxuPC9uZy10ZW1wbGF0ZT5cbiJdfQ==