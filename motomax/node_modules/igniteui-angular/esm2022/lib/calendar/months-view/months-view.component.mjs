import { Component, Input, HostBinding, booleanAttribute, Inject, } from "@angular/core";
import { IgxCalendarMonthDirective } from "../calendar.directives";
import { NgFor, TitleCasePipe, DatePipe } from "@angular/common";
import { IgxCalendarViewDirective, DAY_INTERVAL_TOKEN, } from "../common/calendar-view.directive";
import { NG_VALUE_ACCESSOR } from "@angular/forms";
import { CalendarDay } from "../common/model";
import { calendarRange } from "../common/helpers";
import * as i0 from "@angular/core";
let NEXT_ID = 0;
export class IgxMonthsViewComponent extends IgxCalendarViewDirective {
    #standalone;
    /**
     * @hidden @internal
     */
    get standalone() {
        return this.#standalone;
    }
    set standalone(value) {
        this.#standalone = value;
    }
    /**
     * Gets the month format option of the months view.
     * ```typescript
     * let monthFormat = this.monthsView.monthFormat.
     * ```
     */
    get monthFormat() {
        return this._monthFormat;
    }
    /**
     * Sets the month format option of the months view.
     * ```html
     * <igx-months-view> [monthFormat]="short'"</igx-months-view>
     * ```
     *
     * @memberof IgxMonthsViewComponent
     */
    set monthFormat(value) {
        this._monthFormat = value;
        this.initFormatter();
    }
    /**
     * Returns an array of date objects which are then used to
     * properly render the month names.
     *
     * Used in the template of the component
     *
     * @hidden @internal
     */
    get range() {
        const start = CalendarDay.from(this.date).set({ date: 1, month: 0 });
        const end = start.add(this.dayInterval, 12);
        return Array.from(calendarRange({ start, end, unit: this.dayInterval })).map((m) => m.native);
    }
    constructor(el, dayInterval) {
        super(dayInterval);
        this.el = el;
        this.#standalone = true;
        /**
         * Sets/gets the `id` of the months view.
         * If not set, the `id` will have value `"igx-months-view-0"`.
         * ```html
         * <igx-months-view id="my-months-view"></igx-months-view>
         * ```
         * ```typescript
         * let monthsViewId =  this.monthsView.id;
         * ```
         *
         * @memberof IgxMonthsViewComponent
         */
        this.id = `igx-months-view-${NEXT_ID++}`;
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */
        this.viewClass = true;
        /**
         * Gets/sets whether the view should be rendered
         * according to the locale and format, if any.
         */
        this.formatView = true;
        /**
         * @hidden
         */
        this._monthFormat = "short";
    }
    /**
     * Returns the locale representation of the month in the months view.
     *
     * @hidden
     */
    formattedMonth(value) {
        const rawFormatter = new Intl.DateTimeFormat(this.locale, {
            month: "long",
            year: "numeric",
        });
        if (this.formatView) {
            return {
                long: rawFormatter.format(value),
                formatted: this._formatter.format(value),
            };
        }
        return {
            long: rawFormatter.format(value),
            formatted: `${value.getMonth()}`,
        };
    }
    /**
     * @hidden
     */
    monthTracker(_, item) {
        return `${item.getMonth()}}`;
    }
    /**
     * @hidden
     */
    initFormatter() {
        this._formatter = new Intl.DateTimeFormat(this._locale, {
            month: this.monthFormat,
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxMonthsViewComponent, deps: [{ token: i0.ElementRef }, { token: DAY_INTERVAL_TOKEN }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "18.2.4", type: IgxMonthsViewComponent, isStandalone: true, selector: "igx-months-view", inputs: { id: "id", standalone: "standalone", monthFormat: "monthFormat", formatView: ["formatView", "formatView", booleanAttribute] }, host: { properties: { "attr.id": "this.id", "class.igx-calendar-view": "this.viewClass", "class.igx-calendar-view--standalone": "this.standalone" } }, providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: IgxMonthsViewComponent,
                multi: true,
            },
            {
                provide: DAY_INTERVAL_TOKEN,
                useValue: "month",
            },
        ], usesInheritance: true, ngImport: i0, template: "<div class=\"igx-calendar-view__items\" role=\"row\">\n    <span\n        igxCalendarMonth\n        #item=\"igxCalendarMonth\"\n        *ngFor=\"let month of range; trackBy: monthTracker\"\n        class=\"igx-calendar-view__item\"\n        role=\"gridcell\"\n        [attr.id]=\"month.getTime()\"\n        [attr.aria-label]=\"formattedMonth(month).long\"\n        [attr.aria-selected]=\"item.isSelected\"\n        [value]=\"month\"\n        [date]=\"date\"\n        [showActive]=\"showActive\"\n        (itemSelection)=\"selectDate($event)\"\n    >\n        <span class=\"igx-calendar-view__item-inner\" aria-hidden=\"true\">\n            {{ formattedMonth(month).formatted | titlecase }}\n        </span>\n    </span>\n</div>\n", dependencies: [{ kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: IgxCalendarMonthDirective, selector: "[igxCalendarMonth]", exportAs: ["igxCalendarMonth"] }, { kind: "pipe", type: TitleCasePipe, name: "titlecase" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.4", ngImport: i0, type: IgxMonthsViewComponent, decorators: [{
            type: Component,
            args: [{ providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: IgxMonthsViewComponent,
                            multi: true,
                        },
                        {
                            provide: DAY_INTERVAL_TOKEN,
                            useValue: "month",
                        },
                    ], selector: "igx-months-view", standalone: true, imports: [NgFor, IgxCalendarMonthDirective, TitleCasePipe, DatePipe], template: "<div class=\"igx-calendar-view__items\" role=\"row\">\n    <span\n        igxCalendarMonth\n        #item=\"igxCalendarMonth\"\n        *ngFor=\"let month of range; trackBy: monthTracker\"\n        class=\"igx-calendar-view__item\"\n        role=\"gridcell\"\n        [attr.id]=\"month.getTime()\"\n        [attr.aria-label]=\"formattedMonth(month).long\"\n        [attr.aria-selected]=\"item.isSelected\"\n        [value]=\"month\"\n        [date]=\"date\"\n        [showActive]=\"showActive\"\n        (itemSelection)=\"selectDate($event)\"\n    >\n        <span class=\"igx-calendar-view__item-inner\" aria-hidden=\"true\">\n            {{ formattedMonth(month).formatted | titlecase }}\n        </span>\n    </span>\n</div>\n" }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DAY_INTERVAL_TOKEN]
                }] }], propDecorators: { id: [{
                type: HostBinding,
                args: ["attr.id"]
            }, {
                type: Input
            }], viewClass: [{
                type: HostBinding,
                args: ["class.igx-calendar-view"]
            }], standalone: [{
                type: Input
            }, {
                type: HostBinding,
                args: ["class.igx-calendar-view--standalone"]
            }], monthFormat: [{
                type: Input
            }], formatView: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9udGhzLXZpZXcuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL2NhbGVuZGFyL21vbnRocy12aWV3L21vbnRocy12aWV3LmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9jYWxlbmRhci9tb250aHMtdmlldy9tb250aHMtdmlldy5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0gsU0FBUyxFQUNULEtBQUssRUFDTCxXQUFXLEVBRVgsZ0JBQWdCLEVBQ2hCLE1BQU0sR0FDVCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUNuRSxPQUFPLEVBQUUsS0FBSyxFQUFFLGFBQWEsRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNqRSxPQUFPLEVBQ0gsd0JBQXdCLEVBQ3hCLGtCQUFrQixHQUNyQixNQUFNLG1DQUFtQyxDQUFDO0FBQzNDLE9BQU8sRUFBd0IsaUJBQWlCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN6RSxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFFOUMsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLG1CQUFtQixDQUFDOztBQUVsRCxJQUFJLE9BQU8sR0FBRyxDQUFDLENBQUM7QUFtQmhCLE1BQU0sT0FBTyxzQkFBdUIsU0FBUSx3QkFBd0I7SUFDaEUsV0FBVyxDQUFRO0lBMEJuQjs7T0FFRztJQUNILElBRVcsVUFBVTtRQUNqQixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDNUIsQ0FBQztJQUVELElBQVcsVUFBVSxDQUFDLEtBQWM7UUFDaEMsSUFBSSxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUM7SUFD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QUFFLE9BQU87YUFDcEI7U0FDSixpRENoQ0wsMnRCQW9CQSw0Q0RnQmMsS0FBSyxtSEFBRSx5QkFBeUIsMEZBQUUsYUFBYTs7MkZBRWhELHNCQUFzQjtrQkFqQmxDLFNBQVM7Z0NBQ0s7d0JBQ1A7NEJBQ0ksT0FBTyxFQUFFLGlCQUFpQjs0QkFDMUIsV0FBVyx3QkFBd0I7NEJBQ25DLEtBQUssRUFBRSxJQUFJO3lCQUNkO3dCQUNEOzRCQUNJLE9BQU8sRUFBRSxrQkFBa0I7NEJBQzNCLFFBQVEsRUFBRSxPQUFPO3lCQUNwQjtxQkFDSixZQUNTLGlCQUFpQixjQUVmLElBQUksV0FDUCxDQUFDLEtBQUssRUFBRSx5QkFBeUIsRUFBRSxhQUFhLEVBQUUsUUFBUSxDQUFDOzswQkFpRy9ELE1BQU07MkJBQUMsa0JBQWtCO3lDQTlFdkIsRUFBRTtzQkFGUixXQUFXO3VCQUFDLFNBQVM7O3NCQUNyQixLQUFLO2dCQVNVLFNBQVM7c0JBRHhCLFdBQVc7dUJBQUMseUJBQXlCO2dCQVEzQixVQUFVO3NCQUZwQixLQUFLOztzQkFDTCxXQUFXO3VCQUFDLHFDQUFxQztnQkFnQnZDLFdBQVc7c0JBRHJCLEtBQUs7Z0JBdUJVLFVBQVU7c0JBRHpCLEtBQUs7dUJBQUMsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBJbnB1dCxcbiAgICBIb3N0QmluZGluZyxcbiAgICBFbGVtZW50UmVmLFxuICAgIGJvb2xlYW5BdHRyaWJ1dGUsXG4gICAgSW5qZWN0LFxufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgSWd4Q2FsZW5kYXJNb250aERpcmVjdGl2ZSB9IGZyb20gXCIuLi9jYWxlbmRhci5kaXJlY3RpdmVzXCI7XG5pbXBvcnQgeyBOZ0ZvciwgVGl0bGVDYXNlUGlwZSwgRGF0ZVBpcGUgfSBmcm9tIFwiQGFuZ3VsYXIvY29tbW9uXCI7XG5pbXBvcnQge1xuICAgIElneENhbGVuZGFyVmlld0RpcmVjdGl2ZSxcbiAgICBEQVlfSU5URVJWQUxfVE9LRU4sXG59IGZyb20gXCIuLi9jb21tb24vY2FsZW5kYXItdmlldy5kaXJlY3RpdmVcIjtcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gXCJAYW5ndWxhci9mb3Jtc1wiO1xuaW1wb3J0IHsgQ2FsZW5kYXJEYXkgfSBmcm9tIFwiLi4vY29tbW9uL21vZGVsXCI7XG5pbXBvcnQgdHlwZSB7IERheUludGVydmFsIH0gZnJvbSBcIi4uL2NvbW1vbi9tb2RlbFwiO1xuaW1wb3J0IHsgY2FsZW5kYXJSYW5nZSB9IGZyb20gXCIuLi9jb21tb24vaGVscGVyc1wiO1xuXG5sZXQgTkVYVF9JRCA9IDA7XG5cbkBDb21wb25lbnQoe1xuICAgIHByb3ZpZGVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBJZ3hNb250aHNWaWV3Q29tcG9uZW50LFxuICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHByb3ZpZGU6IERBWV9JTlRFUlZBTF9UT0tFTixcbiAgICAgICAgICAgIHVzZVZhbHVlOiBcIm1vbnRoXCIsXG4gICAgICAgIH0sXG4gICAgXSxcbiAgICBzZWxlY3RvcjogXCJpZ3gtbW9udGhzLXZpZXdcIixcbiAgICB0ZW1wbGF0ZVVybDogXCJtb250aHMtdmlldy5jb21wb25lbnQuaHRtbFwiLFxuICAgIHN0YW5kYWxvbmU6IHRydWUsXG4gICAgaW1wb3J0czogW05nRm9yLCBJZ3hDYWxlbmRhck1vbnRoRGlyZWN0aXZlLCBUaXRsZUNhc2VQaXBlLCBEYXRlUGlwZV0sXG59KVxuZXhwb3J0IGNsYXNzIElneE1vbnRoc1ZpZXdDb21wb25lbnQgZXh0ZW5kcyBJZ3hDYWxlbmRhclZpZXdEaXJlY3RpdmUgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG4gICAgI3N0YW5kYWxvbmUgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBgaWRgIG9mIHRoZSBtb250aHMgdmlldy5cbiAgICAgKiBJZiBub3Qgc2V0LCB0aGUgYGlkYCB3aWxsIGhhdmUgdmFsdWUgYFwiaWd4LW1vbnRocy12aWV3LTBcImAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtbW9udGhzLXZpZXcgaWQ9XCJteS1tb250aHMtdmlld1wiPjwvaWd4LW1vbnRocy12aWV3PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgbW9udGhzVmlld0lkID0gIHRoaXMubW9udGhzVmlldy5pZDtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hNb250aHNWaWV3Q29tcG9uZW50XG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKFwiYXR0ci5pZFwiKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlkID0gYGlneC1tb250aHMtdmlldy0ke05FWFRfSUQrK31gO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgY3NzIGNsYXNzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoXCJjbGFzcy5pZ3gtY2FsZW5kYXItdmlld1wiKVxuICAgIHB1YmxpYyByZWFkb25seSB2aWV3Q2xhc3MgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIEBIb3N0QmluZGluZyhcImNsYXNzLmlneC1jYWxlbmRhci12aWV3LS1zdGFuZGFsb25lXCIpXG4gICAgcHVibGljIGdldCBzdGFuZGFsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jc3RhbmRhbG9uZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IHN0YW5kYWxvbmUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy4jc3RhbmRhbG9uZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1vbnRoIGZvcm1hdCBvcHRpb24gb2YgdGhlIG1vbnRocyB2aWV3LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgbW9udGhGb3JtYXQgPSB0aGlzLm1vbnRoc1ZpZXcubW9udGhGb3JtYXQuXG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IG1vbnRoRm9ybWF0KCk6IGFueSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb250aEZvcm1hdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtb250aCBmb3JtYXQgb3B0aW9uIG9mIHRoZSBtb250aHMgdmlldy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1tb250aHMtdmlldz4gW21vbnRoRm9ybWF0XT1cInNob3J0J1wiPC9pZ3gtbW9udGhzLXZpZXc+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4TW9udGhzVmlld0NvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgbW9udGhGb3JtYXQodmFsdWU6IGFueSkge1xuICAgICAgICB0aGlzLl9tb250aEZvcm1hdCA9IHZhbHVlO1xuICAgICAgICB0aGlzLmluaXRGb3JtYXR0ZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzL3NldHMgd2hldGhlciB0aGUgdmlldyBzaG91bGQgYmUgcmVuZGVyZWRcbiAgICAgKiBhY2NvcmRpbmcgdG8gdGhlIGxvY2FsZSBhbmQgZm9ybWF0LCBpZiBhbnkuXG4gICAgICovXG4gICAgQElucHV0KHsgdHJhbnNmb3JtOiBib29sZWFuQXR0cmlidXRlIH0pXG4gICAgcHVibGljIG92ZXJyaWRlIGZvcm1hdFZpZXcgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBkYXRlIG9iamVjdHMgd2hpY2ggYXJlIHRoZW4gdXNlZCB0b1xuICAgICAqIHByb3Blcmx5IHJlbmRlciB0aGUgbW9udGggbmFtZXMuXG4gICAgICpcbiAgICAgKiBVc2VkIGluIHRoZSB0ZW1wbGF0ZSBvZiB0aGUgY29tcG9uZW50XG4gICAgICpcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgcmFuZ2UoKTogRGF0ZVtdIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBDYWxlbmRhckRheS5mcm9tKHRoaXMuZGF0ZSkuc2V0KHsgZGF0ZTogMSwgbW9udGg6IDAgfSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0LmFkZCh0aGlzLmRheUludGVydmFsLCAxMik7XG5cbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oXG4gICAgICAgICAgICBjYWxlbmRhclJhbmdlKHsgc3RhcnQsIGVuZCwgdW5pdDogdGhpcy5kYXlJbnRlcnZhbCB9KSxcbiAgICAgICAgKS5tYXAoKG0pID0+IG0ubmF0aXZlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfbW9udGhGb3JtYXQgPSBcInNob3J0XCI7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHVibGljIGVsOiBFbGVtZW50UmVmLFxuICAgICAgICBASW5qZWN0KERBWV9JTlRFUlZBTF9UT0tFTikgZGF5SW50ZXJ2YWw6IERheUludGVydmFsLFxuICAgICkge1xuICAgICAgICBzdXBlcihkYXlJbnRlcnZhbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbG9jYWxlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb250aCBpbiB0aGUgbW9udGhzIHZpZXcuXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGZvcm1hdHRlZE1vbnRoKHZhbHVlOiBEYXRlKTogeyBsb25nOiBzdHJpbmc7IGZvcm1hdHRlZDogc3RyaW5nIH0ge1xuICAgICAgICBjb25zdCByYXdGb3JtYXR0ZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh0aGlzLmxvY2FsZSwge1xuICAgICAgICAgICAgbW9udGg6IFwibG9uZ1wiLFxuICAgICAgICAgICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLmZvcm1hdFZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbG9uZzogcmF3Rm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSksXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkOiB0aGlzLl9mb3JtYXR0ZXIuZm9ybWF0KHZhbHVlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9uZzogcmF3Rm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSksXG4gICAgICAgICAgICBmb3JtYXR0ZWQ6IGAke3ZhbHVlLmdldE1vbnRoKCl9YCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG1vbnRoVHJhY2tlcihfOiBudW1iZXIsIGl0ZW06IERhdGUpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYCR7aXRlbS5nZXRNb250aCgpfX1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgaW5pdEZvcm1hdHRlcigpIHtcbiAgICAgICAgdGhpcy5fZm9ybWF0dGVyID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQodGhpcy5fbG9jYWxlLCB7XG4gICAgICAgICAgICBtb250aDogdGhpcy5tb250aEZvcm1hdCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiPGRpdiBjbGFzcz1cImlneC1jYWxlbmRhci12aWV3X19pdGVtc1wiIHJvbGU9XCJyb3dcIj5cbiAgICA8c3BhblxuICAgICAgICBpZ3hDYWxlbmRhck1vbnRoXG4gICAgICAgICNpdGVtPVwiaWd4Q2FsZW5kYXJNb250aFwiXG4gICAgICAgICpuZ0Zvcj1cImxldCBtb250aCBvZiByYW5nZTsgdHJhY2tCeTogbW9udGhUcmFja2VyXCJcbiAgICAgICAgY2xhc3M9XCJpZ3gtY2FsZW5kYXItdmlld19faXRlbVwiXG4gICAgICAgIHJvbGU9XCJncmlkY2VsbFwiXG4gICAgICAgIFthdHRyLmlkXT1cIm1vbnRoLmdldFRpbWUoKVwiXG4gICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiZm9ybWF0dGVkTW9udGgobW9udGgpLmxvbmdcIlxuICAgICAgICBbYXR0ci5hcmlhLXNlbGVjdGVkXT1cIml0ZW0uaXNTZWxlY3RlZFwiXG4gICAgICAgIFt2YWx1ZV09XCJtb250aFwiXG4gICAgICAgIFtkYXRlXT1cImRhdGVcIlxuICAgICAgICBbc2hvd0FjdGl2ZV09XCJzaG93QWN0aXZlXCJcbiAgICAgICAgKGl0ZW1TZWxlY3Rpb24pPVwic2VsZWN0RGF0ZSgkZXZlbnQpXCJcbiAgICA+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaWd4LWNhbGVuZGFyLXZpZXdfX2l0ZW0taW5uZXJcIiBhcmlhLWhpZGRlbj1cInRydWVcIj5cbiAgICAgICAgICAgIHt7IGZvcm1hdHRlZE1vbnRoKG1vbnRoKS5mb3JtYXR0ZWQgfCB0aXRsZWNhc2UgfX1cbiAgICAgICAgPC9zcGFuPlxuICAgIDwvc3Bhbj5cbjwvZGl2PlxuIl19